{"task_id": "Go/1", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {", "canonical_solution": "if a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}", "test": "func TestCalculateTriangleArea(t *testing.T) {\n\t// Using a small delta for floating point comparison\n\tconst delta = 1e-6\n\n\tassert := assert.New(t)\n\n\t// Triangle with sides 3, 5, 4 should return area 6.00\n\tassert.InDelta(6.00, calculateTriangleArea(3, 5, 4), delta)\n\n\t// Not a triangle with sides 1, 1, 4 should return -1\n\tassert.Equal(-1.0, calculateTriangleArea(1, 1, 4))\n\n\t// Triangle with sides 7, 24, 25 should return area 84.00\n\tassert.InDelta(84.00, calculateTriangleArea(7, 24, 25), delta)\n\n\t// Triangle with sides 10.5, 6.2, 7.3 should return close to calculated area\n\tassert.InDelta(22.15, calculateTriangleArea(10.5, 6.2, 7.3), 1e-2) // Looser delta for specific precision\n}", "entry_point": "calculateTriangleArea", "signature": "func calculateTriangleArea(a, b, c float64) float64", "docstring": "Calculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n", "instruction": "Write a Go function `func calculateTriangleArea(a, b, c float64) float64` to solve the following problem:\nCalculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n", "level": "easy"}
{"task_id": "Go/2", "prompt": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {", "canonical_solution": "if 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}", "test": "func TestCalculateFunctionValue(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Not define\", calculateFunctionValue(40)) // the provided test case\n\n\t// Additional test cases based on provided function definitions\n\tassert.Equal(\"Not define\", calculateFunctionValue(40))\n\tassert.Equal(\"-0.14550\", calculateFunctionValue(5))\n\tassert.Equal(\"0.76266\", calculateFunctionValue(15))\n\tassert.Equal(\"0.31314\", calculateFunctionValue(25))\n\tassert.Equal(\"Not define\", calculateFunctionValue(-1))\n}", "entry_point": "calculateFunctionValue", "signature": "func calculateFunctionValue(x int) string", "docstring": "Calculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"", "instruction": "Write a Go function `func calculateFunctionValue(x int) string` to solve the following problem:\nCalculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"", "level": "middle"}
{"task_id": "Go/3", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {", "canonical_solution": "var max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}", "test": "func TestFindMaxMin(t *testing.T) {\n\tassert := assert.New(t)\n\tvar max, min int\n\n\tmax, min = FindMaxMin(1, 2, 3)\n\tassert.Equal(3, max)\n\tassert.Equal(1, min)\n\n\t// Additional tests\n\tmax, min = FindMaxMin(5, 3, 4)\n\tassert.Equal(5, max)\n\tassert.Equal(3, min)\n\n\tmax, min = FindMaxMin(10, -2, 7)\n\tassert.Equal(10, max)\n\tassert.Equal(-2, min)\n\n\tmax, min = FindMaxMin(-1, -3, -2)\n\tassert.Equal(-1, max)\n\tassert.Equal(-3, min)\n}", "entry_point": "FindMaxMin", "signature": "func FindMaxMin(a, b, c int) (int, int)", "docstring": "Find the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)", "instruction": "Write a Go function `func FindMaxMin(a, b, c int) (int, int)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)", "level": "middle"}
{"task_id": "Go/4", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {", "canonical_solution": "return math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}", "test": "func TestCalculateDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.InDelta(5, calculateDistance(0, 0, 3, 4), 1e-6)\n\tassert.InDelta(0, calculateDistance(0, 0, 0, 0), 1e-6)\n\tassert.InDelta(4.242640687, calculateDistance(-1, -1, 2, 2), 1e-6)\n\tassert.InDelta(5.68243, calculateDistance(1.5, 3.9, 4.2, -1.1), 1e-6)\n}", "entry_point": "calculateDistance", "signature": "func calculateDistance(xa, ya, xb, yb float64) float64", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5", "instruction": "Write a Go function `func calculateDistance(xa, ya, xb, yb float64) float64` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5", "level": "easy"}
{"task_id": "Go/5", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n*/\nfunc processRequest(n int) int {", "canonical_solution": "if n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}", "test": "func TestProcessRequest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, processRequest(0), \"Factorial of 0 should be 1\")\n\tassert.Equal(1, processRequest(1), \"Factorial of 1 should be 1\")\n\tassert.Equal(2, processRequest(2), \"Factorial of 2 should be 2\")\n\tassert.Equal(6, processRequest(3), \"Factorial of 3 should be 6\")\n\tassert.Equal(24, processRequest(4), \"Factorial of 4 should be 24\")\n\tassert.Equal(6266, processRequest(10), \"Factorial of 10 modulus 10007 should be 6266\")\n\tassert.Equal(6991, processRequest(10000), \"Boundary condition for Factorial of 10000 modulus 10007 should be 6991\")\n}", "entry_point": "processRequest", "signature": "func processRequest(n int) int", "docstring": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n", "instruction": "Write a Go function `func processRequest(n int) int` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n", "level": "easy"}
{"task_id": "Go/6", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 calculates the area of a triangle given its base and height.\n\u200b\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n\u200b\nReturns:\n\u200bfloat64: The calculated area of the triangle, rounded to a float64 precision.\n\u200b\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {", "canonical_solution": "// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}", "test": "func TestCalculateTriangleArea2(t *testing.T) {\n\t// Using testify for assert comparison with delta for approximation\n\tassert := assert.New(t)\n\n\t// Adding more comprehensive test cases and correcting the expected values\n\tassert.InDelta(1.0, calculateTriangleArea2(1, 2), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(6.0, calculateTriangleArea2(3, 4), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(20.0, calculateTriangleArea2(5, 8), 1e-6)   // Additional test case\n\tassert.InDelta(10.5, calculateTriangleArea2(7, 3), 1e-6)   // Additional test case\n\tassert.InDelta(50.0, calculateTriangleArea2(10, 10), 1e-6) // Additional test case\n}", "entry_point": "calculateTriangleArea2", "signature": "func calculateTriangleArea2(base, height int) float64", "docstring": "CalculateTriangleArea2 calculates the area of a triangle given its base and height.\n\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n\nReturns:\nfloat64: The calculated area of the triangle, rounded to a float64 precision.\n\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n", "instruction": "Write a Go function `func calculateTriangleArea2(base, height int) float64` to solve the following problem:\nCalculateTriangleArea2 calculates the area of a triangle given its base and height.\n\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n\nReturns:\nfloat64: The calculated area of the triangle, rounded to a float64 precision.\n\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n", "level": "easy"}
{"task_id": "Go/7", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {", "canonical_solution": "distance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}", "test": "func TestHammingDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, hammingDistance(1, 2), \"1 and 2 should have a Hamming distance of 2\")\n\tassert.Equal(2, hammingDistance(4, 7), \"4 and 7 should have a Hamming distance of 2\")\n\tassert.Equal(3, hammingDistance(25, 30), \"25 and 30 should have a Hamming distance of 3\")\n\tassert.Equal(0, hammingDistance(0, 0), \"0 and 0 should have a Hamming distance of 0\")\n\tassert.Equal(28, hammingDistance(0xFFFFFFF, 0), \"0xFFFFFFF and 0 should have a Hamming distance of 28\")\n}", "entry_point": "hammingDistance", "signature": "func hammingDistance(x int, y int) int", "docstring": "Calculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n", "instruction": "Write a Go function `func hammingDistance(x int, y int) int` to solve the following problem:\nCalculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n", "level": "middle"}
{"task_id": "Go/8", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {", "canonical_solution": "ans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}", "test": "func TestCountOddNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, countOddNumbers(5, []int{1, 4, 3, 2, 5}))\n\tassert.Equal(0, countOddNumbers(4, []int{2, 2, 0, 0}))\n\tassert.Equal(4, countOddNumbers(6, []int{7, 7, 8, 1, 9, 10})) // Additional Test Sample\n}", "entry_point": "countOddNumbers", "signature": "func countOddNumbers(count int, nums []int) int", "docstring": "Count the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n", "instruction": "Write a Go function `func countOddNumbers(count int, nums []int) int` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n", "level": "easy"}
{"task_id": "Go/9", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\n- size (int): The length of the slice.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {", "canonical_solution": "ans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}", "test": "func TestCalculateEvenSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, calculateEvenSum([]int{1, 4, 3, 2, 5}))\n\tassert.Equal(4, calculateEvenSum([]int{2, 2, 0, 0}))\n\tassert.Equal(0, calculateEvenSum([]int{7, 11, 19})) // Should return 0 because there are no even numbers\n\tassert.Equal(12+14+16+18+20, calculateEvenSum([]int{12, 14, 16, 18, 20}))\n}", "entry_point": "calculateEvenSum", "signature": "func calculateEvenSum(numbers []int) int", "docstring": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n", "instruction": "Write a Go function `func calculateEvenSum(numbers []int) int` to solve the following problem:\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n", "level": "easy"}
{"task_id": "Go/10", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDetermine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {", "canonical_solution": "if (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}", "test": "func TestAreIntervalsIntersecting(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, AreIntervalsIntersecting(1, 1, 1, 2))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 2, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 4, 7))\n\tassert.Equal(0, AreIntervalsIntersecting(3, 5, 6, 7))\n\t// Additional test cases\n\tassert.Equal(1, AreIntervalsIntersecting(0, 0, 0, 0))\n\tassert.Equal(1, AreIntervalsIntersecting(1, 3, 2, 4))\n\tassert.Equal(0, AreIntervalsIntersecting(1, 3, 4, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(10, 20, 20, 30))\n\tassert.Equal(0, AreIntervalsIntersecting(10, 20, 21, 30))\n}", "entry_point": "AreIntervalsIntersecting", "signature": "func AreIntervalsIntersecting(a, b, c, d int) int", "docstring": "Determine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n", "instruction": "Write a Go function `func AreIntervalsIntersecting(a, b, c, d int) int` to solve the following problem:\nDetermine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n", "level": "easy"}
{"task_id": "Go/11", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {", "canonical_solution": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}", "test": "func TestHelloMMCODEEVAL(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\", HelloMMCODEEVAL())\n}", "entry_point": "HelloMMCODEEVAL", "signature": "func HelloMMCODEEVAL() string", "docstring": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"", "instruction": "Write a Go function `func HelloMMCODEEVAL() string` to solve the following problem:\nReturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"", "level": "easy"}
{"task_id": "Go/12", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {", "canonical_solution": "total := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}", "test": "func TestCalculateTotalScore(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(500, CalculateTotalScore(100, 100, 100, 100, 100), \"should return the correct total score\")\n\tassert.Equal(0, CalculateTotalScore(0, 0, 0, 0, 0), \"should handle zero scores correctly\")\n\tassert.Equal(150, CalculateTotalScore(20, 30, 40, 10, 50), \"should return the correct total score for varied inputs\")\n\tassert.Equal(236, CalculateTotalScore(23, 45, 67, 89, 12), \"should return the correct total score for varied inputs\")\n\tassert.Equal(25, CalculateTotalScore(5, 5, 5, 5, 5), \"should return the correct total score for uniform inputs\")\n}", "entry_point": "CalculateTotalScore", "signature": "func CalculateTotalScore(scores ...int) int", "docstring": "CalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n", "instruction": "Write a Go function `func CalculateTotalScore(scores ...int) int` to solve the following problem:\nCalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n", "level": "easy"}
{"task_id": "Go/13", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {", "canonical_solution": "a := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}", "test": "func TestDecodeNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, DecodeNumbers(\"0000\"))\n\tassert.Equal(8, DecodeNumbers(\"8888\"))\n\tassert.Equal(1, DecodeNumbers(\"1234\"))\n\tassert.Equal(3, DecodeNumbers(\"5678\"))\n\tassert.Equal(2, DecodeNumbers(\"9012\"))\n\tassert.Equal(0, DecodeNumbers(\"1357\"))\n\tassert.Equal(4, DecodeNumbers(\"2468\"))\n\n\t// Additional test samples\n\tassert.Equal(4, DecodeNumbers(\"9999\"))\n\tassert.Equal(0, DecodeNumbers(\"1111\"))\n\tassert.Equal(0, DecodeNumbers(\"2222\"))\n\tassert.Equal(0, DecodeNumbers(\"3333\"))\n\tassert.Equal(4, DecodeNumbers(\"4444\"))\n\tassert.Equal(0, DecodeNumbers(\"5555\"))\n\tassert.Equal(4, DecodeNumbers(\"6666\"))\n\tassert.Equal(0, DecodeNumbers(\"7777\"))\n\tassert.Equal(3, DecodeNumbers(\"0001\"))\n\tassert.Equal(1, DecodeNumbers(\"2301\"))\n}", "entry_point": "DecodeNumbers", "signature": "func DecodeNumbers(dataStr string) int", "docstring": "DecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))", "instruction": "Write a Go function `func DecodeNumbers(dataStr string) int` to solve the following problem:\nDecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))", "level": "easy"}
{"task_id": "Go/14", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {", "canonical_solution": "const mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}", "test": "func TestCountColoringMethods(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, CountColoringMethods(1, 1))\n\tassert.Equal(2, CountColoringMethods(2, 2))\n\tassert.Equal(6, CountColoringMethods(3, 3))\n\tassert.Equal(2, CountColoringMethods(4, 2))\n\t// Add your tests here\n\tassert.Equal(6, CountColoringMethods(2, 3))\n\tassert.Equal(67911, CountColoringMethods(1000, 1000))\n\tassert.Equal(501817, CountColoringMethods(999, 66))\n\tassert.Equal(30, CountColoringMethods(5, 3))\n\n\t// Test with unknown expected result, assuming a placeholder value is \"expectedResult\".\n\t// Replace \"expectedResult\" with the actual expected value if known.\n\texpectedResult := 566585 // Placeholder for the expected result of CountColoringMethods(1000, 10)\n\tassert.Equal(expectedResult, CountColoringMethods(1000, 10))\n}", "entry_point": "CountColoringMethods", "signature": "func CountColoringMethods(n, m int) int", "docstring": "CountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n", "instruction": "Write a Go function `func CountColoringMethods(n, m int) int` to solve the following problem:\nCountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n", "level": "hard"}
{"task_id": "Go/15", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {", "canonical_solution": "var a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}", "test": "func TestCountValidCoinTossSequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(uint64(2), CountValidCoinTossSequences(1))\n\tassert.Equal(uint64(3), CountValidCoinTossSequences(2))\n\tassert.Equal(uint64(5), CountValidCoinTossSequences(3))\n\tassert.Equal(uint64(8), CountValidCoinTossSequences(4))  // Additional test\n\tassert.Equal(uint64(13), CountValidCoinTossSequences(5)) // Additional test\n\t// Feel free to add more tests here\n\tassert.Equal(uint64(267914296), CountValidCoinTossSequences(40)) // Additional test\n\tassert.Equal(uint64(165580141), CountValidCoinTossSequences(39))\n\tassert.Equal(uint64(102334155), CountValidCoinTossSequences(38))\n\t// Use t.Log instead of fmt.Print or fmt.Println in tests\n\tt.Log(\"All tests passed!\")\n}", "entry_point": "CountValidCoinTossSequences", "signature": "func CountValidCoinTossSequences(n int) uint64", "docstring": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n", "instruction": "Write a Go function `func CountValidCoinTossSequences(n int) uint64` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n", "level": "easy"}
{"task_id": "Go/16", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {", "canonical_solution": "max := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}", "test": "func TestFindLongestConsecutiveOnesLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, findLongestConsecutiveOnesLength(7))\n\tassert.Equal(2, findLongestConsecutiveOnesLength(13))\n\tassert.Equal(3, findLongestConsecutiveOnesLength(12345))         // New test sample\n\tassert.Equal(4, findLongestConsecutiveOnesLength(0b11011101111)) // New test sample using binary literal for clarity\n\tassert.Equal(32, findLongestConsecutiveOnesLength(0xFFFFFFFF))   // New test sample: all ones for a 32-bit number\n\tassert.Equal(0, findLongestConsecutiveOnesLength(0))             // New test sample: no ones in a zero\n}", "entry_point": "findLongestConsecutiveOnesLength", "signature": "func findLongestConsecutiveOnesLength(n uint64) int", "docstring": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n", "instruction": "Write a Go function `func findLongestConsecutiveOnesLength(n uint64) int` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n", "level": "easy"}
{"task_id": "Go/17", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {", "canonical_solution": "length1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}", "test": "func TestCreateID(t *testing.T) {\n\tassert.Equal(t, \"ftiasch\", CreateID(\"fish\", \"cat\"))\n\tassert.Equal(t, \"imccpac\", CreateID(\"icpc\", \"acm\"))\n\tassert.Equal(t, \"owo\", CreateID(\"oo\", \"w\"))\n\tassert.Equal(t, \"hdellrloow\", CreateID(\"hello\", \"world\"))\n\tassert.Equal(t, \"afbecd\", CreateID(\"abc\", \"def\"))\n\tassert.Equal(t, \"bauaauabnbbn\", CreateID(\"buaanb\", \"nbbuaa\"))\n\tassert.Equal(t, \"xuttuxiesvgooloid\", CreateID(\"xtuisgood\", \"ilovextu\"))\n}", "entry_point": "CreateID", "signature": "func CreateID(word1, word2 string) string", "docstring": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"\n", "instruction": "Write a Go function `func CreateID(word1, word2 string) string` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"\n", "level": "middle"}
{"task_id": "Go/18", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {", "canonical_solution": "factorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}", "test": "func TestCountPermutationsOfBinaryString(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, countPermutationsOfBinaryString(2, 0))\n\tassert.Equal(0, countPermutationsOfBinaryString(2, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 0))\n\tassert.Equal(3, countPermutationsOfBinaryString(3, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 2))\n\tassert.Equal(145422675, countPermutationsOfBinaryString(30, 2))\n\tassert.Equal(4, countPermutationsOfBinaryString(4, 2))\n\tassert.Equal(1, countPermutationsOfBinaryString(5, 5))\n\tassert.Equal(13884156, countPermutationsOfBinaryString(33, 17))\n\tassert.Equal(1, countPermutationsOfBinaryString(1000000, 1000000))\n\t// Add more test cases if necessary\n}", "entry_point": "countPermutationsOfBinaryString", "signature": "func countPermutationsOfBinaryString(n, m int) int", "docstring": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n", "instruction": "Write a Go function `func countPermutationsOfBinaryString(n, m int) int` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n", "level": "hard"}
{"task_id": "Go/19", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nfunc answerQuestions() string {", "canonical_solution": "return \"DDDBA\"\n}", "test": "func TestAnswerQuestions(t *testing.T) {\n\texpectedAnswers := \"DDDBA\"\n\tactualAnswers := answerQuestions()\n\n\tassert.Equal(t, expectedAnswers, actualAnswers, \"they should be equal\")\n}", "entry_point": "answerQuestions", "signature": "func answerQuestions() string", "docstring": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "instruction": "Write a Go function `func answerQuestions() string` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "level": "easy"}
{"task_id": "Go/20", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {", "canonical_solution": "sum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}", "test": "func TestIsSquare(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(IsSquare(1, []int{9}))\n\tassert.True(IsSquare(2, []int{14, 2}))\n\tassert.False(IsSquare(2, []int{7, 7}))\n\tassert.False(IsSquare(7, []int{1, 2, 3, 4, 5, 6, 7}))\n\tassert.True(IsSquare(6, []int{1, 3, 5, 7, 9, 11}))\n\tassert.False(IsSquare(4, []int{2, 2, 2, 2}))\n\n\t// Additional test cases\n\tassert.False(IsSquare(3, []int{4, 5, 6}))\n\tassert.False(IsSquare(4, []int{16, 9, 4, 1}))\n\tassert.False(IsSquare(5, []int{1, 1, 1, 1, 1}))\n\tassert.False(IsSquare(2, []int{25, 25}))\n\tassert.True(IsSquare(3, []int{10, 10, 5}))\n}", "entry_point": "IsSquare", "signature": "func IsSquare(length int, squares []int) bool", "docstring": "Is_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n", "instruction": "Write a Go function `func IsSquare(length int, squares []int) bool` to solve the following problem:\nIs_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n", "level": "easy"}
{"task_id": "Go/21", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven integers c and d, where a + b = c and a * b = d, find\nand return the possible value of a where a <= b. If there are\nmultiple groups, output the group with the smallest a. If no\nvalid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {", "canonical_solution": "for i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}", "test": "func TestFindIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, findIntegers(5, 6))\n\tassert.Equal(3, findIntegers(6, 9))\n\tassert.Equal(3, findIntegers(7, 12))\n\tassert.Equal(-1, findIntegers(7, 11))\n\tassert.Equal(1, findIntegers(9, 8))\n\tassert.Equal(5, findIntegers(10, 25))\n\tassert.Equal(-1, findIntegers(10000, 8765))\n}", "entry_point": "findIntegers", "signature": "func findIntegers(c int, d int) int", "docstring": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a where a <= b. If there are multiple groups, output the group with the smallest a. If no valid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n", "instruction": "Write a Go function `func findIntegers(c int, d int) int` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a where a <= b. If there are multiple groups, output the group with the smallest a. If no valid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n", "level": "easy"}
{"task_id": "Go/22", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n*/\nfunc extraNumber(a, b, c int) int {", "canonical_solution": "if a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}", "test": "func TestExtraNumber(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(7, extraNumber(2, 7, 2), \"Extra number should be 7\")\n\tassert.Equal(3, extraNumber(3, 2, 2), \"Extra number should be 3\")\n\tassert.Equal(1, extraNumber(5, 5, 1), \"Extra number should be 1\")\n\tassert.Equal(3, extraNumber(500000000, 3, 500000000), \"Extra number should be 3\")\n\tassert.Equal(3, extraNumber(500000000, 500000000, 3), \"Extra number should be 3\")\n}", "entry_point": "extraNumber", "signature": "func extraNumber(a, b, c int) int", "docstring": "Given three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n", "instruction": "Write a Go function `func extraNumber(a, b, c int) int` to solve the following problem:\nGiven three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n", "level": "easy"}
{"task_id": "Go/23", "prompt": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {", "canonical_solution": "sort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}", "test": "func TestCountAcuteTriangles(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, countAcuteTriangles([]int{1, 1, 1, 1}))\n\tassert.Equal(0, countAcuteTriangles([]int{1, 2, 3}))\n\t// Additional tests to ensure correctness\n\tassert.Equal(0, countAcuteTriangles([]int{3, 4, 5, 7, 10}))\n\tassert.Equal(4, countAcuteTriangles([]int{6, 8, 10, 5, 5, 5}))\n}", "entry_point": "countAcuteTriangles", "signature": "func countAcuteTriangles(edges []int) int", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n", "instruction": "Write a Go function `func countAcuteTriangles(edges []int) int` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n", "level": "middle"}
{"task_id": "Go/24", "prompt": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {", "canonical_solution": "return fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}", "test": "func TestProcessIntegerAndChar(t *testing.T) {\n\tassert := assert.New(t)\n\n\t// Test 1\n\toutput1 := processIntegerAndChar(234, 'H')\n\tassert.Equal(\"234,H\", output1)\n\n\t// Additional tests can be added here with different input values\n\t// Test 2\n\toutput2 := processIntegerAndChar(123, 'A')\n\tassert.Equal(\"123,A\", output2)\n\n\t// Test 3\n\toutput3 := processIntegerAndChar(0, 'Z')\n\tassert.Equal(\"0,Z\", output3)\n}", "entry_point": "processIntegerAndChar", "signature": "func processIntegerAndChar(integerValue int, charValue rune) string", "docstring": "processIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n", "instruction": "Write a Go function `func processIntegerAndChar(integerValue int, charValue rune) string` to solve the following problem:\nprocessIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n", "level": "easy"}
{"task_id": "Go/25", "prompt": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {", "canonical_solution": "runes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}", "test": "func TestShiftCharacters(t *testing.T) {\n\tassert := assert.New(t)\n\n\ttest1 := \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\"\n\texpected1 := \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\tassert.Equal(expected1, shiftCharacters(test1), \"Test case 1 failed\")\n\n\ttest2 := \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\"\n\texpected2 := \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\"\n\tassert.Equal(expected2, shiftCharacters(test2), \"Test case 2 failed\")\n\n\ttest3 := \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\"\n\texpected3 := \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\"\n\tassert.Equal(expected3, shiftCharacters(test3), \"Test case 3 failed\")\n}", "entry_point": "shiftCharacters", "signature": "func shiftCharacters(text string) string", "docstring": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "instruction": "Write a Go function `func shiftCharacters(text string) string` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n", "level": "easy"}
{"task_id": "Go/26", "prompt": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {", "canonical_solution": "var n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}", "test": "func TestClassifyInteger(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, classifyInteger(\"24\"))\n\tassert.Equal(3, classifyInteger(\"39\"))\n\tassert.Equal(9, classifyInteger(\"123456789\"))\n\tassert.Equal(9, classifyInteger(\"123456789012345678901234567890\"))\n\tassert.Equal(6, classifyInteger(\"12345\"))\n\tassert.Equal(9, classifyInteger(\"999999999\"))\n}", "entry_point": "classifyInteger", "signature": "func classifyInteger(x string) int", "docstring": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n", "instruction": "Write a Go function `func classifyInteger(x string) int` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n", "level": "easy"}
{"task_id": "Go/27", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {", "canonical_solution": "if letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}", "test": "func TestTransformLetterCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(rune('B'), TransformLetterCase('b'), \"Lowercase 'b' should transform to uppercase 'B'\")\n\tassert.Equal(rune('b'), TransformLetterCase('B'), \"Uppercase 'B' should transform to lowercase 'b'\")\n\n\t// Additional test cases\n\tassert.Equal(rune('Z'), TransformLetterCase('z'), \"Lowercase 'z' should transform to uppercase 'Z'\")\n\tassert.Equal(rune('z'), TransformLetterCase('Z'), \"Uppercase 'Z' should transform to lowercase 'z'\")\n\tassert.Equal(rune('M'), TransformLetterCase('m'), \"Lowercase 'm' should transform to uppercase 'M'\")\n\tassert.Equal(rune('m'), TransformLetterCase('M'), \"Uppercase 'M' should transform to lowercase 'm'\")\n\tassert.Equal(rune('1'), TransformLetterCase('1'), \"Non-alphabetic '1' should remain unchanged\")\n\tassert.Equal(rune('!'), TransformLetterCase('!'), \"Non-alphabetic '!' should remain unchanged\")\n}", "entry_point": "TransformLetterCase", "signature": "func TransformLetterCase(letter rune) rune", "docstring": "TransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'", "instruction": "Write a Go function `func TransformLetterCase(letter rune) rune` to solve the following problem:\nTransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'", "level": "easy"}
{"task_id": "Go/28", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {", "canonical_solution": "return int(character)\n}", "test": "func TestDisplayASCIIInfo(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(65, DisplayASCIIInfo('A'), \"ASCII value for 'A' should be 65\")\n\tassert.Equal(66, DisplayASCIIInfo('B'), \"ASCII value for 'B' should be 66\") // Additional test case\n\tassert.Equal(48, DisplayASCIIInfo('0'), \"ASCII value for '0' should be 48\") // Additional test case\n\tassert.Equal(32, DisplayASCIIInfo(' '), \"ASCII value for ' ' should be 32\") // Additional test case\n}", "entry_point": "DisplayASCIIInfo", "signature": "func DisplayASCIIInfo(character rune) int", "docstring": "DisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n", "instruction": "Write a Go function `func DisplayASCIIInfo(character rune) int` to solve the following problem:\nDisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n", "level": "easy"}
{"task_id": "Go/29", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\t Example:\n\t\tevaluateIntegerGrade(90) // Returns 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {", "canonical_solution": "if 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}", "test": "func TestEvaluateIntegerGrade(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal('A', evaluateIntegerGrade(90))\n\tassert.Equal('B', evaluateIntegerGrade(89))\n\tassert.Equal('A', evaluateIntegerGrade(95))\n\tassert.Equal('A', evaluateIntegerGrade(100))\n\tassert.Equal('B', evaluateIntegerGrade(101))\n}", "entry_point": "evaluateIntegerGrade", "signature": "func evaluateIntegerGrade(score int) rune", "docstring": "Evaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n     Example:\n        evaluateIntegerGrade(90) // Returns 'A'", "instruction": "Write a Go function `func evaluateIntegerGrade(score int) rune` to solve the following problem:\nEvaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n     Example:\n        evaluateIntegerGrade(90) // Returns 'A'", "level": "easy"}
{"task_id": "Go/30", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n//\n// Args:\n//\n//\ts (string): The three-character string to be checked.\n//\n// Returns:\n//\n//\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n//\tExamples:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {", "canonical_solution": "if (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}", "test": "func TestCheckTwoEqualDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"112\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"123\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"232\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"444\")) // All three characters are equal, not two.\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"121\"))\n\n\t// Additional test cases to cover more scenarios\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"787\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"999\")) // All three characters are equal\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"890\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"556\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"353\")) // No two characters are equal\n}", "entry_point": "CheckTwoEqualDigits", "signature": "func CheckTwoEqualDigits(s string) string", "docstring": "CheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n\n\ts (string): The three-character string to be checked.\n\nReturns:\n\n\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"", "instruction": "Write a Go function `func CheckTwoEqualDigits(s string) string` to solve the following problem:\nCheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n\n\ts (string): The three-character string to be checked.\n\nReturns:\n\n\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"", "level": "easy"}
{"task_id": "Go/31", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a string consisting of lowercase English letters,\nin each round, you can change one of the characters to another character.\nThe question is: what is the minimum number of rounds needed to make\nthe string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {", "canonical_solution": "var charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}", "test": "func TestMinRoundsToSameChar(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, minRoundsToSameChar(\"aab\"), \"They should be equal\")\n\tassert.Equal(2, minRoundsToSameChar(\"abc\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"aaa\"), \"They should be equal\")\n\tassert.Equal(1, minRoundsToSameChar(\"abab\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"zzzzz\"), \"They should be equal\")\n}", "entry_point": "minRoundsToSameChar", "signature": "func minRoundsToSameChar(s string) int", "docstring": "Given a string consisting of lowercase English letters, in each round, you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0", "instruction": "Write a Go function `func minRoundsToSameChar(s string) int` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round, you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0", "level": "easy"}
{"task_id": "Go/32", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Y_n when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {", "canonical_solution": "year := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}", "test": "func TestApocalypseYear(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(36, apocalypseYear(6, []int{3, 2, 4, 5, 9, 18}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 1, 1, 1, 1}))\n\tassert.Equal(2012, apocalypseYear(6, []int{50, 30, 711, 200, 503, 1006}))\n\tassert.Equal(2, apocalypseYear(2, []int{1, 2}))\n\tassert.Equal(6, apocalypseYear(3, []int{3, 1, 2}))\n\tassert.Equal(4, apocalypseYear(3, []int{2, 3, 4}))\n\tassert.Equal(4, apocalypseYear(4, []int{1, 2, 3, 4}))\n\tassert.Equal(13, apocalypseYear(4, []int{5, 7, 11, 13}))\n\tassert.Equal(10, apocalypseYear(5, []int{2, 2, 2, 2, 2}))\n\tassert.Equal(15, apocalypseYear(3, []int{6, 10, 15}))\n\tassert.Equal(14, apocalypseYear(3, []int{4, 6, 14}))\n\tassert.Equal(800, apocalypseYear(4, []int{50, 30, 711, 200}))\n\tassert.Equal(6, apocalypseYear(6, []int{1, 1, 1, 1, 1, 1}))\n\tassert.Equal(1999998, apocalypseYear(2, []int{1000000, 999999}))\n}", "entry_point": "apocalypseYear", "signature": "func apocalypseYear(n int, signs []int) int", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the nth event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n", "instruction": "Write a Go function `func apocalypseYear(n int, signs []int) int` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the nth event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n", "level": "easy"}
{"task_id": "Go/33", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblem: New Modulo Operation \"\u2295\".\nIn this operation, for x \u2295 y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4\u22955 = 4\n- 20\u22955 = 4\n- 100\u22955 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! \u2295 p,\nwhere n! is the factorial of n (product of all positive integers \u2264 n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {", "canonical_solution": "pj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}", "test": "func TestNewModuloFactorial(t *testing.T) {\n\t// Test cases\n\tassert.Equal(t, uint64(6), newModuloFactorial(3, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(10, 3))\n\tassert.Equal(t, uint64(4), newModuloFactorial(11, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(45, 7))\n\tassert.Equal(t, uint64(2), newModuloFactorial(14, 7))\n\tassert.Equal(t, uint64(3152), newModuloFactorial(1919, 10007))\n\tassert.Equal(t, uint64(3679), newModuloFactorial(810, 10007))\n\tassert.Equal(t, uint64(1), newModuloFactorial(1, 2))\n\tassert.Equal(t, uint64(10), newModuloFactorial(5, 11))\n\tassert.Equal(t, uint64(5), newModuloFactorial(6, 13))\n\tassert.Equal(t, uint64(13), newModuloFactorial(8, 17))\n\tassert.Equal(t, uint64(16), newModuloFactorial(15, 19))\n\tassert.Equal(t, uint64(1), newModuloFactorial(21, 23))\n\tassert.Equal(t, uint64(28), newModuloFactorial(30, 29))\n\tassert.Equal(t, uint64(100), newModuloFactorial(100, 101))\n}", "entry_point": "newModuloFactorial", "signature": "func newModuloFactorial(n, p uint64) uint64", "docstring": "Problem: New Modulo Operation \"\u2295\".\nIn this operation, for x \u2295 y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4\u22955 = 4\n- 20\u22955 = 4\n- 100\u22955 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! \u2295 p,\nwhere n! is the factorial of n (product of all positive integers \u2264 n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n", "instruction": "Write a Go function `func newModuloFactorial(n, p uint64) uint64` to solve the following problem:\nProblem: New Modulo Operation \"\u2295\".\nIn this operation, for x \u2295 y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4\u22955 = 4\n- 20\u22955 = 4\n- 100\u22955 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! \u2295 p,\nwhere n! is the factorial of n (product of all positive integers \u2264 n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n", "level": "middle"}
{"task_id": "Go/34", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {", "canonical_solution": "p, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}", "test": "func TestMakeEqualAgain(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, makeEqualAgain(3, []int{1, 2, 1}))\n\tassert.Equal(1, makeEqualAgain(5, []int{5, 5, 1, 5, 5}))\n\tassert.Equal(0, makeEqualAgain(4, []int{1, 1, 1, 1}))\n\tassert.Equal(1, makeEqualAgain(6, []int{2, 2, 2, 3, 2, 2}))\n\tassert.Equal(0, makeEqualAgain(1, []int{1}))\n\tassert.Equal(1, makeEqualAgain(2, []int{1, 2}))\n\tassert.Equal(2, makeEqualAgain(4, []int{1, 2, 2, 1}))\n\tassert.Equal(2, makeEqualAgain(7, []int{4, 4, 4, 3, 3, 4, 4}))\n\tassert.Equal(3, makeEqualAgain(6, []int{5, 4, 4, 4, 5, 5}))\n\tassert.Equal(5, makeEqualAgain(7, []int{1, 2, 1, 2, 1, 2, 1}))\n\tassert.Equal(4, makeEqualAgain(6, []int{1, 2, 3, 4, 5, 1}))\n\tassert.Equal(0, makeEqualAgain(7, []int{1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(2, makeEqualAgain(8, []int{8, 8, 8, 1, 2, 8, 8, 8}))\n\tassert.Equal(2, makeEqualAgain(3, []int{1, 2, 3}))\n\tassert.Equal(6, makeEqualAgain(7, []int{4, 3, 2, 7, 1, 1, 3}))\n\tassert.Equal(7, makeEqualAgain(9, []int{9, 9, 2, 9, 2, 5, 5, 5, 3}))\n}", "entry_point": "makeEqualAgain", "signature": "func makeEqualAgain(n int, a []int) int", "docstring": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n", "instruction": "Write a Go function `func makeEqualAgain(n int, a []int) int` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n", "level": "middle"}
{"task_id": "Go/35", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {", "canonical_solution": "if n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}", "test": "func TestGameWinner(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Dan\", GameWinner(3, []int{1, 2, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(5, []int{5, 5, 5, 5, 5}))\n\tassert.Equal(\"Charlie\", GameWinner(3, []int{2, 1, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(4, []int{3, 3, 3, 3}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{2, 1}))\n\tassert.Equal(\"Dan\", GameWinner(11, []int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{2, 2, 2, 2, 2, 2, 2, 2, 2, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{10, 10, 10, 10, 10, 10, 10, 10, 10, 10}))\n\tassert.Equal(\"Dan\", GameWinner(10, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}", "entry_point": "GameWinner", "signature": "func GameWinner(n int, piles []int) string", "docstring": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"", "instruction": "Write a Go function `func GameWinner(n int, piles []int) string` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"", "level": "middle"}
{"task_id": "Go/36", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {", "canonical_solution": "return int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}", "test": "func TestMinTotalCost(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(15), MinTotalCost(5, []int{4, 3, 3, 3, 3})) // Note the 0-indexed array for slice in Golang\n\tassert.Equal(int64(3), MinTotalCost(3, []int{1, 1, 1}))\n\tassert.Equal(int64(11), MinTotalCost(4, []int{5, 4, 3, 2}))\n\tassert.Equal(int64(391), MinTotalCost(4, []int{100, 99, 98, 97}))\n\tassert.Equal(int64(35), MinTotalCost(6, []int{10, 9, 8, 7, 6, 5}))\n\tassert.Equal(int64(14), MinTotalCost(7, []int{2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(56), MinTotalCost(8, []int{9, 7, 7, 7, 7, 7, 7, 7}))\n\tassert.Equal(int64(18), MinTotalCost(9, []int{3, 2, 2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(50), MinTotalCost(10, []int{6, 5, 5, 5, 5, 5, 5, 5, 5, 5}))\n\tassert.Equal(int64(11), MinTotalCost(11, []int{8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n}", "entry_point": "MinTotalCost", "signature": "func MinTotalCost(n int, C []int) int64", "docstring": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n", "instruction": "Write a Go function `func MinTotalCost(n int, C []int) int64` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n", "level": "easy"}
{"task_id": "Go/37", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {", "canonical_solution": "var ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}", "test": "func TestCountHandshakes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), CountHandshakes(4, []int{2, 1, 3, 0}))\n\tassert.Equal(int64(15), CountHandshakes(6, []int{0, 1, 2, 3, 4, 5}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{1, 2, 0}))\n\tassert.Equal(int64(0), CountHandshakes(4, []int{3, 2, 1, 0}))\n\tassert.Equal(int64(6), CountHandshakes(4, []int{0, 1, 2, 3}))\n\tassert.Equal(int64(0), CountHandshakes(6, []int{5, 4, 3, 2, 1, 0}))\n\tassert.Equal(int64(5), CountHandshakes(4, []int{0, 2, 1, 3}))\n\tassert.Equal(int64(3), CountHandshakes(5, []int{3, 1, 4, 2, 0}))\n\tassert.Equal(int64(4), CountHandshakes(4, []int{1, 0, 3, 2}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{2, 0, 1}))\n\tassert.Equal(int64(7), CountHandshakes(5, []int{1, 3, 0, 2, 4}))\n\tassert.Equal(int64(0), CountHandshakes(5, []int{4, 3, 2, 1, 0}))\n}\n\n// To run tests in Go, you can use the following command:\n// go test -v", "entry_point": "CountHandshakes", "signature": "func CountHandshakes(n int, order []int) int64", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n", "instruction": "Write a Go function `func CountHandshakes(n int, order []int) int64` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n", "level": "hard"}
{"task_id": "Go/38", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {", "canonical_solution": "ans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}", "test": "func TestMaxModeSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(17), MaxModeSum(3, []int{1, 3, 2}))\n\tassert.Equal(int64(37), MaxModeSum(4, []int{4, 1, 2, 3}))\n\tassert.Equal(int64(4), MaxModeSum(2, []int{1, 1}))\n\tassert.Equal(int64(75), MaxModeSum(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(int64(100000), MaxModeSum(1, []int{100000}))\n\tassert.Equal(int64(62), MaxModeSum(5, []int{5, 3, 2, 4, 1}))\n\tassert.Equal(int64(900000), MaxModeSum(3, []int{100000, 100000, 100000}))\n\tassert.Equal(int64(27), MaxModeSum(3, []int{2, 2, 5}))\n\tassert.Equal(int64(64), MaxModeSum(4, []int{4, 4, 4, 4}))\n\tassert.Equal(int64(126), MaxModeSum(6, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(int64(16), MaxModeSum(3, []int{3, 1, 2}))\n}", "entry_point": "MaxModeSum", "signature": "func MaxModeSum(n int, counts []int) int64", "docstring": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).", "instruction": "Write a Go function `func MaxModeSum(n int, counts []int) int64` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).", "level": "middle"}
{"task_id": "Go/39", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {", "canonical_solution": "n := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}", "test": "func TestSumOfXorSubarrays(t *testing.T) {\n\tassert.Equal(t, int64(39), sumOfXorSubarrays([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(t, int64(4), sumOfXorSubarrays([]int{1, 1, 1}))\n\tassert.Equal(t, int64(9), sumOfXorSubarrays([]int{2, 3, 1}))\n\tassert.Equal(t, int64(74), sumOfXorSubarrays([]int{4, 5, 7, 9}))\n\tassert.Equal(t, int64(0), sumOfXorSubarrays([]int{0, 0, 0, 0}))\n\tassert.Equal(t, int64(72), sumOfXorSubarrays([]int{8, 8, 8, 8, 8}))\n\tassert.Equal(t, int64(125), sumOfXorSubarrays([]int{3, 6, 9, 12, 15}))\n\tassert.Equal(t, int64(390), sumOfXorSubarrays([]int{10, 20, 30, 40, 50}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{16, 16, 16, 16, 16, 16}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{1, 3, 5, 7, 9, 11, 13}))\n\tassert.Equal(t, int64(218), sumOfXorSubarrays([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}))\n}", "entry_point": "sumOfXorSubarrays", "signature": "func sumOfXorSubarrays(A []int) int64", "docstring": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n", "instruction": "Write a Go function `func sumOfXorSubarrays(A []int) int64` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n", "level": "middle"}
{"task_id": "Go/40", "prompt": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {", "canonical_solution": "count := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}", "test": "func TestCountPowerNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(99, countPowerNumbers(99, 1))\n\tassert.Equal(7, countPowerNumbers(99, 3))\n\tassert.Equal(12, countPowerNumbers(99, 2))\n\tassert.Equal(10, countPowerNumbers(10, 1))\n\tassert.Equal(4, countPowerNumbers(10, 2))\n\tassert.Equal(500, countPowerNumbers(500, 1))\n\tassert.Equal(30, countPowerNumbers(500, 2))\n\tassert.Equal(13, countPowerNumbers(500, 3))\n\tassert.Equal(1000, countPowerNumbers(1000, 1))\n\tassert.Equal(41, countPowerNumbers(1000, 2))\n\tassert.Equal(17, countPowerNumbers(1000, 3))\n\tassert.Equal(1, countPowerNumbers(1000, 93))\n\tassert.Equal(10, countPowerNumbers(50, 2))\n\tassert.Equal(5, countPowerNumbers(50, 3))\n\tassert.Equal(1, countPowerNumbers(2, 3))\n}", "entry_point": "countPowerNumbers", "signature": "func countPowerNumbers(n int, k int) int", "docstring": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "instruction": "Write a Go function `func countPowerNumbers(n int, k int) int` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "level": "hard"}
{"task_id": "Go/41", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {", "canonical_solution": "const P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}", "test": "func TestCountBalancedSubsequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), countBalancedSubsequences(2, 2, 2))\n\tassert.Equal(int64(0), countBalancedSubsequences(3, 2, 3))\n\tassert.Equal(int64(4), countBalancedSubsequences(3, 2, 1))\n\tassert.Equal(int64(14), countBalancedSubsequences(4, 3, 2))\n\tassert.Equal(int64(35), countBalancedSubsequences(5, 5, 2))\n\tassert.Equal(int64(6), countBalancedSubsequences(6, 1, 1))\n\tassert.Equal(int64(6), countBalancedSubsequences(1, 6, 1))\n\tassert.Equal(int64(27), countBalancedSubsequences(7, 2, 2))\n\tassert.Equal(int64(110), countBalancedSubsequences(8, 3, 3))\n\tassert.Equal(int64(10659), countBalancedSubsequences(10, 10, 5))\n\tassert.Equal(int64(574221648), countBalancedSubsequences(20, 20, 10))\n\tassert.Equal(int64(854104531), countBalancedSubsequences(2000, 2000, 1000))\n\tassert.Equal(int64(334874485), countBalancedSubsequences(2000, 1999, 1000))\n\tassert.Equal(int64(259428024), countBalancedSubsequences(2000, 2000, 1999))\n}", "entry_point": "countBalancedSubsequences", "signature": "func countBalancedSubsequences(n, m, k int64) int64", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "instruction": "Write a Go function `func countBalancedSubsequences(n, m, k int64) int64` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "level": "hard"}
{"task_id": "Go/42", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {", "canonical_solution": "const MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}", "test": "func TestExpectedCuts(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(int64(0), expectedCuts(2, 4, 10))\n\tassert.Equal(int64(1), expectedCuts(2, 4, 8))\n\tassert.Equal(int64(833333342), expectedCuts(2, 4, 2))\n\tassert.Equal(int64(250000003), expectedCuts(2, 4, 6))\n\tassert.Equal(int64(666666673), expectedCuts(3, 3, 4))\n\tassert.Equal(int64(666666673), expectedCuts(5, 5, 12))\n\tassert.Equal(int64(722222229), expectedCuts(6, 7, 20))\n\tassert.Equal(int64(72727275), expectedCuts(8, 8, 30))\n\tassert.Equal(int64(714285721), expectedCuts(10, 10, 50))\n\tassert.Equal(int64(945634929), expectedCuts(1, 10, 5))\n\tassert.Equal(int64(945634929), expectedCuts(10, 1, 5))\n}", "entry_point": "expectedCuts", "signature": "func expectedCuts(n int, m int, k int64) int64", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n", "instruction": "Write a Go function `func expectedCuts(n int, m int, k int64) int64` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n", "level": "hard"}
{"task_id": "Go/43", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 \u2264 x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {", "canonical_solution": "const N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}", "test": "func TestCountPermutations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, CountPermutations(2, 1, []int{1, 2}))\n\tassert.Equal(1, CountPermutations(3, 3, []int{3, 1, 2}))\n\tassert.Equal(13, CountPermutations(6, 3, []int{1, 2, 3, 6, 5, 4}))\n\tassert.Equal(720, CountPermutations(6, 1, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(0, CountPermutations(6, 3, []int{1, 2, 5, 3, 4, 5}))\n\tassert.Equal(1, CountPermutations(9, 9, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(29093, CountPermutations(9, 2, []int{1, 2, 3, 4, 5, 6, 7, 9, 8}))\n}", "entry_point": "CountPermutations", "signature": "func CountPermutations(n int, k int, qq []int) int", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 \u2264 x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n", "instruction": "Write a Go function `func CountPermutations(n int, k int, qq []int) int` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 \u2264 x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n", "level": "hard"}
{"task_id": "Go/44", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {", "canonical_solution": "count := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}", "test": "func TestCountTriplets(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, countTriplets([]int{1, 5, 7}, 3))\n\tassert.Equal(3, countTriplets([]int{1, 6, 2, 3}, 4))\n\tassert.Equal(0, countTriplets([]int{16, 4, 8, 2}, 4))\n\tassert.Equal(77, countTriplets([]int{10, 1, 6, 7, 9, 8, 4, 3, 5, 2}, 10))\n\tassert.Equal(7, countTriplets([]int{4, 5, 9, 11, 14}, 5))\n\tassert.Equal(104, countTriplets([]int{15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}, 11))\n\tassert.Equal(4, countTriplets([]int{3, 7, 11, 13}, 4))\n\tassert.Equal(10, countTriplets([]int{5, 12, 13, 17, 19}, 5))\n\tassert.Equal(87, countTriplets([]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, 11))\n\tassert.Equal(122, countTriplets([]int{1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}, 11))\n}", "entry_point": "countTriplets", "signature": "func countTriplets(heights []int, n int) int", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n", "instruction": "Write a Go function `func countTriplets(heights []int, n int) int` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n", "level": "hard"}
{"task_id": "Go/45", "prompt": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {", "canonical_solution": "n := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}", "test": "func TestMinOperations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, minOperations([]int{1, 2, 3, 2, 1}))\n\tassert.Equal(1, minOperations([]int{1, 1, 2, 2}))\n\tassert.Equal(3, minOperations([]int{1, 2, 1, 4, 2}))\n\tassert.Equal(0, minOperations([]int{5, 5, 5, 5, 5}))\n\tassert.Equal(1, minOperations([]int{1, 1, 1, 2, 2, 2}))\n\tassert.Equal(2, minOperations([]int{1, 3, 3, 3, 2, 2, 2}))\n\tassert.Equal(1, minOperations([]int{4, 4, 4, 4, 3, 3, 3, 3}))\n\tassert.Equal(8, minOperations([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(5, minOperations([]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2}))\n\tassert.Equal(0, minOperations([]int{3, 3, 3}))\n\tassert.Equal(1, minOperations([]int{2, 1, 1, 2}))\n}", "entry_point": "minOperations", "signature": "func minOperations(pixels []int) int", "docstring": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n", "instruction": "Write a Go function `func minOperations(pixels []int) int` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n", "level": "hard"}
{"task_id": "Go/46", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {", "canonical_solution": "sum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}", "test": "func TestSumOfMultiples(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(33, sumOfMultiples(10))\n\tassert.Equal(60, sumOfMultiples(15))\n\tassert.Equal(98, sumOfMultiples(20))\n\tassert.Equal(8, sumOfMultiples(5))\n\tassert.Equal(3, sumOfMultiples(3))\n\tassert.Equal(14, sumOfMultiples(6))\n\tassert.Equal(23, sumOfMultiples(9))\n\tassert.Equal(45, sumOfMultiples(12))\n\tassert.Equal(60, sumOfMultiples(17))\n\tassert.Equal(119, sumOfMultiples(21))\n\tassert.Equal(168, sumOfMultiples(25))\n}", "entry_point": "sumOfMultiples", "signature": "func sumOfMultiples(n int) int", "docstring": "Given an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n", "instruction": "Write a Go function `func sumOfMultiples(n int) int` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n", "level": "easy"}
{"task_id": "Go/47", "prompt": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the\nsame forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {", "canonical_solution": "str = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}", "test": "func TestIsPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.True(IsPalindrome(\"A man a plan a canal Panama\"))\n\tassert.True(IsPalindrome(\"No lemon, no melon\"))\n\tassert.True(IsPalindrome(\"Was it a car or a cat I saw\"))\n\tassert.True(IsPalindrome(\"Madam, in Eden, I'm Adam\"))\n\tassert.True(IsPalindrome(\"Never odd or even\"))\n\tassert.True(IsPalindrome(\"Eva, can I see bees in a cave\"))\n\tassert.False(IsPalindrome(\"hello\"))\n\tassert.False(IsPalindrome(\"GitHub\"))\n\tassert.False(IsPalindrome(\"programming\"))\n}", "entry_point": "IsPalindrome", "signature": "func IsPalindrome(str string) bool", "docstring": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue", "instruction": "Write a Go function `func IsPalindrome(str string) bool` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue", "level": "hard"}
{"task_id": "Go/48", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nfunc addDigits(num int) int {", "canonical_solution": "for num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}", "test": "func TestAddDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, addDigits(38))\n\tassert.Equal(0, addDigits(0))\n\tassert.Equal(9, addDigits(9))\n\tassert.Equal(6, addDigits(123))\n\tassert.Equal(6, addDigits(456))\n\tassert.Equal(9, addDigits(9999))\n\tassert.Equal(1, addDigits(100))\n\tassert.Equal(2, addDigits(1010))\n\tassert.Equal(1, addDigits(1234))\n\tassert.Equal(3, addDigits(9876))\n\tassert.Equal(1, addDigits(199))\n}", "entry_point": "addDigits", "signature": "func addDigits(num int) int", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "instruction": "Write a Go function `func addDigits(num int) int` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "level": "easy"}
{"task_id": "Go/49", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {", "canonical_solution": "return n%4 != 0\n}", "test": "func TestCanWinNim(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, canWinNim(1))\n\tassert.Equal(true, canWinNim(2))\n\tassert.Equal(true, canWinNim(3))\n\tassert.Equal(false, canWinNim(4))\n\tassert.Equal(true, canWinNim(5))\n\tassert.Equal(true, canWinNim(6))\n\tassert.Equal(true, canWinNim(7))\n\tassert.Equal(false, canWinNim(8))\n\tassert.Equal(true, canWinNim(9))\n\tassert.Equal(true, canWinNim(10))\n\tassert.Equal(true, canWinNim(11))\n\tassert.Equal(false, canWinNim(12))\n\tassert.Equal(true, canWinNim(13))\n\tassert.Equal(true, canWinNim(14))\n\tassert.Equal(true, canWinNim(15))\n\tassert.Equal(false, canWinNim(16))\n\tassert.Equal(true, canWinNim(17))\n\tassert.Equal(true, canWinNim(18))\n\tassert.Equal(true, canWinNim(19))\n\tassert.Equal(false, canWinNim(20))\n}", "entry_point": "canWinNim", "signature": "func canWinNim(n int) bool", "docstring": "You are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n", "instruction": "Write a Go function `func canWinNim(n int) bool` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n", "level": "easy"}
{"task_id": "Go/50", "prompt": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {", "canonical_solution": "sum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}", "test": "func TestEvenSumOrOddProduct(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, EvenSumOrOddProduct(2, 3))\n\tassert.Equal(10, EvenSumOrOddProduct(5, 5))\n\tassert.Equal(2, EvenSumOrOddProduct(1, 1))\n\tassert.Equal(0, EvenSumOrOddProduct(0, 0))\n\tassert.Equal(-2, EvenSumOrOddProduct(-1, -1))\n\tassert.Equal(300, EvenSumOrOddProduct(100, 200))\n\tassert.Equal(12, EvenSumOrOddProduct(3, 4))\n\tassert.Equal(0, EvenSumOrOddProduct(-5, 5))\n\tassert.Equal(56, EvenSumOrOddProduct(7, 8))\n\tassert.Equal(90, EvenSumOrOddProduct(9, 10))\n\tassert.Equal(154, EvenSumOrOddProduct(11, 14))\n}", "entry_point": "EvenSumOrOddProduct", "signature": "func EvenSumOrOddProduct(a, b int) int", "docstring": "EvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10", "instruction": "Write a Go function `func EvenSumOrOddProduct(a, b int) int` to solve the following problem:\nEvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10", "level": "easy"}
