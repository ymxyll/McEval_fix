{"task_id": "Common Lisp/1", "prompt": "(defun has-close-elements (numbers threshold)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t", "canonical_solution": "(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)", "test": "(defun check-has-close-elements ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)", "entry_point": "has-close-elements", "signature": "(defun has-close-elements (numbers threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'", "instruction": "Write a Common Lisp function `(defun has-close-elements (numbers threshold)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'", "level": "middle"}
{"task_id": "Common Lisp/2", "prompt": "(defun bin-search (obj vec)\n;; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.\n;; Example:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t", "canonical_solution": "(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))", "test": "(defun check-bin-search ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check-bin-search)", "entry_point": "bin-search", "signature": "(defun bin-search (obj vec)", "docstring": "Binary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt", "instruction": "Write a Common Lisp function `(defun bin-search (obj vec)` to solve the following problem:\nBinary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt", "level": "middle"}
{"task_id": "Common Lisp/3", "prompt": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n;; Example:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980", "canonical_solution": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))", "test": "(defun check-parse-date ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check-parse-date)", "entry_point": "parse-date", "signature": "(defun parse-date (date-str)", "docstring": "\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980", "instruction": "Write a Common Lisp function `(defun parse-date (date-str)` to solve the following problem:\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980", "level": "hard"}
{"task_id": "Common Lisp/4", "prompt": "(defun fourth-element (lst)\n;; use car and cdr to return the fourth element in list\n;; Example:\n;; >>> fourth-element '(a b c d e f)\n;; 'd", "canonical_solution": "(car (cdr (cdr (cdr lst)))))", "test": "(defun check-fourth-element ()\n(assert (equal (fourth-element '(a b c d e f)) 'd))\n(assert (equal (fourth-element '(1 2 3 4 5 6)) 4))\n(assert (equal (fourth-element '(\"one\" \"two\" \"three\" \"four\" \"five\")) \"four\")))\n\n(check-fourth-element)", "entry_point": "fourth-element", "signature": "(defun fourth-element (lst)", "docstring": "use car and cdr to return the fourth element in list\nExample:\n>>> fourth-element '(a b c d e f)\n'd", "instruction": "Write a Common Lisp function `(defun fourth-element (lst)` to solve the following problem:\nuse car and cdr to return the fourth element in list\nExample:\n>>> fourth-element '(a b c d e f)\n'd", "level": "easy"}
{"task_id": "Common Lisp/5", "prompt": "(defun count-a-in-list (lst)\n;; Calculate the number of times' a 'appears in the list.\n;; Example:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3", "canonical_solution": "(loop for item in lst\ncounting (eql item 'a)))", "test": "(defun check-count-a-in-list ()\n(assert (equal (count-a-in-list '(a b c d a e f a)) 3))\n(assert (equal (count-a-in-list '(1 2 3 4 5)) 0))\n(assert (equal (count-a-in-list '(a a a a)) 4))\n(assert (equal (count-a-in-list '(b c d)) 0)))\n\n(check-count-a-in-list)", "entry_point": "count-a-in-list", "signature": "(defun count-a-in-list (lst)", "docstring": "Calculate the number of times' a 'appears in the list.\nExample:\n>>> count-a-in-list '(a b c d a e f a)\n3", "instruction": "Write a Common Lisp function `(defun count-a-in-list (lst)` to solve the following problem:\nCalculate the number of times' a 'appears in the list.\nExample:\n>>> count-a-in-list '(a b c d a e f a)\n3", "level": "easy"}
{"task_id": "Common Lisp/6", "prompt": "(defun ordered-union (list1 list2)\n;; Write a version of union that preserves the order of the elements in the original lists:\n;; Example:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6", "canonical_solution": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))", "test": "(defun check-ordered-union ()\n(assert (equal (ordered-union '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))\n(assert (equal (ordered-union '(1 2 3) '(3 4 5)) '(1 2 3 4 5)))\n(assert (equal (ordered-union '(a b c) '(b c d)) '(a b c d)))\n(assert (equal (ordered-union '() '(1 2 3)) '(1 2 3)))\n(assert (equal (ordered-union '(1 2 3) '()) '(1 2 3))))\n\n(check-ordered-union)", "entry_point": "ordered-union", "signature": "(defun ordered-union (list1 list2)", "docstring": "Write a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6", "instruction": "Write a Common Lisp function `(defun ordered-union (list1 list2)` to solve the following problem:\nWrite a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6", "level": "easy"}
{"task_id": "Common Lisp/7", "prompt": "(defun occurrences (lst)\n;; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\n;; Example:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)", "canonical_solution": "(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))", "test": "(defun check-occurrences ()\n;; \u6d4b\u8bd5 'occurrences' \u51fd\u6570\u3002\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check-occurrences)", "entry_point": "occurrences", "signature": "(defun occurrences (lst)", "docstring": "takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "instruction": "Write a Common Lisp function `(defun occurrences (lst)` to solve the following problem:\ntakes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)", "level": "easy"}
{"task_id": "Common Lisp/8", "prompt": "(defun list-to-dots (lst)\n;; takes a list and prints it in dot natation\n;; Example:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))", "canonical_solution": "(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))", "test": "(defun check-list-to-dots ()\n;; \u6d4b\u8bd5 'list-to-dots' \u51fd\u6570\u3002\n(assert (equal (list-to-dots '(a b c)) '(a . (b . (c . nil)))))\n(assert (equal (list-to-dots '(1 2 3)) '(1 . (2 . (3 . nil)))))\n(assert (equal (list-to-dots '(x y)) '(x . (y . nil))))\n(assert (equal (list-to-dots '()) 'nil)))\n\n(check-list-to-dots)", "entry_point": "list-to-dots", "signature": "(defun list-to-dots (lst)", "docstring": "takes a list and prints it in dot natation\nExample:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))", "instruction": "Write a Common Lisp function `(defun list-to-dots (lst)` to solve the following problem:\ntakes a list and prints it in dot natation\nExample:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))", "level": "easy"}
{"task_id": "Common Lisp/9", "prompt": "(defun contains-nil? (lst)\n;; Check if the list contains nil elements\n;; Example:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t", "canonical_solution": "(loop for item in lst\nthereis (null item)))", "test": "(defun check-contains-nil? ()\n(assert (equal (contains-nil? '(1 2 3 nil 4 5)) t))\n(assert (equal (contains-nil? '(1 2 3 4 5)) nil))\n(assert (equal (contains-nil? '(nil 1 2 3)) t))\n(assert (equal (contains-nil? '()) nil))\n(assert (equal (contains-nil? '(nil)) t)))\n\n(check-contains-nil?)", "entry_point": "contains-nil?", "signature": "(defun contains-nil? (lst)", "docstring": "Check if the list contains nil elements\nExample:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt", "instruction": "Write a Common Lisp function `(defun contains-nil? (lst)` to solve the following problem:\nCheck if the list contains nil elements\nExample:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt", "level": "easy"}
{"task_id": "Common Lisp/10", "prompt": "(defun index-of-element (element lst)\n;; Returns the index of the element in the list, or nil if the element is not in the list.\n;; Example:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0", "canonical_solution": "(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))", "test": "(defun check-index-of-element ()\n;; \u6d4b\u8bd5 'index-of-element' \u51fd\u6570\u3002\n(assert (equal (index-of-element 'a '(a b c d e)) 0))\n(assert (equal (index-of-element 'c '(a b c d e)) 2))\n(assert (equal (index-of-element 'e '(a b c d e)) 4))\n(assert (equal (index-of-element 'f '(a b c d e)) nil))\n(assert (equal (index-of-element 3 '(1 2 3 4 5)) 2)))\n\n(check-index-of-element)", "entry_point": "index-of-element", "signature": "(defun index-of-element (element lst)", "docstring": "Returns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0", "instruction": "Write a Common Lisp function `(defun index-of-element (element lst)` to solve the following problem:\nReturns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0", "level": "easy"}
{"task_id": "Common Lisp/11", "prompt": "(defun contains-list? (lst)\n;; Check if the list contains a list element.\n;; Example:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t", "canonical_solution": "(loop for item in lst\nthereis (listp item)))", "test": "(defun check-contains-list? ()\n;; \u6d4b\u8bd5 'contains-list?' \u51fd\u6570\u3002\n(assert (equal (contains-list? '(1 2 (3 4) 5)) t))\n(assert (equal (contains-list? '(1 2 3 4 5)) nil))\n(assert (equal (contains-list? '((1 2) 3 4 5)) t))\n(assert (equal (contains-list? '()) nil))\n(assert (equal (contains-list? '(\"string\" 123 (a b))) t)))\n\n(check-contains-list?)", "entry_point": "contains-list?", "signature": "(defun contains-list? (lst)", "docstring": "Check if the list contains a list element.\nExample:\n>>> ontains-list? '(1 2 (3 4) 5)\nt", "instruction": "Write a Common Lisp function `(defun contains-list? (lst)` to solve the following problem:\nCheck if the list contains a list element.\nExample:\n>>> ontains-list? '(1 2 (3 4) 5)\nt", "level": "easy"}
{"task_id": "Common Lisp/12", "prompt": "(defun sum-non-nil-elements (lst)\n;; Calculate the sum of all non nil elements in the list.\n;; Example:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12", "canonical_solution": "(loop for item in lst\nwhen (not (null item))\nsum item))", "test": "(defun check-sum-non-nil-elements ()\n(assert (equal (sum-non-nil-elements '(1 2 nil 4 5)) 12))\n(assert (equal (sum-non-nil-elements '(nil nil nil)) 0))\n(assert (equal (sum-non-nil-elements '(3 4 nil 6)) 13))\n(assert (equal (sum-non-nil-elements '()) 0))\n(assert (equal (sum-non-nil-elements '(nil 7 8)) 15)))\n\n(check-sum-non-nil-elements)", "entry_point": "sum-non-nil-elements", "signature": "(defun sum-non-nil-elements (lst)", "docstring": "Calculate the sum of all non nil elements in the list.\nExample:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12", "instruction": "Write a Common Lisp function `(defun sum-non-nil-elements (lst)` to solve the following problem:\nCalculate the sum of all non nil elements in the list.\nExample:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12", "level": "easy"}
{"task_id": "Common Lisp/13", "prompt": "(defun conditional-square (x)\n;; If x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\n;; Example:\n;; >>> conditional-square 3\n;; 3", "canonical_solution": "(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))", "test": "(defun check-conditional-square ()\n;; \u6d4b\u8bd5 'conditional-square' \u51fd\u6570\u3002\n(assert (equal (conditional-square 3) 3))\n(assert (equal (conditional-square 5) 5))\n(assert (equal (conditional-square 6) 36))\n(assert (equal (conditional-square -3) 9))\n(assert (equal (conditional-square 2.5) 6.25)))\n\n(check-conditional-square)", "entry_point": "conditional-square", "signature": "(defun conditional-square (x)", "docstring": "If x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\nExample:\n>>> conditional-square 3\n3", "instruction": "Write a Common Lisp function `(defun conditional-square (x)` to solve the following problem:\nIf x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\nExample:\n>>> conditional-square 3\n3", "level": "easy"}
{"task_id": "Common Lisp/14", "prompt": "(defun lines-from-file (filename)\n;; Read each line from the file and return them as a string list.", "canonical_solution": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))", "test": "(defun check-lines-from-file ()\n(let ((lines (lines-from-file \"../data/Common Lisp/file.txt\")))\n(assert (equal (first lines) \"First line of the file\"))\n(assert (equal (second lines) \"Second line of the file\"))))\n\n(check-lines-from-file)", "entry_point": "lines-from-file", "signature": "(defun lines-from-file (filename)", "docstring": "Read each line from the file and return them as a string list.", "instruction": "Write a Common Lisp function `(defun lines-from-file (filename)` to solve the following problem:\nRead each line from the file and return them as a string list.", "level": "easy"}
{"task_id": "Common Lisp/15", "prompt": "(defun nondecreasing? (numbers)\n;; Check if the real number list is in non decreasing order.\n;; Example:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t", "canonical_solution": "(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))", "test": "(defun check-nondecreasing? ()\n(assert (equal (nondecreasing? '(1.0 2.0 2.0 3.0 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 3.0 3.9 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 1.0 4.0 5.0)) nil))\n(assert (equal (nondecreasing? '(5.0 5.0 5.0 5.0)) t))\n(assert (equal (nondecreasing? '(1.0)) t))\n(assert (equal (nondecreasing? '()) t)))\n\n(check-nondecreasing?)", "entry_point": "nondecreasing?", "signature": "(defun nondecreasing? (numbers)", "docstring": "Check if the real number list is in non decreasing order.\nExample:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt", "instruction": "Write a Common Lisp function `(defun nondecreasing? (numbers)` to solve the following problem:\nCheck if the real number list is in non decreasing order.\nExample:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt", "level": "easy"}
{"task_id": "Common Lisp/16", "prompt": "(defun make-change (cents)\n;; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\n;; Example:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3", "canonical_solution": "(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))", "test": "(defun check-make-change ()\n;; \u6d4b\u8bd5 'make-change' \u51fd\u6570\u3002\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check-make-change)", "entry_point": "make-change", "signature": "(defun make-change (cents)", "docstring": "Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3", "instruction": "Write a Common Lisp function `(defun make-change (cents)` to solve the following problem:\nDefine a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3", "level": "middle"}
{"task_id": "Common Lisp/17", "prompt": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\n;; Example:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5", "canonical_solution": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))", "test": "(defun check-segments-intersect? ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check-segments-intersect?)", "entry_point": "segments-intersect?", "signature": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)", "docstring": "Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5", "instruction": "Write a Common Lisp function `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` to solve the following problem:\nDefine a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5", "level": "hard"}
{"task_id": "Common Lisp/18", "prompt": "(defun quicksort (list)\n;; Quickly sort the list\n;; Example:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9", "canonical_solution": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))", "test": "(defun check-quicksort ()\n;; \u6d4b\u8bd5 'quicksort' \u51fd\u6570\u3002\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check-quicksort)", "entry_point": "quicksort", "signature": "(defun quicksort (list)", "docstring": "Quickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "instruction": "Write a Common Lisp function `(defun quicksort (list)` to solve the following problem:\nQuickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9", "level": "middle"}
{"task_id": "Common Lisp/19", "prompt": "(defun enqueue-front (object queue)\n;; Define a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\n;; Example:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4", "canonical_solution": "(cons object queue))", "test": "(defun check-enqueue-front ()\n(let ((queue '(2 3 4)))\n(setq queue (enqueue-front 1 queue))\n(assert (equal queue '(1 2 3 4))))\n(let ((queue '()))\n(setq queue (enqueue-front 'a queue))\n(assert (equal queue '(a)))))\n\n(check-enqueue-front)", "entry_point": "enqueue-front", "signature": "(defun enqueue-front (object queue)", "docstring": "Define a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\nExample:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4", "instruction": "Write a Common Lisp function `(defun enqueue-front (object queue)` to solve the following problem:\nDefine a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\nExample:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4", "level": "easy"}
{"task_id": "Common Lisp/20", "prompt": "(defun move-first-instance-to-front (object queue)\n;; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\n;; Example:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d", "canonical_solution": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))", "test": "(defun check-move-first-instance-to-front ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check-move-first-instance-to-front)", "entry_point": "move-first-instance-to-front", "signature": "(defun move-first-instance-to-front (object queue)", "docstring": "Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "instruction": "Write a Common Lisp function `(defun move-first-instance-to-front (object queue)` to solve the following problem:\nDefine a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d", "level": "hard"}
{"task_id": "Common Lisp/21", "prompt": "(defun find-substring-index (haystack needle)\n;; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.\n;; Example:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Returns 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Returns -1", "canonical_solution": "(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))", "test": "(defun test-find-substring-index ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(test-find-substring-index)", "entry_point": "find-substring-index", "signature": "(defun find-substring-index (haystack needle)", "docstring": "Finds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1", "instruction": "Write a Common Lisp function `(defun find-substring-index (haystack needle)` to solve the following problem:\nFinds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1", "level": "middle"}
{"task_id": "Common Lisp/22", "prompt": "(defun min-n-for-sum-greater-than-k (k)\n;; Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; is greater than a given integer k.\n;; The function returns the smallest such n.\n;; Example:\n;; (min-n-for-sum-greater-than-k 2) ;; Returns 4\n;; (min-n-for-sum-greater-than-k 3) ;; Returns 11", "canonical_solution": "(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))", "test": "(defun test-min-n-for-sum-greater-than-k ()\n(assert (equal (min-n-for-sum-greater-than-k 1) 2))\n(assert (equal (min-n-for-sum-greater-than-k 2) 4))\n(assert (equal (min-n-for-sum-greater-than-k 3) 11))\n(assert (equal (min-n-for-sum-greater-than-k 4) 31))\n(assert (equal (min-n-for-sum-greater-than-k 5) 83))\n(assert (equal (min-n-for-sum-greater-than-k 0) 1)))\n\n(test-min-n-for-sum-greater-than-k)", "entry_point": "min-n-for-sum-greater-than-k", "signature": "(defun min-n-for-sum-greater-than-k (k)", "docstring": "Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11", "instruction": "Write a Common Lisp function `(defun min-n-for-sum-greater-than-k (k)` to solve the following problem:\nCalculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11", "level": "easy"}
{"task_id": "Common Lisp/23", "prompt": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Counts the number of apples that Fengfeng can reach.\n;; 'apple-heights' is a list of integers representing the heights of apples.\n;; 'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\n;; Fengfeng can reach apples at or below her maximum height.\n;; Example:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Returns 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Returns 10", "canonical_solution": "(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))", "test": "(defun test-count-reachable-apples ()\n(assert (equal (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4))\n(assert (equal (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10))\n(assert (equal (count-reachable-apples '(110 115 120 125 130 135 140 145 150 155) 120) 3))\n(assert (equal (count-reachable-apples '(200 199 198 197 196 195 194 193 192 191) 190) 0))\n(assert (equal (count-reachable-apples '(101 102 103 104 105 106 107 108 109 110) 105) 5)))\n\n(test-count-reachable-apples)", "entry_point": "count-reachable-apples", "signature": "(defun count-reachable-apples (apple-heights fengfeng-height)", "docstring": "Counts the number of apples that Fengfeng can reach.\n'apple-heights' is a list of integers representing the heights of apples.\n'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\nFengfeng can reach apples at or below her maximum height.\nExample:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10", "instruction": "Write a Common Lisp function `(defun count-reachable-apples (apple-heights fengfeng-height)` to solve the following problem:\nCounts the number of apples that Fengfeng can reach.\n'apple-heights' is a list of integers representing the heights of apples.\n'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\nFengfeng can reach apples at or below her maximum height.\nExample:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10", "level": "easy"}
{"task_id": "Common Lisp/24", "prompt": "(defun count-remaining-trees (road-length regions)\n;; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.\n;; Example:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Returns 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Returns 7", "canonical_solution": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))", "test": "(defun test-count-remaining-trees ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(test-count-remaining-trees)", "entry_point": "count-remaining-trees", "signature": "(defun count-remaining-trees (road-length regions)", "docstring": "Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7", "instruction": "Write a Common Lisp function `(defun count-remaining-trees (road-length regions)` to solve the following problem:\nCounts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7", "level": "easy"}
{"task_id": "Common Lisp/25", "prompt": "(defun larger-prime-factor (n)\n;; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.\n;; Example:\n;; (larger-prime-factor 15) ;; Returns 5\n;; (larger-prime-factor 33) ;; Returns 11", "canonical_solution": "(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))", "test": "(defun test-larger-prime-factor ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(test-larger-prime-factor)", "entry_point": "larger-prime-factor", "signature": "(defun larger-prime-factor (n)", "docstring": "Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11", "instruction": "Write a Common Lisp function `(defun larger-prime-factor (n)` to solve the following problem:\nFinds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11", "level": "easy"}
{"task_id": "Common Lisp/26", "prompt": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n;; 'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\n;; The function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\n;; Example:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Returns 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Returns 0", "canonical_solution": "(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))", "test": "(defun test-day-of-max-unhappiness ()\n(assert (equal (day-of-max-unhappiness '((5 3) (6 2) (7 2) (5 3) (5 4) (0 4) (0 6))) 3))\n(assert (equal (day-of-max-unhappiness '((4 4) (4 4) (4 4) (4 4) (4 4) (4 4) (4 4))) 0))\n(assert (equal (day-of-max-unhappiness '((3 3) (3 3) (3 3) (3 3) (3 3) (3 3) (3 3))) 0))\n(assert (equal (day-of-max-unhappiness '((2 6) (3 5) (4 4) (5 3) (6 2) (7 1) (1 7))) 0))\n(assert (equal (day-of-max-unhappiness '((5 0) (0 5) (6 3) (3 6) (2 7) (7 2) (4 4))) 3)))\n(test-day-of-max-unhappiness)", "entry_point": "day-of-max-unhappiness", "signature": "(defun day-of-max-unhappiness (weekly-schedule)", "docstring": "Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0", "instruction": "Write a Common Lisp function `(defun day-of-max-unhappiness (weekly-schedule)` to solve the following problem:\nAnalyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0", "level": "middle"}
{"task_id": "Common Lisp/27", "prompt": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7", "canonical_solution": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest", "test": "(defun test-calculate-year-end-amount ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(test-calculate-year-end-amount)", "entry_point": "calculate-year-end-amount", "signature": "(defun calculate-year-end-amount (monthly-budgets)", "docstring": "Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7", "instruction": "Write a Common Lisp function `(defun calculate-year-end-amount (monthly-budgets)` to solve the following problem:\nCalculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7", "level": "hard"}
{"task_id": "Common Lisp/28", "prompt": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.\n;; Example:\n;; (total-cigarettes-smoked 4 3) ;; Returns 5\n;; (total-cigarettes-smoked 10 4) ;; Returns 13", "canonical_solution": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))", "test": "(defun test-total-cigarettes-smoked ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(test-total-cigarettes-smoked)", "entry_point": "total-cigarettes-smoked", "signature": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)", "docstring": "Calculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13", "instruction": "Write a Common Lisp function `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13", "level": "middle"}
{"task_id": "Common Lisp/29", "prompt": "(defun divisible-five-digit-numbers (k)\n;; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.\n;; Example:\n;; (divisible-five-digit-numbers 15) ;; Returns (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Returns a list of numbers or 'No' if no such numbers exist", "canonical_solution": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))", "test": "(defun test-divisible-five-digit-numbers ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(test-divisible-five-digit-numbers)", "entry_point": "divisible-five-digit-numbers", "signature": "(defun divisible-five-digit-numbers (k)", "docstring": "Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist", "instruction": "Write a Common Lisp function `(defun divisible-five-digit-numbers (k)` to solve the following problem:\nFinds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist", "level": "middle"}
{"task_id": "Common Lisp/30", "prompt": "(defun count-digit-two (L R)\n;; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.\n;; Example:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9", "canonical_solution": "(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))", "test": "(defun test-count-digit-two ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(test-count-digit-two)", "entry_point": "count-digit-two", "signature": "(defun count-digit-two (L R)", "docstring": "This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9", "instruction": "Write a Common Lisp function `(defun count-digit-two (L R)` to solve the following problem:\nThis function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9", "level": "easy"}
{"task_id": "Common Lisp/31", "prompt": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"", "canonical_solution": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))", "test": "(defun test-represent-as-powers-of-two ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(test-represent-as-powers-of-two)", "entry_point": "represent-as-powers-of-two", "signature": "(defun represent-as-powers-of-two (n)", "docstring": "This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"", "instruction": "Write a Common Lisp function `(defun represent-as-powers-of-two (n)` to solve the following problem:\nThis function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"", "level": "hard"}
{"task_id": "Common Lisp/32", "prompt": "(defun create-largest-number (numbers)\n;; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\n;; Example:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"", "canonical_solution": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))", "test": "(defun test-create-largest-number ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(test-create-largest-number)", "entry_point": "create-largest-number", "signature": "(defun create-largest-number (numbers)", "docstring": "This function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"", "instruction": "Write a Common Lisp function `(defun create-largest-number (numbers)` to solve the following problem:\nThis function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"", "level": "hard"}
{"task_id": "Common Lisp/33", "prompt": "(defun add-numbers (a b)\n\"Add two numbers together.\"\n;; Example:\n;; >>> add-numbers 1 2\n;; 3", "canonical_solution": "(+ a b))", "test": "(defun test_add()\n(assert (equal (add-numbers 1 2) 3))\n(assert (equal (add-numbers 20 10) 30))\n(assert (equal (add-numbers -1 -2) -3))\n)\n;; \u8fd0\u884c\u6d4b\u8bd5\n(test_add)", "entry_point": "add-numbers", "signature": "(defun add-numbers (a b)", "docstring": "\"Add two numbers together.\"\nExample:\n>>> add-numbers 1 2\n3", "instruction": "Write a Common Lisp function `(defun add-numbers (a b)` to solve the following problem:\n\"Add two numbers together.\"\nExample:\n>>> add-numbers 1 2\n3", "level": "easy"}
{"task_id": "Common Lisp/34", "prompt": "(defun count-valid-sequences (n)\n;; This function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\n;; A valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\n;; Example:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4", "canonical_solution": "(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))", "test": "(defun test-count-valid-sequences ()\n(assert (equal (count-valid-sequences 6) 6))\n(assert (equal (count-valid-sequences 4) 4))\n(assert (equal (count-valid-sequences 10) 14))\n(assert (equal (count-valid-sequences 2) 2))\n(assert (equal (count-valid-sequences 1) 1)))\n\n(test-count-valid-sequences)", "entry_point": "count-valid-sequences", "signature": "(defun count-valid-sequences (n)", "docstring": "This function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\nA valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\nExample:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4", "instruction": "Write a Common Lisp function `(defun count-valid-sequences (n)` to solve the following problem:\nThis function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\nA valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\nExample:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4", "level": "easy"}
{"task_id": "Common Lisp/35", "prompt": "(defun construct-preorder (inorder postorder)\n;; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.\n;; Example:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"", "canonical_solution": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))", "test": "(defun test-construct-preorder ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(test-construct-preorder)", "entry_point": "construct-preorder", "signature": "(defun construct-preorder (inorder postorder)", "docstring": "This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"", "instruction": "Write a Common Lisp function `(defun construct-preorder (inorder postorder)` to solve the following problem:\nThis function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"", "level": "hard"}
{"task_id": "Common Lisp/36", "prompt": "(defun count-prime-sums (numbers k)\n;; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\n;; Example:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) and (3+4) are prime\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Only (1+2+5) is prime", "canonical_solution": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))", "test": "(defun test-count-prime-sums ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(test-count-prime-sums)", "entry_point": "count-prime-sums", "signature": "(defun count-prime-sums (numbers k)", "docstring": "This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime", "instruction": "Write a Common Lisp function `(defun count-prime-sums (numbers k)` to solve the following problem:\nThis function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime", "level": "hard"}
{"task_id": "Common Lisp/37", "prompt": "(defun calculate-table-tennis-scores (record)\n;; This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \n;; and calculates the scores under 11-point and 21-point systems.\n;; 'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\n;; The function returns two lists: the first list contains the scores under the 11-point system, \n;; and the second list contains the scores under the 21-point system.\n;; Example:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))", "canonical_solution": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))", "test": "(defun test-calculate-table-tennis-scores ()\n(assert (equal (calculate-table-tennis-scores \"WWLLWE\") '((\"3:2\") (\"3:2\"))))\n(assert (equal (calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\") '((\"11:0\" \"2:1\") (\"13:1\"))))\n(assert (equal (calculate-table-tennis-scores \"WLWLWLWLWLE\") '((\"5:5\") (\"5:5\"))))\n(assert (equal (calculate-table-tennis-scores \"LWE\") '((\"1:1\") (\"1:1\")))))\n\n(test-calculate-table-tennis-scores)", "entry_point": "calculate-table-tennis-scores", "signature": "(defun calculate-table-tennis-scores (record)", "docstring": "This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))", "instruction": "Write a Common Lisp function `(defun calculate-table-tennis-scores (record)` to solve the following problem:\nThis function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))", "level": "hard"}
{"task_id": "Common Lisp/38", "prompt": "(defun count-output-sequences (n)\n;; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\n;; Example:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14", "canonical_solution": "(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))", "test": "(defun test-count-output-sequences ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(test-count-output-sequences)", "entry_point": "count-output-sequences", "signature": "(defun count-output-sequences (n)", "docstring": "This function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14", "instruction": "Write a Common Lisp function `(defun count-output-sequences (n)` to solve the following problem:\nThis function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14", "level": "easy"}
{"task_id": "Common Lisp/39", "prompt": "(defun max-herb-value (time-limit herb-info)\n;; This function calculates the maximum total value of herbs that can be collected within a given time limit.\n;; 'time-limit' is the total time available for collecting herbs.\n;; 'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\n;; The function uses a dynamic programming approach to determine the maximum value that can be obtained.\n;; Example:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14", "canonical_solution": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))", "test": "(defun test-max-herb-value ()\n(assert (equal (max-herb-value 70 '((71 100) (69 1) (1 2))) 3))\n(assert (equal (max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))) 14))\n(assert (equal (max-herb-value 15 '((5 10) (10 15) (20 25))) 25))\n(assert (equal (max-herb-value 100 '((50 60) (50 70))) 130))\n(assert (equal (max-herb-value 5 '((2 3) (2 4) (1 1))) 8)))\n\n(test-max-herb-value)", "entry_point": "max-herb-value", "signature": "(defun max-herb-value (time-limit herb-info)", "docstring": "This function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14", "instruction": "Write a Common Lisp function `(defun max-herb-value (time-limit herb-info)` to solve the following problem:\nThis function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14", "level": "middle"}
{"task_id": "Common Lisp/40", "prompt": "(defun min-box-space (box-capacity item-volumes)\n;; This function calculates the minimum remaining space in a box after optimally packing a given set of items.\n;; Each item has a specific volume, and the box has a fixed capacity.\n;; The function returns the smallest possible remaining space in the box.\n;; Example:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0", "canonical_solution": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))", "test": "(defun test-min-box-space ()\n(assert (equal (min-box-space 20 '(5 5 10 6)) 0))\n(assert (equal (min-box-space 25 '(7 8 5 10)) 0))\n(assert (equal (min-box-space 12 '(3 2 2 5)) 0))\n(assert (equal (min-box-space 30 '(10 10 12)) 8))\n(assert (equal (min-box-space 8 '(1 2 3 4)) 0))\n(assert (equal (min-box-space 18 '(2 5 6 8)) 2))\n(assert (equal (min-box-space 11 '(1 2 3)) 5)))\n\n(test-min-box-space)", "entry_point": "min-box-space", "signature": "(defun min-box-space (box-capacity item-volumes)", "docstring": "This function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0", "instruction": "Write a Common Lisp function `(defun min-box-space (box-capacity item-volumes)` to solve the following problem:\nThis function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0", "level": "middle"}
{"task_id": "Common Lisp/41", "prompt": "(defun calculate-expression (a b c)\n  ;; Computes the value of the expression (a+b)*c for given integers a, b, and c.\n  ;; Returns the result of the computation.\n  ;; Example:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0", "canonical_solution": "  (* (+ a b) c))", "test": "(defun check-calculate-expression ()\n  (assert (= (calculate-expression 1 2 3) 9))\n  (assert (= (calculate-expression -1 2 3) 3))\n  (assert (= (calculate-expression 0 0 0) 0))\n  (assert (= (calculate-expression 100 -100 1) 0))\n  (assert (= (calculate-expression -5 -5 -5) 50))\n  (assert (= (calculate-expression 10 20 30) 900))\n  (assert (= (calculate-expression 0 10 -2) -20)))", "entry_point": "calculate-expression", "signature": "(defun calculate-expression (a b c)", "docstring": "   Computes the value of the expression (a+b)*c for given integers a, b, and c.\n   Returns the result of the computation.\n   Example:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0", "instruction": "Write a Common Lisp function `(defun calculate-expression (a b c)` to solve the following problem:   Computes the value of the expression (a+b)*c for given integers a, b, and c.\n   Returns the result of the computation.\n   Example:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0", "level": "easy"}
{"task_id": "Common Lisp/42", "prompt": "(defun char-to-ascii (char)\n  ;; Converts a single visible character (excluding space) to its ASCII code.\n  ;; Input: A character (not a string) that is visible and not a space.\n  ;; Output: An integer representing the ASCII code of the input character.\n  ;; Example:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33", "canonical_solution": "  (char-code char))", "test": "(defun check-char-to-ascii ()\n  (assert (= (char-to-ascii #\\A) 65))\n  (assert (= (char-to-ascii #\\!) 33))\n  (assert (= (char-to-ascii #\\~) 126))\n  (assert (= (char-to-ascii #\\0) 48))\n  (assert (= (char-to-ascii #\\Z) 90)))\n\n(check-char-to-ascii)", "entry_point": "char-to-ascii", "signature": "defun char-to-ascii (char)", "docstring": " Converts a single visible character (excluding space) to its ASCII code.\n Input: A character (not a string) that is visible and not a space.\n Output: An integer representing the ASCII code of the input character.\n Example:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33", "instruction": "Write a Common Lisp function `defun char-to-ascii (char)` to solve the following problem: Converts a single visible character (excluding space) to its ASCII code.\n Input: A character (not a string) that is visible and not a space.\n Output: An integer representing the ASCII code of the input character.\n Example:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33", "level": "easy"}
{"task_id": "Common Lisp/43", "prompt": "(defun ascii-to-char (code)\n  ;; Converts an ASCII code to its corresponding character.\n  ;; Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n  ;; Output: The character corresponding to the ASCII code.\n  ;; Example:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!", "canonical_solution": "  (code-char code))", "test": "(defun check-ascii-to-char ()\n  (assert (char= (ascii-to-char 65) #\\A))\n  (assert (char= (ascii-to-char 33) #\\!))\n  (assert (char= (ascii-to-char 126) #\\~))\n  (assert (char= (ascii-to-char 48) #\\0))\n  (assert (char= (ascii-to-char 90) #\\Z)))\n\n(check-ascii-to-char)", "entry_point": "ascii-to-char", "signature": "defun ascii-to-char (code)", "docstring": " Converts an ASCII code to its corresponding character.\n Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n Output: The character corresponding to the ASCII code.\n Example:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!", "instruction": "Write a Common Lisp function `defun ascii-to-char (code)` to solve the following problem: Converts an ASCII code to its corresponding character.\n Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n Output: The character corresponding to the ASCII code.\n Example:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!", "level": "easy"}
{"task_id": "Common Lisp/44", "prompt": "(defun reverse-three-digit (num)\n  ;; Reverses a three-digit number.\n  ;; Input: A three-digit integer 'num'.\n  ;; Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n  ;; Example:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.", "canonical_solution": "  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))", "test": "(defun check-reverse-three-digit ()\n  (assert (= (reverse-three-digit 123) 321))\n  (assert (= (reverse-three-digit 100) 1)) ;; Note: Leading zeros are not displayed in integers.\n  (assert (= (reverse-three-digit 250) 52))\n  (assert (= (reverse-three-digit 999) 999))\n  (assert (= (reverse-three-digit 500) 5)))\n\n(check-reverse-three-digit)", "entry_point": "reverse-three-digit", "signature": "(defun reverse-three-digit (num)", "docstring": " Reverses a three-digit number.\n Input: A three-digit integer 'num'.\n Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n Example:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.", "instruction": "Write a Common Lisp function `(defun reverse-three-digit (num)` to solve the following problem: Reverses a three-digit number.\n Input: A three-digit integer 'num'.\n Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n Example:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.", "level": "easy"}
{"task_id": "Common Lisp/45", "prompt": "(defun int-bool-int-conversion (int)\n  ;; Converts an integer to a boolean and then back to an integer.\n  ;; Input: An integer within the range of integer values.\n  ;; Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n  ;; The output is 1 for any non-zero input integer, and 0 for an input of 0.\n  ;; Example:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1", "canonical_solution": "  (if (= int 0) 0 1))", "test": "(defun check-int-bool-int-conversion ()\n  (assert (= (int-bool-int-conversion 3) 1))\n  (assert (= (int-bool-int-conversion 0) 0))\n  (assert (= (int-bool-int-conversion -5) 1))\n  (assert (= (int-bool-int-conversion 1) 1))\n  (assert (= (int-bool-int-conversion 100) 1)))\n\n(check-int-bool-int-conversion)", "entry_point": "int-bool-int-conversion", "signature": "(defun int-bool-int-conversion (int)", "docstring": " Converts an integer to a boolean and then back to an integer.\n Input: An integer within the range of integer values.\n Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n The output is 1 for any non-zero input integer, and 0 for an input of 0.\n Example:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1", "instruction": "Write a Common Lisp function `(defun int-bool-int-conversion (int)` to solve the following problem: Converts an integer to a boolean and then back to an integer.\n Input: An integer within the range of integer values.\n Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n The output is 1 for any non-zero input integer, and 0 for an input of 0.\n Example:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1", "level": "easy"}
{"task_id": "Common Lisp/46", "prompt": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Calculates the nth term of an arithmetic sequence given the first two terms.\n  ;; Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n  ;; Output: The value of the nth term in the arithmetic sequence.\n  ;; Example:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29", "canonical_solution": "  (+ a1 (* (1- n) (- a2 a1))))", "test": "(defun check-nth-term-arithmetic-sequence ()\n  (assert (= (nth-term-arithmetic-sequence 1 4 100) 298))\n  (assert (= (nth-term-arithmetic-sequence 2 5 10) 29))\n  (assert (= (nth-term-arithmetic-sequence 0 3 4) 9))\n  (assert (= (nth-term-arithmetic-sequence -3 1 5) 13))\n  (assert (= (nth-term-arithmetic-sequence 100 -100 50) -9700)))\n\n(check-nth-term-arithmetic-sequence)", "entry_point": "nth-term-arithmetic-sequence", "signature": "(defun nth-term-arithmetic-sequence (a1 a2 n)", "docstring": " Calculates the nth term of an arithmetic sequence given the first two terms.\n Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n Output: The value of the nth term in the arithmetic sequence.\n Example:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29", "instruction": "Write a Common Lisp function `(defun nth-term-arithmetic-sequence (a1 a2 n)` to solve the following problem: Calculates the nth term of an arithmetic sequence given the first two terms.\n Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n Output: The value of the nth term in the arithmetic sequence.\n Example:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29", "level": "easy"}
{"task_id": "Common Lisp/47", "prompt": "(defun multiply-a-b (a b)\n  ;; Multiplies two positive integers A and B and returns the product.\n  ;; Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n  ;; Output: The product of 'a' and 'b'.\n  ;; Example:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648", "canonical_solution": "  (* a b))", "test": "(defun check-multiply-a-b ()\n  (assert (= (multiply-a-b 3 4) 12))\n  (assert (= (multiply-a-b 36 18) 648))\n  (assert (= (multiply-a-b 1 50000) 50000))\n  (assert (= (multiply-a-b 50000 50000) 2500000000))\n  (assert (= (multiply-a-b 123 456) 56088)))\n\n(check-multiply-a-b)", "entry_point": "multiply-a-b", "signature": "(defun multiply-a-b (a b)", "docstring": " Multiplies two positive integers A and B and returns the product.\n Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n Output: The product of 'a' and 'b'.\n Example:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648", "instruction": "Write a Common Lisp function `(defun multiply-a-b (a b)` to solve the following problem: Multiplies two positive integers A and B and returns the product.\n Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n Output: The product of 'a' and 'b'.\n Example:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648", "level": "easy"}
{"task_id": "Common Lisp/48", "prompt": "(defun power-of-two (n)\n  ;; Calculates 2 raised to the power of n, where n is a non-negative integer.\n  ;; Input: A non-negative integer 'n' (0 <= n < 31).\n  ;; Output: An integer representing 2^n.\n  ;; Example:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024", "canonical_solution": "  (expt 2 n))", "test": "(defun check-power-of-two ()\n  (assert (= (power-of-two 3) 8))\n  (assert (= (power-of-two 10) 1024))\n  (assert (= (power-of-two 0) 1))\n  (assert (= (power-of-two 5) 32))\n  (assert (= (power-of-two 15) 32768)))\n\n(check-power-of-two)", "entry_point": "power-of-two", "signature": "(defun power-of-two (n)", "docstring": " Calculates 2 raised to the power of n, where n is a non-negative integer.\n Input: A non-negative integer 'n' (0 <= n < 31).\n Output: An integer representing 2^n.\n Example:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024", "instruction": "Write a Common Lisp function `(defun power-of-two (n)` to solve the following problem: Calculates 2 raised to the power of n, where n is a non-negative integer.\n Input: A non-negative integer 'n' (0 <= n < 31).\n Output: An integer representing 2^n.\n Example:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024", "level": "easy"}
{"task_id": "Common Lisp/49", "prompt": "(defun judge-sign (n)\n  ;; Determines if an integer N is positive, negative, or zero.\n  ;; Input: An integer 'N' (-10^9 <= N <= 10^9).\n  ;; Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n  ;; Example:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"", "canonical_solution": "  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))", "test": "(defun check-judge-sign ()\n  (assert (string= (judge-sign 95) \"positive\"))\n  (assert (string= (judge-sign 0) \"zero\"))\n  (assert (string= (judge-sign -3) \"negative\"))\n  (assert (string= (judge-sign 1) \"positive\"))\n  (assert (string= (judge-sign -1000000) \"negative\")))\n\n(check-judge-sign)", "entry_point": "judge-sign", "signature": "(defun judge-sign (n)", "docstring": " Determines if an integer N is positive, negative, or zero.\n Input: An integer 'N' (-10^9 <= N <= 10^9).\n Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n Example:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"", "instruction": "Write a Common Lisp function `(defun judge-sign (n)` to solve the following problem: Determines if an integer N is positive, negative, or zero.\n Input: An integer 'N' (-10^9 <= N <= 10^9).\n Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n Example:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"", "level": "easy"}
{"task_id": "Common Lisp/50", "prompt": "(defun abs-value (n)\n  ;; Outputs the absolute value of an integer n.\n  ;; Input: An integer 'n', where the absolute value of n does not exceed 10000.\n  ;; Output: The absolute value of 'n'.\n  ;; Example:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0", "canonical_solution": "  (abs n))", "test": "(defun check-abs-value ()\n  (assert (= (abs-value -3) 3))\n  (assert (= (abs-value 5) 5))\n  (assert (= (abs-value 0) 0))\n  (assert (= (abs-value -10000) 10000))\n  (assert (= (abs-value 9999) 9999)))\n\n(check-abs-value)", "entry_point": "abs-value", "signature": "(defun abs-value (n)", "docstring": " Outputs the absolute value of an integer n.\n Input: An integer 'n', where the absolute value of n does not exceed 10000.\n Output: The absolute value of 'n'.\n Example:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0", "instruction": "Write a Common Lisp function `(defun abs-value (n)` to solve the following problem: Outputs the absolute value of an integer n.\n Input: An integer 'n', where the absolute value of n does not exceed 10000.\n Output: The absolute value of 'n'.\n Example:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0", "level": "easy"}
