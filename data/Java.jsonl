{"task_id": "Java/1", "prompt": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculate the average account balance based on the closing balances from the past twelve months.\n         *\n         * @param closingBalances A list of closing balances from the past twelve months.\n         * @return The average account balance.\n         *\n         * Example:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)", "canonical_solution": "    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75)) - 1581.42) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0)) - 650.0) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) - 6.5) < 0.01;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "calculateAverageBalance", "signature": "public static double calculateAverageBalance(List<Double> closingBalances)", "docstring": "Calculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42", "instruction": "Write a Java function `public static double calculateAverageBalance(List<Double> closingBalances)` to solve the following problem:\nCalculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42", "level": "easy"}
{"task_id": "Java/2", "prompt": "class Solution {\n    /**\n     * Given a positive integer Y indicating the start year, and a positive integer N,\n     * this function finds the Nth leap year after the start year Y.\n     *\n     * @param Y The start year.\n     * @param N The position of the leap year to find.\n     * @return The Nth leap year after the start year Y.\n     *\n     * Example:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ", "canonical_solution": "    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert findNthLeapYear(2000, 4) == 2012;\n        assert findNthLeapYear(1996, 10) == 2032;\n        assert findNthLeapYear(2000, 1) == 2000;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "findNthLeapYear", "signature": "public static int findNthLeapYear(int Y, int N)", "docstring": "Given a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032", "instruction": "Write a Java function `public static int findNthLeapYear(int Y, int N)` to solve the following problem:\nGiven a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032", "level": "easy"}
{"task_id": "Java/3", "prompt": "class Solution {\n    /**\n     * Calculate the time needed to obtain the reverse seating order.\n     * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n     * \n     * @param N the number of people\n     * @return the time needed in minutes\n     * \n     * Example:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ", "canonical_solution": "    {\n        return N / 2;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert calculateTimeNeeded(7) == 3;\n        assert calculateTimeNeeded(8) == 4;\n        assert calculateTimeNeeded(9) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "calculateTimeNeeded", "signature": "public static int calculateTimeNeeded(int N)", "docstring": "Calculate the time needed to obtain the reverse seating order.\nFor each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n\n@param N the number of people\n@return the time needed in minutes\n\nExample:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6", "instruction": "Write a Java function `public static int calculateTimeNeeded(int N)` to solve the following problem:\nCalculate the time needed to obtain the reverse seating order.\nFor each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n\n@param N the number of people\n@return the time needed in minutes\n\nExample:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6", "level": "easy"}
{"task_id": "Java/4", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Given an array of distinct integers, return all possible permutations of the array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ", "canonical_solution": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }", "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution\n      .permute(new int[] { 4, 5, 6 })\n      .equals(\n        Arrays.asList(\n          Arrays.asList(4, 5, 6),\n          Arrays.asList(4, 6, 5),\n          Arrays.asList(5, 4, 6),\n          Arrays.asList(5, 6, 4),\n          Arrays.asList(6, 4, 5),\n          Arrays.asList(6, 5, 4)\n        )\n      );\n    assert solution\n      .permute(new int[] { 7, 8 })\n      .equals(Arrays.asList(Arrays.asList(7, 8), Arrays.asList(8, 7)));\n    assert solution\n      .permute(new int[] { 9 })\n      .equals(Collections.singletonList(Collections.singletonList(9)));\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "permute", "signature": "public List<List<Integer>> permute(int[] nums)", "docstring": "Given an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]", "instruction": "Write a Java function `public List<List<Integer>> permute(int[] nums)` to solve the following problem:\nGiven an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]", "level": "hard"}
{"task_id": "Java/5", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n     * \n     * Example:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ", "canonical_solution": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"rose\", \"orchid\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"hello\", \"world\")) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "findLargestSubstring", "signature": "public int findLargestSubstring(List<String> strings)", "docstring": "Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2", "instruction": "Write a Java function `public int findLargestSubstring(List<String> strings)` to solve the following problem:\nGiven a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2", "level": "hard"}
{"task_id": "Java/6", "prompt": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n     * \n     * Parameters:\n     *     grid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n     * \n     * Returns:\n     *     int: The number of distinct oil deposits in the grid.\n     * \n     * Example:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ", "canonical_solution": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countOilDeposits(new char[][] {{'@', '@', '@'}, {'@', '*', '@'}, {'@', '@', '@'}}) == 1;\n        assert countOilDeposits(new char[][] {{'@', '*', '@'}, {'*', '*', '*'}, {'@', '*', '@'}}) == 4;\n        assert countOilDeposits(new char[][] {{'*', '*', '*', '*', '*'}, {'*', '@', '@', '@', '*'}, {'*', '@', '*', '@', '*'}, {'*', '@', '@', '@', '*'}, {'*', '*', '*', '*', '*'}}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countOilDeposits", "signature": "public static int countOilDeposits(char[][] grid)", "docstring": "Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2", "instruction": "Write a Java function `public static int countOilDeposits(char[][] grid)` to solve the following problem:\nGiven a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2", "level": "middle"}
{"task_id": "Java/7", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n     *\n     * Example:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N the number of triangles\n     * @return the maximum number of regions\n     */\n    public static int maxRegions(int N) ", "canonical_solution": "    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert maxRegions(3) == 13;\n        assert maxRegions(4) == 21;\n        assert maxRegions(5) == 31;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "maxRegions", "signature": "public static int maxRegions(int N)", "docstring": "Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n\nExample:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N the number of triangles\n@return the maximum number of regions", "instruction": "Write a Java function `public static int maxRegions(int N)` to solve the following problem:\nGiven the number of triangles N, determine the maximum number of regions the plane can be divided into.\n\nExample:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N the number of triangles\n@return the maximum number of regions", "level": "easy"}
{"task_id": "Java/8", "prompt": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Count the number of words in the given word list that have the given prefix.\n     * \n     * @param wordList: a list of words\n     * @param prefix: the prefix string\n     * @return the number of words with the given prefix\n     * \n     * Example:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ", "canonical_solution": "    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countPrefixWords(Arrays.asList(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3;\n        assert countPrefixWords(Arrays.asList(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4;\n        assert countPrefixWords(Arrays.asList(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countPrefixWords", "signature": "public static int countPrefixWords(List<String> wordList, String prefix)", "docstring": "Count the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1", "instruction": "Write a Java function `public static int countPrefixWords(List<String> wordList, String prefix)` to solve the following problem:\nCount the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1", "level": "easy"}
{"task_id": "Java/9", "prompt": "import java.util.*;\n\nclass Solution {\n   /**\n     * Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n     * \n     * Example:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ", "canonical_solution": "    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countDoubles(new int[]{1, 2, 4, 8, 16}) == 4;\n        assert countDoubles(new int[]{5, 10, 20, 40, 80}) == 4;\n        assert countDoubles(new int[]{3, 6, 12, 24, 48}) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "countDoubles", "signature": "public static int countDoubles(int[] numbers)", "docstring": "Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0", "instruction": "Write a Java function `public static int countDoubles(int[] numbers)` to solve the following problem:\nGiven a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0", "level": "easy"}
{"task_id": "Java/10", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n     * \n     * Parameters:\n     * - n: the size of the n-teresting space\n     * - start: the starting n-tersection coordinates\n     * - end: the ending n-tersection coordinates\n     * - paths: paths between adjacent n-tersections in the n-teresting space\n     * \n     * Output:\n     * - If travel is possible, return \"can be travelled\"\n     * - If travel is not possible, return \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ", "canonical_solution": "    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 2}, {1, 2, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}, {2, 1, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}}).equals(\"cannot be travelled\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "canTravelMaze", "signature": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)", "docstring": "Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"", "instruction": "Write a Java function `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` to solve the following problem:\nGiven the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"", "level": "hard"}
{"task_id": "Java/11", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * The approximate value is calculated by counting the number of common letters\n     * and dividing it by the sum of the lengths of the two words.\n     *\n     * @param word1 The first word.\n     * @param word2 The second word.\n     * @return The approximate value as a reduced fraction.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ", "canonical_solution": "    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert appx(\"DOG\", \"CAT\").equals(\"appx(DOG, CAT) = 0/6\");\n        assert appx(\"HELLO\", \"WORLD\").equals(\"appx(HELLO, WORLD) = 3/10\");\n        assert appx(\"JAVA\", \"PYTHON\").equals(\"appx(JAVA, PYTHON) = 0/10\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "appx", "signature": "public static String appx(String word1, String word2)", "docstring": "The approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"", "instruction": "Write a Java function `public static String appx(String word1, String word2)` to solve the following problem:\nThe approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"", "level": "easy"}
{"task_id": "Java/12", "prompt": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n     * \n     * Example:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ", "canonical_solution": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }", "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert convertDatesToWeekdays(\"02 05 2024\").equals(\"February 5, 2024 is a Monday\");\n        assert convertDatesToWeekdays(\"01 12 2023\").equals(\"January 12, 2023 is a Thursday\");\n        assert convertDatesToWeekdays(\"09 14 2013\").equals(\"September 14, 2013 is a Saturday\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "convertDatesToWeekdays", "signature": "public static String convertDatesToWeekdays(String date)", "docstring": "Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"", "instruction": "Write a Java function `public static String convertDatesToWeekdays(String date)` to solve the following problem:\nGiven a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"", "level": "hard"}
{"task_id": "Java/13", "prompt": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Given an array of integers nums and an integer target,\n     * find two numbers such that they add up to target and return their indices.\n     * You may assume that each input would have exactly one solution,\n     * and you may not use the same element twice.\n     * You can return the answer in any order.\n     *\n     * Example 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     *\n     * Example 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Example 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ", "canonical_solution": "  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 3, 7, 9, 2 }, 11),\n      new int[] { 3, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 5, 3, 7, 8 }, 9),\n      new int[] { 0, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 10, 20, 30, 40, 50 }, 90),\n      new int[] { 3, 4 }\n    );\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "twoSum", "signature": "public int[] twoSum(int[] nums, int target)", "docstring": "Given an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]", "instruction": "Write a Java function `public int[] twoSum(int[] nums, int target)` to solve the following problem:\nGiven an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]", "level": "easy"}
{"task_id": "Java/14", "prompt": "class Solution {\n    /**\n     * Search for the target value in the rotated sorted array.\n     * If the target value exists, return its index; otherwise, return -1.\n     * The array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\n     * The time complexity of the algorithm must be O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ", "canonical_solution": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 6) == 2;\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 7) == 3;\n        assert solution.search(new int[]{1, 3}, 3) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "search", "signature": "public int search(int[] nums, int target)", "docstring": "Search for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1", "instruction": "Write a Java function `public int search(int[] nums, int target)` to solve the following problem:\nSearch for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1", "level": "middle"}
{"task_id": "Java/15", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\n     * Return the mean with an error within 10^-5.\n     *\n     * Example 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Example 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Example 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Example 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Example 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ", "canonical_solution": "  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }) - 5.5\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }) -\n      55.0\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }) - 1.0\n    ) <\n    1e-5;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "trimMean", "signature": "public double trimMean(int[] arr)", "docstring": "Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167", "instruction": "Write a Java function `public double trimMean(int[] arr)` to solve the following problem:\nGiven an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167", "level": "easy"}
{"task_id": "Java/16", "prompt": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n     *\n     * @param arr the input integer array\n     * @param k the divisor\n     * @return true if it is possible, false otherwise\n     *\n     * Example:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n     */\n  public boolean canArrange(int[] arr, int k) ", "canonical_solution": "  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.canArrange(new int[]{1,2,3,4,5,10,6,7,8,9}, 5) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 7) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 10) == false;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "canArrange", "signature": "public boolean canArrange(int[] arr, int k)", "docstring": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.", "instruction": "Write a Java function `public boolean canArrange(int[] arr, int k)` to solve the following problem:\nCheck if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.", "level": "easy"}
{"task_id": "Java/17", "prompt": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\n   * Starting from node 0, return the minimum time required to collect all the apples and return to node 0.\n   *\n   * Example:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ", "canonical_solution": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, false, true, false, true, true, false }\n    ) ==\n    8;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, true, true, true, true, true, true }\n    ) ==\n    12;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,true,false,false,true,false }\n    ) ==\n    6;\n\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,false,false,false,false,false }\n    ) ==\n    0;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minTime", "signature": "public int minTime(int n, int[][] edges, boolean[] hasApple)", "docstring": "Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0", "instruction": "Write a Java function `public int minTime(int n, int[][] edges, boolean[] hasApple)` to solve the following problem:\nGiven a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0", "level": "middle"}
{"task_id": "Java/18", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s)", "canonical_solution": "    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "sortString", "signature": "public String sortString(String s)", "docstring": "Given a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.", "instruction": "Write a Java function `public String sortString(String s)` to solve the following problem:\nGiven a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.", "level": "middle"}
{"task_id": "Java/19", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to split the given integer array into two non-empty arrays\n     * with the same average.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ", "canonical_solution": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }", "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 9}) == false;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 10}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == true;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "splitArraySameAverage", "signature": "public boolean splitArraySameAverage(int[] nums)", "docstring": "Check if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse", "instruction": "Write a Java function `public boolean splitArraySameAverage(int[] nums)` to solve the following problem:\nCheck if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse", "level": "hard"}
{"task_id": "Java/20", "prompt": "class Solution {\n    /**\n     * Given an integer array cost where cost[i] is the cost of ith step on a staircase,\n     * return the minimum cost to reach the top of the floor.\n     * You can either start from the step with index 0 or the step with index 1.\n     *\n     * Example:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explanation: You will start at index 1.\n     * - Pay 15 and climb two steps to reach the top.\n     * The total cost is 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explanation: You will start at index 0.\n     * - Pay 1 and climb two steps to reach index 2.\n     * - Pay 1 and climb two steps to reach index 4.\n     * - Pay 1 and climb two steps to reach index 6.\n     * - Pay 1 and climb one step to reach index 7.\n     * - Pay 1 and climb two steps to reach index 9.\n     * - Pay 1 and climb one step to reach the top.\n     * The total cost is 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ", "canonical_solution": "  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minCostClimbingStairs(new int[] { 10, 15, 20 }) == 15;\n    assert solution.minCostClimbingStairs(\n      new int[] { 1, 100, 1, 1, 1, 100, 1, 1, 100, 1 }\n    ) ==\n    6;\n    assert solution.minCostClimbingStairs(new int[] { 0, 0, 0, 1 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "minCostClimbingStairs", "signature": "public int minCostClimbingStairs(int[] cost)", "docstring": "Given an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.", "instruction": "Write a Java function `public int minCostClimbingStairs(int[] cost)` to solve the following problem:\nGiven an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.", "level": "easy"}
{"task_id": "Java/21", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\n     * return the number of different transformations among all words.\n     *\n     * Example:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ", "canonical_solution": "    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.uniqueMorseRepresentations(new String[]{\"hello\", \"world\", \"hello\"}) == 2;\n        assert solution.uniqueMorseRepresentations(new String[]{\"abc\", \"def\", \"ghi\"}) == 3;\n        assert solution.uniqueMorseRepresentations(new String[]{\"aaa\", \"aaa\", \"aaa\"}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "uniqueMorseRepresentations", "signature": "public int uniqueMorseRepresentations(String[] words)", "docstring": "Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1", "instruction": "Write a Java function `public int uniqueMorseRepresentations(String[] words)` to solve the following problem:\nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1", "level": "middle"}
{"task_id": "Java/22", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n     *\n     * Example 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Explanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n     *\n     * Example 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Explanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n     *\n     * Example 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Explanation: The binary string \"00\" is not a substring of s.\n     */\n  public boolean hasAllCodes(String s, int k) ", "canonical_solution": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.hasAllCodes(\"00110110\", 3) == false;\n    assert solution.hasAllCodes(\"00110110\", 2) == true;\n    assert solution.hasAllCodes(\n      \"1111111111111111111111111111111111111111111111111111111111111111\",\n      1\n    ) ==\n    false;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "hasAllCodes", "signature": "public boolean hasAllCodes(String s, int k)", "docstring": "Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.", "instruction": "Write a Java function `public boolean hasAllCodes(String s, int k)` to solve the following problem:\nGiven a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.", "level": "easy"}
{"task_id": "Java/23", "prompt": "class Solution {\n    /**\n    * Check if the searchWord is a prefix of any word in the sentence.\n    * If searchWord is a prefix of multiple words, return the index of the first matching word.\n    * If searchWord is not a prefix of any word, return -1.\n    * \n    * Example:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ", "canonical_solution": "  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }", "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.isPrefixOfWord(\"hello world\", \"wor\") == 2;\n      assert solution.isPrefixOfWord(\"hello world\", \"hell\") == 1;\n      assert solution.isPrefixOfWord(\"hello world\", \"foo\") == -1;\n      System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isPrefixOfWord", "signature": "public int isPrefixOfWord(String sentence, String searchWord)", "docstring": "Check if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1", "instruction": "Write a Java function `public int isPrefixOfWord(String sentence, String searchWord)` to solve the following problem:\nCheck if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1", "level": "easy"}
{"task_id": "Java/24", "prompt": "class Solution {\n    /**\n    * Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n    *\n    * Example 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\n    * Example 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s consists of '(' and ')' only.\n    */\n public int minInsertions(String s) ", "canonical_solution": " {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.minInsertions(\"((()))\") == 0;\n        assert solution.minInsertions(\"()()()\") == 0;\n        assert solution.minInsertions(\"(()))(()\") == 2;\n        assert solution.minInsertions(\"))())(((\") == 6;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "minInsertions", "signature": "public int minInsertions(String s)", "docstring": "Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.", "instruction": "Write a Java function `public int minInsertions(String s)` to solve the following problem:\nGiven a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.", "level": "hard"}
{"task_id": "Java/25", "prompt": "class Solution {\n  /**\n  * Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\n  * The array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\n  * In one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\n  * The goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n  *\n  * Example 1:\n  * Input: n = 3\n  * Output: 2\n  * Explanation: arr = [1, 3, 5]\n  * First operation: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Second operation: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Example 2:\n  * Input: n = 6\n  * Output: 9\n  */\n  public int minOperations(int n) ", "canonical_solution": "  {\n\n      return n * n / 4;\n  }", "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.minOperations(4) == 4;\n      assert solution.minOperations(5) == 6;\n      assert solution.minOperations(7) == 12;\n      System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minOperations", "signature": "public int minOperations(int n)", "docstring": "Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\nThe array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\nIn one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\nThe goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:\nInput: n = 6\nOutput: 9", "instruction": "Write a Java function `public int minOperations(int n)` to solve the following problem:\nGiven an integer n, return the minimum number of operations required to make all elements in the array arr equal.\nThe array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\nIn one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\nThe goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:\nInput: n = 6\nOutput: 9", "level": "easy"}
{"task_id": "Java/26", "prompt": "class Solution {\n    /**\n     * Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n     *\n     * Example:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n     *\n     * Constraints:\n     * - The length of the `gain` array is between 1 and 100, inclusive.\n     * - Each element in the `gain` array is between -100 and 100, inclusive.\n     */\n    public int highestAltitude(int[] gain) ", "canonical_solution": "    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.highestAltitude(new int[]{-5,1,5,0,-7}) == 1;\n        assert solution.highestAltitude(new int[]{-4,-3,-2,-1,4,3,2}) == 0;\n        assert solution.highestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2, 1}) == 0;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "highestAltitude", "signature": "public int highestAltitude(int[] gain)", "docstring": "Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.", "instruction": "Write a Java function `public int highestAltitude(int[] gain)` to solve the following problem:\nGiven an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.", "level": "easy"}
{"task_id": "Java/27", "prompt": "class Solution {\n    /**\n     * Given an integer array nums, return the maximum absolute sum of any subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ", "canonical_solution": "    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }", "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.maxAbsoluteSum(new int[]{1,-3,2,3,-4}) == 5;\n        assert solution.maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2}) == 8;\n        assert solution.maxAbsoluteSum(new int[]{-2, -3, 4, -1, -2, 1, 5, -3}) == 7;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "maxAbsoluteSum", "signature": "public int maxAbsoluteSum(int[] nums)", "docstring": "Given an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8", "instruction": "Write a Java function `public int maxAbsoluteSum(int[] nums)` to solve the following problem:\nGiven an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8", "level": "easy"}
{"task_id": "Java/28", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\n     * Fibonacci numbers are defined as follows:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, for n > 2.\n     * It is guaranteed that there is at least one valid solution for the given k.\n     *\n     * Example 1:\n     * Input: k = 7\n     * Output: 2\n     * Explanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\n     * For k = 7, we can get 2 + 5 = 7.\n     *\n     * Example 2:\n     * Input: k = 10\n     * Output: 2\n     * Explanation: For k = 10, we can get 2 + 8 = 10.\n     *\n     * Example 3:\n     * Input: k = 19\n     * Output: 3\n     * Explanation: For k = 19, we can get 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ", "canonical_solution": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.findMinFibonacciNumbers(7) == 2;\n    assert solution.findMinFibonacciNumbers(10) == 2;\n    assert solution.findMinFibonacciNumbers(13) == 1;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "findMinFibonacciNumbers", "signature": "public int findMinFibonacciNumbers(int k)", "docstring": "Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.", "instruction": "Write a Java function `public int findMinFibonacciNumbers(int k)` to solve the following problem:\nGiven an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.", "level": "easy"}
{"task_id": "Java/29", "prompt": "class Solution {\n    /**\n     * Given two positive integers n and k, find the kth factor of n.\n     * A factor of n is a positive integer that divides n evenly.\n     * Return the kth factor in ascending order. If n has less than k factors, return -1.\n     *\n     * Example 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Explanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n     *\n     * Example 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Explanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n     *\n     * Example 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Explanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n     */\n    public int kthFactor(int n, int k) ", "canonical_solution": "    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }", "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.kthFactor(100, 3) == 4;\n        assert solution.kthFactor(15, 4) == 15;\n        assert solution.kthFactor(30, 18) == -1;\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "kthFactor", "signature": "public int kthFactor(int n, int k)", "docstring": "Given two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.", "instruction": "Write a Java function `public int kthFactor(int n, int k)` to solve the following problem:\nGiven two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.", "level": "easy"}
{"task_id": "Java/30", "prompt": "class Solution {\n    /**\n     * Given a string s consisting of lowercase and uppercase English letters,\n     * you need to make the string \"good\".\n     * A string is considered \"good\" if there are no adjacent characters such that\n     * one is a lowercase letter and the other is the corresponding uppercase letter.\n     * You can choose any adjacent characters in the string and remove them until the string is \"good\".\n     * Return the final \"good\" string.\n     *\n     * Example 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Explanation: You can remove \"Ee\" to make \"leetcode\".\n     *\n     * Example 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Explanation: There are multiple possible solutions, such as:\n     * - Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n     * - Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\n     *   then remove \"aA\" to make \"\".\n     * No matter the choices, the result is an empty string.\n     *\n     * Example 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Explanation: The string is already \"good\".\n     */\n  public String makeGood(String s) ", "canonical_solution": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }", "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.makeGood(\"aAbBcC\").equals(\"\");\n    assert solution.makeGood(\"AaBbCc\").equals(\"\");\n    assert solution.makeGood(\"abcABC\").equals(\"abcABC\");\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "makeGood", "signature": "public String makeGood(String s)", "docstring": "Given a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".", "instruction": "Write a Java function `public String makeGood(String s)` to solve the following problem:\nGiven a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".", "level": "easy"}
{"task_id": "Java/31", "prompt": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a string s, split the string and return the maximum number of unique substrings.\n   * The split substrings should be able to reconstruct the original string, and each substring must be unique.\n   *\n   * Example:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Explanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\n   *              Splitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n   *\n   * Note:\n   * - The length of s is between 1 and 16.\n   * - s only contains lowercase English letters.\n   */\n  public int maxUniqueSplit(String s) ", "canonical_solution": "  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.maxUniqueSplit(\"ababccc\") == 5;\n    assert solution.maxUniqueSplit(\"abcabcabc\") == 6;\n    assert solution.maxUniqueSplit(\"abcdefg\") == 7;\n    assert solution.maxUniqueSplit(\"aaaaaaa\") == 3;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "maxUniqueSplit", "signature": "public int maxUniqueSplit(String s)", "docstring": "Given a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.", "instruction": "Write a Java function `public int maxUniqueSplit(String s)` to solve the following problem:\nGiven a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.", "level": "easy"}
{"task_id": "Java/32", "prompt": "class Solution {\n    /**\n     * Given a list of logs representing folder operations,\n     * return the minimum number of steps required to return to the main folder.\n     *\n     * Example:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explanation: Perform the \"../\" operation twice to return to the main folder.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ", "canonical_solution": "  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }", "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"../\", \"d21/\", \"./\", \"../\" }\n    ) ==\n    1;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"./\", \"d3/\", \"../\", \"d31/\", \"../\" }\n    ) ==\n    2;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"../\", \"../\", \"../\", \"d2/\" }\n    ) ==\n    1;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minOperations", "signature": "public int minOperations(String[] logs)", "docstring": "Given a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0", "instruction": "Write a Java function `public int minOperations(String[] logs)` to solve the following problem:\nGiven a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0", "level": "easy"}
{"task_id": "Java/33", "prompt": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the lexicographically smallest string of length n and value k.\n     * The value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\n     * Example:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ", "canonical_solution": "    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }", "test": "\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.getSmallestString(3, 27).equals(\"aay\");\n        assert solution.getSmallestString(5, 73).equals(\"aaszz\");\n        assert solution.getSmallestString(3, 30).equals(\"acz\");\n        System.out.println(\"All tests passed\");\n    }\n}", "entry_point": "getSmallestString", "signature": "public String getSmallestString(int n, int k)", "docstring": "Return the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"", "instruction": "Write a Java function `public String getSmallestString(int n, int k)` to solve the following problem:\nReturn the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"", "level": "easy"}
{"task_id": "Java/34", "prompt": "public class Solution {\n\n  // Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  // @param n The number of passengers.\n  // @return The probability that the last passenger will sit in their own seat.\n\n  // Example 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Example 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Example 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Example 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Example 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Example 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Function to calculate the probability that the last passenger will sit in their own seat\n  public static double calculateProbability(int n) ", "canonical_solution": "  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }", "test": "public static void main(String[] args) {\n    assert Math.abs(calculateProbability(6) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(10) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(50) - 0.50000) < 0.00001;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "calculateProbability", "signature": "public static double calculateProbability(int n)", "docstring": "Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  @param n The number of passengers.\n  @return The probability that the last passenger will sit in their own seat.\n\n  Example 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Example 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Example 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Example 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Example 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Example 6:\n  Input: n = 100000\n  Output: 0.50000", "instruction": "Write a Java function `public static double calculateProbability(int n)` to solve the following problem:\nGiven the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  @param n The number of passengers.\n  @return The probability that the last passenger will sit in their own seat.\n\n  Example 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Example 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Example 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Example 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Example 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Example 6:\n  Input: n = 100000\n  Output: 0.50000", "level": "easy"}
{"task_id": "Java/35", "prompt": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n   *\n   * @param nums An integer array where every element appears three times except for one.\n   * @return The element that appears only once.\n   *\n   * Example:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Example:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ", "canonical_solution": "  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }", "test": "  public static void main(String[] args) {\n    assert singleNumber(new int[] { 6, 1, 6, 6 }) == 1 : \"Test case 1 failed\";\n    assert singleNumber(new int[] { 22, 22, 22, 11, 11, 11, 55 }) ==\n    55 : \"Test case 2 failed\";\n    assert singleNumber(new int[] { -1, 3, -1, 3, -1, 3, 99 }) ==\n    99 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "singleNumber", "signature": "public static int singleNumber(int[] nums)", "docstring": "Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99", "instruction": "Write a Java function `public static int singleNumber(int[] nums)` to solve the following problem:\nGiven an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99", "level": "easy"}
{"task_id": "Java/36", "prompt": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n   *\n   * @param low The lower bound of the range.\n   * @param high The upper bound of the range.\n   * @return A list of stepping numbers within the range [low, high] sorted in ascending order.\n   *\n   * Example:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ", "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }", "test": "  public static void main(String[] args) {\n    assert findSteppingNumbers(0, 21)\n      .equals(\n        new ArrayList<>(List.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21))\n      );\n    assert findSteppingNumbers(10, 15).equals(new ArrayList<>(List.of(10, 12)));\n    assert findSteppingNumbers(50, 55).equals(List.of(54));\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "findSteppingNumbers", "signature": "public static List<Integer> findSteppingNumbers(int low, int high)", "docstring": "Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]", "instruction": "Write a Java function `public static List<Integer> findSteppingNumbers(int low, int high)` to solve the following problem:\nFind all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]", "level": "middle"}
{"task_id": "Java/37", "prompt": "public class Solution {\n\n  /**\n   * Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   *\n   * @param n An integer representing the upper limit.\n   * @return The number of times the digit 1 appears.\n   *\n   * Example:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Example:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ", "canonical_solution": "  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }", "test": "  public static void main(String[] args) {\n    assert countDigitOne(20) == 12 : \"Test case 1 failed\";\n    assert countDigitOne(55) == 16 : \"Test case 2 failed\";\n    assert countDigitOne(99) == 20 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "countDigitOne", "signature": "public static int countDigitOne(int n)", "docstring": "Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0", "instruction": "Write a Java function `public static int countDigitOne(int n)` to solve the following problem:\nCalculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0", "level": "easy"}
{"task_id": "Java/38", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, determine if it is a power of two.\n   * If it is, return true; otherwise, return false.\n   * A number n is a power of two if there exists an integer x such that n == 2^x.\n   *\n   * @param n The integer to be checked.\n   * @return True if n is a power of two, false otherwise.\n   *\n   * Example:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Example:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ", "canonical_solution": "  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert isPowerOfTwo(1024) == true; // 1024 is 2^10\n    assert isPowerOfTwo(65536) == true; // 65536 is 2^16\n    assert isPowerOfTwo(14) == false; // 14 is not a power of two\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isPowerOfTwo", "signature": "public static boolean isPowerOfTwo(int n)", "docstring": "Given an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false", "instruction": "Write a Java function `public static boolean isPowerOfTwo(int n)` to solve the following problem:\nGiven an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false", "level": "easy"}
{"task_id": "Java/39", "prompt": "public class Solution {\n\n  /**\n   * Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n   *\n   * @param num The non-negative integer to perform the operation on.\n   * @return The single digit result after repeatedly adding all digits.\n   *\n   * Example:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ", "canonical_solution": "  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }", "test": "  public static void main(String[] args) {\n    assert addDigits(123) == 6 : \"Test case 1 failed\";\n    assert addDigits(59) == 5 : \"Test case 2 failed\";\n    assert addDigits(0) == 0 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "addDigits", "signature": "public static int addDigits(int num)", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2", "instruction": "Write a Java function `public static int addDigits(int num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2", "level": "easy"}
{"task_id": "Java/40", "prompt": "public class Solution {\n\n  /**\n   * Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n   * The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   *\n   * @param mat The binary matrix.\n   * @return The length of the longest continuous line of 1s.\n   *\n   * Example:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ", "canonical_solution": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }", "test": "  public static void main(String[] args) {\n    assert longestLine(\n      new int[][] {\n        { 1, 1, 0, 0 },\n        { 0, 1, 1, 0 },\n        { 0, 0, 0, 1 },\n        { 1, 0, 0, 0 },\n      }\n    ) ==\n    3;\n    assert longestLine(\n      new int[][] {\n        { 1, 0, 0, 1 },\n        { 0, 1, 1, 0 },\n        { 1, 1, 0, 0 },\n        { 1, 0, 1, 1 },\n      }\n    ) ==\n    4;\n    assert longestLine(new int[][] { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } }) ==\n    1;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "longestLine", "signature": "public static int longestLine(int[][] mat)", "docstring": "Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3", "instruction": "Write a Java function `public static int longestLine(int[][] mat)` to solve the following problem:\nGiven a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3", "level": "hard"}
{"task_id": "Java/41", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   *\n   * @param n The integer to add thousand separators to.\n   * @return The string with thousand separators added.\n   *\n   * Example:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Example:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Example:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Example:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ", "canonical_solution": "  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }", "test": "  public static void main(String[] args) {\n    assert \"2.147.483.647\".equals(\n        addThousandSeparator(2147483647)\n      ) : \"Test case 1 failed\";\n    assert \"10.000\".equals(addThousandSeparator(10000)) : \"Test case 2 failed\";\n    assert \"999\".equals(addThousandSeparator(999)) : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "addThousandSeparator", "signature": "public static String addThousandSeparator(int n)", "docstring": "Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"", "instruction": "Write a Java function `public static String addThousandSeparator(int n)` to solve the following problem:\nGiven an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"", "level": "easy"}
{"task_id": "Java/42", "prompt": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n   * Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   *\n   * @param A The input non-negative integer array.\n   * @return The number of square permutations of A.\n   *\n   * Example:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Example:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ", "canonical_solution": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }", "test": "  public static void main(String[] args) {\n    assert squarePermutations(new int[] { 1, 8, 27 }) == 0;\n    assert squarePermutations(new int[] { 1, 8, 17 }) == 2;\n    assert squarePermutations(new int[] { 4, 1, 3, 0, 2 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "squarePermutations", "signature": "public static int squarePermutations(int[] A)", "docstring": "Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1", "instruction": "Write a Java function `public static int squarePermutations(int[] A)` to solve the following problem:\nGiven a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1", "level": "hard"}
{"task_id": "Java/43", "prompt": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Given n non-negative integers representing the heights of bars in a bar chart.\n   * Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   *\n   * @param heights An array of integers representing the heights of bars.\n   * @return The maximum area of the rectangle that can be formed.\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ", "canonical_solution": "  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }", "test": "  public static void main(String[] args) {\n    assert largestRectangleArea(new int[] { 1, 2, 3, 4, 5, 3, 3, 2 }) == 15;\n    assert largestRectangleArea(new int[] { 6, 2, 5, 4, 5, 1, 6 }) == 12;\n    assert largestRectangleArea(new int[] { 2, 1, 2, 3, 1 }) == 5;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "largestRectangleArea", "signature": "public static int largestRectangleArea(int[] heights)", "docstring": "Given n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4", "instruction": "Write a Java function `public static int largestRectangleArea(int[] heights)` to solve the following problem:\nGiven n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4", "level": "middle"}
{"task_id": "Java/44", "prompt": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Return all elements in the matrix in diagonal order.\n   *\n   * @param mat The input matrix.\n   * @return An array containing all elements in diagonal order.\n   *\n   * Example:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ", "canonical_solution": "  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }", "test": "  public static void main(String[] args) {\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1, 2 }, { 3, 4 } }),\n      new int[] { 1, 2, 3, 4 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(\n        new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }\n      ),\n      new int[] { 1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1 }, { 2 }, { 3 } }),\n      new int[] { 1, 2, 3 }\n    );\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "diagonalOrder", "signature": "public static int[] diagonalOrder(int[][] mat)", "docstring": "Return all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]", "instruction": "Write a Java function `public static int[] diagonalOrder(int[][] mat)` to solve the following problem:\nReturn all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]", "level": "hard"}
{"task_id": "Java/45", "prompt": "public class Solution {\n\n  /**\n   * Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n   *\n   * @param n The input positive integer.\n   * @return The smallest rearranged integer greater than n, or -1 if not possible.\n   *\n   * Example:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ", "canonical_solution": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n", "test": "  public static void main(String[] args) {\n    assert findSmallestInteger(123) == 132;\n    assert findSmallestInteger(531) == -1;\n    assert findSmallestInteger(2071) == 2107;\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "findSmallestInteger", "signature": "public static int findSmallestInteger(int n)", "docstring": "Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21", "instruction": "Write a Java function `public static int findSmallestInteger(int n)` to solve the following problem:\nFind the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21", "level": "hard"}
{"task_id": "Java/46", "prompt": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Given an integer n, return all the center symmetric numbers of length n.\n   *\n   * @param n The length of the center symmetric numbers.\n   * @return A list of center symmetric numbers.\n   *\n   * Example:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ", "canonical_solution": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }", "test": "  private static void assertArrays(String[] expected, List<String> actual) {\n    if (actual == null || actual.size() != expected.length) {\n      throw new AssertionError(\"Test case failed\");\n    }\n    for (String str : expected) {\n      if (!actual.contains(str)) {\n        throw new AssertionError(\"Test case failed\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    assertArrays(\n      new String[] { \"11\", \"69\", \"88\", \"96\" },\n      centerSymmetricNumbers(2)\n    );\n    assertArrays(new String[] { \"0\", \"1\", \"8\" }, centerSymmetricNumbers(1));\n    assertArrays(\n      new String[] {\n        \"101\",\n        \"111\",\n        \"181\",\n        \"609\",\n        \"619\",\n        \"689\",\n        \"808\",\n        \"818\",\n        \"888\",\n        \"906\",\n        \"916\",\n        \"986\",\n      },\n      centerSymmetricNumbers(3)\n    );\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "centerSymmetricNumbers", "signature": "public static List<String> centerSymmetricNumbers(int n)", "docstring": "Given an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]", "instruction": "Write a Java function `public static List<String> centerSymmetricNumbers(int n)` to solve the following problem:\nGiven an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]", "level": "middle"}
{"task_id": "Java/47", "prompt": "public class Solution {\n\n  /**\n   * Determine if the given points form a boomerang on the X-Y plane.\n   *\n   * @param points An array of points where points[i] = [xi, yi].\n   * @return True if the points form a boomerang, false otherwise.\n   *\n   * Example:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ", "canonical_solution": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }", "test": "  public static void main(String[] args) {\n    assert isBoomerang(new int[][] { { 0, 0 }, { 2, 2 }, { 1, 1 } }) ==\n    false : \"Test case 1 failed\";\n    assert isBoomerang(new int[][] { { 1, 1 }, { 2, 4 }, { 3, 1 } }) ==\n    true : \"Test case 2 failed\";\n    assert isBoomerang(new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 } }) ==\n    true : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "isBoomerang", "signature": "public static boolean isBoomerang(int[][] points)", "docstring": "Determine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true", "instruction": "Write a Java function `public static boolean isBoomerang(int[][] points)` to solve the following problem:\nDetermine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true", "level": "hard"}
{"task_id": "Java/48", "prompt": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Find and return the nth ugly number.\n   *\n   * @param n The index of the ugly number to find.\n   * @return The nth ugly number.\n   *\n   * Example:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ", "canonical_solution": "  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n", "test": "  public static void main(String[] args) {\n    assert findNthUglyNumber(1) == 1 : \"Test case 1 failed\";\n    assert findNthUglyNumber(7) == 8 : \"Test case 2 failed\";\n    assert findNthUglyNumber(15) == 24 : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "findNthUglyNumber", "signature": "public static int findNthUglyNumber(int n)", "docstring": "Find and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12", "instruction": "Write a Java function `public static int findNthUglyNumber(int n)` to solve the following problem:\nFind and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12", "level": "hard"}
{"task_id": "Java/49", "prompt": "public class Solution {\n\n  /**\n   * Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   *\n   * @param s The input string.\n   * @return The energy of the string.\n   *\n   * Example:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ", "canonical_solution": "  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert calculateEnergy(\"aabbccdd\") == 2 : \"Test case 1 failed\"; // Contains two characters 'aa', 'bb', 'cc', 'dd'\n    assert calculateEnergy(\"horizon\") == 1 : \"Test case 2 failed\"; // All characters are unique\n    assert calculateEnergy(\"success\") == 2 : \"Test case 3 failed\"; // Contains three characters 'ccc'\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "calculateEnergy", "signature": "public static int calculateEnergy(String s)", "docstring": "Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2", "instruction": "Write a Java function `public static int calculateEnergy(String s)` to solve the following problem:\nCalculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2", "level": "hard"}
{"task_id": "Java/50", "prompt": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Return all integers in the range [1, n] in lexicographical order.\n   *\n   * @param n The upper limit of the range.\n   * @return List of integers in lexicographical order.\n   *\n   * Example:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ", "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }", "test": "  public static void main(String[] args) {\n    // Test cases\n    assert lexicalOrder(13)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(2);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 1 failed\";\n\n    assert lexicalOrder(20)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(14);\n            add(15);\n            add(16);\n            add(17);\n            add(18);\n            add(19);\n            add(2);\n            add(20);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 2 failed\";\n\n    assert lexicalOrder(2)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(2);\n          }\n        }\n      ) : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n", "entry_point": "lexicalOrder", "signature": "public static List<Integer> lexicalOrder(int n)", "docstring": "Return all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]", "instruction": "Write a Java function `public static List<Integer> lexicalOrder(int n)` to solve the following problem:\nReturn all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]", "level": "middle"}
{"task_id": "Java/51", "prompt": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculate the sum of unique elements in the given integer array.\n   *\n   * @param nums An array of integers.\n   * @return The sum of unique elements.\n   *\n   * Example:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ", "canonical_solution": "  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }", "test": "  public static void main(String[] args) {\n    assert calculateUniqueSum(new int[] { 1, 4, 5, 1, 2, 4 }) == 7; // Test Case 1\n    assert calculateUniqueSum(new int[] { 0, 0, 0, 0 }) == 0; // Test Case 2\n    assert calculateUniqueSum(new int[] { -1, -2, -3, -2 }) == -4; // Test Case 3\n\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "calculateUniqueSum", "signature": "public static int calculateUniqueSum(int[] nums)", "docstring": "Calculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4", "instruction": "Write a Java function `public static int calculateUniqueSum(int[] nums)` to solve the following problem:\nCalculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4", "level": "easy"}
{"task_id": "Java/52", "prompt": "public class Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ", "canonical_solution": "  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }", "test": "  public static void main(String[] args) {\n    assert minPerfectSquareSum(26) == 2 : \"Test case 1 failed\";\n    assert minPerfectSquareSum(17) == 2 : \"Test case 2 failed\";\n    assert minPerfectSquareSum(99) == 3 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "public static int minPerfectSquareSum(int n)", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2", "instruction": "Write a Java function `public static int minPerfectSquareSum(int n)` to solve the following problem:\nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2", "level": "easy"}
{"task_id": "Java/53", "prompt": "public class Solution {\n\n  /**\n   * Reverse the characters of each word in the given string while maintaining the original word order.\n   *\n   * @param s The input string containing words separated by spaces.\n   * @return The string with characters of each word reversed.\n   *\n   * Example:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ", "canonical_solution": "  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }", "test": "  public static void main(String[] args) {\n    testReverseWords(\"The quick brown fox\", \"ehT kciuq nworb xof\");\n    testReverseWords(\"Hello World\", \"olleH dlroW\");\n    testReverseWords(\"a b c d e f\", \"a b c d e f\");\n    System.out.println(\"All tests passed\");\n  }\n}", "entry_point": "reverseWords", "signature": "public static String reverseWords(String s)", "docstring": "Reverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"", "instruction": "Write a Java function `public static String reverseWords(String s)` to solve the following problem:\nReverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"", "level": "middle"}
