{"task_id": "Tcl/1", "prompt": "proc has_close_elements {numbers threshold} {\n# Check if in given list of numbers, are any two numbers closer to each other than\n# given threshold.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True", "canonical_solution": "set length [llength $numbers]\nfor {set idx 0} {$idx < $length} {incr idx} {\nset elem [lindex $numbers $idx]\nfor {set idx2 0} {$idx2 < $length} {incr idx2} {\nset elem2 [lindex $numbers $idx2]\nif {$idx != $idx2} {\nset distance [expr {abs($elem - $elem2)}]\nif {$distance < $threshold} {\nreturn 1\n}\n}\n}\n}\nreturn 0\n}", "test": "# Test cases\nproc check {has_close_elements} {\nif {[has_close_elements {1.0 2.0 3.9 4.0 5.0 2.2} 0.3] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 3.9 4.0 5.0 2.2} 0.05] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.95] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 5.9 4.0 5.0} 0.8] == 0} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[has_close_elements {1.0 2.0 3.0 4.0 5.0 2.0} 0.1] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 1.0] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[has_close_elements {1.1 2.2 3.1 4.1 5.1} 0.5] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck has_close_elements", "entry_point": "has_close_elements", "signature": "proc has_close_elements {numbers threshold} {", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Write a Tcl function `proc has_close_elements {numbers threshold} {` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "level": "easy"}
{"task_id": "Tcl/2", "prompt": "proc find_third_largest {numbers} {\n# This function returns the third largest number in a non-empty array.\n# If the third largest number does not exist, it returns the largest number.\n# Examples:\n# >>> find_third_largest [1, 2, 3, 4, 5]\n# 3\n# >>> find_third_largest [12, 35, 1, 10, 34, 1]\n# 12\n# >>> find_third_largest [10, 10, 10]\n# 10", "canonical_solution": "set unique_numbers [lsort -unique -decreasing $numbers]\nif {[llength $unique_numbers] < 3} {\nreturn [lindex $unique_numbers 0]\n} else {\nreturn [lindex $unique_numbers 2]\n}\n}", "test": "proc check {find_third_largest} {\nif {[find_third_largest {5 4 3 2 1}] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_third_largest {10 10 10 10}] == 10} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_third_largest {5 7 3 9 6}] == 6} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_third_largest {1 2}] == 2} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_third_largest {20 10 20 30 40}] == 20} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_third_largest {1}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_third_largest {-1 -2 -3 -4}] == -2} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_third_largest", "entry_point": "find_third_largest", "signature": "proc find_third_largest {numbers} {", "docstring": "This function returns the third largest number in a non-empty array.\nIf the third largest number does not exist, it returns the largest number.\nExamples:\n>>> find_third_largest [1, 2, 3, 4, 5]\n3\n>>> find_third_largest [12, 35, 1, 10, 34, 1]\n12\n>>> find_third_largest [10, 10, 10]\n10", "instruction": "Write a Tcl function `proc find_third_largest {numbers} {` to solve the following problem:\nThis function returns the third largest number in a non-empty array.\nIf the third largest number does not exist, it returns the largest number.\nExamples:\n>>> find_third_largest [1, 2, 3, 4, 5]\n3\n>>> find_third_largest [12, 35, 1, 10, 34, 1]\n12\n>>> find_third_largest [10, 10, 10]\n10", "level": "easy"}
{"task_id": "Tcl/3", "prompt": "proc is_covered {ranges left right} {\n# Check if every integer in the interval [left, right] is covered\n# by at least one interval in 'ranges'.\n# Each element in 'ranges' is a two-element list [start, end] representing\n# a closed interval.\n# >>> is_covered {{1 2} {3 4} {5 6}} 2 5\n# True\n# >>> is_covered {{1 10} {10 20}} 10 15\n# True\n# >>> is_covered {{1 5} {10 15}} 5 10\n# False", "canonical_solution": "for {set num $left} {$num <= $right} {incr num} {\nset covered 0\nforeach range $ranges {\nif {$num >= [lindex $range 0] && $num <= [lindex $range 1]} {\nset covered 1\nbreak\n}\n}\nif {!$covered} {\nreturn 0\n}\n}\n\nreturn 1\n}", "test": "proc check {is_covered} {\nif {[is_covered {{1 2} {3 4} {5 6}} 2 5] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[is_covered {{1 10} {10 20}} 10 15] == 1} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[is_covered {{1 5} {10 15}} 5 10] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[is_covered {{1 3} {4 6} {7 9}} 1 9] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[is_covered {{5 10}} 1 4] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[is_covered {{0 0} {2 2} {4 4}} 0 4] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[is_covered {{10 20} {20 30} {30 40}} 15 25] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck is_covered", "entry_point": "is_covered", "signature": "proc is_covered {ranges left right} {", "docstring": "Check if every integer in the interval [left, right] is covered\nby at least one interval in 'ranges'.\nEach element in 'ranges' is a two-element list [start, end] representing\na closed interval.\n>>> is_covered {{1 2} {3 4} {5 6}} 2 5\nTrue\n>>> is_covered {{1 10} {10 20}} 10 15\nTrue\n>>> is_covered {{1 5} {10 15}} 5 10\nFalse", "instruction": "Write a Tcl function `proc is_covered {ranges left right} {` to solve the following problem:\nCheck if every integer in the interval [left, right] is covered\nby at least one interval in 'ranges'.\nEach element in 'ranges' is a two-element list [start, end] representing\na closed interval.\n>>> is_covered {{1 2} {3 4} {5 6}} 2 5\nTrue\n>>> is_covered {{1 10} {10 20}} 10 15\nTrue\n>>> is_covered {{1 5} {10 15}} 5 10\nFalse", "level": "easy"}
{"task_id": "Tcl/4", "prompt": "proc can_be_increasing {nums} {\n# Check if removing exactly one element from 'nums' makes it strictly increasing.\n# If the array is already strictly increasing, return true.\n# >>> can_be_increasing {1 3 2 4}\n# True\n# >>> can_be_increasing {2 3 1 2}\n# False\n# >>> can_be_increasing {1 2 3}\n# True", "canonical_solution": "set length [llength $nums]\nset remove_count 0\n\nfor {set i 1} {$i < $length} {incr i} {\nif {[lindex $nums $i] <= [lindex $nums [expr {$i - 1}]]} {\nincr remove_count\nif {$remove_count > 1} {\nreturn 0\n}\nif {$i > 1 && $i < $length - 1 && [lindex $nums $i] <= [lindex $nums [expr {$i - 2}]] && [lindex $nums [expr {$i + 1}]] <= [lindex $nums [expr {$i - 1}]]} {\nreturn 0\n}\n}\n}\nreturn 1\n}", "test": "proc check {can_be_increasing} {\nif {[can_be_increasing {1 3 2 4}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[can_be_increasing {2 3 1 2}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[can_be_increasing {1 2 3}] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[can_be_increasing {10 1 2 3 4}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[can_be_increasing {1 2 10 3 4}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[can_be_increasing {1 2 3 4 3}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[can_be_increasing {5 4 3 2 1}] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck can_be_increasing", "entry_point": "can_be_increasing", "signature": "proc can_be_increasing {nums} {", "docstring": "Check if removing exactly one element from 'nums' makes it strictly increasing.\nIf the array is already strictly increasing, return true.\n>>> can_be_increasing {1 3 2 4}\nTrue\n>>> can_be_increasing {2 3 1 2}\nFalse\n>>> can_be_increasing {1 2 3}\nTrue", "instruction": "Write a Tcl function `proc can_be_increasing {nums} {` to solve the following problem:\nCheck if removing exactly one element from 'nums' makes it strictly increasing.\nIf the array is already strictly increasing, return true.\n>>> can_be_increasing {1 3 2 4}\nTrue\n>>> can_be_increasing {2 3 1 2}\nFalse\n>>> can_be_increasing {1 2 3}\nTrue", "level": "middle"}
{"task_id": "Tcl/5", "prompt": "proc build_concatenated_array {nums} {\n# Construct an array 'ans' of length 2n from 'nums' such that \n# ans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\n# The 'ans' array is formed by concatenating two 'nums' arrays.\n# >>> build_concatenated_array {1 2 3}\n# {1 2 3 1 2 3}\n# >>> build_concatenated_array {4 5 6 7}\n# {4 5 6 7 4 5 6 7}", "canonical_solution": "set ans $nums\nforeach num $nums {\nlappend ans $num\n}\nreturn $ans\n}", "test": "proc check {build_concatenated_array} {\nif {[build_concatenated_array {1 2 3}] eq {1 2 3 1 2 3}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[build_concatenated_array {4 5 6 7}] eq {4 5 6 7 4 5 6 7}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[build_concatenated_array {0}] eq {0 0}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[build_concatenated_array {9 8 7 6 5}] eq {9 8 7 6 5 9 8 7 6 5}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[build_concatenated_array {1 1 1 1}] eq {1 1 1 1 1 1 1 1}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[build_concatenated_array {10 20 30}] eq {10 20 30 10 20 30}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[build_concatenated_array {0 0 0 0 0 0}] eq {0 0 0 0 0 0 0 0 0 0 0 0}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck build_concatenated_array", "entry_point": "build_concatenated_array", "signature": "proc build_concatenated_array {nums} {", "docstring": "Construct an array 'ans' of length 2n from 'nums' such that \nans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\nThe 'ans' array is formed by concatenating two 'nums' arrays.\n>>> build_concatenated_array {1 2 3}\n{1 2 3 1 2 3}\n>>> build_concatenated_array {4 5 6 7}\n{4 5 6 7 4 5 6 7}", "instruction": "Write a Tcl function `proc build_concatenated_array {nums} {` to solve the following problem:\nConstruct an array 'ans' of length 2n from 'nums' such that \nans[i] = nums[i] and ans[i + n] = nums[i] for all 0 <= i < n.\nThe 'ans' array is formed by concatenating two 'nums' arrays.\n>>> build_concatenated_array {1 2 3}\n{1 2 3 1 2 3}\n>>> build_concatenated_array {4 5 6 7}\n{4 5 6 7 4 5 6 7}", "level": "easy"}
{"task_id": "Tcl/6", "prompt": "proc is_prefix_string {s words} {\n# Check if 's' is a prefix string of 'words'.\n# 's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n# >>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\n# True\n# >>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\n# False", "canonical_solution": "set concatenated \"\"\nforeach word $words {\nappend concatenated $word\nif {$concatenated eq $s} {\nreturn 1\n}\nif {[string length $concatenated] > [string length $s]} {\nbreak\n}\n}\nreturn 0\n}", "test": "proc check {is_prefix_string} {\nif {[is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[is_prefix_string \"hello\" {\"hello\" \"world\"}] == 1} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[is_prefix_string \"helloworld\" {\"hello\" \"world\"}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[is_prefix_string \"hell\" {\"hello\" \"world\"}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[is_prefix_string \"\" {\"a\" \"b\" \"c\"}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[is_prefix_string \"abc\" {\"a\" \"b\" \"c\"}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck is_prefix_string", "entry_point": "is_prefix_string", "signature": "proc is_prefix_string {s words} {", "docstring": "Check if 's' is a prefix string of 'words'.\n's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n>>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nTrue\n>>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nFalse", "instruction": "Write a Tcl function `proc is_prefix_string {s words} {` to solve the following problem:\nCheck if 's' is a prefix string of 'words'.\n's' is a prefix string of 'words' if it can be formed by concatenating the first k strings of 'words'.\n>>> is_prefix_string \"iloveleetcode\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nTrue\n>>> is_prefix_string \"iloveleetcodex\" {\"i\" \"love\" \"leetcode\" \"apples\"}\nFalse", "level": "easy"}
{"task_id": "Tcl/7", "prompt": "proc max_min_gcd {nums} {\n# Find the greatest common divisor of the maximum and minimum numbers in 'nums'.\n# >>> max_min_gcd {2 4 6 8 10}\n# 2 (GCD of 2 and 10)\n# >>> max_min_gcd {7 5 12 16 35}\n# 5 (GCD of 5 and 35)", "canonical_solution": "set max_num [lindex $nums 0]\nset min_num [lindex $nums 0]\nforeach num $nums {\nif {$num > $max_num} {\nset max_num $num\n}\nif {$num < $min_num} {\nset min_num $num\n}\n}\nreturn [gcd $max_num $min_num]\n}\n\nproc gcd {a b} {\n# Helper function to find the greatest common divisor of two numbers.\nwhile {$b != 0} {\nset temp $b\nset b [expr {$a % $b}]\nset a $temp\n}\nreturn $a\n}", "test": "proc check {max_min_gcd} {\nif {[max_min_gcd {2 4 6 8 10}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_min_gcd {7 5 12 16 35}] == 5} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_min_gcd {15 45 75}] == 15} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_min_gcd {11 13 17 19}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_min_gcd {20 40 60 80}] == 20} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_min_gcd {5 5 5 5}] == 5} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_min_gcd {100 200 300 400 500}] == 100} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_min_gcd", "entry_point": "max_min_gcd", "signature": "proc max_min_gcd {nums} {", "docstring": "Find the greatest common divisor of the maximum and minimum numbers in 'nums'.\n>>> max_min_gcd {2 4 6 8 10}\n2 (GCD of 2 and 10)\n>>> max_min_gcd {7 5 12 16 35}\n5 (GCD of 5 and 35)", "instruction": "Write a Tcl function `proc max_min_gcd {nums} {` to solve the following problem:\nFind the greatest common divisor of the maximum and minimum numbers in 'nums'.\n>>> max_min_gcd {2 4 6 8 10}\n2 (GCD of 2 and 10)\n>>> max_min_gcd {7 5 12 16 35}\n5 (GCD of 5 and 35)", "level": "middle"}
{"task_id": "Tcl/8", "prompt": "proc count_quadruplets {nums} {\n# Count the number of unique quadruplets (a, b, c, d) in 'nums' such that\n# nums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n# >>> count_quadruplets {1 2 3 6}\n# 1 (The quadruplet is (0, 1, 2, 3))\n# >>> count_quadruplets {3 3 6 4 5}\n# 0 (No such quadruplets exist)", "canonical_solution": "set count 0\nset length [llength $nums]\nfor {set a 0} {$a < $length - 3} {incr a} {\nfor {set b [expr {$a + 1}]} {$b < $length - 2} {incr b} {\nfor {set c [expr {$b + 1}]} {$c < $length - 1} {incr c} {\nfor {set d [expr {$c + 1}]} {$d < $length} {incr d} {\nif {[expr {[lindex $nums $a] + [lindex $nums $b] + [lindex $nums $c]}] == [lindex $nums $d]} {\nincr count\n}\n}\n}\n}\n}\nreturn $count\n}", "test": "proc check {count_quadruplets} {\nif {[count_quadruplets {1 2 3 6}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_quadruplets {3 3 6 4 5}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_quadruplets {1 1 1 1 1}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_quadruplets {0 0 0 0}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_quadruplets {1 2 3 4 5}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_quadruplets {1 1 2 3 4 5 6}] == 5} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_quadruplets {-1 0 1 0}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_quadruplets", "entry_point": "count_quadruplets", "signature": "proc count_quadruplets {nums} {", "docstring": "Count the number of unique quadruplets (a, b, c, d) in 'nums' such that\nnums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n>>> count_quadruplets {1 2 3 6}\n1 (The quadruplet is (0, 1, 2, 3))\n>>> count_quadruplets {3 3 6 4 5}\n0 (No such quadruplets exist)", "instruction": "Write a Tcl function `proc count_quadruplets {nums} {` to solve the following problem:\nCount the number of unique quadruplets (a, b, c, d) in 'nums' such that\nnums[a] + nums[b] + nums[c] == nums[d] and a < b < c < d.\n>>> count_quadruplets {1 2 3 6}\n1 (The quadruplet is (0, 1, 2, 3))\n>>> count_quadruplets {3 3 6 4 5}\n0 (No such quadruplets exist)", "level": "middle"}
{"task_id": "Tcl/9", "prompt": "proc count_pairs_with_diff_k {nums k} {\n# Count the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n# >>> count_pairs_with_diff_k {1 2 3 4} 1\n# 3 (The pairs are (0, 1), (1, 2), and (2, 3))\n# >>> count_pairs_with_diff_k {1 3 5 7} 2\n# 3 (The pairs are (0, 1), (1, 2), and (2, 3))", "canonical_solution": "set count 0\nset length [llength $nums]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[expr {abs([lindex $nums $i] - [lindex $nums $j])}] == $k} {\nincr count\n}\n}\n}\nreturn $count\n}", "test": "proc check {count_pairs_with_diff_k} {\nif {[count_pairs_with_diff_k {1 2 3 4} 1] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 3 5 7} 2] == 3} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 1 1 1} 0] == 6} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_pairs_with_diff_k {1 5 9 1 5 9} 4] == 8} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_pairs_with_diff_k {4 7 10 13 16} 3] == 4} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_pairs_with_diff_k {-2 2 4 6} 4] == 2} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_pairs_with_diff_k {0 0 0 0} 1] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_pairs_with_diff_k", "entry_point": "count_pairs_with_diff_k", "signature": "proc count_pairs_with_diff_k {nums k} {", "docstring": "Count the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n>>> count_pairs_with_diff_k {1 2 3 4} 1\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n>>> count_pairs_with_diff_k {1 3 5 7} 2\n3 (The pairs are (0, 1), (1, 2), and (2, 3))", "instruction": "Write a Tcl function `proc count_pairs_with_diff_k {nums k} {` to solve the following problem:\nCount the number of pairs (i, j) such that i < j and |nums[i] - nums[j]| == k.\n>>> count_pairs_with_diff_k {1 2 3 4} 1\n3 (The pairs are (0, 1), (1, 2), and (2, 3))\n>>> count_pairs_with_diff_k {1 3 5 7} 2\n3 (The pairs are (0, 1), (1, 2), and (2, 3))", "level": "easy"}
{"task_id": "Tcl/10", "prompt": "proc final_value_after_operations {operations} {\n# Calculate the final value of X after performing the operations in 'operations'.\n# X starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n# >>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n# 2\n# >>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n# 0", "canonical_solution": "set X 0\nforeach operation $operations {\nif {$operation eq \"++X\" || $operation eq \"X++\"} {\nincr X\n} elseif {$operation eq \"--X\" || $operation eq \"X--\"} {\nincr X -1\n}\n}\nreturn $X\n}", "test": "proc check {final_value_after_operations} {\nif {[final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[final_value_after_operations {\"++X\" \"++X\" \"++X\"}] == 3} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[final_value_after_operations {\"X--\" \"X--\" \"X--\"}] == -3} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[final_value_after_operations {\"X++\" \"X++\" \"X--\" \"X--\"}] == 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[final_value_after_operations {\"--X\" \"X++\" \"X++\"}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[final_value_after_operations {\"++X\" \"++X\" \"X--\"}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck final_value_after_operations", "entry_point": "final_value_after_operations", "signature": "proc final_value_after_operations {operations} {", "docstring": "Calculate the final value of X after performing the operations in 'operations'.\nX starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n>>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n2\n>>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n0", "instruction": "Write a Tcl function `proc final_value_after_operations {operations} {` to solve the following problem:\nCalculate the final value of X after performing the operations in 'operations'.\nX starts at 0 and can be incremented (++X, X++) or decremented (--X, X--).\n>>> final_value_after_operations {\"X++\" \"++X\" \"X++\" \"--X\"}\n2\n>>> final_value_after_operations {\"--X\" \"X--\" \"X++\" \"X++\"}\n0", "level": "easy"}
{"task_id": "Tcl/11", "prompt": "proc max_difference {nums} {\n# Calculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\n# and nums[i] < nums[j]. Return -1 if no such i and j exist.\n# >>> max_difference {7 1 5 4}\n# 4 (The difference is 5 - 1)\n# >>> max_difference {9 4 3 2}\n# -1 (No such i and j exist)", "canonical_solution": "set max_diff -1\nset min_element [lindex $nums 0]\n\nforeach num $nums {\nif {$num > $min_element} {\nset max_diff [expr {max($max_diff, $num - $min_element)}]\n} else {\nset min_element $num\n}\n}\n\nreturn $max_diff\n}\n\n# Helper function to get the maximum of two numbers\nproc max {a b} {\nif {$a > $b} {return $a} else {return $b}\n}", "test": "proc check {max_difference} {\nif {[max_difference {7 1 5 4}] == 4} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_difference {9 4 3 2}] == -1} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_difference {2 3 10 6 4 8 1}] == 8} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_difference {7 9 5 6 3 2}] == 2} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_difference {1 5 2 10}] == 9} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_difference {10 10 10 10}] == -1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_difference {1 2 3 4 5 6 7 8 9 10}] == 9} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_difference", "entry_point": "max_difference", "signature": "proc max_difference {nums} {", "docstring": "Calculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\nand nums[i] < nums[j]. Return -1 if no such i and j exist.\n>>> max_difference {7 1 5 4}\n4 (The difference is 5 - 1)\n>>> max_difference {9 4 3 2}\n-1 (No such i and j exist)", "instruction": "Write a Tcl function `proc max_difference {nums} {` to solve the following problem:\nCalculate the maximum difference nums[j] - nums[i] for 0 <= i < j < n\nand nums[i] < nums[j]. Return -1 if no such i and j exist.\n>>> max_difference {7 1 5 4}\n4 (The difference is 5 - 1)\n>>> max_difference {9 4 3 2}\n-1 (No such i and j exist)", "level": "easy"}
{"task_id": "Tcl/12", "prompt": "proc create_2d_array {original m n} {\n# Create an m x n 2D array from the 1D array 'original'.\n# Return an empty array if it's not possible.\n# >>> create_2d_array {1 2 3 4} 2 2\n# {{1 2} {3 4}}\n# >>> create_2d_array {1 2 3} 2 2\n# {} (Not enough elements to fill a 2x2 array)", "canonical_solution": "set total_elements [expr {$m * $n}]\nif {[llength $original] != $total_elements} {\nreturn {}\n}\n\nset result [list]\nfor {set i 0} {$i < $total_elements} {incr i $n} {\nlappend result [lrange $original $i [expr {$i + $n - 1}]]\n}\n\nreturn $result\n}", "test": "proc check {create_2d_array} {\nif {[create_2d_array {1 2 3 4} 2 2] eq {{1 2} {3 4}}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[create_2d_array {1 2 3} 2 2] eq {}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6} 2 3] eq {{1 2 3} {4 5 6}}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8 9} 3 3] eq {{1 2 3} {4 5 6} {7 8 9}}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8} 4 2] eq {{1 2} {3 4} {5 6} {7 8}}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[create_2d_array {1 2 3 4 5 6 7 8 9 10 11 12} 3 4] eq {{1 2 3 4} {5 6 7 8} {9 10 11 12}}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\n}\n\n# Call the check procedure\ncheck create_2d_array", "entry_point": "create_2d_array", "signature": "proc create_2d_array {original m n} {", "docstring": "Create an m x n 2D array from the 1D array 'original'.\nReturn an empty array if it's not possible.\n>>> create_2d_array {1 2 3 4} 2 2\n{{1 2} {3 4}}\n>>> create_2d_array {1 2 3} 2 2\n{} (Not enough elements to fill a 2x2 array)", "instruction": "Write a Tcl function `proc create_2d_array {original m n} {` to solve the following problem:\nCreate an m x n 2D array from the 1D array 'original'.\nReturn an empty array if it's not possible.\n>>> create_2d_array {1 2 3 4} 2 2\n{{1 2} {3 4}}\n>>> create_2d_array {1 2 3} 2 2\n{} (Not enough elements to fill a 2x2 array)", "level": "easy"}
{"task_id": "Tcl/13", "prompt": "proc construct_common_elements_array {nums1 nums2 nums3} {\n# Construct an array of unique elements that appear in at least two out of three arrays.\n# The elements are in ascending order.\n# >>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n# {2 3}\n# >>> construct_common_elements_array {3 1} {2 3} {1}\n# {1 3}", "canonical_solution": "array set count_nums1 {}\narray set count_nums2 {}\narray set count_nums3 {}\nforeach num $nums1 {incr count_nums1($num)}\nforeach num $nums2 {incr count_nums2($num)}\nforeach num $nums3 {incr count_nums3($num)}\n\n# Create a dictionary to store the count of each element across all arrays\narray set total_count {}\nforeach num [array names count_nums1] {incr total_count($num)}\nforeach num [array names count_nums2] {incr total_count($num)}\nforeach num [array names count_nums3] {incr total_count($num)}\n\n# Create the result array with elements appearing at least in two arrays\nset result [list]\nforeach num [array names total_count] {\nif {$total_count($num) > 1} {\nlappend result $num\n}\n}\n\nreturn [lsort -integer $result]\n}", "test": "proc check {} {\nif {[construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}] eq {2 3}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[construct_common_elements_array {3 1} {2 3} {1}] eq {1 3}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[construct_common_elements_array {1 4 5} {2 4 6} {3 4 7}] eq {4}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[construct_common_elements_array {10 20 30} {30 40 50} {50 60 70}] eq {30 50}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[construct_common_elements_array {1 2 3} {4 5 6} {7 8 9}] eq {}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[construct_common_elements_array {1 1 1} {1 1} {1}] eq {1}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[construct_common_elements_array {1 2 3 4} {2 3 4 5} {3 4 5 6}] eq {2 3 4 5}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck", "entry_point": "construct_common_elements_array", "signature": "proc construct_common_elements_array {nums1 nums2 nums3} {", "docstring": "Construct an array of unique elements that appear in at least two out of three arrays.\nThe elements are in ascending order.\n>>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n{2 3}\n>>> construct_common_elements_array {3 1} {2 3} {1}\n{1 3}", "instruction": "Write a Tcl function `proc construct_common_elements_array {nums1 nums2 nums3} {` to solve the following problem:\nConstruct an array of unique elements that appear in at least two out of three arrays.\nThe elements are in ascending order.\n>>> construct_common_elements_array {1 2 3} {4 3 2} {5 6 2}\n{2 3}\n>>> construct_common_elements_array {3 1} {2 3} {1}\n{1 3}", "level": "hard"}
{"task_id": "Tcl/14", "prompt": "proc min_moves_to_seat {seats students} {\n# Calculate the minimum number of moves to seat all students.\n# Students can be moved one position at a time.\n# >>> min_moves_to_seat {3 1 5} {2 7 4}\n# 4 (Move student from 7 to 5 and from 2 to 1)\n# >>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n# 7 (Various moves to match each student to a seat", "canonical_solution": "set sorted_seats [lsort -integer $seats]\nset sorted_students [lsort -integer $students]\nset moves 0\n\nforeach seat $sorted_seats student $sorted_students {\nincr moves [expr {abs($seat - $student)}]\n}\n\nreturn $moves\n}", "test": "proc check {min_moves_to_seat} {\nif {[min_moves_to_seat {3 1 5} {2 7 4}] == 4} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[min_moves_to_seat {4 1 5 9} {1 3 2 6}] == 7} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[min_moves_to_seat {10 2 6} {3 8 9}] == 4} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[min_moves_to_seat {1 4 2 3} {4 1 3 2}] == 0} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[min_moves_to_seat {5 5 5} {1 2 3}] == 9} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[min_moves_to_seat {1 2 3} {3 2 1}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[min_moves_to_seat {5 6 7} {5 6 7}] == 0} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck min_moves_to_seat", "entry_point": "min_moves_to_seat", "signature": "proc min_moves_to_seat {seats students} {", "docstring": "Calculate the minimum number of moves to seat all students.\nStudents can be moved one position at a time.\n>>> min_moves_to_seat {3 1 5} {2 7 4}\n4 (Move student from 7 to 5 and from 2 to 1)\n>>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n7 (Various moves to match each student to a seat", "instruction": "Write a Tcl function `proc min_moves_to_seat {seats students} {` to solve the following problem:\nCalculate the minimum number of moves to seat all students.\nStudents can be moved one position at a time.\n>>> min_moves_to_seat {3 1 5} {2 7 4}\n4 (Move student from 7 to 5 and from 2 to 1)\n>>> min_moves_to_seat {4 1 5 9} {1 3 2 6}\n7 (Various moves to match each student to a seat", "level": "easy"}
{"task_id": "Tcl/15", "prompt": "proc kth_unique_string {arr k} {\n# Return the k-th unique string from 'arr'.\n# A unique string appears exactly once in 'arr'.\n# >>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n# \"\"\n# >>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n# \"\"", "canonical_solution": "array set count {}\nforeach str $arr {\nincr count($str)\n}\n\n# Find the k-th unique string\nset unique_count 0\nforeach str $arr {\nif {$count($str) == 1} {\nincr unique_count\nif {$unique_count == $k} {\nreturn $str\n}\n}\n}\n\nreturn \"\"\n}", "test": "proc check {kth_unique_string} {\nif {[kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2] eq \"\"} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3] eq \"\"} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[kth_unique_string {\"apple\" \"banana\" \"apple\" \"orange\"} 1] eq \"banana\"} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[kth_unique_string {\"hello\" \"hello\" \"world\"} 1] eq \"world\"} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[kth_unique_string {\"x\" \"y\" \"z\" \"x\" \"y\"} 1] eq \"z\"} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[kth_unique_string {\"one\" \"two\" \"three\" \"four\"} 2] eq \"two\"} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[kth_unique_string {\"one\" \"one\" \"one\"} 1] eq \"\"} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck kth_unique_string", "entry_point": "kth_unique_string", "signature": "proc kth_unique_string {arr k} {", "docstring": "Return the k-th unique string from 'arr'.\nA unique string appears exactly once in 'arr'.\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n\"\"\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n\"\"", "instruction": "Write a Tcl function `proc kth_unique_string {arr k} {` to solve the following problem:\nReturn the k-th unique string from 'arr'.\nA unique string appears exactly once in 'arr'.\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 2\n\"\"\n>>> kth_unique_string {\"a\" \"b\" \"a\" \"c\" \"b\"} 3\n\"\"", "level": "easy"}
{"task_id": "Tcl/16", "prompt": "proc time_to_buy_tickets {tickets k} {\n# Calculate the time for the person at position k to buy their tickets.\n# Each person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n# >>> time_to_buy_tickets {5 1 1 1} 0\n# 8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n# >>> time_to_buy_tickets {2 3 2} 2\n# 6 (The person at position 2 takes 6 seconds to buy 2 tickets)", "canonical_solution": "set time 0\nset length [llength $tickets]\nfor {set i 0} {$i < $length} {incr i} {\nset min_tickets [min [lindex $tickets $i] [expr {[lindex $tickets $k] - ($i > $k)}]]\nincr time $min_tickets\n}\nreturn $time\n}\n\n# Helper function to get the minimum of two numbers\nproc min {a b} {\nif {$a < $b} {return $a} else {return $b}\n}", "test": "proc check {time_to_buy_tickets} {\nif {[time_to_buy_tickets {5 1 1 1} 0] == 8} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[time_to_buy_tickets {2 3 2} 2] == 6} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[time_to_buy_tickets {1 2 3 4 5} 3] == 13} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[time_to_buy_tickets {2 2 2 2 2} 4] == 10} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[time_to_buy_tickets {1 1 1 1 1} 2] == 3} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[time_to_buy_tickets {3 3 3 3 3} 0] == 11} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[time_to_buy_tickets {1 1 1 1 1} 0] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck time_to_buy_tickets", "entry_point": "time_to_buy_tickets", "signature": "proc time_to_buy_tickets {tickets k} {", "docstring": "Calculate the time for the person at position k to buy their tickets.\nEach person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n>>> time_to_buy_tickets {5 1 1 1} 0\n8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n>>> time_to_buy_tickets {2 3 2} 2\n6 (The person at position 2 takes 6 seconds to buy 2 tickets)", "instruction": "Write a Tcl function `proc time_to_buy_tickets {tickets k} {` to solve the following problem:\nCalculate the time for the person at position k to buy their tickets.\nEach person takes 1 second to buy a ticket and goes to the end of the line if they need more.\n>>> time_to_buy_tickets {5 1 1 1} 0\n8 (The person at position 0 takes 8 seconds to buy 5 tickets)\n>>> time_to_buy_tickets {2 3 2} 2\n6 (The person at position 2 takes 6 seconds to buy 2 tickets)", "level": "easy"}
{"task_id": "Tcl/17", "prompt": "proc max_distance_different_colors {colors} {\n# Calculate the maximum distance between two houses of different colors.\n# >>> max_distance_different_colors {1 1 1 6 1 1 1}\n# 3 (Max distance between colors 1 and 6)\n# >>> max_distance_different_colors {1 2 1 2 1 2 1}\n# 5 (Max distance between any two different colors)", "canonical_solution": "set max_distance 0\nset length [llength $colors]\nfor {set i 0} {$i < $length - 1} {incr i} {\nfor {set j [expr {$i + 1}]} {$j < $length} {incr j} {\nif {[lindex $colors $i] ne [lindex $colors $j]} {\nset distance [expr {abs($i - $j)}]\nif {$distance > $max_distance} {\nset max_distance $distance\n}\n}\n}\n}\nreturn $max_distance\n}", "test": "proc check {max_distance_different_colors} {\nif {[max_distance_different_colors {1 1 1 6 1 1 1}] == 3} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_distance_different_colors {1 2 1 2 1 2 1}] == 5} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_distance_different_colors {1 1 1 1 1}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_distance_different_colors {2 2 3 3 3 2 2}] == 4} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_distance_different_colors {1 3 2 4 5}] == 4} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_distance_different_colors {1}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_distance_different_colors {1 2 3 4 5 6}] == 5} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_distance_different_colors", "entry_point": "max_distance_different_colors", "signature": "proc max_distance_different_colors {colors} {", "docstring": "Calculate the maximum distance between two houses of different colors.\n>>> max_distance_different_colors {1 1 1 6 1 1 1}\n3 (Max distance between colors 1 and 6)\n>>> max_distance_different_colors {1 2 1 2 1 2 1}\n5 (Max distance between any two different colors)", "instruction": "Write a Tcl function `proc max_distance_different_colors {colors} {` to solve the following problem:\nCalculate the maximum distance between two houses of different colors.\n>>> max_distance_different_colors {1 1 1 6 1 1 1}\n3 (Max distance between colors 1 and 6)\n>>> max_distance_different_colors {1 2 1 2 1 2 1}\n5 (Max distance between any two different colors)", "level": "easy"}
{"task_id": "Tcl/18", "prompt": "proc count_unique_strings {words1 words2} {\n# Count the number of strings that appear exactly once in both arrays.\n# >>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n# 2 (\"banana\" appears exactly once in both arrays)\n# >>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n# 2 (\"b\" and \"c\" appear exactly once in both arrays)", "canonical_solution": "array set count_words1 {}\narray set count_words2 {}\nforeach word $words1 {\nincr count_words1($word)\n}\nforeach word $words2 {\nincr count_words2($word)\n}\n\nset unique_count 0\nforeach word $words1 {\nif {[info exists count_words1($word)] && [info exists count_words2($word)] && \n$count_words1($word) == 1 && $count_words2($word) == 1} {\nincr unique_count\n}\n}\nreturn $unique_count\n}", "test": "proc check {count_unique_strings} {\nif {[count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}] == 2} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}] == 2} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[count_unique_strings {\"one\" \"two\" \"three\"} {\"four\" \"five\" \"six\"}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[count_unique_strings {\"alpha\" \"beta\" \"gamma\"} {\"alpha\" \"beta\" \"gamma\"}] == 3} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[count_unique_strings {\"x\" \"y\" \"z\"} {\"a\" \"b\" \"z\"}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[count_unique_strings {\"cat\" \"dog\" \"cat\"} {\"dog\" \"dog\" \"cat\"}] == 0} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[count_unique_strings {\"hello\" \"world\"} {\"world\" \"hello\"}] == 2} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck count_unique_strings", "entry_point": "count_unique_strings", "signature": "proc count_unique_strings {words1 words2} {", "docstring": "Count the number of strings that appear exactly once in both arrays.\n>>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n2 (\"banana\" appears exactly once in both arrays)\n>>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n2 (\"b\" and \"c\" appear exactly once in both arrays)", "instruction": "Write a Tcl function `proc count_unique_strings {words1 words2} {` to solve the following problem:\nCount the number of strings that appear exactly once in both arrays.\n>>> count_unique_strings {\"apple\" \"banana\" \"cherry\"} {\"banana\" \"kiwi\" \"apple\"}\n2 (\"banana\" appears exactly once in both arrays)\n>>> count_unique_strings {\"a\" \"b\" \"c\"} {\"c\" \"b\" \"d\"}\n2 (\"b\" and \"c\" appear exactly once in both arrays)", "level": "middle"}
{"task_id": "Tcl/19", "prompt": "proc find_even_numbers {digits} {\n# Find all unique even numbers formed by concatenating three digits from 'digits'.\n# Exclude numbers with leading zeros.\n# >>> find_even_numbers {1 2 3}\n# {132 312}\n# >>> find_even_numbers {0 1 2}\n# {102 120 201 210}", "canonical_solution": "set unique_numbers {}\nset length [llength $digits]\n\nfor {set i 0} {$i < $length} {incr i} {\nfor {set j 0} {$j < $length} {incr j} {\nfor {set k 0} {$k < $length} {incr k} {\nif {$i == $j || $j == $k || $i == $k} continue\nset number [expr {[lindex $digits $i] * 100 + [lindex $digits $j] * 10 + [lindex $digits $k]}]\nif {[lindex $digits $i] != 0 && $number % 2 == 0} {\nlappend unique_numbers $number\n}\n}\n}\n}\n\nreturn [lsort -integer -unique $unique_numbers]\n}", "test": "proc check {find_even_numbers} {\nif {[find_even_numbers {1 2 3}] eq {132 312}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_even_numbers {0 1 2}] eq {102 120 210}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_even_numbers {4 6 8}] eq {468 486 648 684 846 864}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_even_numbers {0 0 2}] eq {200}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_even_numbers {5 7 9}] eq {}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_even_numbers {1 1 2}] eq {112}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_even_numbers {0 1 1}] eq {110}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_even_numbers", "entry_point": "find_even_numbers", "signature": "proc find_even_numbers {digits} {", "docstring": "Find all unique even numbers formed by concatenating three digits from 'digits'.\nExclude numbers with leading zeros.\n>>> find_even_numbers {1 2 3}\n{132 312}\n>>> find_even_numbers {0 1 2}\n{102 120 201 210}", "instruction": "Write a Tcl function `proc find_even_numbers {digits} {` to solve the following problem:\nFind all unique even numbers formed by concatenating three digits from 'digits'.\nExclude numbers with leading zeros.\n>>> find_even_numbers {1 2 3}\n{132 312}\n>>> find_even_numbers {0 1 2}\n{102 120 201 210}", "level": "middle"}
{"task_id": "Tcl/20", "prompt": "proc max_sum_subsequence {nums k} {\n# Find a subsequence of length k with the maximum sum.\n# >>> max_sum_subsequence {1 2 3 4 5} 3\n# {3 4 5}\n# >>> max_sum_subsequence {5 4 3 2 1} 2\n# {5 4}", "canonical_solution": "set sorted_nums [lsort -integer -decreasing $nums]\nset subsequence [lrange $sorted_nums 0 [expr {$k - 1}]]\n\nreturn $subsequence\n}", "test": "proc check {max_sum_subsequence} {\nif {[max_sum_subsequence {1 2 3 4 5} 3] eq {5 4 3}} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[max_sum_subsequence {5 4 3 2 1} 2] eq {5 4}} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[max_sum_subsequence {10 20 30 40 50} 4] eq {50 40 30 20}} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[max_sum_subsequence {1 1 1 1 1} 5] eq {1 1 1 1 1}} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[max_sum_subsequence {-1 -2 -3 -4 -5} 3] eq {-1 -2 -3}} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[max_sum_subsequence {5 1 3 4 2} 2] eq {5 4}} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[max_sum_subsequence {9 8 7 6 5 4 3 2 1 0} 1] eq {9}} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck max_sum_subsequence", "entry_point": "max_sum_subsequence", "signature": "proc max_sum_subsequence {nums k} {", "docstring": "Find a subsequence of length k with the maximum sum.\n>>> max_sum_subsequence {1 2 3 4 5} 3\n{3 4 5}\n>>> max_sum_subsequence {5 4 3 2 1} 2\n{5 4}", "instruction": "Write a Tcl function `proc max_sum_subsequence {nums k} {` to solve the following problem:\nFind a subsequence of length k with the maximum sum.\n>>> max_sum_subsequence {1 2 3 4 5} 3\n{3 4 5}\n>>> max_sum_subsequence {5 4 3 2 1} 2\n{5 4}", "level": "easy"}
{"task_id": "Tcl/21", "prompt": "proc find_max_population_year {logs} {\n# This function finds the earliest year with the highest population.\n# Each element in 'logs' is a two-element list [birth, death] representing\n# the birth and death years of a person.\n# A person is counted in the population for each year from their birth year\n# up to the year before their death.\n# >>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n# 1940\n# >>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n# 2000", "canonical_solution": "array set year_count {}\nforeach log $logs {\nfor {set year [lindex $log 0]} {$year < [lindex $log 1]} {incr year} {\nincr year_count($year)\n}\n}\n\nset max_population 0\nset max_population_year 0\nforeach year [array names year_count] {\nif {$year_count($year) > $max_population} {\nset max_population $year_count($year)\nset max_population_year $year\n} elseif {$year_count($year) == $max_population && $year < $max_population_year} {\nset max_population_year $year\n}\n}\n\nreturn $max_population_year\n}", "test": "proc check {find_max_population_year} {\nif {[find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}] == 1940} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}] == 2000} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[find_max_population_year {{1990 1995} {1995 2000} {2000 2005}}] == 1990} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[find_max_population_year {{1800 1801} {1800 1802} {1801 1802}}] == 1800} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[find_max_population_year {{1950 1960} {1950 1960} {1950 1960}}] == 1950} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[find_max_population_year {{1600 1700} {1601 1701} {1602 1702}}] == 1602} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[find_max_population_year {{2000 2005} {2001 2006} {2002 2007}}] == 2002} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck find_max_population_year", "entry_point": "find_max_population_year", "signature": "proc find_max_population_year {logs} {", "docstring": "This function finds the earliest year with the highest population.\nEach element in 'logs' is a two-element list [birth, death] representing\nthe birth and death years of a person.\nA person is counted in the population for each year from their birth year\nup to the year before their death.\n>>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n1940\n>>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n2000", "instruction": "Write a Tcl function `proc find_max_population_year {logs} {` to solve the following problem:\nThis function finds the earliest year with the highest population.\nEach element in 'logs' is a two-element list [birth, death] representing\nthe birth and death years of a person.\nA person is counted in the population for each year from their birth year\nup to the year before their death.\n>>> find_max_population_year {{1900 1950} {1940 2000} {1950 2000}}\n1940\n>>> find_max_population_year {{2000 2010} {1975 2005} {1975 2003}}\n2000", "level": "hard"}
{"task_id": "Tcl/22", "prompt": "proc can_be_equal_by_rotation {mat target} {\n# Check if rotating 'mat' 90 degrees clockwise any number of times\n# can make it identical to 'target'.\n# >>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n# 1\n# >>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n# 0", "canonical_solution": "for {set i 0} {$i < 4} {incr i} {\nif {[is_matrix_equal $mat $target]} {\nreturn 1\n}\nset mat [rotate_matrix $mat]\n}\n\nreturn 0\n}\n\nproc rotate_matrix {matrix} {\n# Rotate a square matrix 90 degrees clockwise.\nset n [llength $matrix]\nset rotated_matrix [list]\n\nfor {set i 0} {$i < $n} {incr i} {\nset row [list]\nfor {set j [expr {$n - 1}]} {$j >= 0} {incr j -1} {\nlappend row [lindex $matrix $j $i]\n}\nlappend rotated_matrix $row\n}\n\nreturn $rotated_matrix\n}\n\nproc is_matrix_equal {mat1 mat2} {\n# Check if two matrices are equal.\nset n [llength $mat1]\nfor {set i 0} {$i < $n} {incr i} {\nfor {set j 0} {$j < $n} {incr j} {\nif {[lindex $mat1 $i $j] ne [lindex $mat2 $i $j]} {\nreturn 0\n}\n}\n}\nreturn 1\n}", "test": "proc check {can_be_equal_by_rotation} {\nif {[can_be_equal_by_rotation {{1 0} {0 1}} {{0 1} {1 0}}] == 1} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}] == 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 1 0} {0 0 1} {0 1 0}} {{0 0 1} {1 1 0} {0 1 0}}] == 0} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 1} {1 0}} {{0 1} {1 1}}] == 1} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{0 0} {0 0}} {{0 0} {0 0}}] == 1} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 0 0} {0 1 0} {0 0 1}} {{0 0 1} {0 1 0} {1 0 0}}] == 1} {\nputs \"Test case 6 Passed\"\n} else {\nerror \"Test case 6 Failed\"\n}\n\nif {[can_be_equal_by_rotation {{1 0 1} {0 1 0} {1 0 1}} {{1 0 1} {0 1 0} {1 0 1}}] == 1} {\nputs \"Test case 7 Passed\"\n} else {\nerror \"Test case 7 Failed\"\n}\n}\n\n# Call the check procedure\ncheck can_be_equal_by_rotation", "entry_point": "can_be_equal_by_rotation", "signature": "proc can_be_equal_by_rotation {mat target} {", "docstring": "Check if rotating 'mat' 90 degrees clockwise any number of times\ncan make it identical to 'target'.\n>>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n1\n>>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n0", "instruction": "Write a Tcl function `proc can_be_equal_by_rotation {mat target} {` to solve the following problem:\nCheck if rotating 'mat' 90 degrees clockwise any number of times\ncan make it identical to 'target'.\n>>> can_be_equal_by_rotation {{0 1} {1 0}} {{1 0} {0 1}}\n1\n>>> can_be_equal_by_rotation {{0 1} {1 1}} {{1 0} {0 1}}\n0", "level": "hard"}
{"task_id": "Tcl/23", "prompt": "proc findTriplets {A B C} {\n# This function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\n# The numbers are composed of the digits 1 to 9, each used exactly once.\n# It returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\n# Example usage:\n# >>> findTriplets 1 2 3\n# {192 384 576} {219 438 657} {273 546 819} {327 654 981}\n# >>> findTriplets 1 1 1\n# No!!!", "canonical_solution": "set digits {1 2 3 4 5 6 7 8 9}\nset result {}\n\nforeach a [permute $digits 3] {\nforeach b [permute $digits 3] {\nforeach c [permute $digits 3] {\nif {![uniqueDigits $a $b $c]} continue\nset numA [join $a \"\"]\nset numB [join $b \"\"]\nset numC [join $c \"\"]\n\nif {$numB * $A == $numA * $B && $numC * $A == $numA * $C} {\nlappend result [list $numA $numB $numC]\n}\n}\n}\n}\n\nif {[llength $result] == 0} {\nreturn \"No!!!\"\n} else {\nreturn [lsort $result]\n}\n}\n\nproc permute {list n} {\n# Generate all n-length permutations of the list\n}\n\nproc uniqueDigits {list1 list2 list3} {\n# Check if all digits in the three lists are unique\n}", "test": "proc check {findTriplets} {\n# Test Cases\nset test1 [findTriplets 1 2 3]\nif {[llength $test1] > 0} {\nputs \"Test case 1 Passed\"\n} else {\nerror \"Test case 1 Failed\"\n}\n\nset test2 [findTriplets 2 3 4]\nif {[llength $test2] > 0} {\nputs \"Test case 2 Passed\"\n} else {\nerror \"Test case 2 Failed\"\n}\n\nset test3 [findTriplets 1 1 1]\nif {$test3 eq \"No!!!\"} {\nputs \"Test case 3 Passed\"\n} else {\nerror \"Test case 3 Failed\"\n}\n\nset test4 [findTriplets 3 3 3]\nif {$test4 eq \"No!!!\"} {\nputs \"Test case 4 Passed\"\n} else {\nerror \"Test case 4 Failed\"\n}\n\nset test5 [findTriplets 5 7 9]\nif {[llength $test5] > 0} {\nputs \"Test case 5 Passed\"\n} else {\nerror \"Test case 5 Failed\"\n}\n}\n\n# Call the check procedure\ncheck findTriplets", "entry_point": "findTriplets", "signature": "proc findTriplets {A B C} {", "docstring": "This function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\nThe numbers are composed of the digits 1 to 9, each used exactly once.\nIt returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\nExample usage:\n>>> findTriplets 1 2 3\n{192 384 576} {219 438 657} {273 546 819} {327 654 981}\n>>> findTriplets 1 1 1\nNo!!!", "instruction": "Write a Tcl function `proc findTriplets {A B C} {` to solve the following problem:\nThis function finds all unique sets of three 3-digit numbers that have a ratio of A:B:C.\nThe numbers are composed of the digits 1 to 9, each used exactly once.\nIt returns a list of such number triplets if they exist; otherwise, it returns \"No!!!\".\nExample usage:\n>>> findTriplets 1 2 3\n{192 384 576} {219 438 657} {273 546 819} {327 654 981}\n>>> findTriplets 1 1 1\nNo!!!", "level": "hard"}
{"task_id": "Tcl/24", "prompt": "proc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {\n# Calculate the perimeter of a triangle given the coordinates of its three vertices.\n# The coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\n# The function returns the perimeter of the triangle rounded to two decimal places.\n#\n# Example usage:\n# >>> calculate_triangle_perimeter 0 0 3 0 0 4\n# 12.00\n# >>> calculate_triangle_perimeter 1 1 4 1 1 5\n# 12.00", "canonical_solution": "# Helper function to calculate distance between two points\nproc distance {x1 y1 x2 y2} {\nreturn [expr {sqrt(pow($x2 - $x1, 2) + pow($y2 - $y1, 2))}]\n}\n\n# Calculate distances between each pair of points\nset d1 [distance $x1 $y1 $x2 $y2]\nset d2 [distance $x2 $y2 $x3 $y3]\nset d3 [distance $x3 $y3 $x1 $y1]\n\n# Sum the distances and round to two decimal places\nreturn [format \"%.2f\" [expr {$d1 + $d2 + $d3}]]\n}", "test": "proc check {calculate_triangle_perimeter} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_triangle_perimeter 0 0 3 0 0 4] \"12.00\" \"Test case 1\"\nassert_equal [calculate_triangle_perimeter 1 1 4 1 1 5] \"12.00\" \"Test case 2\"\nassert_equal [calculate_triangle_perimeter 0 0 0 6 8 0] \"24.00\" \"Test case 3\"\nassert_equal [calculate_triangle_perimeter 1 2 3 4 5 6] \"11.31\" \"Test case 4\"\nassert_equal [calculate_triangle_perimeter -1 -2 -3 -4 -5 -6] \"11.31\" \"Test case 5\"\nassert_equal [calculate_triangle_perimeter 10 10 20 20 30 30] \"56.57\" \"Test case 6\"\n}\n\n# Call the check procedure\ncheck calculate_triangle_perimeter", "entry_point": "calculate_triangle_perimeter", "signature": "proc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {", "docstring": "Calculate the perimeter of a triangle given the coordinates of its three vertices.\nThe coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\nThe function returns the perimeter of the triangle rounded to two decimal places.\n\nExample usage:\n>>> calculate_triangle_perimeter 0 0 3 0 0 4\n12.00\n>>> calculate_triangle_perimeter 1 1 4 1 1 5\n12.00", "instruction": "Write a Tcl function `proc calculate_triangle_perimeter {x1 y1 x2 y2 x3 y3} {` to solve the following problem:\nCalculate the perimeter of a triangle given the coordinates of its three vertices.\nThe coordinates are expected to be real numbers, not exceeding the absolute value of 100.00.\nThe function returns the perimeter of the triangle rounded to two decimal places.\n\nExample usage:\n>>> calculate_triangle_perimeter 0 0 3 0 0 4\n12.00\n>>> calculate_triangle_perimeter 1 1 4 1 1 5\n12.00", "level": "middle"}
{"task_id": "Tcl/25", "prompt": "proc count_leap_years {x y} {\n# Count the number of leap years within a given range [x, y] and list them.\n# Leap years are years divisible by 4, but not by 100, unless also divisible by 400.\n# The function returns the count of leap years and a list of these leap years.\n# The input x and y should be non-negative integers with x <= y.\n#\n# Example usage:\n# >>> count_leap_years 2000 2020\n# 6\n# 2000 2004 2008 2012 2016 2020\n# >>> count_leap_years 1900 1920\n# 5\n# 1904 1908 1912 1916 1920", "canonical_solution": "set leap_years {}\nset count 0\n\nfor {set i $x} {$i <= $y} {incr i} {\nif {[is_leap_year $i]} {\nlappend leap_years $i\nincr count\n}\n}\n\n# Format the output as a single string\nreturn [format \"%d\\n%s\" $count [join $leap_years \" \"]]\n}\nproc is_leap_year {year} {\nexpr {($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0)}\n}", "test": "proc test_count_leap_years {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual ne $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [count_leap_years 2000 2020] \"6\\n2000 2004 2008 2012 2016 2020\" \"Test case 1\"\nassert_equal [count_leap_years 1900 1920] \"5\\n1904 1908 1912 1916 1920\" \"Test case 2\"\nassert_equal [count_leap_years 1950 1960] \"3\\n1952 1956 1960\" \"Test case 3\"\nassert_equal [count_leap_years 1985 1995] \"2\\n1988 1992\" \"Test case 4\" \nassert_equal [count_leap_years 2010 2015] \"1\\n2012\" \"Test case 5\"\n}\n\n# Call the test procedure\ntest_count_leap_years", "entry_point": "count_leap_years", "signature": "proc count_leap_years {x y} {", "docstring": "Count the number of leap years within a given range [x, y] and list them.\nLeap years are years divisible by 4, but not by 100, unless also divisible by 400.\nThe function returns the count of leap years and a list of these leap years.\nThe input x and y should be non-negative integers with x <= y.\n\nExample usage:\n>>> count_leap_years 2000 2020\n6\n2000 2004 2008 2012 2016 2020\n>>> count_leap_years 1900 1920\n5\n1904 1908 1912 1916 1920", "instruction": "Write a Tcl function `proc count_leap_years {x y} {` to solve the following problem:\nCount the number of leap years within a given range [x, y] and list them.\nLeap years are years divisible by 4, but not by 100, unless also divisible by 400.\nThe function returns the count of leap years and a list of these leap years.\nThe input x and y should be non-negative integers with x <= y.\n\nExample usage:\n>>> count_leap_years 2000 2020\n6\n2000 2004 2008 2012 2016 2020\n>>> count_leap_years 1900 1920\n5\n1904 1908 1912 1916 1920", "level": "easy"}
{"task_id": "Tcl/26", "prompt": "proc calculate_peaches {n} {\n# This function calculates the total number of peaches a monkey bought,\n# based on the number of days it ate them.\n# Each day the monkey eats half of the peaches plus one.\n# On the nth day, only one peach is left.\n# The function expects a positive integer n, representing the number of days,\n# and returns the total number of peaches initially bought by the monkey.\n#\n# Example usage:\n# >>> calculate_peaches 3\n# 10\n# >>> calculate_peaches 5\n# 46", "canonical_solution": "set peaches 1\nfor {set i 1} {$i < $n} {incr i} {\nset peaches [expr {($peaches + 1) * 2}]\n}\nreturn $peaches\n}", "test": "proc check {calculate_peaches} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_peaches 3] \"10\" \"Test case 1\"\nassert_equal [calculate_peaches 5] \"46\" \"Test case 2\"\nassert_equal [calculate_peaches 6] \"94\" \"Test case 3\"\nassert_equal [calculate_peaches 7] \"190\" \"Test case 4\"\nassert_equal [calculate_peaches 8] \"382\" \"Test case 5\"\nassert_equal [calculate_peaches 2] \"4\" \"Test case 6\"\n}\n\n# Call the check procedure\ncheck calculate_peaches", "entry_point": "calculate_peaches", "signature": "proc calculate_peaches {n} {", "docstring": "This function calculates the total number of peaches a monkey bought,\nbased on the number of days it ate them.\nEach day the monkey eats half of the peaches plus one.\nOn the nth day, only one peach is left.\nThe function expects a positive integer n, representing the number of days,\nand returns the total number of peaches initially bought by the monkey.\n\nExample usage:\n>>> calculate_peaches 3\n10\n>>> calculate_peaches 5\n46", "instruction": "Write a Tcl function `proc calculate_peaches {n} {` to solve the following problem:\nThis function calculates the total number of peaches a monkey bought,\nbased on the number of days it ate them.\nEach day the monkey eats half of the peaches plus one.\nOn the nth day, only one peach is left.\nThe function expects a positive integer n, representing the number of days,\nand returns the total number of peaches initially bought by the monkey.\n\nExample usage:\n>>> calculate_peaches 3\n10\n>>> calculate_peaches 5\n46", "level": "easy"}
{"task_id": "Tcl/27", "prompt": "proc update_student_info {students} {\n# This function updates the information of students who have undergone a year of training.\n# Each student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\n# After a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n#\n# Arguments:\n# students: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n#\n# Returns:\n# A list of updated student information with increased age and improved NOIP scores.\n#\n# Example usage:\n# >>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\n# Alice 16 360 Bob 18 540 Charlie 17 600", "canonical_solution": "set updated_students {}\n\nforeach student $students {\nlassign $student name age score\n\n# Increase age and calculate new score\nincr age\nset new_score [expr {min(600, int($score * 1.2))}]\n\n# Append updated student info to the list\nlappend updated_students [list $name $age $new_score]\n}\n\nreturn $updated_students\n}", "test": "proc check {update_student_info} {\n# Test case utility\nproc assert_equal {actual expected message} {\nset actual_str \"\"\nforeach student $actual {\nappend actual_str [join $student \" \"] \" \"\n}\nset actual_str [string trim $actual_str]\n\nif {$actual_str != $expected} {\nerror \"$message. Expected $expected but got $actual_str\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}] \"Alice 16 360 Bob 18 540 Charlie 17 600\" \"Test case 1\"\nassert_equal [update_student_info {{\"Daniel\" 14 100} {\"Eve\" 18 580} {\"Frank\" 17 500}}] \"Daniel 15 120 Eve 19 600 Frank 18 600\" \"Test case 2\"\nassert_equal [update_student_info {{\"Grace\" 15 0} {\"Henry\" 16 600}}] \"Grace 16 0 Henry 17 600\" \"Test case 3\"\n}\n\n# Call the check procedure\ncheck update_student_info", "entry_point": "update_student_info", "signature": "proc update_student_info {students} {", "docstring": "This function updates the information of students who have undergone a year of training.\nEach student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\nAfter a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n\nArguments:\nstudents: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n\nReturns:\nA list of updated student information with increased age and improved NOIP scores.\n\nExample usage:\n>>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\nAlice 16 360 Bob 18 540 Charlie 17 600", "instruction": "Write a Tcl function `proc update_student_info {students} {` to solve the following problem:\nThis function updates the information of students who have undergone a year of training.\nEach student's information includes their name (string), age (integer), and last year's NOIP score (integer, multiple of 5).\nAfter a year of training, each student's age increases by 1, and their NOIP score increases by 20%, capped at 600.\n\nArguments:\nstudents: A list of student information, where each student is represented as a sublist with name, age, and last year's NOIP score.\n\nReturns:\nA list of updated student information with increased age and improved NOIP scores.\n\nExample usage:\n>>> update_student_info {{\"Alice\" 15 300} {\"Bob\" 17 450} {\"Charlie\" 16 550}}\nAlice 16 360 Bob 18 540 Charlie 17 600", "level": "easy"}
{"task_id": "Tcl/28", "prompt": "proc calculate_max_necklace_length {totalVolume lossPerBead} {\n# This function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\n# The diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\n# The function returns the maximum length of the necklace by determining the optimal number of beads.\n# It returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n#\n# Example usage:\n# >>> calculate_max_necklace_length 100 10\n# Result: 5", "canonical_solution": "set maxLen 0\nset numOfBeads 0\n\nfor {set i 1} {$i * $lossPerBead < $totalVolume} {incr i} {\nset volumePerBead [expr {$totalVolume / double($i)}]\nif {$volumePerBead <= $lossPerBead} break\n\nset diameter [expr {0.3 * sqrt($volumePerBead - $lossPerBead)}]\nset length [expr {$diameter * $i}]\nif {$length > $maxLen} {\nset maxLen $length\nset numOfBeads $i\n}\n}\n\nif {$numOfBeads == 0 || $maxLen == [expr {0.3 * sqrt($totalVolume - $lossPerBead) * 2}]} {\nreturn 0\n} else {\nreturn $numOfBeads\n}\n}", "test": "proc check {calculate_max_necklace_length} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_max_necklace_length 100 10] \"5\" {Test case 1}\nassert_equal [calculate_max_necklace_length 15 4] \"2\" {Test case 2}\nassert_equal [calculate_max_necklace_length 5000 50] \"50\" {Test case 3}\nassert_equal [calculate_max_necklace_length 300 30] \"5\" {Test case 4}\nassert_equal [calculate_max_necklace_length 2000 200] \"5\" {Test case 5}\n}\n\n# Call the check procedure\ncheck calculate_max_necklace_length", "entry_point": "calculate_max_necklace_length", "signature": "proc calculate_max_necklace_length {totalVolume lossPerBead} {", "docstring": "This function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\nThe diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\nThe function returns the maximum length of the necklace by determining the optimal number of beads.\nIt returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n\nExample usage:\n>>> calculate_max_necklace_length 100 10\nResult: 5", "instruction": "Write a Tcl function `proc calculate_max_necklace_length {totalVolume lossPerBead} {` to solve the following problem:\nThis function calculates the maximum length of a necklace that can be made from a given total volume of clay (totalVolume) and a fixed loss per bead (lossPerBead).\nThe diameter of each bead is calculated using the formula D = 0.3 * sqrt(V - lossPerBead) for V > lossPerBead, and D = 0 for V <= lossPerBead.\nThe function returns the maximum length of the necklace by determining the optimal number of beads.\nIt returns 0 if it's not possible to make any bead or if there are multiple optimal solutions.\n\nExample usage:\n>>> calculate_max_necklace_length 100 10\nResult: 5", "level": "middle"}
{"task_id": "Tcl/29", "prompt": "proc calculate_consistent_pairs {k rankings} {\n# Calculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\n# A pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n#\n# Args:\n# k: The number of training sessions (integer).\n# rankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n#\n# Returns:\n# The number of consistent pairs of cows.\n#\n# Example usage:\n# >>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n# 2", "canonical_solution": "# Helper function to check if a pair is consistent\nproc is_consistent {pair rankings} {\nforeach session $rankings {\nif {[lsearch -exact $session [lindex $pair 0]] > [lsearch -exact $session [lindex $pair 1]]} {\nreturn 0\n}\n}\nreturn 1\n}\n\n\nset consistent_count 0\n\n# Assume N is the number of cows, which should be the length of the first ranking list\nset N [llength [lindex $rankings 0]]\n\n# Generate all pairs of cows\nfor {set i 1} {$i < $N} {incr i} {\nfor {set j [expr {$i + 1}]} {$j <= $N} {incr j} {\nset pair [list $i $j]\nif {[is_consistent $pair $rankings]} {\nincr consistent_count\n}\n}\n}\n\n\nreturn $consistent_count\n}", "test": "proc check {calculate_consistent_pairs} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}] 2 \"Test case 1\"\nassert_equal [calculate_consistent_pairs 3 {{3 2 1} {1 3 2} {2 1 3}}] 0 \"Test case 2\"\nassert_equal [calculate_consistent_pairs 3 {{1 2 3 4} {2 3 4 1} {3 4 1 2}}] 1 \"Test case 3\"\nassert_equal [calculate_consistent_pairs 4 {{1 2 3 4} {4 3 2 1} {1 4 2 3} {3 1 4 2}}] 0 \"Test case 4\"\n}\n\n# Call the check procedure\ncheck calculate_consistent_pairs", "entry_point": "calculate_consistent_pairs", "signature": "proc calculate_consistent_pairs {k rankings} {", "docstring": "Calculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\nA pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n\nArgs:\nk: The number of training sessions (integer).\nrankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n\nReturns:\nThe number of consistent pairs of cows.\n\nExample usage:\n>>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n2", "instruction": "Write a Tcl function `proc calculate_consistent_pairs {k rankings} {` to solve the following problem:\nCalculates the number of consistent pairs of cows based on their performance rankings over multiple training sessions.\nA pair of cows is considered consistent if one cow always ranks higher than the other in every session.\n\nArgs:\nk: The number of training sessions (integer).\nrankings: A list of lists, where each inner list represents the rankings of cows in a training session.\n\nReturns:\nThe number of consistent pairs of cows.\n\nExample usage:\n>>> calculate_consistent_pairs 2 {{1 2 3} {2 1 3}}\n2", "level": "hard"}
{"task_id": "Tcl/30", "prompt": "proc find_min_unique_sequence_length {mailbox_sequence} {\n# This function finds the minimum length of a unique sequence of characters\n# in a given string representing a series of colored mailboxes along a road.\n# Each character in the string is an uppercase letter from A to Z, representing\n# the color of a mailbox. The function returns the smallest integer K such that\n# any sequence of K consecutive characters in the string is unique within the string.\n#\n# Example usage:\n# >>> find_min_unique_sequence_length \"AABCAA\"\n# 3\n# >>> find_min_unique_sequence_length \"XYZXYZ\"\n# 4", "canonical_solution": "set n [string length $mailbox_sequence]\nfor {set k 1} {$k <= $n} {incr k} {\nset unique 1\n# Initialize seen_sequences as an array\narray set seen_sequences {}\nfor {set i 0} {$i <= $n - $k} {incr i} {\nset seq [string range $mailbox_sequence $i [expr {$i + $k - 1}]]\nif {[info exists seen_sequences($seq)]} {\nset unique 0\nbreak\n} else {\nset seen_sequences($seq) 1\n}\n}\nif {$unique} {\nreturn $k\n}\n}\n}", "test": "proc check {find_min_unique_sequence_length} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [find_min_unique_sequence_length \"AABCAA\"] 3 \"Test case 1\"\nassert_equal [find_min_unique_sequence_length \"XYZXYZ\"] 4 \"Test case 2\"\nassert_equal [find_min_unique_sequence_length \"BBBBB\"] 5 \"Test case 3\"\nassert_equal [find_min_unique_sequence_length \"ABCDEFA\"] 2 \"Test case 4\"\nassert_equal [find_min_unique_sequence_length \"GHIJKLGH\"] 3 \"Test case 5\"\nassert_equal [find_min_unique_sequence_length \"RSTUVWXYZRST\"] 4 \"Test case 6\"\n}\n\n# Call the check procedure\ncheck find_min_unique_sequence_length", "entry_point": "find_min_unique_sequence_length", "signature": "proc find_min_unique_sequence_length {mailbox_sequence} {", "docstring": "This function finds the minimum length of a unique sequence of characters\nin a given string representing a series of colored mailboxes along a road.\nEach character in the string is an uppercase letter from A to Z, representing\nthe color of a mailbox. The function returns the smallest integer K such that\nany sequence of K consecutive characters in the string is unique within the string.\n\nExample usage:\n>>> find_min_unique_sequence_length \"AABCAA\"\n3\n>>> find_min_unique_sequence_length \"XYZXYZ\"\n4", "instruction": "Write a Tcl function `proc find_min_unique_sequence_length {mailbox_sequence} {` to solve the following problem:\nThis function finds the minimum length of a unique sequence of characters\nin a given string representing a series of colored mailboxes along a road.\nEach character in the string is an uppercase letter from A to Z, representing\nthe color of a mailbox. The function returns the smallest integer K such that\nany sequence of K consecutive characters in the string is unique within the string.\n\nExample usage:\n>>> find_min_unique_sequence_length \"AABCAA\"\n3\n>>> find_min_unique_sequence_length \"XYZXYZ\"\n4", "level": "middle"}
{"task_id": "Tcl/31", "prompt": "proc calculate_final_position {n p k} {\n# Calculate the final position of a light beam in a unit circle after a certain number of reflections.\n# The unit circle is divided into 'n' equal parts, and a light beam is emitted from point A0 towards Ap.\n# After 'k' reflections, the beam reaches point At. The function calculates the value of 't'.\n#\n# Args:\n# n (integer): Number of divisions in the unit circle.\n# p (integer): Initial direction of the light beam towards Ap.\n# k (integer): Number of reflections.\n#\n# Returns:\n# Integer: The final position 't' of the light beam in the unit circle.\n#\n# Example usage:\n# >>> calculate_final_position 12 3 1\n# 3\n# >>> calculate_final_position 20 7 4\n# 8", "canonical_solution": "set t [expr {($p * $k) % $n}]\nreturn $t\n}", "test": "proc check {calculate_final_position} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [calculate_final_position 12 3 1] 3 \"Test case 1\"\nassert_equal [calculate_final_position 20 7 4] 8 \"Test case 2\"\nassert_equal [calculate_final_position 15 4 7] 13 \"Test case 3\"\nassert_equal [calculate_final_position 100 25 50] 50 \"Test case 4\"\nassert_equal [calculate_final_position 50 20 15] 0 \"Test case 5\"\nassert_equal [calculate_final_position 30 5 17] 25 \"Test case 6\"\n}\n\n# Call the check procedure\ncheck calculate_final_position", "entry_point": "calculate_final_position", "signature": "proc calculate_final_position {n p k} {", "docstring": "Calculate the final position of a light beam in a unit circle after a certain number of reflections.\nThe unit circle is divided into 'n' equal parts, and a light beam is emitted from point A0 towards Ap.\nAfter 'k' reflections, the beam reaches point At. The function calculates the value of 't'.\n\nArgs:\nn (integer): Number of divisions in the unit circle.\np (integer): Initial direction of the light beam towards Ap.\nk (integer): Number of reflections.\n\nReturns:\nInteger: The final position 't' of the light beam in the unit circle.\n\nExample usage:\n>>> calculate_final_position 12 3 1\n3\n>>> calculate_final_position 20 7 4\n8", "instruction": "Write a Tcl function `proc calculate_final_position {n p k} {` to solve the following problem:\nCalculate the final position of a light beam in a unit circle after a certain number of reflections.\nThe unit circle is divided into 'n' equal parts, and a light beam is emitted from point A0 towards Ap.\nAfter 'k' reflections, the beam reaches point At. The function calculates the value of 't'.\n\nArgs:\nn (integer): Number of divisions in the unit circle.\np (integer): Initial direction of the light beam towards Ap.\nk (integer): Number of reflections.\n\nReturns:\nInteger: The final position 't' of the light beam in the unit circle.\n\nExample usage:\n>>> calculate_final_position 12 3 1\n3\n>>> calculate_final_position 20 7 4\n8", "level": "easy"}
{"task_id": "Tcl/32", "prompt": "proc calculate_minimal_dissatisfaction {schoolScores studentScores} {\n# This function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\n# It takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\n# The function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n#\n# Example usage:\n# >>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n# 25\n# >>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n# 40", "canonical_solution": "set totalDissatisfaction 0\n\nforeach studentScore $studentScores {\nset minDissatisfaction 1000000\n\nforeach schoolScore $schoolScores {\nset difference [expr {abs($studentScore - $schoolScore)}]\n\nif {$difference < $minDissatisfaction} {\nset minDissatisfaction $difference\n}\n}\n\nset totalDissatisfaction [expr {$totalDissatisfaction + $minDissatisfaction}]\n}\n\nreturn $totalDissatisfaction\n}", "test": "proc check {calculate_minimal_dissatisfaction} {\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\nassert_equal [calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}] 25 \"Test case 1\"\nassert_equal [calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}] 40 \"Test case 2\"\nassert_equal [calculate_minimal_dissatisfaction {520 580 640} {500 630 550}] 60 \"Test case 3\"\nassert_equal [calculate_minimal_dissatisfaction {530 560 590 620} {550 570 540}] 30 \"Test case 4\"\nassert_equal [calculate_minimal_dissatisfaction {500 530 560 590} {510 540 570}] 30 \"Test case 5\"\n}\n\ncheck calculate_minimal_dissatisfaction", "entry_point": "calculate_minimal_dissatisfaction", "signature": "proc calculate_minimal_dissatisfaction {schoolScores studentScores} {", "docstring": "This function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\nIt takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\nThe function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n\nExample usage:\n>>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n25\n>>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n40", "instruction": "Write a Tcl function `proc calculate_minimal_dissatisfaction {schoolScores studentScores} {` to solve the following problem:\nThis function calculates the minimal total dissatisfaction of students based on their estimated scores and the projected admission scores of schools.\nIt takes two lists: the first contains the projected admission scores of schools, and the second contains the estimated scores of students.\nThe function returns the sum of the minimum absolute differences between each student's score and the closest school's score.\n\nExample usage:\n>>> calculate_minimal_dissatisfaction {510 600 580 700} {505 610 570}\n25\n>>> calculate_minimal_dissatisfaction {500 550 600 650} {520 560 590}\n40", "level": "middle"}
{"task_id": "Tcl/33", "prompt": "proc solveEquation {equation} {\n# Solves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\n# The function takes a string input representing the equation. The equation may contain additional spaces.\n# It returns the value of the unknown variable as an integer.\n#\n# Example usage:\n# >>> solveEquation \"1+?=2\"\n# 1\n# >>> solveEquation \"4-3=?\"\n# 1\n# >>> solveEquation \"?-3=2\"\n# 5", "canonical_solution": "set cleanEquation [string map {\" \" \"\"} $equation]\n\n# Split the equation into parts\nregexp {(\\d+|\\?)([+-])(\\d+|\\?)=(\\d+|\\?)} $cleanEquation -> x op y z\n\n# Solve for the unknown\nif {\"?\" in $x} {\nset result [expr {$op eq \"+\" ? $z - $y : $z + $y}]\n} elseif {\"?\" in $y} {\nset result [expr {$op eq \"+\" ? $z - $x : $x - $z}]\n} else {\nset result [expr {$op eq \"+\" ? $x + $y : $x - $y}]\n}\nreturn $result\n}", "test": "proc testSolveEquation {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [solveEquation \"1+?=2\"] 1 \"Test case 1\"\nassert_equal [solveEquation \"4-3=?\"] 1 \"Test case 2\"\nassert_equal [solveEquation \"?-3=2\"] 5 \"Test case 3\"\nassert_equal [solveEquation \"5+?=10\"] 5 \"Test case 4\"\nassert_equal [solveEquation \"?+4=7\"] 3 \"Test case 5\"\nassert_equal [solveEquation \"10-?=5\"] 5 \"Test case 6\"\n}\n\n# Call the test procedure\ntestSolveEquation", "entry_point": "solveEquation", "signature": "proc solveEquation {equation} {", "docstring": "Solves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\nThe function takes a string input representing the equation. The equation may contain additional spaces.\nIt returns the value of the unknown variable as an integer.\n\nExample usage:\n>>> solveEquation \"1+?=2\"\n1\n>>> solveEquation \"4-3=?\"\n1\n>>> solveEquation \"?-3=2\"\n5", "instruction": "Write a Tcl function `proc solveEquation {equation} {` to solve the following problem:\nSolves a simple arithmetic equation of the form X+Y=Z or X-Y=Z, where one of the variables is unknown and represented by '?'.\nThe function takes a string input representing the equation. The equation may contain additional spaces.\nIt returns the value of the unknown variable as an integer.\n\nExample usage:\n>>> solveEquation \"1+?=2\"\n1\n>>> solveEquation \"4-3=?\"\n1\n>>> solveEquation \"?-3=2\"\n5", "level": "middle"}
{"task_id": "Tcl/34", "prompt": "proc generate_bitonic_sequence {numbers} {\n# Generates a bitonic sequence from a list of integers.\n# The sequence starts with the largest number, followed by the smallest,\n# then the second largest, second smallest, and so on until all numbers are used.\n# The numbers are given as a list and are within the range of long integers.\n#\n# Example usage:\n# >>> generate_bitonic_sequence {10 -1 3 3 -9}\n# 10 -9 3 -1 3\n# >>> generate_bitonic_sequence {5 1 9 2 8 3}\n# 9 1 8 2 5 3", "canonical_solution": "set sorted_numbers [lsort -integer $numbers]\nset sequence {}\nset left 0\nset right [expr {[llength $sorted_numbers] - 1}]\n\nwhile {$left <= $right} {\nif {$left != $right} {\nlappend sequence [lindex $sorted_numbers $right]\n}\nlappend sequence [lindex $sorted_numbers $left]\nincr left\nincr right -1\n}\n\nreturn $sequence\n}", "test": "proc check {generate_bitonic_sequence} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [generate_bitonic_sequence {10 -1 3 3 -9}] {10 -9 3 -1 3} \"Test case 1\"\nassert_equal [generate_bitonic_sequence {5 1 9 2 8 3}] {9 1 8 2 5 3} \"Test case 2\"\nassert_equal [generate_bitonic_sequence {-5 -1 -9 -2 -8 -3}] {-1 -9 -2 -8 -3 -5} \"Test case 3\"\nassert_equal [generate_bitonic_sequence {0 0 0 0}] {0 0 0 0} \"Test case 4\"\nassert_equal [generate_bitonic_sequence {1000 500 100 -500}] {1000 -500 500 100} \"Test case 5\"\n}\n\n# Call the check procedure\ncheck generate_bitonic_sequence", "entry_point": "generate_bitonic_sequence", "signature": "proc generate_bitonic_sequence {numbers} {", "docstring": "Generates a bitonic sequence from a list of integers.\nThe sequence starts with the largest number, followed by the smallest,\nthen the second largest, second smallest, and so on until all numbers are used.\nThe numbers are given as a list and are within the range of long integers.\n\nExample usage:\n>>> generate_bitonic_sequence {10 -1 3 3 -9}\n10 -9 3 -1 3\n>>> generate_bitonic_sequence {5 1 9 2 8 3}\n9 1 8 2 5 3", "instruction": "Write a Tcl function `proc generate_bitonic_sequence {numbers} {` to solve the following problem:\nGenerates a bitonic sequence from a list of integers.\nThe sequence starts with the largest number, followed by the smallest,\nthen the second largest, second smallest, and so on until all numbers are used.\nThe numbers are given as a list and are within the range of long integers.\n\nExample usage:\n>>> generate_bitonic_sequence {10 -1 3 3 -9}\n10 -9 3 -1 3\n>>> generate_bitonic_sequence {5 1 9 2 8 3}\n9 1 8 2 5 3", "level": "easy"}
{"task_id": "Tcl/35", "prompt": "proc maxSubmatrixSum {matrix} {\n# Calculates the maximum sum of a submatrix within a given matrix.\n# The matrix is represented as a list of lists, where each inner list is a row in the matrix.\n# The elements of the matrix are integers in the range [-127, 127].\n# The function returns the maximum sum of any submatrix within the input matrix.\n#\n# Example usage:\n# >>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n# 15\n# >>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n# 9", "canonical_solution": "proc maxSubArray {array} {\nset maxSoFar [lindex $array 0]\nset maxEndingHere [lindex $array 0]\n\nforeach x [lrange $array 1 end] {\nset maxEndingHere [expr {$maxEndingHere > 0 ? $maxEndingHere + $x : $x}]\nset maxSoFar [expr {$maxEndingHere > $maxSoFar ? $maxEndingHere : $maxSoFar}]\n}\n\nreturn $maxSoFar\n}\n\nset maxSum -128\nset rowCount [llength $matrix]\nset colCount [llength [lindex $matrix 0]]\n\nfor {set left 0} {$left < $colCount} {incr left} {\nset temp [lrepeat $rowCount 0]\n\nfor {set right $left} {$right < $colCount} {incr right} {\nfor {set row 0} {$row < $rowCount} {incr row} {\nset tempRow [lindex $matrix $row]\nlset temp $row [expr {[lindex $temp $row] + [lindex $tempRow $right]}]\n}\n\nset tempMax [maxSubArray $temp]\nset maxSum [expr {$tempMax > $maxSum ? $tempMax : $maxSum}]\n}\n}\n\nreturn $maxSum\n}", "test": "proc check {maxSubmatrixSum} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}] \"15\" \"Test case 1\"\nassert_equal [maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}] \"9\" \"Test case 2\"\nassert_equal [maxSubmatrixSum {{1 2 3} {4 5 6} {7 8 9}}] \"45\" \"Test case 3\"\nassert_equal [maxSubmatrixSum {{-1 -2 -3} {-4 -5 -6} {-7 -8 -9}}] \"-1\" \"Test case 4\"\nassert_equal [maxSubmatrixSum {{5 -4 2} {-3 8 -1} {4 -2 6}}] \"15\" \"Test case 5\"\n}\n\n# Call the check procedure\ncheck maxSubmatrixSum", "entry_point": "maxSubmatrixSum", "signature": "proc maxSubmatrixSum {matrix} {", "docstring": "Calculates the maximum sum of a submatrix within a given matrix.\nThe matrix is represented as a list of lists, where each inner list is a row in the matrix.\nThe elements of the matrix are integers in the range [-127, 127].\nThe function returns the maximum sum of any submatrix within the input matrix.\n\nExample usage:\n>>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n15\n>>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n9", "instruction": "Write a Tcl function `proc maxSubmatrixSum {matrix} {` to solve the following problem:\nCalculates the maximum sum of a submatrix within a given matrix.\nThe matrix is represented as a list of lists, where each inner list is a row in the matrix.\nThe elements of the matrix are integers in the range [-127, 127].\nThe function returns the maximum sum of any submatrix within the input matrix.\n\nExample usage:\n>>> maxSubmatrixSum {{0 -2 -7 0} {9 2 -6 2} {-4 1 -4 1} {-1 8 0 -2}}\n15\n>>> maxSubmatrixSum {{-1 -1 -1} {-1 9 -1} {-1 -1 -1}}\n9", "level": "hard"}
{"task_id": "Tcl/36", "prompt": "proc maximize_herb_value {totalTime numHerbs herbData} {\n# Maximizes the total value of herbs that can be collected within a given time limit.\n# This function takes the total time available for collecting herbs (totalTime),\n# the number of different herbs in the cave (numHerbs), and a list of pairs\n# where each pair consists of the time required to collect a specific herb and its value (herbData).\n# The function returns the maximum total value of herbs that can be collected within the time limit.\n#\n# Example usage:\n# >>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n# 100", "canonical_solution": "# Initialize a list to store the maximum value at each time point\nset dp [list]\nfor {set i 0} {$i <= $totalTime} {incr i} {\nlappend dp 0\n}\n\n# Iterate through each herb\nforeach herb $herbData {\nset time [lindex $herb 0]\nset value [lindex $herb 1]\n\n# Update the dp list for each time point\nfor {set t $totalTime} {$t >= $time} {incr t -1} {\nlset dp $t [expr {max([lindex $dp $t], [expr {[lindex $dp [expr {$t - $time}]] + $value}])}]\n}\n}\n\n# Return the maximum value\nreturn [lindex $dp $totalTime]\n}", "test": "proc check {maximize_herb_value} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}] 100 \"Test case 1\"\nassert_equal [maximize_herb_value 50 4 {{5 10} {10 20} {20 30} {25 40}}] 80 \"Test case 2\"\nassert_equal [maximize_herb_value 30 2 {{15 10} {15 20}}] 30 \"Test case 3\"\nassert_equal [maximize_herb_value 100 5 {{10 10} {20 20} {30 30} {40 40} {50 50}}] 100 \"Test case 4\"\nassert_equal [maximize_herb_value 75 3 {{25 35} {30 40} {20 25}}] 100 \"Test case 5\"\nassert_equal [maximize_herb_value 80 4 {{10 15} {20 25} {30 35} {40 45}}] 95 \"Test case 6\"\n}\n\n# Call the check procedure\ncheck maximize_herb_value", "entry_point": "maximize_herb_value", "signature": "proc maximize_herb_value {totalTime numHerbs herbData} {", "docstring": "Maximizes the total value of herbs that can be collected within a given time limit.\nThis function takes the total time available for collecting herbs (totalTime),\nthe number of different herbs in the cave (numHerbs), and a list of pairs\nwhere each pair consists of the time required to collect a specific herb and its value (herbData).\nThe function returns the maximum total value of herbs that can be collected within the time limit.\n\nExample usage:\n>>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n100", "instruction": "Write a Tcl function `proc maximize_herb_value {totalTime numHerbs herbData} {` to solve the following problem:\nMaximizes the total value of herbs that can be collected within a given time limit.\nThis function takes the total time available for collecting herbs (totalTime),\nthe number of different herbs in the cave (numHerbs), and a list of pairs\nwhere each pair consists of the time required to collect a specific herb and its value (herbData).\nThe function returns the maximum total value of herbs that can be collected within the time limit.\n\nExample usage:\n>>> maximize_herb_value 60 3 {{10 10} {20 40} {30 50}}\n100", "level": "hard"}
{"task_id": "Tcl/37", "prompt": "proc count_prime_sums {n k numbers} {\n# This function counts the number of ways to select k integers from a list of n integers\n# such that their sum is a prime number.\n# The inputs are the total number of integers (n), the number of integers to be selected (k),\n# and a list of integers (numbers).\n# The function returns the count of combinations whose sum is a prime number.\n#\n# Example usage:\n# >>> count_prime_sums 5 3 {2 3 5 7 11}\n# 2\n# >>> count_prime_sums 4 2 {4 6 8 9}\n# 2", "canonical_solution": "set count 0\nforeach combination [combine $numbers $k] {\nset sum [expr [join $combination +]]\nif {[is_prime $sum]} {incr count}\n}\nreturn $count\n}\nproc is_prime {num} {\nif {$num <= 1} {return 0}\nset limit [expr {int(sqrt($num))}]\nfor {set i 2} {$i <= $limit} {incr i} {\nif {$num % $i == 0} {return 0}\n}\nreturn 1\n}\n\nproc combine {lst k} {\nif {$k == 0} {return {{}}}\nif {[llength $lst] == 0} {return {}}\nset result {}\nforeach x $lst {\nforeach y [combine [lreplace $lst 0 0] [expr {$k - 1}]] {\nlappend result [concat $x $y]\n}\nset lst [lrange $lst 1 end]\n}\nreturn $result\n}", "test": "proc check {count_prime_sums} {\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\nassert_equal [count_prime_sums 5 3 {2 3 5 7 11}] 2 \"Test case 1\"\nassert_equal [count_prime_sums 4 2 {4 6 8 9}] 2 \"Test case 2\"\nassert_equal [count_prime_sums 6 4 {1 3 5 7 9 11}] 0 \"Test case 3\"\nassert_equal [count_prime_sums 3 2 {2 5 6}] 2 \"Test case 4\"\nassert_equal [count_prime_sums 4 3 {10 12 14 15}] 2 \"Test case 5\"\n}\n\ncheck count_prime_sums", "entry_point": "count_prime_sums", "signature": "proc count_prime_sums {n k numbers} {", "docstring": "This function counts the number of ways to select k integers from a list of n integers\nsuch that their sum is a prime number.\nThe inputs are the total number of integers (n), the number of integers to be selected (k),\nand a list of integers (numbers).\nThe function returns the count of combinations whose sum is a prime number.\n\nExample usage:\n>>> count_prime_sums 5 3 {2 3 5 7 11}\n2\n>>> count_prime_sums 4 2 {4 6 8 9}\n2", "instruction": "Write a Tcl function `proc count_prime_sums {n k numbers} {` to solve the following problem:\nThis function counts the number of ways to select k integers from a list of n integers\nsuch that their sum is a prime number.\nThe inputs are the total number of integers (n), the number of integers to be selected (k),\nand a list of integers (numbers).\nThe function returns the count of combinations whose sum is a prime number.\n\nExample usage:\n>>> count_prime_sums 5 3 {2 3 5 7 11}\n2\n>>> count_prime_sums 4 2 {4 6 8 9}\n2", "level": "hard"}
{"task_id": "Tcl/38", "prompt": "proc remove_duplicates_and_sort {numbers} {\n# This function takes a list of integers and performs two main tasks:\n# 1. Removes duplicate numbers.\n# 2. Sorts the remaining numbers in ascending order.\n# The function returns a list containing the count of unique numbers followed by the sorted unique numbers.\n#\n# Example usage:\n# >>> remove_duplicates_and_sort {20 40 32 67 40 20 89 300 400 15}\n# 8 15 20 32 40 67 89 300 400\n# >>> remove_duplicates_and_sort {5 1 2 2 4 5}\n# 4 1 2 4 5", "canonical_solution": "set number_set [lsort -unique -integer $numbers]\n\n# Count unique numbers\nset count [llength $number_set]\n\n# Return count and sorted unique numbers\nreturn [list $count {*}$number_set]\n}", "test": "proc test_remove_duplicates_and_sort {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual ne $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [remove_duplicates_and_sort {20 40 32 67 40 20 89 300 400 15}] \"8 15 20 32 40 67 89 300 400\" \"Test case 1\"\nassert_equal [remove_duplicates_and_sort {5 1 2 2 4 5}] \"4 1 2 4 5\" \"Test case 2\"\nassert_equal [remove_duplicates_and_sort {3 3 3 3}] \"1 3\" \"Test case 3\"\nassert_equal [remove_duplicates_and_sort {10 9 8 7 6 5 4 3 2 1}] \"10 1 2 3 4 5 6 7 8 9 10\" \"Test case 4\"\nassert_equal [remove_duplicates_and_sort {100 200 300 200 100}] \"3 100 200 300\" \"Test case 5\"\n}\n\n# Call the test procedure\ntest_remove_duplicates_and_sort", "entry_point": "remove_duplicates_and_sort", "signature": "proc remove_duplicates_and_sort {numbers} {", "docstring": "This function takes a list of integers and performs two main tasks:\n1. Removes duplicate numbers.\n2. Sorts the remaining numbers in ascending order.\nThe function returns a list containing the count of unique numbers followed by the sorted unique numbers.\n\nExample usage:\n>>> remove_duplicates_and_sort {20 40 32 67 40 20 89 300 400 15}\n8 15 20 32 40 67 89 300 400\n>>> remove_duplicates_and_sort {5 1 2 2 4 5}\n4 1 2 4 5", "instruction": "Write a Tcl function `proc remove_duplicates_and_sort {numbers} {` to solve the following problem:\nThis function takes a list of integers and performs two main tasks:\n1. Removes duplicate numbers.\n2. Sorts the remaining numbers in ascending order.\nThe function returns a list containing the count of unique numbers followed by the sorted unique numbers.\n\nExample usage:\n>>> remove_duplicates_and_sort {20 40 32 67 40 20 89 300 400 15}\n8 15 20 32 40 67 89 300 400\n>>> remove_duplicates_and_sort {5 1 2 2 4 5}\n4 1 2 4 5", "level": "easy"}
{"task_id": "Tcl/39", "prompt": "proc maximize_value {n m item_list} {\n# This function calculates the maximum value achievable within a given budget when purchasing a set of items,\n# each with its own price and importance. The value of an item is its price multiplied by its importance.\n# The function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n# \n# Args:\n# n (int): The total money available.\n# m (int): The number of items available for purchase.\n# item_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n#\n# Returns:\n# int: The maximum total value of the items that can be purchased without exceeding the budget.\n#\n# Example usage:\n# >>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n# 3900", "canonical_solution": "set dp [list]\nfor {set i 0} {$i <= $n} {incr i} {\nlappend dp 0\n}\n\n# Iterate over each item\nforeach item $item_list {\nset price [lindex $item 0]\nset importance [lindex $item 1]\n\n# Update the dp list in reverse to avoid overwriting needed values\nfor {set j $n} {$j >= $price} {incr j -1} {\n# Calculate the new value if this item is included\nset newValue [expr {[lindex $dp [expr {$j - $price}]] + $price * $importance}]\n\n# Update the dp value if newValue is better\nif {$newValue > [lindex $dp $j]} {\nlset dp $j $newValue\n}\n}\n}\n\nreturn [lindex $dp $n]\n}", "test": "proc check_maximize_value {} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}] 3900 \"Test case 1\"\nassert_equal [maximize_value 500 3 {{300 4} {200 3} {100 2}}] 1800 \"Test case 2\"\nassert_equal [maximize_value 200 2 {{100 1} {50 2}}] 200 \"Test case 3\"\nassert_equal [maximize_value 700 4 {{350 3} {200 2} {100 5} {50 2}}] 2050 \"Test case 4\"\nassert_equal [maximize_value 1500 6 {{500 5} {400 4} {300 3} {200 2} {100 1} {50 1}}] 5500 \"Test case 5\"\n}\n\n# Call the check procedure\ncheck_maximize_value", "entry_point": "maximize_value", "signature": "proc maximize_value {n m item_list} {", "docstring": "This function calculates the maximum value achievable within a given budget when purchasing a set of items,\neach with its own price and importance. The value of an item is its price multiplied by its importance.\nThe function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n\nArgs:\nn (int): The total money available.\nm (int): The number of items available for purchase.\nitem_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n\nReturns:\nint: The maximum total value of the items that can be purchased without exceeding the budget.\n\nExample usage:\n>>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n3900", "instruction": "Write a Tcl function `proc maximize_value {n m item_list} {` to solve the following problem:\nThis function calculates the maximum value achievable within a given budget when purchasing a set of items,\neach with its own price and importance. The value of an item is its price multiplied by its importance.\nThe function uses dynamic programming to solve this variation of the 0/1 knapsack problem.\n\nArgs:\nn (int): The total money available.\nm (int): The number of items available for purchase.\nitem_list (list of lists): A list where each element is a list of two integers [price, importance] of an item.\n\nReturns:\nint: The maximum total value of the items that can be purchased without exceeding the budget.\n\nExample usage:\n>>> maximize_value 1000 5 {{800 2} {400 5} {300 5} {400 3} {200 2}}\n3900", "level": "hard"}
{"task_id": "Tcl/40", "prompt": "proc max_subsequence_sum {sequence} {\n# Calculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\n# The input is a list of integers, which can include both positive and negative values.\n# The function returns the maximum sum of any such subsequence.\n#\n# Example usage:\n# >>> max_subsequence_sum {2 -1 3 4 -2}\n# 8\n# >>> max_subsequence_sum {-3 -2 -1 -4}\n# -1", "canonical_solution": "set max_so_far [lindex $sequence 0]\nset max_ending_here 0\n\nforeach i $sequence {\nset max_ending_here [expr {$max_ending_here + $i}]\nif {$max_so_far < $max_ending_here} {\nset max_so_far $max_ending_here\n}\nif {$max_ending_here < 0} {\nset max_ending_here 0\n}\n}\n\nreturn $max_so_far\n}", "test": "proc check {max_subsequence_sum} {\n# Test case utility\nproc assert_equal {actual expected message} {\nif {$actual != $expected} {\nerror \"$message. Expected $expected but got $actual\"\n} else {\nputs \"$message - Passed\"\n}\n}\n\n# Test cases\nassert_equal [max_subsequence_sum {2 -1 3 4 -2}] \"8\" \"Test case 1\"\nassert_equal [max_subsequence_sum {-3 -2 -1 -4}] \"-1\" \"Test case 2\"\nassert_equal [max_subsequence_sum {1 -2 3 10 -4 7 -2 5}] \"19\" \"Test case 3\"\nassert_equal [max_subsequence_sum {-1 -2 -3 -4}] \"-1\" \"Test case 4\"\nassert_equal [max_subsequence_sum {1 2 3 4 5 -10 5 4 3 2 1}] \"20\" \"Test case 5\"\n}\n\n# Call the check procedure\ncheck max_subsequence_sum", "entry_point": "max_subsequence_sum", "signature": "proc max_subsequence_sum {sequence} {", "docstring": "Calculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\nThe input is a list of integers, which can include both positive and negative values.\nThe function returns the maximum sum of any such subsequence.\n\nExample usage:\n>>> max_subsequence_sum {2 -1 3 4 -2}\n8\n>>> max_subsequence_sum {-3 -2 -1 -4}\n-1", "instruction": "Write a Tcl function `proc max_subsequence_sum {sequence} {` to solve the following problem:\nCalculates the maximum sum of a continuous and non-empty subsequence in a given sequence.\nThe input is a list of integers, which can include both positive and negative values.\nThe function returns the maximum sum of any such subsequence.\n\nExample usage:\n>>> max_subsequence_sum {2 -1 3 4 -2}\n8\n>>> max_subsequence_sum {-3 -2 -1 -4}\n-1", "level": "easy"}
{"task_id": "Tcl/41", "prompt": "proc calculate_expression_value {a b c} {\n    # This function calculates the value of the expression (a + b) * c.\n    # \n    # Args:\n    #   a (int): The first integer.\n    #   b (int): The second integer.\n    #   c (int): The third integer.\n    # \n    # Returns:\n    #   int: The value of the expression (a + b) * c.\n    #\n    # Example usage:\n    #   calculate_expression_value 2 3 5\n    #   Output: 25", "canonical_solution": "    return [expr {($a + $b) * $c}]\n}", "test": "proc test_calculate_expression_value {} {\n    # Test case utility\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [calculate_expression_value 2 3 5] 25 \"Test case 1\"\n    assert_equal [calculate_expression_value 10 20 3] 90 \"Test case 2\"\n    assert_equal [calculate_expression_value -4 7 2] 6 \"Test case 3\"\n    assert_equal [calculate_expression_value 0 0 0] 0 \"Test case 4\"\n    assert_equal [calculate_expression_value 10000 -9999 2] 2 \"Test case 5\"\n}\n\n# Call the test procedure\ntest_calculate_expression_value", "entry_point": "calculate_expression_value", "signature": "proc calculate_expression_value {a b c} {", "docstring": " This function calculates the value of the expression (a + b) * c.\n\nArgs:\n  a (int): The first integer.\n  b (int): The second integer.\n  c (int): The third integer.\n\nReturns:\n  int: The value of the expression (a + b) * c.\n    \nExample usage:\n  calculate_expression_value 2 3 5\n  Output: 25", "instruction": "Write a Tcl function `proc calculate_expression_value {a b c} {` to solve the following problem: This function calculates the value of the expression (a + b) * c.\n\nArgs:\n  a (int): The first integer.\n  b (int): The second integer.\n  c (int): The third integer.\n\nReturns:\n  int: The value of the expression (a + b) * c.\n    \nExample usage:\n  calculate_expression_value 2 3 5\n  Output: 25", "level": "easy"}
{"task_id": "Tcl/42", "prompt": "proc char_to_ascii {char} {\n    # Converts a given visible character (excluding space) to its ASCII code.\n    # This function takes a single character as input (ensure it's not a space or control character) and returns its ASCII code as an integer.\n    # The conversion leverages Tcl's built-in string to ASCII conversion capabilities.\n    # \n    # Args:\n    #   char (string): A single character for which the ASCII code is desired.\n    # \n    # Returns:\n    #   int: The ASCII code of the provided character.\n    # \n    # Example usage:\n    # >>> char_to_ascii \"A\"\n    # 65\n    # >>> char_to_ascii \"a\"\n    # 97\n    # >>> char_to_ascii \"0\"\n    # 48", "canonical_solution": "    return [scan $char %c]\n}", "test": "proc check_char_to_ascii {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [char_to_ascii \"A\"] 65 \"Test case 1: 'A' to ASCII\"\n    assert_equal [char_to_ascii \"a\"] 97 \"Test case 2: 'a' to ASCII\"\n    assert_equal [char_to_ascii \"0\"] 48 \"Test case 3: '0' to ASCII\"\n    assert_equal [char_to_ascii \"@\"] 64 \"Test case 4: '@' to ASCII\"\n}\n\ncheck_char_to_ascii", "entry_point": "char_to_ascii", "signature": "proc char_to_ascii {char} {", "docstring": " Converts a given visible character (excluding space) to its ASCII code.\nThis function takes a single character as input (ensure it's not a space or control character) and returns its ASCII code as an integer.\nThe conversion leverages Tcl's built-in string to ASCII conversion capabilities.\n\nArgs:\n  char (string): A single character for which the ASCII code is desired.\n\nReturns:\n  int: The ASCII code of the provided character.\n\nExample usage:\n>>> char_to_ascii \"A\"\n65\n>>> char_to_ascii \"a\"\n97\n>>> char_to_ascii \"0\"\n48", "instruction": "Write a Tcl function `proc char_to_ascii {char} {` to solve the following problem: Converts a given visible character (excluding space) to its ASCII code.\nThis function takes a single character as input (ensure it's not a space or control character) and returns its ASCII code as an integer.\nThe conversion leverages Tcl's built-in string to ASCII conversion capabilities.\n\nArgs:\n  char (string): A single character for which the ASCII code is desired.\n\nReturns:\n  int: The ASCII code of the provided character.\n\nExample usage:\n>>> char_to_ascii \"A\"\n65\n>>> char_to_ascii \"a\"\n97\n>>> char_to_ascii \"0\"\n48", "level": "easy"}
{"task_id": "Tcl/43", "prompt": "proc ascii_to_char {ascii_code} {\n    # Converts an ASCII code to its corresponding character.\n    # This function takes an integer representing an ASCII code (ensuring it's within the range of visible characters, i.e., >0 and <128) and returns the character associated with that code.\n    # The function demonstrates the use of Tcl's built-in command to convert ASCII codes to characters.\n    # \n    # Args:\n    #   ascii_code (int): The ASCII code to be converted.\n    # \n    # Returns:\n    #   string: The character corresponding to the ASCII code.\n    # \n    # Example usage:\n    # >>> ascii_to_char 65\n    # A\n    # >>> ascii_to_char 97\n    # a\n    # >>> ascii_to_char 48\n    # 0", "canonical_solution": "    return [format %c $ascii_code]\n}", "test": "proc check_ascii_to_char {} {\n    proc assert_equal {actual expected message} {\n        if {$actual ne $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [ascii_to_char 65] \"A\" \"Test case 1: ASCII to char for 65\"\n    assert_equal [ascii_to_char 97] \"a\" \"Test case 2: ASCII to char for 97\"\n    assert_equal [ascii_to_char 48] \"0\" \"Test case 3: ASCII to char for 48\"\n    assert_equal [ascii_to_char 64] \"@\" \"Test case 4: ASCII to char for 64\"\n}\n\ncheck_ascii_to_char", "entry_point": "ascii_to_char", "signature": "proc ascii_to_char {ascii_code} {", "docstring": " Converts an ASCII code to its corresponding character.\nThis function takes an integer representing an ASCII code (ensuring it's within the range of visible characters, i.e., >0 and <128) and returns the character associated with that code.\nThe function demonstrates the use of Tcl's built-in command to convert ASCII codes to characters.\n\nArgs:\n  ascii_code (int): The ASCII code to be converted.\n\nReturns:\n  string: The character corresponding to the ASCII code.\n\nExample usage:\n>>> ascii_to_char 65\nA\n>>> ascii_to_char 97\na\n>>> ascii_to_char 48\n0", "instruction": "Write a Tcl function `proc ascii_to_char {ascii_code} {` to solve the following problem: Converts an ASCII code to its corresponding character.\nThis function takes an integer representing an ASCII code (ensuring it's within the range of visible characters, i.e., >0 and <128) and returns the character associated with that code.\nThe function demonstrates the use of Tcl's built-in command to convert ASCII codes to characters.\n\nArgs:\n  ascii_code (int): The ASCII code to be converted.\n\nReturns:\n  string: The character corresponding to the ASCII code.\n\nExample usage:\n>>> ascii_to_char 65\nA\n>>> ascii_to_char 97\na\n>>> ascii_to_char 48\n0", "level": "easy"}
{"task_id": "Tcl/44", "prompt": "proc int_to_bool_to_int {int_value} {\n    # Converts an integer to a boolean and then back to an integer.\n    # This function demonstrates the conversion of an integer value to a boolean value and then back to an integer in Tcl. In Tcl,\n    # non-zero values are considered true (1), and zero is considered false (0). This function returns 1 for any non-zero integer input\n    # and 0 for zero input.\n    # \n    # Args:\n    #   int_value (int): The integer value to be converted.\n    # \n    # Returns:\n    #   int: The integer value after conversion to boolean and back to integer, which will be 1 for any non-zero input and 0 otherwise.\n    # \n    # Example usage:\n    # >>> int_to_bool_to_int 3\n    # 1\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1", "canonical_solution": "    set bool_value [expr {$int_value != 0}]\n    return $bool_value\n}", "test": "proc check_int_to_bool_to_int {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [int_to_bool_to_int 3] 1 \"Test case 1: Integer 3 to Boolean and back\"\n    assert_equal [int_to_bool_to_int 0] 0 \"Test case 2: Integer 0 to Boolean and back\"\n    assert_equal [int_to_bool_to_int -5] 1 \"Test case 3: Integer -5 to Boolean and back\"\n    assert_equal [int_to_bool_to_int 100] 1 \"Test case 4: Integer 100 to Boolean and back\"\n    assert_equal [int_to_bool_to_int -100] 1 \"Test case 5: Integer -100 to Boolean and back\"\n}\n\ncheck_int_to_bool_to_int", "entry_point": "int_to_bool_to_int", "signature": "proc int_to_bool_to_int {int_value} {", "docstring": " Converts an integer to a boolean and then back to an integer.\nThis function demonstrates the conversion of an integer value to a boolean value and then back to an integer in Tcl. In Tcl,\nnon-zero values are considered true (1), and zero is considered false (0). This function returns 1 for any non-zero integer input\nand 0 for zero input.\n\nArgs:\n  int_value (int): The integer value to be converted.\n\nReturns:\n  int: The integer value after conversion to boolean and back to integer, which will be 1 for any non-zero input and 0 otherwise.\n\nExample usage:\n>>> int_to_bool_to_int 3\n1\n>>> int_to_bool_to_int 0\n0\n>>> int_to_bool_to_int -5\n1", "instruction": "Write a Tcl function `proc int_to_bool_to_int {int_value} {` to solve the following problem: Converts an integer to a boolean and then back to an integer.\nThis function demonstrates the conversion of an integer value to a boolean value and then back to an integer in Tcl. In Tcl,\nnon-zero values are considered true (1), and zero is considered false (0). This function returns 1 for any non-zero integer input\nand 0 for zero input.\n\nArgs:\n  int_value (int): The integer value to be converted.\n\nReturns:\n  int: The integer value after conversion to boolean and back to integer, which will be 1 for any non-zero input and 0 otherwise.\n\nExample usage:\n>>> int_to_bool_to_int 3\n1\n>>> int_to_bool_to_int 0\n0\n>>> int_to_bool_to_int -5\n1", "level": "easy"}
{"task_id": "Tcl/45", "prompt": "proc reverse_three_digit_number {n} {\n    # Reverses a three-digit number.\n    # This function takes a three-digit integer as input and returns its reversal. The reversal should consider leading zeros, \n    # meaning that if the input is '100', the output should be '001'. This process highlights the handling of numbers as strings \n    # for manipulation and then converting them back to numbers if necessary.\n    # \n    # Args:\n    #   n (int): A three-digit integer to be reversed.\n    # \n    # Returns:\n    #   string: The reversed number as a string to preserve any leading zeros in the output.\n    # \n    # Example usage:\n    # >>> reverse_three_digit_number 358\n    # '853'\n    # >>> reverse_three_digit_number 100\n    # '001'\n    # >>> reverse_three_digit_number 20 # Conceptually, this should be entered as '020'\n    # '020'", "canonical_solution": "    set n_str [format %03d $n]\n    set reversed [string reverse $n_str]\n    return $reversed\n}", "test": "proc check_reverse_three_digit_number {} {\n    proc assert_equal {actual expected message} {\n        if {$actual ne $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [reverse_three_digit_number 358] \"853\" \"Test case 1: Reverse of 358\"\n    assert_equal [reverse_three_digit_number 100] \"001\" \"Test case 2: Reverse of 100\"\n    assert_equal [reverse_three_digit_number 20] \"020\" \"Test case 3: Reverse of 020\"\n    assert_equal [reverse_three_digit_number 678] \"876\" \"Test case 4: Reverse of 678\"\n    assert_equal [reverse_three_digit_number 1] \"100\" \"Test case 5: Reverse of 001\"\n}\n\ncheck_reverse_three_digit_number", "entry_point": "reverse_three_digit_number", "signature": "proc reverse_three_digit_number {n} {", "docstring": " Reverses a three-digit number.\nThis function takes a three-digit integer as input and returns its reversal. The reversal should consider leading zeros, \nmeaning that if the input is '100', the output should be '001'. This process highlights the handling of numbers as strings \nfor manipulation and then converting them back to numbers if necessary.\n\nArgs:\n  n (int): A three-digit integer to be reversed.\n\nReturns:\n  string: The reversed number as a string to preserve any leading zeros in the output.\n\nExample usage:\n>>> reverse_three_digit_number 358\n'853'\n>>> reverse_three_digit_number 100\n'001'\n>>> reverse_three_digit_number 20  Conceptually, this should be entered as '020'\n'020'", "instruction": "Write a Tcl function `proc reverse_three_digit_number {n} {` to solve the following problem: Reverses a three-digit number.\nThis function takes a three-digit integer as input and returns its reversal. The reversal should consider leading zeros, \nmeaning that if the input is '100', the output should be '001'. This process highlights the handling of numbers as strings \nfor manipulation and then converting them back to numbers if necessary.\n\nArgs:\n  n (int): A three-digit integer to be reversed.\n\nReturns:\n  string: The reversed number as a string to preserve any leading zeros in the output.\n\nExample usage:\n>>> reverse_three_digit_number 358\n'853'\n>>> reverse_three_digit_number 100\n'001'\n>>> reverse_three_digit_number 20  Conceptually, this should be entered as '020'\n'020'", "level": "easy"}
{"task_id": "Tcl/46", "prompt": "proc calculate_nth_term {a1 a2 n} {\n    # Calculates the nth term of an arithmetic sequence given the first two terms and the term's position.\n    # This function uses the formula for finding the nth term of an arithmetic sequence, which is a_n = a_1 + (n-1)d,\n    # where d is the common difference (a2 - a1), a_1 is the first term, and n is the term position.\n    #\n    # Args:\n    #   a1 (int): The first term of the arithmetic sequence.\n    #   a2 (int): The second term of the arithmetic sequence, used to calculate the common difference.\n    #   n (int): The position of the term in the sequence to calculate.\n    #\n    # Returns:\n    #   int: The value of the nth term in the sequence.\n    #\n    # Example usage:\n    # >>> calculate_nth_term 1 4 100\n    # 298\n    # >>> calculate_nth_term 5 7 10\n    # 23\n    # >>> calculate_nth_term -1 1 50\n    # 97", "canonical_solution": "    set d [expr {$a2 - $a1}] ;# Calculate the common difference\n    set an [expr {$a1 + ($n - 1) * $d}] ;# Calculate the nth term\n    return $an\n}", "test": "proc check_calculate_nth_term {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [calculate_nth_term 1 4 100] 298 \"Test case 1: nth term for 1, 4, 100\"\n    assert_equal [calculate_nth_term 5 7 10] 23 \"Test case 2: nth term for 5, 7, 10\"\n    assert_equal [calculate_nth_term -1 1 50] 97 \"Test case 3: nth term for -1, 1, 50\"\n    assert_equal [calculate_nth_term 2 5 20] 59 \"Test case 4: nth term for 2, 5, 20\"\n    assert_equal [calculate_nth_term 0 2 100] 198 \"Test case 5: nth term for 0, 2, 100\"\n}\n\ncheck_calculate_nth_term", "entry_point": "calculate_nth_term", "signature": "proc calculate_nth_term {a1 a2 n} {", "docstring": " Calculates the nth term of an arithmetic sequence given the first two terms and the term's position.\nThis function uses the formula for finding the nth term of an arithmetic sequence, which is a_n = a_1 + (n-1)d,\nwhere d is the common difference (a2 - a1), a_1 is the first term, and n is the term position.\n    \nArgs:\n  a1 (int): The first term of the arithmetic sequence.\n  a2 (int): The second term of the arithmetic sequence, used to calculate the common difference.\n  n (int): The position of the term in the sequence to calculate.\n    \nReturns:\n  int: The value of the nth term in the sequence.\n    \nExample usage:\n>>> calculate_nth_term 1 4 100\n298\n>>> calculate_nth_term 5 7 10\n23\n>>> calculate_nth_term -1 1 50\n97", "instruction": "Write a Tcl function `proc calculate_nth_term {a1 a2 n} {` to solve the following problem: Calculates the nth term of an arithmetic sequence given the first two terms and the term's position.\nThis function uses the formula for finding the nth term of an arithmetic sequence, which is a_n = a_1 + (n-1)d,\nwhere d is the common difference (a2 - a1), a_1 is the first term, and n is the term position.\n    \nArgs:\n  a1 (int): The first term of the arithmetic sequence.\n  a2 (int): The second term of the arithmetic sequence, used to calculate the common difference.\n  n (int): The position of the term in the sequence to calculate.\n    \nReturns:\n  int: The value of the nth term in the sequence.\n    \nExample usage:\n>>> calculate_nth_term 1 4 100\n298\n>>> calculate_nth_term 5 7 10\n23\n>>> calculate_nth_term -1 1 50\n97", "level": "easy"}
{"task_id": "Tcl/47", "prompt": "proc multiply {A B} {\n    # Multiplies two positive integers A and B, and returns their product.\n    # This function takes two integers A and B as input, where both are positive and their values range from 1 to 50,000.\n    # It returns the product of A and B. Care should be taken to ensure that the product does not exceed the maximum integer value \n    # supported by Tcl, although in this specified range, that is not a concern.\n    #\n    # Args:\n    #   A (int): The first positive integer.\n    #   B (int): The second positive integer.\n    #\n    # Returns:\n    #   int: The product of A and B.\n    #\n    # Example usage:\n    # >>> multiply 3 4\n    # 12\n    # >>> multiply 36 18\n    # 648\n    # >>> multiply 1 50000\n    # 50000", "canonical_solution": "    return [expr {$A * $B}]\n}", "test": "proc check_multiply {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [multiply 3 4] 12 \"Test case 1: Multiplying 3 and 4\"\n    assert_equal [multiply 36 18] 648 \"Test case 2: Multiplying 36 and 18\"\n    assert_equal [multiply 1 50000] 50000 \"Test case 3: Multiplying 1 and 50000\"\n    assert_equal [multiply 123 456] 56088 \"Test case 4: Multiplying 123 and 456\"\n    assert_equal [multiply 500 100] 50000 \"Test case 5: Multiplying 500 and 100\"\n}\n\ncheck_multiply", "entry_point": "multiply", "signature": "proc multiply {A B} {", "docstring": " Multiplies two positive integers A and B, and returns their product.\nThis function takes two integers A and B as input, where both are positive and their values range from 1 to 50,000.\nIt returns the product of A and B. Care should be taken to ensure that the product does not exceed the maximum integer value \nsupported by Tcl, although in this specified range, that is not a concern.\n    \nArgs:\n  A (int): The first positive integer.\n  B (int): The second positive integer.\n    \nReturns:\n  int: The product of A and B.\n    \nExample usage:\n>>> multiply 3 4\n12\n>>> multiply 36 18\n648\n>>> multiply 1 50000\n50000", "instruction": "Write a Tcl function `proc multiply {A B} {` to solve the following problem: Multiplies two positive integers A and B, and returns their product.\nThis function takes two integers A and B as input, where both are positive and their values range from 1 to 50,000.\nIt returns the product of A and B. Care should be taken to ensure that the product does not exceed the maximum integer value \nsupported by Tcl, although in this specified range, that is not a concern.\n    \nArgs:\n  A (int): The first positive integer.\n  B (int): The second positive integer.\n    \nReturns:\n  int: The product of A and B.\n    \nExample usage:\n>>> multiply 3 4\n12\n>>> multiply 36 18\n648\n>>> multiply 1 50000\n50000", "level": "easy"}
{"task_id": "Tcl/48", "prompt": "proc power_of_two {n} {\n    # Calculates 2 raised to the power of n.\n    # This function takes a non-negative integer n (where 0 <= n < 31) as input and returns 2 to the power of n. The calculation \n    # is straightforward, leveraging Tcl's built-in command to perform the exponential calculation.\n    #\n    # Args:\n    #   n (int): The exponent to raise 2 to, where n is a non-negative integer less than 31.\n    #\n    # Returns:\n    #   int: The result of 2 raised to the power of n.\n    #\n    # Example usage:\n    # >>> power_of_two 3\n    # 8\n    # >>> power_of_two 10\n    # 1024\n    # >>> power_of_two 0\n    # 1", "canonical_solution": "    return [expr {2 ** $n}]\n}", "test": "proc check_power_of_two {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [power_of_two 3] 8 \"Test case 1: 2^3\"\n    assert_equal [power_of_two 10] 1024 \"Test case 2: 2^10\"\n    assert_equal [power_of_two 0] 1 \"Test case 3: 2^0\"\n    assert_equal [power_of_two 5] 32 \"Test case 4: 2^5\"\n    assert_equal [power_of_two 15] 32768 \"Test case 5: 2^15\"\n}\n\ncheck_power_of_two", "entry_point": "power_of_two", "signature": "proc power_of_two {n} {", "docstring": " Calculates 2 raised to the power of n.\nThis function takes a non-negative integer n (where 0 <= n < 31) as input and returns 2 to the power of n. The calculation \nis straightforward, leveraging Tcl's built-in command to perform the exponential calculation.\n    \nArgs:\n  n (int): The exponent to raise 2 to, where n is a non-negative integer less than 31.\n    \nReturns:\n  int: The result of 2 raised to the power of n.\n    \nExample usage:\n>>> power_of_two 3\n8\n>>> power_of_two 10\n1024\n>>> power_of_two 0\n1", "instruction": "Write a Tcl function `proc power_of_two {n} {` to solve the following problem: Calculates 2 raised to the power of n.\nThis function takes a non-negative integer n (where 0 <= n < 31) as input and returns 2 to the power of n. The calculation \nis straightforward, leveraging Tcl's built-in command to perform the exponential calculation.\n    \nArgs:\n  n (int): The exponent to raise 2 to, where n is a non-negative integer less than 31.\n    \nReturns:\n  int: The result of 2 raised to the power of n.\n    \nExample usage:\n>>> power_of_two 3\n8\n>>> power_of_two 10\n1024\n>>> power_of_two 0\n1", "level": "easy"}
{"task_id": "Tcl/49", "prompt": "proc determine_sign {N} {\n    # Determines the sign of a given integer N.\n    # This function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\n    # It uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    #\n    # Args:\n    #   N (int): The integer whose sign is to be determined.\n    #\n    # Returns:\n    #   string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    #\n    # Example usage:\n    # >>> determine_sign 95\n    # 'positive'\n    # >>> determine_sign 0\n    # 'zero'\n    # >>> determine_sign -10\n    # 'negative'", "canonical_solution": "    if {$N > 0} {\n        return \"positive\"\n    } elseif {$N == 0} {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}", "test": "proc check_determine_sign {} {\n    proc assert_equal {actual expected message} {\n        if {$actual ne $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [determine_sign 95] \"positive\" \"Test case 1: Determining sign for 95\"\n    assert_equal [determine_sign 0] \"zero\" \"Test case 2: Determining sign for 0\"\n    assert_equal [determine_sign -10] \"negative\" \"Test case 3: Determining sign for -10\"\n    assert_equal [determine_sign 1] \"positive\" \"Test case 4: Determining sign for 1\"\n    assert_equal [determine_sign -1] \"negative\" \"Test case 5: Determining sign for -1\"\n}\n\ncheck_determine_sign", "entry_point": "determine_sign", "signature": "proc determine_sign {N} {", "docstring": " Determines the sign of a given integer N.\nThis function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\nIt uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    \nArgs:\n  N (int): The integer whose sign is to be determined.\n    \nReturns:\n  string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    \nExample usage:\n>>> determine_sign 95\n'positive'\n>>> determine_sign 0\n'zero'\n>>> determine_sign -10\n'negative'", "instruction": "Write a Tcl function `proc determine_sign {N} {` to solve the following problem: Determines the sign of a given integer N.\nThis function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\nIt uses conditional statements to compare the integer against zero and determine its sign accordingly.\n    \nArgs:\n  N (int): The integer whose sign is to be determined.\n    \nReturns:\n  string: 'positive' if N > 0, 'zero' if N == 0, and 'negative' if N < 0.\n    \nExample usage:\n>>> determine_sign 95\n'positive'\n>>> determine_sign 0\n'zero'\n>>> determine_sign -10\n'negative'", "level": "easy"}
{"task_id": "Tcl/50", "prompt": "proc calculate_absolute_value {n} {\n    # Calculates the absolute value of an integer n.\n    # This function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\n    # The absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    #\n    # Args:\n    #   n (int): An integer whose absolute value is to be calculated.\n    #\n    # Returns:\n    #   int: The absolute value of n.\n    #\n    # Example usage:\n    # >>> calculate_absolute_value -3\n    # 3\n    # >>> calculate_absolute_value 5\n    # 5\n    # >>> calculate_absolute_value 0\n    # 0", "canonical_solution": "    if {$n < 0} {\n        return [expr {-$n}]\n    } else {\n        return $n\n    }\n}", "test": "proc check_calculate_absolute_value {} {\n    proc assert_equal {actual expected message} {\n        if {$actual != $expected} {\n            error \"$message. Expected $expected but got $actual\"\n        } else {\n            puts \"$message - Passed\"\n        }\n    }\n\n    # Test cases\n    assert_equal [calculate_absolute_value -3] 3 \"Test case 1: Absolute value of -3\"\n    assert_equal [calculate_absolute_value 5] 5 \"Test case 2: Absolute value of 5\"\n    assert_equal [calculate_absolute_value 0] 0 \"Test case 3: Absolute value of 0\"\n    assert_equal [calculate_absolute_value -10000] 10000 \"Test case 4: Absolute value of -10000\"\n    assert_equal [calculate_absolute_value 10000] 10000 \"Test case 5: Absolute value of 10000\"\n}\n\ncheck_calculate_absolute_value", "entry_point": "calculate_absolute_value", "signature": "proc calculate_absolute_value {n} {", "docstring": " Calculates the absolute value of an integer n.\nThis function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\nThe absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    \nArgs:\n  n (int): An integer whose absolute value is to be calculated.\n    \nReturns:\n  int: The absolute value of n.\n    \nExample usage:\n>>> calculate_absolute_value -3\n3\n>>> calculate_absolute_value 5\n5\n>>> calculate_absolute_value 0\n0", "instruction": "Write a Tcl function `proc calculate_absolute_value {n} {` to solve the following problem: Calculates the absolute value of an integer n.\nThis function takes an integer n as input, which can be positive, negative, or zero, and returns its absolute value.\nThe absolute value of an integer is the non-negative value of that integer without regard to its sign.\n    \nArgs:\n  n (int): An integer whose absolute value is to be calculated.\n    \nReturns:\n  int: The absolute value of n.\n    \nExample usage:\n>>> calculate_absolute_value -3\n3\n>>> calculate_absolute_value 5\n5\n>>> calculate_absolute_value 0\n0", "level": "easy"}
