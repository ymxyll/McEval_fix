{"task_id": "Julia/1", "prompt": "function has_close_elements(numbers::Vector{Float64}, threshold::Float64) :: Bool\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "canonical_solution": "    for i in 1:length(numbers)\n            for j in 1:length(numbers)\n                if i != j\n                    distance = abs(numbers[i] - numbers[j])\n                    if distance < threshold\n                        return true\n                    end\n                end\n            end\n        end\n        return false\n    end", "test": "# Test cases\n@assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true\n@assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false\n@assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true\n@assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false\n@assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true\n@assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true\n@assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false", "entry_point": "has_close_elements", "signature": "function has_close_elements(numbers::Vector{Float64}, threshold::Float64) :: Bool", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "instruction": "Write a Julia function `function has_close_elements(numbers::Vector{Float64}, threshold::Float64) :: Bool` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True", "level": "easy"}
{"task_id": "Julia/2", "prompt": "function longest_common_prefix(strs::Vector{String}) :: String\n\"\"\"\nFind the longest common prefix among a vector of strings.\n\n# Examples\n- `longest_common_prefix([\"flower\", \"flow\", \"flight\"])` should return \"fl\".\n- `longest_common_prefix([\"dog\", \"racecar\", \"car\"])` should return \"\" (no common prefix).\n\"\"\"", "canonical_solution": "    if isempty(strs)\n        return \"\"\n    end\n    prefix = strs[1]\n    for str in strs\n        while startswith(str, prefix) == false\n            prefix = prefix[1:end-1]\n            if isempty(prefix)\n                return \"\"\n            end\n        end\n    end\n    return prefix\nend", "test": "# Test cases\n@assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\n@assert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\n@assert longest_common_prefix([\"interspace\", \"interstellar\", \"internet\", \"intermediate\"]) == \"inter\"\n@assert longest_common_prefix([\"apple\", \"apricot\", \"apps\"]) == \"ap\"\n@assert longest_common_prefix([\"\", \"\"]) == \"\"\n@assert longest_common_prefix([\"single\"]) == \"single\"", "entry_point": "longest_common_prefix", "signature": "function longest_common_prefix(strs::Vector{String}) :: String", "docstring": "Find the longest common prefix among a vector of strings.\n\n# Examples\n- `longest_common_prefix([\"flower\", \"flow\", \"flight\"])` should return \"fl\".\n- `longest_common_prefix([\"dog\", \"racecar\", \"car\"])` should return \"\" (no common prefix).", "instruction": "Write a Julia function `function longest_common_prefix(strs::Vector{String}) :: String` to solve the following problem:\nFind the longest common prefix among a vector of strings.\n\n# Examples\n- `longest_common_prefix([\"flower\", \"flow\", \"flight\"])` should return \"fl\".\n- `longest_common_prefix([\"dog\", \"racecar\", \"car\"])` should return \"\" (no common prefix).", "level": "easy"}
{"task_id": "Julia/3", "prompt": "function is_palindrome(number::Int) :: Bool\n\n\"\"\"\nCheck if the given integer is a palindrome. A palindrome is a number that reads the same backward as forward.\n\nExamples:\n>>> is_palindrome(121)\ntrue\n>>> is_palindrome(-121)\nfalse\n>>> is_palindrome(10)\nfalse\n\"\"\"", "canonical_solution": "    if number < 0\n        return false\n    end\n    reversed, original = 0, number\n    while number != 0\n        digit = number % 10\n        reversed = reversed * 10 + digit\n        number \u00f7= 10\n    end\n    return original == reversed\nend", "test": "# Test cases\n@assert is_palindrome(121) == true\n@assert is_palindrome(-121) == false\n@assert is_palindrome(10) == false\n@assert is_palindrome(12321) == true\n@assert is_palindrome(123321) == true\n@assert is_palindrome(123456) == false\n@assert is_palindrome(0) == true", "entry_point": "is_palindrome", "signature": "function is_palindrome(number::Int) :: Bool", "docstring": "Check if the given integer is a palindrome. A palindrome is a number that reads the same backward as forward.\n\nExamples:\n>>> is_palindrome(121)\ntrue\n>>> is_palindrome(-121)\nfalse\n>>> is_palindrome(10)\nfalse", "instruction": "Write a Julia function `function is_palindrome(number::Int) :: Bool` to solve the following problem:\nCheck if the given integer is a palindrome. A palindrome is a number that reads the same backward as forward.\n\nExamples:\n>>> is_palindrome(121)\ntrue\n>>> is_palindrome(-121)\nfalse\n>>> is_palindrome(10)\nfalse", "level": "easy"}
{"task_id": "Julia/4", "prompt": "function is_valid_brackets(s::String) :: Bool\n\n\"\"\"\n    Check if a given string of brackets is valid. A string is considered valid if \n    all types of brackets are correctly closed and in the correct order.\n    \n    # Examples\n    >>> is_valid_brackets(\"[]{}()\")\n    True\n    >>> is_valid_brackets(\"([)]\")\n    False\n    >>> is_valid_brackets(\"{[()]}\")\n    True\n    >>> is_valid_brackets(\"{{[[(())]]}}\")\n    True\n\"\"\"", "canonical_solution": "stack = []\n    bracket_map = Dict(')' => '(', ']' => '[', '}' => '{')\n\n    for char in s\n        if char in keys(bracket_map)\n            if isempty(stack) || pop!(stack) != bracket_map[char]\n                return false\n            end\n        else\n            push!(stack, char)\n        end\n    end\n\n    return isempty(stack)\nend", "test": "# Test cases\n@assert is_valid_brackets(\"()\") == true\n@assert is_valid_brackets(\"()[]{}\") == true\n@assert is_valid_brackets(\"(]\") == false\n@assert is_valid_brackets(\"([)]\") == false\n@assert is_valid_brackets(\"{[]}\") == true\n@assert is_valid_brackets(\"\") == true\n@assert is_valid_brackets(\"{[()]}\") == true\n@assert is_valid_brackets(\"{{[[(())]]}}\") == true", "entry_point": "is_valid_brackets", "signature": "function is_valid_brackets(s::String) :: Bool", "docstring": "Check if a given string of brackets is valid. A string is considered valid if \n    all types of brackets are correctly closed and in the correct order.\n    \n    # Examples\n    >>> is_valid_brackets(\"[]{}()\")\n    True\n    >>> is_valid_brackets(\"([)]\")\n    False\n    >>> is_valid_brackets(\"{[()]}\")\n    True\n    >>> is_valid_brackets(\"{{[[(())]]}}\")\n    True", "instruction": "Write a Julia function `function is_valid_brackets(s::String) :: Bool` to solve the following problem:\nCheck if a given string of brackets is valid. A string is considered valid if \n    all types of brackets are correctly closed and in the correct order.\n    \n    # Examples\n    >>> is_valid_brackets(\"[]{}()\")\n    True\n    >>> is_valid_brackets(\"([)]\")\n    False\n    >>> is_valid_brackets(\"{[()]}\")\n    True\n    >>> is_valid_brackets(\"{{[[(())]]}}\")\n    True", "level": "easy"}
{"task_id": "Julia/5", "prompt": "function remove_specific_elements!(nums::Vector{Int}, val::Int) :: Int\n \"\"\"\nRemove all instances of a specified value from an array and return the new length of the array.\nThe array is modified in place to save space. The order of the elements can be changed.\n\n# Examples\n>>> remove_specific_elements!([3, 1, 2, 3, 4], 3)\n4  # [1, 2, 4, 3] or any other order of [1, 2, 4]\n\n>>> remove_specific_elements!([2, 2, 3, 2, 2, 4, 2, 5], 2)\n3  # [3, 4, 5] or any other order of [3, 4, 5]\n\"\"\"", "canonical_solution": "    i = 1\n    for j in 1:length(nums)\n        if nums[j] != val\n            nums[i] = nums[j]\n            i += 1\n        end\n    end\n    return i-1\nend", "test": "# Test cases\n@assert remove_specific_elements!([3, 1, 2, 3, 4], 3) == 3\n@assert remove_specific_elements!([2, 2, 3, 2, 2, 4, 2, 5], 2) == 3\n@assert remove_specific_elements!([1, 1, 1, 1, 1], 1) == 0\n@assert remove_specific_elements!([5, 6, 7, 8, 9], 10) == 5", "entry_point": "remove_specific_elements!", "signature": "function remove_specific_elements!(nums::Vector{Int}, val::Int) :: Int", "docstring": "Remove all instances of a specified value from an array and return the new length of the array.\nThe array is modified in place to save space. The order of the elements can be changed.\n\n# Examples\n>>> remove_specific_elements!([3, 1, 2, 3, 4], 3)\n4  # [1, 2, 4, 3] or any other order of [1, 2, 4]\n\n>>> remove_specific_elements!([2, 2, 3, 2, 2, 4, 2, 5], 2)\n3  # [3, 4, 5] or any other order of [3, 4, 5]", "instruction": "Write a Julia function `function remove_specific_elements!(nums::Vector{Int}, val::Int) :: Int` to solve the following problem:\nRemove all instances of a specified value from an array and return the new length of the array.\nThe array is modified in place to save space. The order of the elements can be changed.\n\n# Examples\n>>> remove_specific_elements!([3, 1, 2, 3, 4], 3)\n4  # [1, 2, 4, 3] or any other order of [1, 2, 4]\n\n>>> remove_specific_elements!([2, 2, 3, 2, 2, 4, 2, 5], 2)\n3  # [3, 4, 5] or any other order of [3, 4, 5]", "level": "easy"}
{"task_id": "Julia/6", "prompt": "function find_substring_index(haystack::String, needle::String) :: Int\n\"\"\"\nFinds the first occurrence of the substring 'needle' in the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\n\n# Examples\n```julia\nfind_substring_index(\"hello world\", \"world\")  # returns 7\nfind_substring_index(\"hello world\", \"bye\")    # returns -1\n\"\"\"", "canonical_solution": "    if needle == \"\"\n        return 1\n    end\n    for i in 1:length(haystack) - length(needle) + 1\n        if haystack[i:i+length(needle)-1] == needle\n            return i\n        end\n    end\n    return -1\nend", "test": "# Test cases\n@assert find_substring_index(\"hello world\", \"world\") == 7\n@assert find_substring_index(\"hello world\", \"bye\") == -1\n@assert find_substring_index(\"abcdabcd\", \"bc\") == 2\n@assert find_substring_index(\"abcd\", \"\") == 1", "entry_point": "find_substring_index", "signature": "function find_substring_index(haystack::String, needle::String) :: Int", "docstring": "Finds the first occurrence of the substring 'needle' in the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\n\n# Examples\n```julia\nfind_substring_index(\"hello world\", \"world\")  # returns 7\nfind_substring_index(\"hello world\", \"bye\")    # returns -1", "instruction": "Write a Julia function `function find_substring_index(haystack::String, needle::String) :: Int` to solve the following problem:\nFinds the first occurrence of the substring 'needle' in the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\n\n# Examples\n```julia\nfind_substring_index(\"hello world\", \"world\")  # returns 7\nfind_substring_index(\"hello world\", \"bye\")    # returns -1", "level": "easy"}
{"task_id": "Julia/7", "prompt": "function find_insert_position(nums::Vector{Int}, target::Int) :: Int\n\n    \"\"\"\n    Find the index at which a target value should be inserted into a sorted array to maintain order, or the index of the target value if it is already in the array.\n    \n    This function uses a binary search algorithm for an O(log n) time complexity.\n    \n    # Examples\n    - `find_insert_position([1, 3, 5, 6], 4)` should return `2`.\n    - `find_insert_position([2, 4, 6, 8, 10], 7)` should return `3`.\n    - `find_insert_position([10, 20, 30], 15)` should return `1`.\n    \"\"\"", "canonical_solution": "low, high = 1, length(nums)\n\n    while low <= high\n        mid = low + ((high - low) >> 1)\n        if nums[mid] == target\n            return mid\n        elseif nums[mid] < target\n            low = mid + 1\n        else\n            high = mid - 1\n        end\n    end\n\n    return low\nend", "test": "# Test cases\n@assert find_insert_position([1, 3, 5, 6], 4) == 3\n@assert find_insert_position([2, 4, 6, 8, 10], 7) == 4\n@assert find_insert_position([10, 20, 30], 15) == 2\n@assert find_insert_position([1, 3, 5, 6], 6) == 4\n@assert find_insert_position([5, 10, 15], 1) == 1", "entry_point": "find_insert_position", "signature": "function find_insert_position(nums::Vector{Int}, target::Int) :: Int", "docstring": "Find the index at which a target value should be inserted into a sorted array to maintain order, or the index of the target value if it is already in the array.\n    \n    This function uses a binary search algorithm for an O(log n) time complexity.\n    \n    # Examples\n    - `find_insert_position([1, 3, 5, 6], 4)` should return `2`.\n    - `find_insert_position([2, 4, 6, 8, 10], 7)` should return `3`.\n    - `find_insert_position([10, 20, 30], 15)` should return `1`.", "instruction": "Write a Julia function `function find_insert_position(nums::Vector{Int}, target::Int) :: Int` to solve the following problem:\nFind the index at which a target value should be inserted into a sorted array to maintain order, or the index of the target value if it is already in the array.\n    \n    This function uses a binary search algorithm for an O(log n) time complexity.\n    \n    # Examples\n    - `find_insert_position([1, 3, 5, 6], 4)` should return `2`.\n    - `find_insert_position([2, 4, 6, 8, 10], 7)` should return `3`.\n    - `find_insert_position([10, 20, 30], 15)` should return `1`.", "level": "easy"}
{"task_id": "Julia/8", "prompt": "function length_of_last_word(s::String) :: Int\n\n    \"\"\"\n    Calculate the length of the last word in a given string. \n    A word is defined as a maximal substring consisting exclusively of letters, \n    separated by one or more spaces.\n    \n    # Examples\n    - `length_of_last_word(\"Good morning everyone\")` should return `8` (length of \"everyone\").\n    - `length_of_last_word(\"JuliaProgramming\")` should return `16` (length of the entire string).\n    - `length_of_last_word(\" \")` should return `0` (no words in the string).\n    \"\"\"", "canonical_solution": "    words = split(strip(s))\n    return isempty(words) ? 0 : length(last(words))\nend\n    ", "test": "@assert length_of_last_word(\"Good morning everyone\") == 8\n@assert length_of_last_word(\"JuliaProgramming\") == 16\n@assert length_of_last_word(\" \") == 0\n@assert length_of_last_word(\"Hello Julia World  \") == 5\n@assert length_of_last_word(\"a\") == 1", "entry_point": "length_of_last_word", "signature": "function length_of_last_word(s::String) :: Int", "docstring": "Calculate the length of the last word in a given string. \n    A word is defined as a maximal substring consisting exclusively of letters, \n    separated by one or more spaces.\n    \n    # Examples\n    - `length_of_last_word(\"Good morning everyone\")` should return `8` (length of \"everyone\").\n    - `length_of_last_word(\"JuliaProgramming\")` should return `16` (length of the entire string).\n    - `length_of_last_word(\" \")` should return `0` (no words in the string).", "instruction": "Write a Julia function `function length_of_last_word(s::String) :: Int` to solve the following problem:\nCalculate the length of the last word in a given string. \n    A word is defined as a maximal substring consisting exclusively of letters, \n    separated by one or more spaces.\n    \n    # Examples\n    - `length_of_last_word(\"Good morning everyone\")` should return `8` (length of \"everyone\").\n    - `length_of_last_word(\"JuliaProgramming\")` should return `16` (length of the entire string).\n    - `length_of_last_word(\" \")` should return `0` (no words in the string).", "level": "easy"}
{"task_id": "Julia/9", "prompt": "function increment_digit_array(digits::Vector{Int}) :: Vector{Int}\n    \"\"\"\n    Increment a non-empty array of digits by one. Each element in the array represents a single digit of a non-negative integer, with the most significant digit at the start of the array. The integer does not start with zero except for the integer 0 itself.\n    \n    # Examples\n    >>> increment_digit_array([1, 9, 9])\n    [2, 0, 0]\n    \n    >>> increment_digit_array([9, 9])\n    [1, 0, 0]\n    \n    >>> increment_digit_array([1, 2, 3])\n    [1, 2, 4]\n    \"\"\"", "canonical_solution": "    n = length(digits)\n    for i in reverse(1:n)\n        if digits[i] < 9\n            digits[i] += 1\n            return digits\n        end\n        digits[i] = 0\n    end\n    return [1; digits]\nend", "test": "@assert increment_digit_array([1, 9, 9]) == [2, 0, 0]\n@assert increment_digit_array([9, 9]) == [1, 0, 0]\n@assert increment_digit_array([2, 3, 4]) == [2, 3, 5]\n@assert increment_digit_array([0]) == [1]\n@assert increment_digit_array([1, 2, 3]) == [1, 2, 4]", "entry_point": "increment_digit_array", "signature": "function increment_digit_array(digits::Vector{Int}) :: Vector{Int}", "docstring": "Increment a non-empty array of digits by one. Each element in the array represents a single digit of a non-negative integer, with the most significant digit at the start of the array. The integer does not start with zero except for the integer 0 itself.\n    \n    # Examples\n    >>> increment_digit_array([1, 9, 9])\n    [2, 0, 0]\n    \n    >>> increment_digit_array([9, 9])\n    [1, 0, 0]\n    \n    >>> increment_digit_array([1, 2, 3])\n    [1, 2, 4]", "instruction": "Write a Julia function `function increment_digit_array(digits::Vector{Int}) :: Vector{Int}` to solve the following problem:\nIncrement a non-empty array of digits by one. Each element in the array represents a single digit of a non-negative integer, with the most significant digit at the start of the array. The integer does not start with zero except for the integer 0 itself.\n    \n    # Examples\n    >>> increment_digit_array([1, 9, 9])\n    [2, 0, 0]\n    \n    >>> increment_digit_array([9, 9])\n    [1, 0, 0]\n    \n    >>> increment_digit_array([1, 2, 3])\n    [1, 2, 4]", "level": "easy"}
{"task_id": "Julia/10", "prompt": "function add_binary_strings(a::String, b::String) :: String\n\n\"\"\"\n    Add two binary strings and return their sum as a binary string.\n\n    # Examples\n    >>> add_binary_strings(\"110\", \"1001\")\n    \"1111\"\n\n    >>> add_binary_strings(\"0\", \"1\")\n    \"1\"\n\n    >>> add_binary_strings(\"101\", \"110\")\n    \"1011\"\n\"\"\"", "canonical_solution": "    carry = 0\n    result = \"\"\n    \n    i, j = length(a), length(b)\n    while i > 0 || j > 0 || carry == 1\n        sum = carry\n        if i > 0\n            sum += parse(Int, a[i])\n            i -= 1\n        end\n        if j > 0\n            sum += parse(Int, b[j])\n            j -= 1\n        end\n        \n        carry = sum > 1 ? 1 : 0\n        result = string(sum % 2) * result\n    end\n\n    return result\nend", "test": "@assert add_binary_strings(\"110\", \"1001\") == \"1111\"\n@assert add_binary_strings(\"0\", \"1\") == \"1\"\n@assert add_binary_strings(\"101\", \"110\") == \"1011\"\n@assert add_binary_strings(\"111\", \"111\") == \"1110\"\n@assert add_binary_strings(\"10101\", \"1100\") == \"100001\"", "entry_point": "add_binary_strings", "signature": "function add_binary_strings(a::String, b::String) :: String", "docstring": "Add two binary strings and return their sum as a binary string.\n\n    # Examples\n    >>> add_binary_strings(\"110\", \"1001\")\n    \"1111\"\n\n    >>> add_binary_strings(\"0\", \"1\")\n    \"1\"\n\n    >>> add_binary_strings(\"101\", \"110\")\n    \"1011\"", "instruction": "Write a Julia function `function add_binary_strings(a::String, b::String) :: String` to solve the following problem:\nAdd two binary strings and return their sum as a binary string.\n\n    # Examples\n    >>> add_binary_strings(\"110\", \"1001\")\n    \"1111\"\n\n    >>> add_binary_strings(\"0\", \"1\")\n    \"1\"\n\n    >>> add_binary_strings(\"101\", \"110\")\n    \"1011\"", "level": "middle"}
{"task_id": "Julia/11", "prompt": "function integer_square_root(x::Int) :: Int\n\"\"\"\nCalculate the integer part of the square root of a given non-negative integer `x`.\nThe function returns the largest integer `y` such that `y*y <= x`.\nThe calculation is done without using any built-in exponent functions or operators.\n\n# Examples\n```\njulia> integer_square_root(9)\n3\n\njulia> integer_square_root(15)\n3\n\njulia> integer_square_root(26)\n5\n\"\"\"", "canonical_solution": "    if x < 2\n        return x\n    end\n\n    low, high = 1, x\n\n    while low <= high\n        mid = low + (high - low) \u00f7 2\n        if mid*mid > x\n            high = mid - 1\n        else\n            low = mid + 1\n        end\n    end\n\n    return high\nend", "test": "@assert integer_square_root(9) == 3\n@assert integer_square_root(15) == 3\n@assert integer_square_root(26) == 5\n@assert integer_square_root(1) == 1\n@assert integer_square_root(0) == 0", "entry_point": "integer_square_root", "signature": "function integer_square_root(x::Int) :: Int", "docstring": "Calculate the integer part of the square root of a given non-negative integer `x`.\nThe function returns the largest integer `y` such that `y*y <= x`.\nThe calculation is done without using any built-in exponent functions or operators.\n\n# Examples\n```\njulia> integer_square_root(9)\n3\n\njulia> integer_square_root(15)\n3\n\njulia> integer_square_root(26)\n5", "instruction": "Write a Julia function `function integer_square_root(x::Int) :: Int` to solve the following problem:\nCalculate the integer part of the square root of a given non-negative integer `x`.\nThe function returns the largest integer `y` such that `y*y <= x`.\nThe calculation is done without using any built-in exponent functions or operators.\n\n# Examples\n```\njulia> integer_square_root(9)\n3\n\njulia> integer_square_root(15)\n3\n\njulia> integer_square_root(26)\n5", "level": "easy"}
{"task_id": "Julia/12", "prompt": "function count_paths(grid_size::Int) :: Int\n\"\"\"\nCalculate the number of distinct paths from the top-left corner to the bottom-right corner of a 2D grid of a given size.\nEach move is either one step to the right or one step down.\n>>> count_paths(2)\n2\n>>> count_paths(3)\n6\n\"\"\"", "canonical_solution": "    # Initialize a 2D array with zeros\n    paths = zeros(Int, grid_size, grid_size)\n\n    # Set the first row and column to 1 as there's only one way to reach those cells\n    for i in 1:grid_size\n        paths[i, 1] = 1\n        paths[1, i] = 1\n    end\n\n    # Calculate the number of paths for each cell\n    for i in 2:grid_size\n        for j in 2:grid_size\n            paths[i, j] = paths[i - 1, j] + paths[i, j - 1]\n        end\n    end\n\n    return paths[grid_size, grid_size]\nend", "test": "@assert count_paths(2) == 2 # 2x2 grid has 2 paths (Right-Down, Down-Right)\n@assert count_paths(3) == 6 # 3x3 grid has 6 paths\n@assert count_paths(4) == 20 # 4x4 grid has 20 paths\n@assert count_paths(1) == 1 # 1x1 grid has only 1 path", "entry_point": "count_paths", "signature": "function count_paths(grid_size::Int) :: Int", "docstring": "Calculate the number of distinct paths from the top-left corner to the bottom-right corner of a 2D grid of a given size.\nEach move is either one step to the right or one step down.\n>>> count_paths(2)\n2\n>>> count_paths(3)\n6", "instruction": "Write a Julia function `function count_paths(grid_size::Int) :: Int` to solve the following problem:\nCalculate the number of distinct paths from the top-left corner to the bottom-right corner of a 2D grid of a given size.\nEach move is either one step to the right or one step down.\n>>> count_paths(2)\n2\n>>> count_paths(3)\n6", "level": "middle"}
{"task_id": "Julia/13", "prompt": "function count_climb_ways(steps::Int) :: Int\n    \"\"\"\n    Calculate the number of distinct ways to climb a given number of stairs when\n    each step can be either 1 or 2 stairs.\n    \n    # Examples\n    - `count_climb_ways(2)` should return `2`, representing [1 step + 1 step, 2 steps].\n    - `count_climb_ways(4)` should return `5`, representing [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2].\n    - `count_climb_ways(3)` should return `3`, representing [1+1+1, 1+2, 2+1].\n    \"\"\"", "canonical_solution": "    if steps == 1\n        return 1\n    elseif steps == 2\n        return 2\n    else\n        first, second = 1, 2\n        for i in 3:steps\n            first, second = second, first + second\n        end\n        return second\n    end\nend", "test": "@assert count_climb_ways(2) == 2\n@assert count_climb_ways(3) == 3\n@assert count_climb_ways(4) == 5\n@assert count_climb_ways(5) == 8", "entry_point": "count_climb_ways", "signature": "function count_climb_ways(steps::Int) :: Int", "docstring": "Calculate the number of distinct ways to climb a given number of stairs when\n    each step can be either 1 or 2 stairs.\n    \n    # Examples\n    - `count_climb_ways(2)` should return `2`, representing [1 step + 1 step, 2 steps].\n    - `count_climb_ways(4)` should return `5`, representing [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2].\n    - `count_climb_ways(3)` should return `3`, representing [1+1+1, 1+2, 2+1].", "instruction": "Write a Julia function `function count_climb_ways(steps::Int) :: Int` to solve the following problem:\nCalculate the number of distinct ways to climb a given number of stairs when\n    each step can be either 1 or 2 stairs.\n    \n    # Examples\n    - `count_climb_ways(2)` should return `2`, representing [1 step + 1 step, 2 steps].\n    - `count_climb_ways(4)` should return `5`, representing [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2].\n    - `count_climb_ways(3)` should return `3`, representing [1+1+1, 1+2, 2+1].", "level": "easy"}
{"task_id": "Julia/14", "prompt": "function merge_sorted_arrays(nums1::Vector{Int}, m::Int, nums2::Vector{Int}, n::Int) :: Vector{Int}\n    \"\"\"\n    Merge two sorted arrays, `nums1` and `nums2`, where `nums1` has a size of `m + n`, with the first `m` elements containing values and the last `n` elements set to zero, representing space allocated for merging. `nums2` has `n` elements. The merged array should maintain non-decreasing order.\n    \n    Examples:\n    >>> merge_sorted_arrays([1, 3, 5, 0, 0, 0], 3, [2, 4, 6], 3)\n    [1, 2, 3, 4, 5, 6]\n    >>> merge_sorted_arrays([4, 0], 1, [3], 1)\n    [3, 4]\n    >>> merge_sorted_arrays([0], 0, [1], 1)\n    [1]\n    \"\"\"", "canonical_solution": "    i = m \n    j = n \n    k = m + n\n    \n    while j > 0\n        if i > 0 && nums1[i] > nums2[j]\n            nums1[k] = nums1[i]\n            i -= 1\n        else\n            nums1[k] = nums2[j]\n            j -= 1\n        end\n        k -= 1\n    end\n    \n    nums1\nend", "test": "@assert merge_sorted_arrays([1, 3, 5, 0, 0, 0], 3, [2, 4, 6], 3) == [1, 2, 3, 4, 5, 6]\n@assert merge_sorted_arrays([4, 0], 1, [3], 1) == [3, 4]\n@assert merge_sorted_arrays([0], 0, [1], 1) == [1]\n@assert merge_sorted_arrays([2, 3, 0, 0, 0], 2, [1, 4, 5], 3) == [1, 2, 3, 4, 5]", "entry_point": "merge_sorted_arrays", "signature": "function merge_sorted_arrays(nums1::Vector{Int}, m::Int, nums2::Vector{Int}, n::Int) :: Vector{Int}", "docstring": "Merge two sorted arrays, `nums1` and `nums2`, where `nums1` has a size of `m + n`, with the first `m` elements containing values and the last `n` elements set to zero, representing space allocated for merging. `nums2` has `n` elements. The merged array should maintain non-decreasing order.\n    \n    Examples:\n    >>> merge_sorted_arrays([1, 3, 5, 0, 0, 0], 3, [2, 4, 6], 3)\n    [1, 2, 3, 4, 5, 6]\n    >>> merge_sorted_arrays([4, 0], 1, [3], 1)\n    [3, 4]\n    >>> merge_sorted_arrays([0], 0, [1], 1)\n    [1]", "instruction": "Write a Julia function `function merge_sorted_arrays(nums1::Vector{Int}, m::Int, nums2::Vector{Int}, n::Int) :: Vector{Int}` to solve the following problem:\nMerge two sorted arrays, `nums1` and `nums2`, where `nums1` has a size of `m + n`, with the first `m` elements containing values and the last `n` elements set to zero, representing space allocated for merging. `nums2` has `n` elements. The merged array should maintain non-decreasing order.\n    \n    Examples:\n    >>> merge_sorted_arrays([1, 3, 5, 0, 0, 0], 3, [2, 4, 6], 3)\n    [1, 2, 3, 4, 5, 6]\n    >>> merge_sorted_arrays([4, 0], 1, [3], 1)\n    [3, 4]\n    >>> merge_sorted_arrays([0], 0, [1], 1)\n    [1]", "level": "easy"}
{"task_id": "Julia/15", "prompt": "struct BinaryTreeNode\n    val::Int\n    left::Union{BinaryTreeNode, Nothing}\n    right::Union{BinaryTreeNode, Nothing}\n\n    # Constructor for a node with a value and optional left and right children.\n    BinaryTreeNode(val::Int, left::Union{BinaryTreeNode, Nothing}=nothing, right::Union{BinaryTreeNode, Nothing}=nothing) = new(val, left, right)\nend\n    \n\nfunction inorder_traversal(root::Union{BinaryTreeNode, Nothing}) :: Vector{Int}\n    \"\"\"\n    Perform an inorder traversal of a binary tree and return the values in a list.\n    \n    This function traverses a binary tree in an inorder manner (left node, root, right node) and collects the values of the nodes in a list. For a binary tree, this results in values being returned in a non-decreasing order.\n    \n    Examples:\n    >>> inorder_traversal(BinaryTreeNode(1, nothing, BinaryTreeNode(2, BinaryTreeNode(3), nothing)))\n    [1, 3, 2]\n    \n    >>> inorder_traversal(nothing)\n    []\n    \n    >>> inorder_traversal(BinaryTreeNode(1))\n    [1]\n    \"\"\"", "canonical_solution": "    values = Int[]\n    stack = BinaryTreeNode[]\n    current = root\n    while current != nothing || !isempty(stack)\n        while current != nothing\n            push!(stack, current)\n            current = current.left\n        end\n        current = pop!(stack)\n        push!(values, current.val)\n        current = current.right\n    end\n    return values\nend", "test": "@assert inorder_traversal(BinaryTreeNode(1, nothing, BinaryTreeNode(2, BinaryTreeNode(3), nothing))) == [1, 3, 2]\n@assert inorder_traversal(nothing) == []\n@assert inorder_traversal(BinaryTreeNode(1)) == [1]\n@assert inorder_traversal(BinaryTreeNode(1, BinaryTreeNode(2), BinaryTreeNode(3))) == [2, 1, 3]", "entry_point": "inorder_traversal", "signature": "function inorder_traversal(root::Union{BinaryTreeNode, Nothing}) :: Vector{Int}", "docstring": "Perform an inorder traversal of a binary tree and return the values in a list.\n    \n    This function traverses a binary tree in an inorder manner (left node, root, right node) and collects the values of the nodes in a list. For a binary tree, this results in values being returned in a non-decreasing order.\n    \n    Examples:\n    >>> inorder_traversal(BinaryTreeNode(1, nothing, BinaryTreeNode(2, BinaryTreeNode(3), nothing)))\n    [1, 3, 2]\n    \n    >>> inorder_traversal(nothing)\n    []\n    \n    >>> inorder_traversal(BinaryTreeNode(1))\n    [1]", "instruction": "Write a Julia function `function inorder_traversal(root::Union{BinaryTreeNode, Nothing}) :: Vector{Int}` to solve the following problem:\nPerform an inorder traversal of a binary tree and return the values in a list.\n    \n    This function traverses a binary tree in an inorder manner (left node, root, right node) and collects the values of the nodes in a list. For a binary tree, this results in values being returned in a non-decreasing order.\n    \n    Examples:\n    >>> inorder_traversal(BinaryTreeNode(1, nothing, BinaryTreeNode(2, BinaryTreeNode(3), nothing)))\n    [1, 3, 2]\n    \n    >>> inorder_traversal(nothing)\n    []\n    \n    >>> inorder_traversal(BinaryTreeNode(1))\n    [1]", "level": "middle"}
{"task_id": "Julia/16", "prompt": "function sum_natural_numbers(x::Int, y::Int) :: Int\n    \"\"\"\n    Calculate the sum of two given natural numbers.\n    \n    This function takes two integers and returns their sum.\n    \n    # Examples\n    >>> sum_natural_numbers(10, 20)\n    30\n    \n    >>> sum_natural_numbers(5, 15)\n    20\n    \"\"\"", "canonical_solution": "    return x + y\nend", "test": "@assert sum_natural_numbers(10, 20) == 30\n@assert sum_natural_numbers(5, 15) == 20\n@assert sum_natural_numbers(0, 0) == 0\n@assert sum_natural_numbers(-5, 10) == 5", "entry_point": "sum_natural_numbers", "signature": "function sum_natural_numbers(x::Int, y::Int) :: Int", "docstring": "Calculate the sum of two given natural numbers.\n    \n    This function takes two integers and returns their sum.\n    \n    # Examples\n    >>> sum_natural_numbers(10, 20)\n    30\n    \n    >>> sum_natural_numbers(5, 15)\n    20", "instruction": "Write a Julia function `function sum_natural_numbers(x::Int, y::Int) :: Int` to solve the following problem:\nCalculate the sum of two given natural numbers.\n    \n    This function takes two integers and returns their sum.\n    \n    # Examples\n    >>> sum_natural_numbers(10, 20)\n    30\n    \n    >>> sum_natural_numbers(5, 15)\n    20", "level": "easy"}
{"task_id": "Julia/17", "prompt": "function calculate_average_age(students_ages::Vector{Int}) :: Float64\n    \"\"\"\n    Calculate the average age of a group of students. The ages are provided as a list of integers. Keep to two decimal places\n    \n    # Examples\n    >>> calculate_average_age([18, 17, 20])\n    18.33\n    >>> calculate_average_age([16, 22, 19, 20])\n    19.25\n    \"\"\"", "canonical_solution": "    total_age = sum(students_ages)\n    number_of_students = length(students_ages)\n    return round(total_age / number_of_students, digits=2)\nend", "test": "@assert calculate_average_age([18, 17, 20]) \u2248 18.33\n@assert calculate_average_age([16, 22, 19, 20]) \u2248 19.25\n@assert calculate_average_age([15, 25, 16, 24]) \u2248 20.00\n@assert calculate_average_age([21, 22, 23, 24, 25]) \u2248 23.00", "entry_point": "calculate_average_age", "signature": "function calculate_average_age(students_ages::Vector{Int}) :: Float64", "docstring": "Calculate the average age of a group of students. The ages are provided as a list of integers. Keep to two decimal places\n    \n    # Examples\n    >>> calculate_average_age([18, 17, 20])\n    18.33\n    >>> calculate_average_age([16, 22, 19, 20])\n    19.25", "instruction": "Write a Julia function `function calculate_average_age(students_ages::Vector{Int}) :: Float64` to solve the following problem:\nCalculate the average age of a group of students. The ages are provided as a list of integers. Keep to two decimal places\n    \n    # Examples\n    >>> calculate_average_age([18, 17, 20])\n    18.33\n    >>> calculate_average_age([16, 22, 19, 20])\n    19.25", "level": "easy"}
{"task_id": "Julia/18", "prompt": "function average_balance(balances::Vector{Float64}) :: String\n\n\"\"\"\nCalculate the average of a series of monthly balances.\n\nThis function takes a vector of monthly balances and returns the average balance,\nformatted as a string with a \"\\$\" sign and rounded to two decimal places.\n\n# Examples\n>>> average_balance([100.0, 200.0, 300.0])\n\"\\$200.00\"\n\n>>> average_balance([123.45, 678.90, 234.56, 789.01, 456.78])\n\"\\$456.54\"\n\"\"\"", "canonical_solution": "    total = sum(balances)\n    avg = total / length(balances)\n    return \"\\$\" * string(round(avg, digits=2))\nend", "test": "@assert average_balance([150.50, 300.75, 450.25]) == \"\\$300.5\"\n@assert average_balance([1200.00, 1100.00, 1000.00, 900.00]) == \"\\$1050.0\"\n@assert average_balance([1234.56, 7890.12, 4567.89]) == \"\\$4564.19\"\n@assert average_balance([500.00, 600.00, 700.00, 800.00, 900.00]) == \"\\$700.0\"", "entry_point": "average_balance", "signature": "function average_balance(balances::Vector{Float64}) :: String", "docstring": "Calculate the average of a series of monthly balances.\n\nThis function takes a vector of monthly balances and returns the average balance,\nformatted as a string with a \"\\$\" sign and rounded to two decimal places.\n\n# Examples\n>>> average_balance([100.0, 200.0, 300.0])\n\"\\$200.00\"\n\n>>> average_balance([123.45, 678.90, 234.56, 789.01, 456.78])\n\"\\$456.54\"", "instruction": "Write a Julia function `function average_balance(balances::Vector{Float64}) :: String` to solve the following problem:\nCalculate the average of a series of monthly balances.\n\nThis function takes a vector of monthly balances and returns the average balance,\nformatted as a string with a \"\\$\" sign and rounded to two decimal places.\n\n# Examples\n>>> average_balance([100.0, 200.0, 300.0])\n\"\\$200.00\"\n\n>>> average_balance([123.45, 678.90, 234.56, 789.01, 456.78])\n\"\\$456.54\"", "level": "easy"}
{"task_id": "Julia/19", "prompt": "function calculate_growth(initial_value::Float64, growth_rate::Float64, years::Int) :: Float64\n\"\"\"\n    calculate_growth(initial_value, growth_rate, years)\n\nCalculate the final value after applying a constant growth rate over a number of years.\n\n# Arguments\n- `initial_value`: Initial value (e.g., initial amount of money).\n- `growth_rate`: Annual growth rate as a decimal (e.g., 0.1 for 10%).\n- `years`: Number of years over which the growth is applied.\n\n# Examples\n```julia\ncalculate_growth(10.0, 0.05, 5) # should return approximately 12.7628\ncalculate_growth(15.0, 0.03, 10) # should return approximately 20.1559\n\"\"\"", "canonical_solution": "    final_value = initial_value * (1 + growth_rate) ^ years\n    println(round(final_value, digits=4))\n    \n    return round(final_value, digits=4)\nend", "test": "@assert calculate_growth(10.0, 0.05, 5) \u2248 12.7628\n@assert calculate_growth(15.0, 0.03, 10) \u2248 20.1587\n@assert calculate_growth(20.0, 0.02, 3) \u2248 21.2242\n@assert calculate_growth(5.0, 0.1, 8) \u2248 10.7179", "entry_point": "calculate_growth", "signature": "function calculate_growth(initial_value::Float64, growth_rate::Float64, years::Int) :: Float64", "docstring": "calculate_growth(initial_value, growth_rate, years)\n\nCalculate the final value after applying a constant growth rate over a number of years.\n\n# Arguments\n- `initial_value`: Initial value (e.g., initial amount of money).\n- `growth_rate`: Annual growth rate as a decimal (e.g., 0.1 for 10%).\n- `years`: Number of years over which the growth is applied.\n\n# Examples\n```julia\ncalculate_growth(10.0, 0.05, 5) # should return approximately 12.7628\ncalculate_growth(15.0, 0.03, 10) # should return approximately 20.1559", "instruction": "Write a Julia function `function calculate_growth(initial_value::Float64, growth_rate::Float64, years::Int) :: Float64` to solve the following problem:\ncalculate_growth(initial_value, growth_rate, years)\n\nCalculate the final value after applying a constant growth rate over a number of years.\n\n# Arguments\n- `initial_value`: Initial value (e.g., initial amount of money).\n- `growth_rate`: Annual growth rate as a decimal (e.g., 0.1 for 10%).\n- `years`: Number of years over which the growth is applied.\n\n# Examples\n```julia\ncalculate_growth(10.0, 0.05, 5) # should return approximately 12.7628\ncalculate_growth(15.0, 0.03, 10) # should return approximately 20.1559", "level": "easy"}
{"task_id": "Julia/20", "prompt": "function count_digit_occurrences(L::Int, R::Int, digit::Int) :: Int\n\"\"\"\nCount the number of times a specific digit appears in all integers within the range [L, R].\n\n# Examples\n```jldoctest\njulia> count_digit_occurrences(3, 23, 2)\n6\njulia> count_digit_occurrences(10, 50, 3)\n5\n\"\"\"", "canonical_solution": "    count = 0\n    for number in L:R\n        for d in string(number)\n            if string(d) == string(digit)\n                count += 1\n            end\n        end\n    end\n    return count\nend", "test": "@assert count_digit_occurrences(3, 23, 2) == 6\n@assert count_digit_occurrences(10, 50, 3) == 14\n@assert count_digit_occurrences(1, 100, 1) == 21\n@assert count_digit_occurrences(55, 80, 7) == 13", "entry_point": "count_digit_occurrences", "signature": "function count_digit_occurrences(L::Int, R::Int, digit::Int) :: Int", "docstring": "Count the number of times a specific digit appears in all integers within the range [L, R].\n\n# Examples\n```jldoctest\njulia> count_digit_occurrences(3, 23, 2)\n6\njulia> count_digit_occurrences(10, 50, 3)\n5", "instruction": "Write a Julia function `function count_digit_occurrences(L::Int, R::Int, digit::Int) :: Int` to solve the following problem:\nCount the number of times a specific digit appears in all integers within the range [L, R].\n\n# Examples\n```jldoctest\njulia> count_digit_occurrences(3, 23, 2)\n6\njulia> count_digit_occurrences(10, 50, 3)\n5", "level": "easy"}
{"task_id": "Julia/21", "prompt": "function p_type_encoding(str::String) :: String\n\"\"\"\nEncode a string of digits into its p-type encoding. The p-type encoding of a string describes\neach sequence of consecutive identical digits by stating the count followed by the digit. \nFor example, \"122344111\" becomes \"1122132431\", which means \"1 one, 2 twos, 1 three, 2 fours, 3 ones\". \nSimilarly, \"00000\" becomes \"50\", representing \"5 zeros\".\n\n# Examples\n```julia\njulia> p_type_encoding(\"122344111\")\n\"1122132431\"\n\njulia> p_type_encoding(\"11111\")\n\"51\"\n\njulia> p_type_encoding(\"121212\")\n\"11121212\"\n\"\"\"", "canonical_solution": "    encoded = \"\"\n    current_char = str[1]\n    count = 1\n\n    for i in 2:length(str)\n        if str[i] == current_char\n            count += 1\n        else\n            encoded *= string(count) * string(current_char)\n            current_char = str[i]\n            count = 1\n        end\n    end\n\n    encoded *= string(count) * string(current_char)\n    return encoded\nend", "test": "@assert p_type_encoding(\"122344111\") == \"1122132431\"\n@assert p_type_encoding(\"11111\") == \"51\"\n@assert p_type_encoding(\"121212\") == \"111211121112\"\n@assert p_type_encoding(\"00000\") == \"50\"\n@assert p_type_encoding(\"100200300\") == \"112012201320\"", "entry_point": "p_type_encoding", "signature": "function p_type_encoding(str::String) :: String", "docstring": "Encode a string of digits into its p-type encoding. The p-type encoding of a string describes\neach sequence of consecutive identical digits by stating the count followed by the digit. \nFor example, \"122344111\" becomes \"1122132431\", which means \"1 one, 2 twos, 1 three, 2 fours, 3 ones\". \nSimilarly, \"00000\" becomes \"50\", representing \"5 zeros\".\n\n# Examples\n```julia\njulia> p_type_encoding(\"122344111\")\n\"1122132431\"\n\njulia> p_type_encoding(\"11111\")\n\"51\"\n\njulia> p_type_encoding(\"121212\")\n\"11121212\"", "instruction": "Write a Julia function `function p_type_encoding(str::String) :: String` to solve the following problem:\nEncode a string of digits into its p-type encoding. The p-type encoding of a string describes\neach sequence of consecutive identical digits by stating the count followed by the digit. \nFor example, \"122344111\" becomes \"1122132431\", which means \"1 one, 2 twos, 1 three, 2 fours, 3 ones\". \nSimilarly, \"00000\" becomes \"50\", representing \"5 zeros\".\n\n# Examples\n```julia\njulia> p_type_encoding(\"122344111\")\n\"1122132431\"\n\njulia> p_type_encoding(\"11111\")\n\"51\"\n\njulia> p_type_encoding(\"121212\")\n\"11121212\"", "level": "middle"}
{"task_id": "Julia/22", "prompt": "function longest_common_substring_in_rings(ring1::String, ring2::String) :: Int\n\"\"\"\nDetermines the length of the longest continuous common substring in two character rings.\nA character ring is a string where the end connects back to the beginning, forming a loop.\nThe function takes two strings representing the rings and returns the length of the longest common substring.\n\nExamples:\n>>> longest_common_substring_in_rings(\"ABCDEFABC\", \"FABCDE\")\n6\n>>> longest_common_substring_in_rings(\"XYZABCDXYZ\", \"ABCD\")\n9\n\"\"\"", "canonical_solution": "    extended_ring1 = ring1 * ring1\n    extended_ring2 = ring2 * ring2\n    max_length = 0\n\n    for i in 1:length(ring1)\n        for j in 1:length(ring2)\n            common_length = 0\n            while i + common_length <= length(extended_ring1) && j + common_length <= length(extended_ring2) && extended_ring1[i + common_length] == extended_ring2[j + common_length]\n                common_length += 1\n            end\n            max_length = max(max_length, common_length)\n        end\n    end\n    return max_length\nend", "test": "@assert longest_common_substring_in_rings(\"ABCEFAGADEGKABUVKLM\", \"MADJKLUVKL\") == 6\n@assert longest_common_substring_in_rings(\"ABCDEFABC\", \"FABCDE\") == 9", "entry_point": "longest_common_substring_in_rings", "signature": "function longest_common_substring_in_rings(ring1::String, ring2::String) :: Int", "docstring": "Determines the length of the longest continuous common substring in two character rings.\nA character ring is a string where the end connects back to the beginning, forming a loop.\nThe function takes two strings representing the rings and returns the length of the longest common substring.\n\nExamples:\n>>> longest_common_substring_in_rings(\"ABCDEFABC\", \"FABCDE\")\n6\n>>> longest_common_substring_in_rings(\"XYZABCDXYZ\", \"ABCD\")\n9", "instruction": "Write a Julia function `function longest_common_substring_in_rings(ring1::String, ring2::String) :: Int` to solve the following problem:\nDetermines the length of the longest continuous common substring in two character rings.\nA character ring is a string where the end connects back to the beginning, forming a loop.\nThe function takes two strings representing the rings and returns the length of the longest common substring.\n\nExamples:\n>>> longest_common_substring_in_rings(\"ABCDEFABC\", \"FABCDE\")\n6\n>>> longest_common_substring_in_rings(\"XYZABCDXYZ\", \"ABCD\")\n9", "level": "hard"}
{"task_id": "Julia/23", "prompt": "function swap_matrix_rows(matrix::Array{Int,2}, row1::Int, row2::Int) :: Array{Int,2}\n    \"\"\"\n    Swap two rows in a given 2D integer matrix.\n    \n    This function takes a 2D matrix of integers and swaps the elements of the specified rows.\n    Note: Row indices are 1-based.\n    \n    # Examples\n    >>> swap_matrix_rows([1 2 3; 4 5 6; 7 8 9], 1, 3)\n    3\u00d73 Array{Int64,2}:\n     7  8  9\n     4  5  6\n     1  2  3\n    \n    >>> swap_matrix_rows([10 20; 30 40], 1, 2)\n    2\u00d72 Array{Int64,2}:\n     30  40\n     10  20\n    \"\"\"", "canonical_solution": "    if row1 > size(matrix, 1) || row2 > size(matrix, 1) || row1 < 1 || row2 < 1\n        error(\"Row indices out of bounds\")\n    end\n\n    matrix[row1, :], matrix[row2, :] = matrix[row2, :], matrix[row1, :]\n    return matrix\nend", "test": "@assert swap_matrix_rows([1 2 3; 4 5 6; 7 8 9], 1, 3) == [7 8 9; 4 5 6; 1 2 3]\n@assert swap_matrix_rows([10 20; 30 40], 1, 2) == [30 40; 10 20]\n@assert swap_matrix_rows([1 2; 3 4; 5 6; 7 8; 9 10], 2, 5) == [1 2; 9 10; 5 6; 7 8; 3 4]\n@assert swap_matrix_rows([1 1 1; 2 2 2; 3 3 3], 2, 3) == [1 1 1; 3 3 3; 2 2 2]", "entry_point": "swap_matrix_rows", "signature": "function swap_matrix_rows(matrix::Array{Int,2}, row1::Int, row2::Int) :: Array{Int,2}", "docstring": "Swap two rows in a given 2D integer matrix.\n    \n    This function takes a 2D matrix of integers and swaps the elements of the specified rows.\n    Note: Row indices are 1-based.\n    \n    # Examples\n    >>> swap_matrix_rows([1 2 3; 4 5 6; 7 8 9], 1, 3)\n    3\u00d73 Array{Int64,2}:\n     7  8  9\n     4  5  6\n     1  2  3\n    \n    >>> swap_matrix_rows([10 20; 30 40], 1, 2)\n    2\u00d72 Array{Int64,2}:\n     30  40\n     10  20", "instruction": "Write a Julia function `function swap_matrix_rows(matrix::Array{Int,2}, row1::Int, row2::Int) :: Array{Int,2}` to solve the following problem:\nSwap two rows in a given 2D integer matrix.\n    \n    This function takes a 2D matrix of integers and swaps the elements of the specified rows.\n    Note: Row indices are 1-based.\n    \n    # Examples\n    >>> swap_matrix_rows([1 2 3; 4 5 6; 7 8 9], 1, 3)\n    3\u00d73 Array{Int64,2}:\n     7  8  9\n     4  5  6\n     1  2  3\n    \n    >>> swap_matrix_rows([10 20; 30 40], 1, 2)\n    2\u00d72 Array{Int64,2}:\n     30  40\n     10  20", "level": "easy"}
{"task_id": "Julia/24", "prompt": "function check_matrix_parity(matrix)\n\"\"\"\nCheck if a given n x n matrix of 0s and 1s has an even number of 1s in each row and column. \nIf not, determine if changing one element can achieve this condition.\n\nThis function returns \"OK\" if the matrix already meets the condition. \nIf changing one element can meet the condition, it returns the row and column index of that element. \nIf neither is possible, it returns \"Corrupt\".\n\n# Examples\n>>> check_matrix_parity([1 0 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1])\n\"OK\"\n>>> check_matrix_parity([1 1 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1])\n(1, 4)\n>>> check_matrix_parity([1 1 1 1; 1 1 1 1; 1 1 1 1; 1 1 1 1])\n\"Corrupt\"\n\"\"\"", "canonical_solution": "    nrows, ncols = size(matrix)\n    \n    # Function to check if the sum of elements is even\n    is_even(x) = x % 2 == 0\n\n    # Check rows and columns for even parity\n    row_sum = [sum(matrix[i, :]) for i in 1:nrows]\n    col_sum = [sum(matrix[:, j]) for j in 1:ncols]\n\n    # Identify rows and columns with odd parity\n    odd_rows = findall(!is_even, row_sum)\n    odd_cols = findall(!is_even, col_sum)\n\n    # Check conditions\n    if length(odd_rows) == 0 && length(odd_cols) == 0\n        return \"OK\"\n    elseif length(odd_rows) == 1 && length(odd_cols) == 1\n        return (odd_rows[1], odd_cols[1])\n    else\n        return \"Corrupt\"\n    end\nend", "test": "@assert check_matrix_parity([1 0 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1]) == \"OK\"\n@assert check_matrix_parity([1 1 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1]) == (1, 2)\n@assert check_matrix_parity([1 1 1 1; 1 1 1 1; 1 1 1 1; 1 1 1 1]) == \"OK\"\n@assert check_matrix_parity([1 0 1 0; 1 0 1 0; 1 0 1 0; 0 1 0 1]) == \"Corrupt\"", "entry_point": "check_matrix_parity", "signature": "function check_matrix_parity(matrix)", "docstring": "Check if a given n x n matrix of 0s and 1s has an even number of 1s in each row and column. \nIf not, determine if changing one element can achieve this condition.\n\nThis function returns \"OK\" if the matrix already meets the condition. \nIf changing one element can meet the condition, it returns the row and column index of that element. \nIf neither is possible, it returns \"Corrupt\".\n\n# Examples\n>>> check_matrix_parity([1 0 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1])\n\"OK\"\n>>> check_matrix_parity([1 1 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1])\n(1, 4)\n>>> check_matrix_parity([1 1 1 1; 1 1 1 1; 1 1 1 1; 1 1 1 1])\n\"Corrupt\"", "instruction": "Write a Julia function `function check_matrix_parity(matrix)` to solve the following problem:\nCheck if a given n x n matrix of 0s and 1s has an even number of 1s in each row and column. \nIf not, determine if changing one element can achieve this condition.\n\nThis function returns \"OK\" if the matrix already meets the condition. \nIf changing one element can meet the condition, it returns the row and column index of that element. \nIf neither is possible, it returns \"Corrupt\".\n\n# Examples\n>>> check_matrix_parity([1 0 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1])\n\"OK\"\n>>> check_matrix_parity([1 1 1 0; 0 0 0 0; 1 1 1 1; 0 1 0 1])\n(1, 4)\n>>> check_matrix_parity([1 1 1 1; 1 1 1 1; 1 1 1 1; 1 1 1 1])\n\"Corrupt\"", "level": "hard"}
{"task_id": "Julia/25", "prompt": "function find_saddle_point(matrix::Matrix{Int}) :: Union{Tuple{Int, Int, Int}, String}\n\"\"\"\nFind the saddle point in a given 5x5 matrix. A saddle point is an element which is the maximum in its row and minimum in its column.\n\n- Parameters:\n    - matrix: A 5x5 matrix of integers.\n\n- Returns: \n    - A tuple (row, column, value) of the saddle point if found; otherwise, \"not found\".\n\nExample:\n    find_saddle_point([11 3 5 6 9; 12 4 7 8 10; 10 5 6 9 11; 8 6 4 7 2; 15 10 11 20 25]) \n    # should return (4, 1, 8)\n\n\"\"\"", "canonical_solution": "    for i in 1:size(matrix, 1)\n        for j in 1:size(matrix, 2)\n            if matrix[i, j] == maximum(matrix[i, :]) && matrix[i, j] == minimum(matrix[:, j])\n                return (i, j, matrix[i, j])\n            end\n        end\n    end\n    return \"not found\"\nend", "test": "@assert find_saddle_point([11 3 5 6 9; 12 4 7 8 10; 10 5 6 9 11; 8 6 4 7 2; 15 10 11 20 25]) == (4, 1, 8)\n@assert find_saddle_point([1 2 3 4 5; 6 7 8 9 10; 11 12 13 14 15; 16 17 18 19 20; 21 22 23 24 25]) == (1, 5, 5)\n@assert find_saddle_point([10 20 30 40 50; 40 30 20 10 0; 50 40 30 20 10; 0 10 20 30 40; 30 20 10 0 50]) == \"not found\"", "entry_point": "find_saddle_point", "signature": "function find_saddle_point(matrix::Matrix{Int}) :: Union{Tuple{Int, Int, Int}, String}", "docstring": "Find the saddle point in a given 5x5 matrix. A saddle point is an element which is the maximum in its row and minimum in its column.\n\n- Parameters:\n    - matrix: A 5x5 matrix of integers.\n\n- Returns: \n    - A tuple (row, column, value) of the saddle point if found; otherwise, \"not found\".\n\nExample:\n    find_saddle_point([11 3 5 6 9; 12 4 7 8 10; 10 5 6 9 11; 8 6 4 7 2; 15 10 11 20 25]) \n    # should return (4, 1, 8)", "instruction": "Write a Julia function `function find_saddle_point(matrix::Matrix{Int}) :: Union{Tuple{Int, Int, Int}, String}` to solve the following problem:\nFind the saddle point in a given 5x5 matrix. A saddle point is an element which is the maximum in its row and minimum in its column.\n\n- Parameters:\n    - matrix: A 5x5 matrix of integers.\n\n- Returns: \n    - A tuple (row, column, value) of the saddle point if found; otherwise, \"not found\".\n\nExample:\n    find_saddle_point([11 3 5 6 9; 12 4 7 8 10; 10 5 6 9 11; 8 6 4 7 2; 15 10 11 20 25]) \n    # should return (4, 1, 8)", "level": "easy"}
{"task_id": "Julia/26", "prompt": "function calculate_image_similarity(image1::Matrix{Int}, image2::Matrix{Int}) :: Float64\n    \"\"\"\n    Calculate the similarity percentage between two binary images represented as matrices of 0s and 1s.\n    The similarity is determined by the percentage of matching pixel values at corresponding positions in both images.\n    \n    Args:\n    image1: A matrix of integers (0 or 1) representing the first binary image.\n    image2: A matrix of integers (0 or 1) representing the second binary image.\n    \n    Returns:\n    A Float64 representing the similarity percentage between the two images.\n    \n    Examples:\n    >>> calculate_image_similarity([1 0 1; 0 1 0; 1 0 1], [1 1 0; 0 1 0; 1 0 1])\n    77.78 \n    \n    >>> calculate_image_similarity([1 0; 0 1], [0 1; 1 0])\n    0.0\n    \"\"\"", "canonical_solution": "    # Ensure matrices are of the same size\n    if size(image1) != size(image2)\n        throw(ArgumentError(\"Images must be of the same dimensions\"))\n    end\n\n    total_pixels = size(image1, 1) * size(image1, 2)\n    matching_pixels = 0\n\n    for i in 1:size(image1, 1)\n        for j in 1:size(image1, 2)\n            if image1[i, j] == image2[i, j]\n                matching_pixels += 1\n            end\n        end\n    end\n\n    similarity_percentage = (matching_pixels / total_pixels) * 100\n    return round(similarity_percentage, digits=2)\nend", "test": "@assert calculate_image_similarity([1 0 1; 0 1 0; 1 0 1], [1 1 0; 0 1 0; 1 0 1]) \u2248 77.78 \n@assert calculate_image_similarity([1 0; 0 1], [0 1; 1 0]) \u2248 0.0\n@assert calculate_image_similarity([1 1; 1 1], [1 1; 1 1]) \u2248 100.0\n@assert calculate_image_similarity([0 0; 0 0], [1 1; 1 1]) \u2248 0.0", "entry_point": "calculate_image_similarity", "signature": "function calculate_image_similarity(image1::Matrix{Int}, image2::Matrix{Int}) :: Float64", "docstring": "Calculate the similarity percentage between two binary images represented as matrices of 0s and 1s.\n    The similarity is determined by the percentage of matching pixel values at corresponding positions in both images.\n    \n    Args:\n    image1: A matrix of integers (0 or 1) representing the first binary image.\n    image2: A matrix of integers (0 or 1) representing the second binary image.\n    \n    Returns:\n    A Float64 representing the similarity percentage between the two images.\n    \n    Examples:\n    >>> calculate_image_similarity([1 0 1; 0 1 0; 1 0 1], [1 1 0; 0 1 0; 1 0 1])\n    77.78 \n    \n    >>> calculate_image_similarity([1 0; 0 1], [0 1; 1 0])\n    0.0", "instruction": "Write a Julia function `function calculate_image_similarity(image1::Matrix{Int}, image2::Matrix{Int}) :: Float64` to solve the following problem:\nCalculate the similarity percentage between two binary images represented as matrices of 0s and 1s.\n    The similarity is determined by the percentage of matching pixel values at corresponding positions in both images.\n    \n    Args:\n    image1: A matrix of integers (0 or 1) representing the first binary image.\n    image2: A matrix of integers (0 or 1) representing the second binary image.\n    \n    Returns:\n    A Float64 representing the similarity percentage between the two images.\n    \n    Examples:\n    >>> calculate_image_similarity([1 0 1; 0 1 0; 1 0 1], [1 1 0; 0 1 0; 1 0 1])\n    77.78 \n    \n    >>> calculate_image_similarity([1 0; 0 1], [0 1; 1 0])\n    0.0", "level": "hard"}
{"task_id": "Julia/27", "prompt": "function reduce_matrix(matrix)\n    \"\"\"\n    Reduces a given square matrix through a series of row and column zeroing operations, followed by element removal, until it becomes a 1x1 matrix. In each step, the matrix is first row-zeroed by subtracting the minimum value of each row from all elements in that row. Then, it is column-zeroed by subtracting the minimum value of each column from all elements in that column. After each zeroing process, the second row and second column are removed. The function returns the values that were in the second row and second column before every zeroing operations.\n\n    # Examples\n    >>> reduce_matrix([1 2 3; 2 3 4; 3 4 5])\n    [3, 0]\n\n    \"\"\"", "canonical_solution": "    values = []\n\n    while size(matrix, 1) > 1 && size(matrix, 2) > 1\n        # Record the values in the second row and second column before zeroing\n        push!(values, matrix[2, 2])\n\n        # Row zeroing\n        for i in 1:size(matrix, 1)\n            min_val = minimum(matrix[i, :])\n            matrix[i, :] .-= min_val\n        end\n\n        # Column zeroing\n        for j in 1:size(matrix, 2)\n            min_val = minimum(matrix[:, j])\n            matrix[:, j] .-= min_val\n        end\n\n        # Remove the second row and column\n        matrix = matrix[[1; 3:end], [1; 3:end]]\n    end\n    return values\nend", "test": "# reduce_matrix([1 2 3; 2 3 4; 3 4 5])\n@assert reduce_matrix([1 2 3; 2 3 4; 3 4 5]) == [3, 0]\n@assert reduce_matrix([4 5 6; 5 6 7; 6 7 8]) == [6, 0]\n@assert reduce_matrix([2 4 6; 4 6 8; 6 8 10]) == [6, 0]\n@assert reduce_matrix([1 1 1; 1 1 1; 1 1 1]) == [1, 0]", "entry_point": "reduce_matrix", "signature": "function reduce_matrix(matrix)", "docstring": "Reduces a given square matrix through a series of row and column zeroing operations, followed by element removal, until it becomes a 1x1 matrix. In each step, the matrix is first row-zeroed by subtracting the minimum value of each row from all elements in that row. Then, it is column-zeroed by subtracting the minimum value of each column from all elements in that column. After each zeroing process, the second row and second column are removed. The function returns the values that were in the second row and second column before every zeroing operations.\n\n    # Examples\n    >>> reduce_matrix([1 2 3; 2 3 4; 3 4 5])\n    [3, 0]", "instruction": "Write a Julia function `function reduce_matrix(matrix)` to solve the following problem:\nReduces a given square matrix through a series of row and column zeroing operations, followed by element removal, until it becomes a 1x1 matrix. In each step, the matrix is first row-zeroed by subtracting the minimum value of each row from all elements in that row. Then, it is column-zeroed by subtracting the minimum value of each column from all elements in that column. After each zeroing process, the second row and second column are removed. The function returns the values that were in the second row and second column before every zeroing operations.\n\n    # Examples\n    >>> reduce_matrix([1 2 3; 2 3 4; 3 4 5])\n    [3, 0]", "level": "hard"}
{"task_id": "Julia/28", "prompt": "function rotate_image_clockwise(image::Matrix{Int})\n    \"\"\"\n    Rotate a grayscale image represented by an n x m matrix clockwise by 90 degrees.\n    \n    # Arguments\n    - `image`: Matrix{Int} representing the grayscale image. Each element is a pixel intensity ranging from 0 to 255.\n    \n    # Returns\n    - `Matrix{Int}`: The image rotated clockwise by 90 degrees.\n    \n    # Examples\n    ```julia\n    rotate_image_clockwise([1 2 3; 4 5 6; 7 8 9])\n    # Output: [7 4 1; 8 5 2; 9 6 3]\n    \"\"\"", "canonical_solution": "    n, m = size(image)\n    rotated_image = zeros(Int, m, n)\n\n    for i in 1:n\n        for j in 1:m\n            rotated_image[j, n - i + 1] = image[i, j]\n        end\n    end\n\n    return rotated_image\nend", "test": "@assert rotate_image_clockwise([1 2 3; 4 5 6; 7 8 9]) == [7 4 1; 8 5 2; 9 6 3]\n@assert rotate_image_clockwise([1 2; 3 4; 5 6]) == [5 3 1; 6 4 2]\n@assert rotate_image_clockwise([0 0; 0 0]) == [0 0; 0 0]\n@assert rotate_image_clockwise([255;;]) == [255;;]", "entry_point": "rotate_image_clockwise", "signature": "function rotate_image_clockwise(image::Matrix{Int})", "docstring": "Rotate a grayscale image represented by an n x m matrix clockwise by 90 degrees.\n    \n    # Arguments\n    - `image`: Matrix{Int} representing the grayscale image. Each element is a pixel intensity ranging from 0 to 255.\n    \n    # Returns\n    - `Matrix{Int}`: The image rotated clockwise by 90 degrees.\n    \n    # Examples\n    ```julia\n    rotate_image_clockwise([1 2 3; 4 5 6; 7 8 9])\n    # Output: [7 4 1; 8 5 2; 9 6 3]", "instruction": "Write a Julia function `function rotate_image_clockwise(image::Matrix{Int})` to solve the following problem:\nRotate a grayscale image represented by an n x m matrix clockwise by 90 degrees.\n    \n    # Arguments\n    - `image`: Matrix{Int} representing the grayscale image. Each element is a pixel intensity ranging from 0 to 255.\n    \n    # Returns\n    - `Matrix{Int}`: The image rotated clockwise by 90 degrees.\n    \n    # Examples\n    ```julia\n    rotate_image_clockwise([1 2 3; 4 5 6; 7 8 9])\n    # Output: [7 4 1; 8 5 2; 9 6 3]", "level": "easy"}
{"task_id": "Julia/29", "prompt": "function blur_image(image::Matrix{Int}, n::Int, m::Int) :: Matrix{Int}\n    \"\"\"\n    Apply a blur effect to a 2D image represented by a matrix of integers, where each integer represents the pixel's grayscale value. The blur effect is applied to the inner pixels, keeping the outermost pixels unchanged. Each inner pixel's new grayscale value is the average of its own value and the values of its immediate neighbors (up, down, left, right), rounded to the nearest integer.\n\n    # Arguments\n    - `image`: A matrix of integers representing the image's pixels.\n    - `n`: The number of rows in the image.\n    - `m`: The number of columns in the image.\n\n    # Returns\n    - A new matrix representing the blurred image.\n\n    # Examples\n    blur_image([100 0 100 0 50; 50 100 200 0 0; 50 50 100 100 200; 100 100 50 50 100], 4, 5)\n    # Output: [100 0 100 0 50; 50 80 100 60 0; 50 80 100 90 200; 100 100 50 50 100]\n    \"\"\"", "canonical_solution": "    new_image = copy(image)\n    for i in 2:n-1\n        for j in 2:m-1\n            new_image[i, j] = round(Int, (image[i-1, j] + image[i+1, j] + image[i, j-1] + image[i, j+1] + image[i, j]) / 5)\n        end\n    end\n    return new_image\nend", "test": "@assert blur_image([100 0 100 0 50; 50 100 200 0 0; 50 50 100 100 200; 100 100 50 50 100], 4, 5) == [100 0 100 0 50; 50 80 100 60 0; 50 80 100 90 200; 100 100 50 50 100]\n@assert blur_image([255 255; 255 255], 2, 2) == [255 255; 255 255] # Edge case: Small image where no blur is applied\n@assert blur_image([10 20 30; 40 50 60; 70 80 90], 3, 3) == [10 20 30; 40 50 60; 70 80 90] # Test with different values\n@assert blur_image([10 30; 40 60; 70 90], 3, 2) == [10 30; 40 60; 70 90] # Test with different values", "entry_point": "blur_image", "signature": "function blur_image(image::Matrix{Int}, n::Int, m::Int) :: Matrix{Int}", "docstring": "Apply a blur effect to a 2D image represented by a matrix of integers, where each integer represents the pixel's grayscale value. The blur effect is applied to the inner pixels, keeping the outermost pixels unchanged. Each inner pixel's new grayscale value is the average of its own value and the values of its immediate neighbors (up, down, left, right), rounded to the nearest integer.\n\n    # Arguments\n    - `image`: A matrix of integers representing the image's pixels.\n    - `n`: The number of rows in the image.\n    - `m`: The number of columns in the image.\n\n    # Returns\n    - A new matrix representing the blurred image.\n\n    # Examples\n    blur_image([100 0 100 0 50; 50 100 200 0 0; 50 50 100 100 200; 100 100 50 50 100], 4, 5)\n    # Output: [100 0 100 0 50; 50 80 100 60 0; 50 80 100 90 200; 100 100 50 50 100]", "instruction": "Write a Julia function `function blur_image(image::Matrix{Int}, n::Int, m::Int) :: Matrix{Int}` to solve the following problem:\nApply a blur effect to a 2D image represented by a matrix of integers, where each integer represents the pixel's grayscale value. The blur effect is applied to the inner pixels, keeping the outermost pixels unchanged. Each inner pixel's new grayscale value is the average of its own value and the values of its immediate neighbors (up, down, left, right), rounded to the nearest integer.\n\n    # Arguments\n    - `image`: A matrix of integers representing the image's pixels.\n    - `n`: The number of rows in the image.\n    - `m`: The number of columns in the image.\n\n    # Returns\n    - A new matrix representing the blurred image.\n\n    # Examples\n    blur_image([100 0 100 0 50; 50 100 200 0 0; 50 50 100 100 200; 100 100 50 50 100], 4, 5)\n    # Output: [100 0 100 0 50; 50 80 100 60 0; 50 80 100 90 200; 100 100 50 50 100]", "level": "easy"}
{"task_id": "Julia/30", "prompt": "function calculate_mine_proximity(grid::Array{Char,2}) :: Array{Char,2}\n    \"\"\"\n    This function takes a grid representing a Minesweeper field and calculates the number\n    of adjacent mines for each non-mine cell. The grid is a 2D array of characters, where\n    '*' represents a mine and '?' represents an unknown cell. The function returns a new\n    grid where each '?' is replaced with the count of adjacent mines (including diagonals).\n\n    Example:\n    >>> calculate_mine_proximity(['*' '?' '?'; '?' '?' '?'; '?' '*' '?'])\n    ['*' '1' '0'; '2' '2' '1'; '1' '*' '1']\n\n    >>> calculate_mine_proximity(['*' '*' '?'; '?' '?' '?'; '?' '?' '*'])\n    ['*' '*' '1'; '2' '4' '2'; '0' '2' '*']\n    \"\"\"", "canonical_solution": "    rows, cols = size(grid)\n    for i in 1:rows\n        for j in 1:cols\n            if grid[i, j] == '?'\n                mine_count = 0\n                for di in -1:1\n                    for dj in -1:1\n                        ni, nj = i + di, j + dj\n                        if 1 <= ni <= rows && 1 <= nj <= cols && grid[ni, nj] == '*'\n                            mine_count += 1\n                        end\n                    end\n                end\n                grid[i, j] = Char(mine_count + 48)  # Convert to char\n            end\n        end\n    end\n    return grid\nend", "test": "@assert calculate_mine_proximity(['*' '?' '?'; '?' '?' '?'; '?' '*' '?']) == ['*' '1' '0'; '2' '2' '1'; '1' '*' '1']\n@assert calculate_mine_proximity(['*' '*' '?'; '?' '?' '?'; '?' '?' '*']) == ['*' '*' '1'; '2' '3' '2'; '0' '1' '*']\n@assert calculate_mine_proximity(['?' '?' '?'; '?' '*' '?'; '?' '?' '?']) == ['1' '1' '1'; '1' '*' '1'; '1' '1' '1']", "entry_point": "calculate_mine_proximity", "signature": "function calculate_mine_proximity(grid::Array{Char,2}) :: Array{Char,2}", "docstring": "This function takes a grid representing a Minesweeper field and calculates the number\n    of adjacent mines for each non-mine cell. The grid is a 2D array of characters, where\n    '*' represents a mine and '?' represents an unknown cell. The function returns a new\n    grid where each '?' is replaced with the count of adjacent mines (including diagonals).\n\n    Example:\n    >>> calculate_mine_proximity(['*' '?' '?'; '?' '?' '?'; '?' '*' '?'])\n    ['*' '1' '0'; '2' '2' '1'; '1' '*' '1']\n\n    >>> calculate_mine_proximity(['*' '*' '?'; '?' '?' '?'; '?' '?' '*'])\n    ['*' '*' '1'; '2' '4' '2'; '0' '2' '*']", "instruction": "Write a Julia function `function calculate_mine_proximity(grid::Array{Char,2}) :: Array{Char,2}` to solve the following problem:\nThis function takes a grid representing a Minesweeper field and calculates the number\n    of adjacent mines for each non-mine cell. The grid is a 2D array of characters, where\n    '*' represents a mine and '?' represents an unknown cell. The function returns a new\n    grid where each '?' is replaced with the count of adjacent mines (including diagonals).\n\n    Example:\n    >>> calculate_mine_proximity(['*' '?' '?'; '?' '?' '?'; '?' '*' '?'])\n    ['*' '1' '0'; '2' '2' '1'; '1' '*' '1']\n\n    >>> calculate_mine_proximity(['*' '*' '?'; '?' '?' '?'; '?' '?' '*'])\n    ['*' '*' '1'; '2' '4' '2'; '0' '2' '*']", "level": "hard"}
{"task_id": "Julia/31", "prompt": "function bacteria_distribution(initial_count::Int, days::Int) :: Array{Int, 2}\n    \"\"\"\n    Compute the distribution of bacteria in a 9x9 petri dish over a specified number of days. Initially, a given number of bacteria are placed in the center of the dish. Suppose a bacterium lives only one day. Each day, each bacterium produces 10 offspring. Two of these remain in the original cell, while the other eight are evenly distributed among the adjacent cells.\n\n    # Examples\n    - `bacteria_distribution(2, 1)` results in a 9x9 matrix with certain cells having bacteria counts.\n    - `bacteria_distribution(3, 2)` will show the spread of bacteria after 2 days starting from 3 bacteria.\n\n    The function returns a 9x9 matrix representing the bacteria distribution in the dish.\n    \"\"\"", "canonical_solution": "    # Initialize a 9x9 matrix\n    dish = zeros(Int, 9, 9)\n\n    # Place initial bacteria in the center\n    dish[5, 5] = initial_count\n\n    for day in 1:days\n        # Temporary matrix to store the new day's distribution\n        new_dish = zeros(Int, 9, 9)\n\n        for i in 1:9, j in 1:9\n            if dish[i, j] > 0\n                # Calculate offspring\n                offspring = dish[i, j] * 10\n\n                # Two stay in the original cell\n                new_dish[i, j] += 2 * dish[i, j]\n\n                # Distribute the remaining 8 to adjacent cells\n                for di in -1:1, dj in -1:1\n                    if di == 0 && dj == 0\n                        continue\n                    end\n                    new_i, new_j = i + di, j + dj\n                    if new_i >= 1 && new_i <= 9 && new_j >= 1 && new_j <= 9\n                        new_dish[new_i, new_j] += dish[i, j]\n                    end\n                end\n            end\n        end\n\n        # Update dish for the next day\n        dish = new_dish\n    end\n    return dish\nend\n", "test": "@assert bacteria_distribution(2, 1) == [\n    0 0 0 0 0 0 0 0 0;\n    0 0 0 0 0 0 0 0 0;\n    0 0 0 0 0 0 0 0 0;\n    0 0 0 2 2 2 0 0 0;\n    0 0 0 2 4 2 0 0 0;\n    0 0 0 2 2 2 0 0 0;\n    0 0 0 0 0 0 0 0 0;\n    0 0 0 0 0 0 0 0 0;\n    0 0 0 0 0 0 0 0 0\n]\n\n@assert bacteria_distribution(2, 4) == [2 8 20 32 38 32 20 8 2; 8 40 104 176 208 176 104 40 8; 20 104 284 488 584 488 284 104 20; 32 176 488 856 1024 856 488 176 32; 38 208 584 1024 1232 1024 584 208 38; 32 176 488 856 1024 856 488 176 32; 20 104 284 488 584 488 284 104 20; 8 40 104 176 208 176 104 40 8; 2 8 20 32 38 32 20 8 2]", "entry_point": "bacteria_distribution", "signature": "function bacteria_distribution(initial_count::Int, days::Int) :: Array{Int, 2}", "docstring": "Compute the distribution of bacteria in a 9x9 petri dish over a specified number of days. Initially, a given number of bacteria are placed in the center of the dish. Suppose a bacterium lives only one day. Each day, each bacterium produces 10 offspring. Two of these remain in the original cell, while the other eight are evenly distributed among the adjacent cells.\n\n    # Examples\n    - `bacteria_distribution(2, 1)` results in a 9x9 matrix with certain cells having bacteria counts.\n    - `bacteria_distribution(3, 2)` will show the spread of bacteria after 2 days starting from 3 bacteria.\n\n    The function returns a 9x9 matrix representing the bacteria distribution in the dish.", "instruction": "Write a Julia function `function bacteria_distribution(initial_count::Int, days::Int) :: Array{Int, 2}` to solve the following problem:\nCompute the distribution of bacteria in a 9x9 petri dish over a specified number of days. Initially, a given number of bacteria are placed in the center of the dish. Suppose a bacterium lives only one day. Each day, each bacterium produces 10 offspring. Two of these remain in the original cell, while the other eight are evenly distributed among the adjacent cells.\n\n    # Examples\n    - `bacteria_distribution(2, 1)` results in a 9x9 matrix with certain cells having bacteria counts.\n    - `bacteria_distribution(3, 2)` will show the spread of bacteria after 2 days starting from 3 bacteria.\n\n    The function returns a 9x9 matrix representing the bacteria distribution in the dish.", "level": "hard"}
{"task_id": "Julia/32", "prompt": "function count_grass_clusters(field::Vector{String})\n    \"\"\"\n    Count the number of grass clusters in a given field.\n\n    Given a field represented as an R x C grid with characters '#' representing grass and '.' representing empty spaces, calculate the number of grass clusters. A grass cluster consists of one or more adjacent grass patches sharing at least one side.\n\n    Parameters:\n    - R (Int): The number of rows in the field.\n    - C (Int): The number of columns in the field.\n    - field (Vector{String}): A 2D array of characters representing the field.\n\n    Returns:\n    - Int: The number of grass clusters in the field.\n\n    Example:\n    >>> count_grass_clusters([\"#....#\", \"..#...\", \"..#..#\", \"...##.\", \"#....#\"])\n    7\n    >>> count_grass_clusters([\".#....\", \"..#...\", \"..#..#\", \"...##.\", \".#....\"])\n    5\n    \"\"\"", "canonical_solution": "    R = length(field)\n    C = length(field[1])\n    visited = falses(R, C)\n    count = 0\n\n    function dfs(r::Int, c::Int)\n        if r < 0 || r >= R || c < 0 || c >= C || visited[r+1, c+1] || field[r+1][c+1] != '#'\n            return\n        end\n        visited[r+1, c+1] = true\n        dfs(r-1, c)\n        dfs(r+1, c)\n        dfs(r, c-1)\n        dfs(r, c+1)\n    end\n\n    for r in 0:R-1\n        for c in 0:C-1\n            if !visited[r+1, c+1] && field[r+1][c+1] == '#'\n                dfs(r, c)\n                count += 1\n            end\n        end\n    end\n\n    return count\nend", "test": "@assert count_grass_clusters([\"#....#\", \"..#...\", \"..#..#\", \"...##.\", \"#....#\"]) == 7\n@assert count_grass_clusters([\".#....\", \"..#...\", \"..#..#\", \"...##.\", \".#....\"]) == 5\n@assert count_grass_clusters([\"#..#.\", \".##.#\", \"....#\", \".#.#.\"]) == 6\n@assert count_grass_clusters([\"###\", \"###\", \"###\"]) == 1", "entry_point": "count_grass_clusters", "signature": "function count_grass_clusters(field::Vector{String})", "docstring": "Count the number of grass clusters in a given field.\n\n    Given a field represented as an R x C grid with characters '#' representing grass and '.' representing empty spaces, calculate the number of grass clusters. A grass cluster consists of one or more adjacent grass patches sharing at least one side.\n\n    Parameters:\n    - R (Int): The number of rows in the field.\n    - C (Int): The number of columns in the field.\n    - field (Vector{String}): A 2D array of characters representing the field.\n\n    Returns:\n    - Int: The number of grass clusters in the field.\n\n    Example:\n    >>> count_grass_clusters([\"#....#\", \"..#...\", \"..#..#\", \"...##.\", \"#....#\"])\n    7\n    >>> count_grass_clusters([\".#....\", \"..#...\", \"..#..#\", \"...##.\", \".#....\"])\n    5", "instruction": "Write a Julia function `function count_grass_clusters(field::Vector{String})` to solve the following problem:\nCount the number of grass clusters in a given field.\n\n    Given a field represented as an R x C grid with characters '#' representing grass and '.' representing empty spaces, calculate the number of grass clusters. A grass cluster consists of one or more adjacent grass patches sharing at least one side.\n\n    Parameters:\n    - R (Int): The number of rows in the field.\n    - C (Int): The number of columns in the field.\n    - field (Vector{String}): A 2D array of characters representing the field.\n\n    Returns:\n    - Int: The number of grass clusters in the field.\n\n    Example:\n    >>> count_grass_clusters([\"#....#\", \"..#...\", \"..#..#\", \"...##.\", \"#....#\"])\n    7\n    >>> count_grass_clusters([\".#....\", \"..#...\", \"..#..#\", \"...##.\", \".#....\"])\n    5", "level": "hard"}
{"task_id": "Julia/33", "prompt": "function fill_snake_matrix(n::Int) :: Matrix{Int}\n    \"\"\"\n    Generate a snake-filled matrix of size n x n.\n\n    Given a positive integer n, create an n x n matrix and fill it in a snake-like pattern.\n    Starting from the top-left corner, populate the matrix with integers from 1 to n^2 in a zigzag manner.\n    - Fill the odd-numbered diagonals (left-bottom to right-top) from left to right.\n    - Fill the even-numbered diagonals (right-top to left-bottom) from top to bottom.\n\n    Example:\n    >>> fill_snake_matrix(4)\n    4\u00d74 Matrix{Int64}:\n    1  2  6  7\n    3  5  8  13\n    4  9  12 14\n    10 11 15 16\n    \"\"\"", "canonical_solution": "    mat = Matrix{Int}(undef, n, n)\n    num = 1\n\n    for slice in 1:(2*n - 1)\n        if slice % 2 == 1\n            # Odd-numbered diagonals\n            i = slice <= n ? slice : n\n            j = slice <= n ? 1 : slice - n + 1\n            while i >= 1 && j <= n\n                mat[i, j] = num\n                num += 1\n                i -= 1\n                j += 1\n            end\n        else\n            # Even-numbered diagonals\n            i = slice <= n ? 1 : slice - n + 1\n            j = slice <= n ? slice : n\n            while j >= 1 && i <= n\n                mat[i, j] = num\n                num += 1\n                i += 1\n                j -= 1\n            end\n        end\n    end\n\n    return mat\nend", "test": "@assert fill_snake_matrix(4) == [1 2 6 7; 3 5 8 13; 4 9 12 14; 10 11 15 16]\n@assert fill_snake_matrix(3) == [1 2 6; 3 5 7; 4 8 9]\n@assert fill_snake_matrix(1) == [1;;]", "entry_point": "fill_snake_matrix", "signature": "function fill_snake_matrix(n::Int) :: Matrix{Int}", "docstring": "Generate a snake-filled matrix of size n x n.\n\n    Given a positive integer n, create an n x n matrix and fill it in a snake-like pattern.\n    Starting from the top-left corner, populate the matrix with integers from 1 to n^2 in a zigzag manner.\n    - Fill the odd-numbered diagonals (left-bottom to right-top) from left to right.\n    - Fill the even-numbered diagonals (right-top to left-bottom) from top to bottom.\n\n    Example:\n    >>> fill_snake_matrix(4)\n    4\u00d74 Matrix{Int64}:\n    1  2  6  7\n    3  5  8  13\n    4  9  12 14\n    10 11 15 16", "instruction": "Write a Julia function `function fill_snake_matrix(n::Int) :: Matrix{Int}` to solve the following problem:\nGenerate a snake-filled matrix of size n x n.\n\n    Given a positive integer n, create an n x n matrix and fill it in a snake-like pattern.\n    Starting from the top-left corner, populate the matrix with integers from 1 to n^2 in a zigzag manner.\n    - Fill the odd-numbered diagonals (left-bottom to right-top) from left to right.\n    - Fill the even-numbered diagonals (right-top to left-bottom) from top to bottom.\n\n    Example:\n    >>> fill_snake_matrix(4)\n    4\u00d74 Matrix{Int64}:\n    1  2  6  7\n    3  5  8  13\n    4  9  12 14\n    10 11 15 16", "level": "hard"}
{"task_id": "Julia/34", "prompt": "function calculate_highest_scholarship(students::Vector{Tuple{String, Int, Int, Char, Char, Int}}) :: Tuple{String, Int}\n    \"\"\"\n    Calculate the student(s) who receive the highest total scholarship amount among a group of students based on specific criteria.\n\n    Parameters:\n    - students (Vector{Tuple{String, Int, Int, Char, Char, Int}}): A vector of tuples representing students' data. Each tuple contains:\n    - Student's name (String)\n    - Final average score (Int)\n    - Class rating score (Int)\n    - Whether the student is a student cadre (Char: 'Y' for yes, 'N' for no)\n    - Whether the student is from a western province (Char: 'Y' for yes, 'N' for no)\n    - Number of papers published (Int)\n\n    Returns:\n    - Tuple{String, Int}: A tuple containing the name of the student(s) with the highest total scholarship amount and the total scholarship amount received.\n\n    Example:\n    ```julia\n    students_data = [(\"YaoLin\", 87, 82, 'Y', 'N', 0),\n                    (\"ChenRuiyi\", 88, 78, 'N', 'Y', 1),\n                    (\"LiXin\", 92, 88, 'N', 'N', 0),\n                    (\"ZhangQin\", 83, 87, 'Y', 'N', 1)]\n\n    calculate_highest_scholarship(students_data)\n    # Output: (\"ChenRuiyi\", 9000)\n    \"\"\"", "canonical_solution": "    max_scholarship = 0\n    top_students = []\n\n    for student in students\n        name, avg_score, class_score, is_cadre, is_western, num_papers = student\n        scholarship = 0\n\n        if avg_score > 80 && num_papers >= 1\n            scholarship += 8000\n        end\n\n        if avg_score > 85 && class_score > 80 && is_western == 'Y'\n            scholarship += 4000\n        end\n\n        if avg_score > 90\n            scholarship += 2000\n        end\n\n        if avg_score > 85 && is_western == 'Y'\n            scholarship += 1000\n        end\n\n        if class_score > 80 && is_cadre == 'Y'\n            scholarship += 850\n        end\n\n        if scholarship > max_scholarship\n            max_scholarship = scholarship\n            top_students = [name]\n        elseif scholarship == max_scholarship\n            push!(top_students, name)\n        end\n    end\n    return (top_students[1], max_scholarship)\nend", "test": "students_data = [(\"YaoLin\", 87, 82, 'Y', 'N', 0),\n                 (\"ChenRuiyi\", 88, 78, 'N', 'Y', 1),\n                 (\"LiXin\", 92, 88, 'N', 'N', 0),\n                 (\"ZhangQin\", 83, 87, 'Y', 'N', 1)]\n\n@assert calculate_highest_scholarship(students_data) == (\"ChenRuiyi\", 9000)\n\nstudents_data = [(\"YaoLin\", 87, 82, 'Y', 'N', 0),\n                 (\"LiXin\", 92, 88, 'N', 'N', 0),\n                 (\"ZhangQin\", 83, 87, 'Y', 'N', 1)]\n@assert calculate_highest_scholarship(students_data) == (\"ZhangQin\", 8850)", "entry_point": "calculate_highest_scholarship", "signature": "function calculate_highest_scholarship(students::Vector{Tuple{String, Int, Int, Char, Char, Int}}) :: Tuple{String, Int}", "docstring": "Calculate the student(s) who receive the highest total scholarship amount among a group of students based on specific criteria.\n\n    Parameters:\n    - students (Vector{Tuple{String, Int, Int, Char, Char, Int}}): A vector of tuples representing students' data. Each tuple contains:\n    - Student's name (String)\n    - Final average score (Int)\n    - Class rating score (Int)\n    - Whether the student is a student cadre (Char: 'Y' for yes, 'N' for no)\n    - Whether the student is from a western province (Char: 'Y' for yes, 'N' for no)\n    - Number of papers published (Int)\n\n    Returns:\n    - Tuple{String, Int}: A tuple containing the name of the student(s) with the highest total scholarship amount and the total scholarship amount received.\n\n    Example:\n    ```julia\n    students_data = [(\"YaoLin\", 87, 82, 'Y', 'N', 0),\n                    (\"ChenRuiyi\", 88, 78, 'N', 'Y', 1),\n                    (\"LiXin\", 92, 88, 'N', 'N', 0),\n                    (\"ZhangQin\", 83, 87, 'Y', 'N', 1)]\n\n    calculate_highest_scholarship(students_data)\n    # Output: (\"ChenRuiyi\", 9000)", "instruction": "Write a Julia function `function calculate_highest_scholarship(students::Vector{Tuple{String, Int, Int, Char, Char, Int}}) :: Tuple{String, Int}` to solve the following problem:\nCalculate the student(s) who receive the highest total scholarship amount among a group of students based on specific criteria.\n\n    Parameters:\n    - students (Vector{Tuple{String, Int, Int, Char, Char, Int}}): A vector of tuples representing students' data. Each tuple contains:\n    - Student's name (String)\n    - Final average score (Int)\n    - Class rating score (Int)\n    - Whether the student is a student cadre (Char: 'Y' for yes, 'N' for no)\n    - Whether the student is from a western province (Char: 'Y' for yes, 'N' for no)\n    - Number of papers published (Int)\n\n    Returns:\n    - Tuple{String, Int}: A tuple containing the name of the student(s) with the highest total scholarship amount and the total scholarship amount received.\n\n    Example:\n    ```julia\n    students_data = [(\"YaoLin\", 87, 82, 'Y', 'N', 0),\n                    (\"ChenRuiyi\", 88, 78, 'N', 'Y', 1),\n                    (\"LiXin\", 92, 88, 'N', 'N', 0),\n                    (\"ZhangQin\", 83, 87, 'Y', 'N', 1)]\n\n    calculate_highest_scholarship(students_data)\n    # Output: (\"ChenRuiyi\", 9000)", "level": "hard"}
{"task_id": "Julia/35", "prompt": "function is_lucky_word(word::String)::Tuple{String, Int64}\n    \"\"\"\n    Determine if a word is a Lucky Word and calculate maxn - minn.\n    \n    A word is considered a Lucky Word if the difference between the maximum and minimum\n    frequencies of letters in the word is a prime number.\n    \n    Args:\n    - word (String): The input word containing only lowercase letters.\n    \n    Returns:\n    - Tuple{String, Int64}: A tuple containing two elements:\n      - If the word is a Lucky Word, the first element is \"Lucky Word\", otherwise \"No Answer\".\n      - The second element is the value of maxn - minn, where maxn is the maximum frequency of\n        a letter in the word, and minn is the minimum frequency of a letter in the word.\n    \n    Examples:\n    >>> is_lucky_word(\"error\")\n    (\"Lucky Word\", 2)\n    \n    >>> is_lucky_word(\"olympic\")\n    (\"Lucky Word\", 1)\n    \n    >>> is_lucky_word(\"programming\")\n    (\"No Answer\", 0)\n    \"\"\"", "canonical_solution": "    # Initialize a dictionary to store letter frequencies\n    letter_freq = Dict{Char, Int}()\n\n    # Calculate letter frequencies\n    for letter in word\n        if haskey(letter_freq, letter)\n            letter_freq[letter] += 1\n        else\n            letter_freq[letter] = 1\n        end\n    end\n\n    # Find maxn and minn\n    maxn = maximum(values(letter_freq))\n    minn = minimum(values(letter_freq))\n\n    # Calculate maxn - minn\n    diff = maxn - minn\n\n    # Check if diff is prime\n    is_prime = isprime(diff)\n\n    if is_prime\n        return (\"Lucky Word\", diff)\n    else\n        return (\"No Answer\", 0)\n    end\nend\n\nfunction isprime(n::Int)::Bool\n    if n <= 1\n        return false\n    end\n    \n    if n == 2\n        return true\n    end\n    \n    if n % 2 == 0\n        return false\n    end\n    \n    for i in 3:2:isqrt(n)\n        if n % i == 0\n            return false\n        end\n    end\n    \n    return true\nend", "test": "# Test cases for is_lucky_word function\n@assert is_lucky_word(\"error\") == (\"Lucky Word\", 2)\n@assert is_lucky_word(\"olympic\") == (\"No Answer\", 0)\n@assert is_lucky_word(\"programming\") == (\"No Answer\", 0)\n@assert is_lucky_word(\"banana\") == (\"Lucky Word\", 2)", "entry_point": "is_lucky_word", "signature": "function is_lucky_word(word::String)::Tuple{String, Int64}", "docstring": "Determine if a word is a Lucky Word and calculate maxn - minn.\n    \n    A word is considered a Lucky Word if the difference between the maximum and minimum\n    frequencies of letters in the word is a prime number.\n    \n    Args:\n    - word (String): The input word containing only lowercase letters.\n    \n    Returns:\n    - Tuple{String, Int64}: A tuple containing two elements:\n      - If the word is a Lucky Word, the first element is \"Lucky Word\", otherwise \"No Answer\".\n      - The second element is the value of maxn - minn, where maxn is the maximum frequency of\n        a letter in the word, and minn is the minimum frequency of a letter in the word.\n    \n    Examples:\n    >>> is_lucky_word(\"error\")\n    (\"Lucky Word\", 2)\n    \n    >>> is_lucky_word(\"olympic\")\n    (\"Lucky Word\", 1)\n    \n    >>> is_lucky_word(\"programming\")\n    (\"No Answer\", 0)", "instruction": "Write a Julia function `function is_lucky_word(word::String)::Tuple{String, Int64}` to solve the following problem:\nDetermine if a word is a Lucky Word and calculate maxn - minn.\n    \n    A word is considered a Lucky Word if the difference between the maximum and minimum\n    frequencies of letters in the word is a prime number.\n    \n    Args:\n    - word (String): The input word containing only lowercase letters.\n    \n    Returns:\n    - Tuple{String, Int64}: A tuple containing two elements:\n      - If the word is a Lucky Word, the first element is \"Lucky Word\", otherwise \"No Answer\".\n      - The second element is the value of maxn - minn, where maxn is the maximum frequency of\n        a letter in the word, and minn is the minimum frequency of a letter in the word.\n    \n    Examples:\n    >>> is_lucky_word(\"error\")\n    (\"Lucky Word\", 2)\n    \n    >>> is_lucky_word(\"olympic\")\n    (\"Lucky Word\", 1)\n    \n    >>> is_lucky_word(\"programming\")\n    (\"No Answer\", 0)", "level": "hard"}
{"task_id": "Julia/36", "prompt": "function find_max_and_lines(input::Vector{Vector{Int}})\n    \"\"\"\n    Given a 2D array of unsigned integers, find the maximum integer and the line numbers (1-based) where it appears. If the maximum integer appears in multiple lines, list the line numbers in ascending order and separate them with commas.\n\n    Parameters:\n    - input (Vector{Vector{Int}}): A 2D array of unsigned integers where each row represents a line.\n\n    Returns:\n    - Tuple{Int, Vector{Int}}: A tuple containing the maximum integer and a vector of line numbers where it appears.\n\n    Example:\n    >>> find_max_and_lines([[1, 3, 5, 23, 6, 8, 14], [20, 22, 13, 4, 16], [23, 12, 17, 22], [2, 6, 10, 9, 3, 6], [22, 21, 20, 8, 10], [22, 1, 23, 6, 8, 19, 23]])\n    (23, [1, 3, 6])\n    \"\"\"", "canonical_solution": "    max_num = -1\n    line_numbers = Vector{Int}()\n    \n    for (i, line) in enumerate(input)\n        max_line = maximum(line)\n        if max_line > max_num\n            max_num = max_line\n            line_numbers = [i]\n        elseif max_line == max_num\n            push!(line_numbers, i)\n        end\n    end\n    \n    return (max_num, line_numbers)\nend", "test": "# Testcase 1\n@assert find_max_and_lines([[1, 3, 5, 23, 6, 8, 14], [20, 22, 13, 4, 16], [23, 12, 17, 22], [2, 6, 10, 9, 3, 6], [22, 21, 20, 8, 10], [22, 1, 23, 6, 8, 19, 23]]) == (23, [1, 3, 6])\n\n# Testcase 2\n@assert find_max_and_lines([[5, 5, 5, 5], [1, 2, 3], [4, 4, 4]]) == (5, [1])\n\n# Testcase 3\n@assert find_max_and_lines([[10, 20, 30], [40, 50], [60, 70, 80, 90]]) == (90, [3])\n\n# Testcase 4\n@assert find_max_and_lines([[1]]) == (1, [1])", "entry_point": "find_max_and_lines", "signature": "function find_max_and_lines(input::Vector{Vector{Int}})", "docstring": "Given a 2D array of unsigned integers, find the maximum integer and the line numbers (1-based) where it appears. If the maximum integer appears in multiple lines, list the line numbers in ascending order and separate them with commas.\n\n    Parameters:\n    - input (Vector{Vector{Int}}): A 2D array of unsigned integers where each row represents a line.\n\n    Returns:\n    - Tuple{Int, Vector{Int}}: A tuple containing the maximum integer and a vector of line numbers where it appears.\n\n    Example:\n    >>> find_max_and_lines([[1, 3, 5, 23, 6, 8, 14], [20, 22, 13, 4, 16], [23, 12, 17, 22], [2, 6, 10, 9, 3, 6], [22, 21, 20, 8, 10], [22, 1, 23, 6, 8, 19, 23]])\n    (23, [1, 3, 6])", "instruction": "Write a Julia function `function find_max_and_lines(input::Vector{Vector{Int}})` to solve the following problem:\nGiven a 2D array of unsigned integers, find the maximum integer and the line numbers (1-based) where it appears. If the maximum integer appears in multiple lines, list the line numbers in ascending order and separate them with commas.\n\n    Parameters:\n    - input (Vector{Vector{Int}}): A 2D array of unsigned integers where each row represents a line.\n\n    Returns:\n    - Tuple{Int, Vector{Int}}: A tuple containing the maximum integer and a vector of line numbers where it appears.\n\n    Example:\n    >>> find_max_and_lines([[1, 3, 5, 23, 6, 8, 14], [20, 22, 13, 4, 16], [23, 12, 17, 22], [2, 6, 10, 9, 3, 6], [22, 21, 20, 8, 10], [22, 1, 23, 6, 8, 19, 23]])\n    (23, [1, 3, 6])", "level": "middle"}
{"task_id": "Julia/37", "prompt": "function longest_plateau(numbers::Vector{Int}) :: Int\n    \"\"\"\n    Finds the length of the longest contiguous sequence of equal values in a sorted array. \n    A plateau is defined as a sequence of consecutive elements with the same value that cannot be extended. \n    For example, in the array [1, 2, 2, 3, 3, 3, 4, 5, 5, 6], the longest plateau is [3, 3, 3], with a length of 3.\n\n    Examples:\n    >>> longest_plateau([1, 2, 2, 3, 3, 3, 4, 5, 5, 6])\n    3\n    >>> longest_plateau([1, 1, 2, 2, 3, 3, 4, 4, 4, 4])\n    4\n    \"\"\"", "canonical_solution": "    max_length = 0\n    current_length = 1\n\n    for i in 2:length(numbers)\n        if numbers[i] == numbers[i-1]\n            current_length += 1\n        else\n            max_length = max(max_length, current_length)\n            current_length = 1\n        end\n    end\n\n    return max(max_length, current_length)\nend", "test": "@assert longest_plateau([1, 2, 2, 3, 3, 3, 4, 5, 5, 6]) == 3\n@assert longest_plateau([1, 1, 2, 2, 3, 3, 4, 4, 4, 4]) == 4\n@assert longest_plateau([1, 1, 1, 1, 1, 1]) == 6\n@assert longest_plateau([1, 2, 3, 4, 5, 6]) == 1", "entry_point": "longest_plateau", "signature": "function longest_plateau(numbers::Vector{Int}) :: Int", "docstring": "Finds the length of the longest contiguous sequence of equal values in a sorted array. \n    A plateau is defined as a sequence of consecutive elements with the same value that cannot be extended. \n    For example, in the array [1, 2, 2, 3, 3, 3, 4, 5, 5, 6], the longest plateau is [3, 3, 3], with a length of 3.\n\n    Examples:\n    >>> longest_plateau([1, 2, 2, 3, 3, 3, 4, 5, 5, 6])\n    3\n    >>> longest_plateau([1, 1, 2, 2, 3, 3, 4, 4, 4, 4])\n    4", "instruction": "Write a Julia function `function longest_plateau(numbers::Vector{Int}) :: Int` to solve the following problem:\nFinds the length of the longest contiguous sequence of equal values in a sorted array. \n    A plateau is defined as a sequence of consecutive elements with the same value that cannot be extended. \n    For example, in the array [1, 2, 2, 3, 3, 3, 4, 5, 5, 6], the longest plateau is [3, 3, 3], with a length of 3.\n\n    Examples:\n    >>> longest_plateau([1, 2, 2, 3, 3, 3, 4, 5, 5, 6])\n    3\n    >>> longest_plateau([1, 1, 2, 2, 3, 3, 4, 4, 4, 4])\n    4", "level": "easy"}
{"task_id": "Julia/38", "prompt": "function calculate_watering_time(student_water_needs::Vector{Int}, faucets::Int) :: Int\n    \"\"\"\n    Calculates the total time required for a group of students to fill their water containers using a limited number of faucets.\n\n    Each faucet delivers water at a constant rate of 1 unit per second. Students are queued in a given order and each has a specific amount of water they need to collect. Students fill their containers simultaneously using the available faucets. As soon as a student finishes, the next in line begins to fill their container without delay. If there are more faucets than students, only the needed number of faucets are used.\n\n    # Arguments\n    - `student_water_needs`: A list of integers representing the amount of water each student needs.\n    - `faucets`: The number of available faucets.\n\n    # Examples\n    >>> calculate_watering_time([4, 4, 1, 2, 1], 3)\n    4\n    >>> calculate_watering_time([2, 3, 1], 2)\n    3\n    \"\"\"", "canonical_solution": "    total_time = 0\n    while sum(student_water_needs) > 0\n        for i in 1:min(faucets, length(student_water_needs))\n            if student_water_needs[i] > 0\n                student_water_needs[i] -= 1\n            end\n        end\n        student_water_needs = filter(x -> x > 0, student_water_needs)\n        total_time += 1\n    end\n    return total_time\nend", "test": "@assert calculate_watering_time([4, 4, 1, 2, 1], 3) == 4\n@assert calculate_watering_time([2, 3, 1], 2) == 3\n@assert calculate_watering_time([5, 3, 2, 1], 1) == 11\n@assert calculate_watering_time([1, 1, 1, 1, 1], 5) == 1", "entry_point": "calculate_watering_time", "signature": "function calculate_watering_time(student_water_needs::Vector{Int}, faucets::Int) :: Int", "docstring": "Calculates the total time required for a group of students to fill their water containers using a limited number of faucets.\n\n    Each faucet delivers water at a constant rate of 1 unit per second. Students are queued in a given order and each has a specific amount of water they need to collect. Students fill their containers simultaneously using the available faucets. As soon as a student finishes, the next in line begins to fill their container without delay. If there are more faucets than students, only the needed number of faucets are used.\n\n    # Arguments\n    - `student_water_needs`: A list of integers representing the amount of water each student needs.\n    - `faucets`: The number of available faucets.\n\n    # Examples\n    >>> calculate_watering_time([4, 4, 1, 2, 1], 3)\n    4\n    >>> calculate_watering_time([2, 3, 1], 2)\n    3", "instruction": "Write a Julia function `function calculate_watering_time(student_water_needs::Vector{Int}, faucets::Int) :: Int` to solve the following problem:\nCalculates the total time required for a group of students to fill their water containers using a limited number of faucets.\n\n    Each faucet delivers water at a constant rate of 1 unit per second. Students are queued in a given order and each has a specific amount of water they need to collect. Students fill their containers simultaneously using the available faucets. As soon as a student finishes, the next in line begins to fill their container without delay. If there are more faucets than students, only the needed number of faucets are used.\n\n    # Arguments\n    - `student_water_needs`: A list of integers representing the amount of water each student needs.\n    - `faucets`: The number of available faucets.\n\n    # Examples\n    >>> calculate_watering_time([4, 4, 1, 2, 1], 3)\n    4\n    >>> calculate_watering_time([2, 3, 1], 2)\n    3", "level": "middle"}
{"task_id": "Julia/39", "prompt": "function find_root_bisection() :: Float64\n    \"\"\"\n    Find the root of a polynomial function in the given interval [1.5, 2.4] using the bisection method.\n    The polynomial is defined as f(x) = x^5 - 15x^4 + 85x^3 - 225x^2 + 274x - 121. \n    It is known that there is exactly one root in the interval [1.5, 2.4].\n\n    Returns:\n    - The root of the polynomial in the interval, rounded to 4 decimal places.\n\n    Example:\n    >>> find_root_bisection()\n    \"\"\"", "canonical_solution": "    function f(x::Float64) :: Float64\n        return x^5 - 15 * x^4 + 85 * x^3 - 225 * x^2 + 274 * x - 121\n    end\n    epsilon = 1e-4\n    left, right = 1.5, 2.4\n    while (right - left) > epsilon\n        mid = (left + right) / 2\n        if f(left) * f(mid) > 0\n            left = mid\n        else\n            right = mid\n        end\n    end\n    print(round((left + right) / 2; digits=4))\n    return round((left + right) / 2; digits=4)\nend", "test": "@assert find_root_bisection() \u2248 1.8490", "entry_point": "find_root_bisection", "signature": "function find_root_bisection() :: Float64", "docstring": "Find the root of a polynomial function in the given interval [1.5, 2.4] using the bisection method.\n    The polynomial is defined as f(x) = x^5 - 15x^4 + 85x^3 - 225x^2 + 274x - 121. \n    It is known that there is exactly one root in the interval [1.5, 2.4].\n\n    Returns:\n    - The root of the polynomial in the interval, rounded to 4 decimal places.\n\n    Example:\n    >>> find_root_bisection()", "instruction": "Write a Julia function `function find_root_bisection() :: Float64` to solve the following problem:\nFind the root of a polynomial function in the given interval [1.5, 2.4] using the bisection method.\n    The polynomial is defined as f(x) = x^5 - 15x^4 + 85x^3 - 225x^2 + 274x - 121. \n    It is known that there is exactly one root in the interval [1.5, 2.4].\n\n    Returns:\n    - The root of the polynomial in the interval, rounded to 4 decimal places.\n\n    Example:\n    >>> find_root_bisection()", "level": "middle"}
{"task_id": "Julia/40", "prompt": "function count_dictionary_lookups(memory_capacity::Int, words::Vector{Int}) :: Int\n    \"\"\"\n    Count the number of times a translation software has to look up words in an external dictionary while translating an article.\n\n    The software has a memory that can store a limited number of word translations. If a word's translation is not in memory, it looks it up in the external dictionary and stores it in memory. If the memory is full, the oldest entry is removed to make space for the new one.\n\n    Parameters:\n    - memory_capacity: An integer representing the number of translations that can be stored in memory at a time.\n    - article_length: An integer representing the number of words in the article.\n    - words: A vector of integers, each representing a unique word in the article.\n\n    Returns:\n    - An integer representing the number of dictionary lookups performed.\n\n    Examples:\n    >>> count_dictionary_lookups(3, [1, 2, 1, 5, 4, 4, 1])\n    5\n    >>> count_dictionary_lookups(2, [1, 2, 3, 2, 1])\n    4\n    \"\"\"", "canonical_solution": "    memory = Int[]\n    lookups = 0\n\n    for word in words\n        if !(word in memory)\n            lookups += 1\n            if length(memory) >= memory_capacity\n                deleteat!(memory, 1)\n            end\n            push!(memory, word)\n        end\n    end\n\n    return lookups\nend", "test": "@assert count_dictionary_lookups(3, [1, 2, 1, 5, 4, 4, 1]) == 5\n@assert count_dictionary_lookups(2, [1, 2, 3, 2, 1]) == 4\n@assert count_dictionary_lookups(1, [1, 2, 1, 2, 1]) == 5\n@assert count_dictionary_lookups(4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10", "entry_point": "count_dictionary_lookups", "signature": "function count_dictionary_lookups(memory_capacity::Int, words::Vector{Int}) :: Int", "docstring": "Count the number of times a translation software has to look up words in an external dictionary while translating an article.\n\n    The software has a memory that can store a limited number of word translations. If a word's translation is not in memory, it looks it up in the external dictionary and stores it in memory. If the memory is full, the oldest entry is removed to make space for the new one.\n\n    Parameters:\n    - memory_capacity: An integer representing the number of translations that can be stored in memory at a time.\n    - article_length: An integer representing the number of words in the article.\n    - words: A vector of integers, each representing a unique word in the article.\n\n    Returns:\n    - An integer representing the number of dictionary lookups performed.\n\n    Examples:\n    >>> count_dictionary_lookups(3, [1, 2, 1, 5, 4, 4, 1])\n    5\n    >>> count_dictionary_lookups(2, [1, 2, 3, 2, 1])\n    4", "instruction": "Write a Julia function `function count_dictionary_lookups(memory_capacity::Int, words::Vector{Int}) :: Int` to solve the following problem:\nCount the number of times a translation software has to look up words in an external dictionary while translating an article.\n\n    The software has a memory that can store a limited number of word translations. If a word's translation is not in memory, it looks it up in the external dictionary and stores it in memory. If the memory is full, the oldest entry is removed to make space for the new one.\n\n    Parameters:\n    - memory_capacity: An integer representing the number of translations that can be stored in memory at a time.\n    - article_length: An integer representing the number of words in the article.\n    - words: A vector of integers, each representing a unique word in the article.\n\n    Returns:\n    - An integer representing the number of dictionary lookups performed.\n\n    Examples:\n    >>> count_dictionary_lookups(3, [1, 2, 1, 5, 4, 4, 1])\n    5\n    >>> count_dictionary_lookups(2, [1, 2, 3, 2, 1])\n    4", "level": "easy"}
{"task_id": "Julia/41", "prompt": "function count_competitive_pairs(scores::Vector{Vector{Int64}}) :: Int\n    \"\"\"\n    Determine the number of pairs of students who are considered \"competitive pairs\" based on their scores.\n    A pair is considered competitive if the absolute difference in each subject (Math, English, Science) is <= 5,\n    and the total score difference is <= 10.\n    - scores: A Nx3 matrix where each row represents a student and columns represent scores in Math, English, and Science.\n\n    # Examples\n    >>> count_competitive_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n    2\n    \"\"\"", "canonical_solution": "    count = 0\n    n = length(scores)\n    \n    for i in 1:n-1\n        for j in i+1:n\n            if all(abs.(scores[i] .- scores[j]) .<= 5) && abs(sum(scores[i]) - sum(scores[j])) <= 10\n                count += 1\n            end\n        end\n    end\n    println(count)\n    return count\nend", "test": "@assert count_competitive_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]]) == 2\n@assert count_competitive_pairs([[100, 100, 100], [95, 95, 95], [90, 90, 90]]) == 0\n@assert count_competitive_pairs([[100, 105, 100], [95, 100, 95], [90, 85, 90], [85, 80, 85]]) == 0\n@assert count_competitive_pairs([[110, 115, 120], [110, 110, 115], [100, 105, 110], [95, 100, 105]]) == 1", "entry_point": "count_competitive_pairs", "signature": "function count_competitive_pairs(scores::Vector{Vector{Int64}}) :: Int", "docstring": "Determine the number of pairs of students who are considered \"competitive pairs\" based on their scores.\n    A pair is considered competitive if the absolute difference in each subject (Math, English, Science) is <= 5,\n    and the total score difference is <= 10.\n    - scores: A Nx3 matrix where each row represents a student and columns represent scores in Math, English, and Science.\n\n    # Examples\n    >>> count_competitive_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n    2", "instruction": "Write a Julia function `function count_competitive_pairs(scores::Vector{Vector{Int64}}) :: Int` to solve the following problem:\nDetermine the number of pairs of students who are considered \"competitive pairs\" based on their scores.\n    A pair is considered competitive if the absolute difference in each subject (Math, English, Science) is <= 5,\n    and the total score difference is <= 10.\n    - scores: A Nx3 matrix where each row represents a student and columns represent scores in Math, English, and Science.\n\n    # Examples\n    >>> count_competitive_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n    2", "level": "easy"}
{"task_id": "Julia/42", "prompt": "function total_smoked_cigarettes(cigarettes::Int, conversion_rate::Int) :: Int\n\n    \"\"\"\n    Calculate the total number of cigarettes Peter can smoke. Peter starts with a certain number of cigarettes, \n    and for every `conversion_rate` number of cigarette butts, he can get a new cigarette.\n\n    # Arguments\n    - `cigarettes`: Initial number of cigarettes Peter has.\n    - `conversion_rate`: Number of cigarette butts needed to get a new cigarette.\n\n    # Examples\n    julia> total_smoked_cigarettes(4, 3)\n    5\n    \"\"\"", "canonical_solution": "    total_smoked = cigarettes\n    butts = cigarettes\n\n    while butts >= conversion_rate\n        new_cigarettes = div(butts, conversion_rate)\n        butts = butts % conversion_rate + new_cigarettes\n        total_smoked += new_cigarettes\n    end\n\n    return total_smoked\nend", "test": "@assert total_smoked_cigarettes(4, 3) == 5\n@assert total_smoked_cigarettes(10, 3) == 14\n@assert total_smoked_cigarettes(100, 4) == 133\n@assert total_smoked_cigarettes(1, 2) == 1  # Edge case: Not enough cigarettes to exchange for a new one.", "entry_point": "total_smoked_cigarettes", "signature": "function total_smoked_cigarettes(cigarettes::Int, conversion_rate::Int) :: Int", "docstring": "Calculate the total number of cigarettes Peter can smoke. Peter starts with a certain number of cigarettes, \n    and for every `conversion_rate` number of cigarette butts, he can get a new cigarette.\n\n    # Arguments\n    - `cigarettes`: Initial number of cigarettes Peter has.\n    - `conversion_rate`: Number of cigarette butts needed to get a new cigarette.\n\n    # Examples\n    julia> total_smoked_cigarettes(4, 3)\n    5", "instruction": "Write a Julia function `function total_smoked_cigarettes(cigarettes::Int, conversion_rate::Int) :: Int` to solve the following problem:\nCalculate the total number of cigarettes Peter can smoke. Peter starts with a certain number of cigarettes, \n    and for every `conversion_rate` number of cigarette butts, he can get a new cigarette.\n\n    # Arguments\n    - `cigarettes`: Initial number of cigarettes Peter has.\n    - `conversion_rate`: Number of cigarette butts needed to get a new cigarette.\n\n    # Examples\n    julia> total_smoked_cigarettes(4, 3)\n    5", "level": "easy"}
{"task_id": "Julia/43", "prompt": "function longest_consecutive_sequence(numbers::Vector{Int}) :: Int\n    \"\"\"\n    Calculate the length of the longest consecutive sequence in a given list of integers.\n\n    The consecutive sequence is a series of numbers where each number follows the previous one without any gaps. The sequence can start with any number and the numbers do not need to be in order initially.\n\n    # Examples\n    - `longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])` should return `5` because the longest consecutive sequence is `[1, 2, 3, 4, 5,6]`.\n    - `longest_consecutive_sequence([10, 4, 20, 1, 3, 2])` should return `4` because the longest consecutive sequence is `[1, 2, 3, 4]`.\n    \"\"\"", "canonical_solution": "    if isempty(numbers)\n        return 0\n    end\n\n    sort!(numbers)\n    longest, current = 1, 1\n\n    for i in 2:length(numbers)\n        # Check for duplicates\n        if numbers[i] == numbers[i-1]\n            continue\n        # Check if current number is consecutive\n        elseif numbers[i] == numbers[i-1] + 1\n            current += 1\n            longest = max(longest, current)\n        else\n            current = 1\n        end\n    end\n\n    return longest\nend", "test": "@assert longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) == 6\n@assert longest_consecutive_sequence([10, 4, 20, 1, 3, 2]) == 4\n@assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4\n@assert longest_consecutive_sequence([5, 4, 2, 1]) == 2", "entry_point": "longest_consecutive_sequence", "signature": "function longest_consecutive_sequence(numbers::Vector{Int}) :: Int", "docstring": "Calculate the length of the longest consecutive sequence in a given list of integers.\n\n    The consecutive sequence is a series of numbers where each number follows the previous one without any gaps. The sequence can start with any number and the numbers do not need to be in order initially.\n\n    # Examples\n    - `longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])` should return `5` because the longest consecutive sequence is `[1, 2, 3, 4, 5,6]`.\n    - `longest_consecutive_sequence([10, 4, 20, 1, 3, 2])` should return `4` because the longest consecutive sequence is `[1, 2, 3, 4]`.", "instruction": "Write a Julia function `function longest_consecutive_sequence(numbers::Vector{Int}) :: Int` to solve the following problem:\nCalculate the length of the longest consecutive sequence in a given list of integers.\n\n    The consecutive sequence is a series of numbers where each number follows the previous one without any gaps. The sequence can start with any number and the numbers do not need to be in order initially.\n\n    # Examples\n    - `longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])` should return `5` because the longest consecutive sequence is `[1, 2, 3, 4, 5,6]`.\n    - `longest_consecutive_sequence([10, 4, 20, 1, 3, 2])` should return `4` because the longest consecutive sequence is `[1, 2, 3, 4]`.", "level": "middle"}
{"task_id": "Julia/44", "prompt": "function compare_area(a::Int, b::Int, c::Int) :: String\n    \"\"\"\n    Determine whose geometric shape has a greater area, Alice with her square of side length `a`, \n    or Bob with his rectangle of dimensions `b` x `c`. Returns \"Alice\" if the square's area is larger, \n    and \"Bob\" if the rectangle's area is larger.\n\n    # Examples\n    - `compare_area(5, 4, 6)` returns \"Alice\" because the area of the square (25) is greater than the area of the rectangle (24).\n    - `compare_area(7, 5, 10)` returns \"Bob\" because the area of the rectangle (50) is greater than the area of the square (49).\n    \"\"\"", "canonical_solution": "    square_area = a^2\n    rectangle_area = b * c\n    if square_area > rectangle_area\n        return \"Alice\"\n    else\n        return \"Bob\"\n    end\nend\n", "test": "@assert compare_area(5, 4, 6) == \"Alice\"\n@assert compare_area(7, 5, 10) == \"Bob\"\n@assert compare_area(2, 3, 1) == \"Alice\"  # Testing with a smaller square and rectangle, square's area is 4, rectangle's area is 3\n@assert compare_area(8, 4, 4) == \"Alice\"    ", "entry_point": "compare_area", "signature": "function compare_area(a::Int, b::Int, c::Int) :: String", "docstring": "Determine whose geometric shape has a greater area, Alice with her square of side length `a`, \n    or Bob with his rectangle of dimensions `b` x `c`. Returns \"Alice\" if the square's area is larger, \n    and \"Bob\" if the rectangle's area is larger.\n\n    # Examples\n    - `compare_area(5, 4, 6)` returns \"Alice\" because the area of the square (25) is greater than the area of the rectangle (24).\n    - `compare_area(7, 5, 10)` returns \"Bob\" because the area of the rectangle (50) is greater than the area of the square (49).", "instruction": "Write a Julia function `function compare_area(a::Int, b::Int, c::Int) :: String` to solve the following problem:\nDetermine whose geometric shape has a greater area, Alice with her square of side length `a`, \n    or Bob with his rectangle of dimensions `b` x `c`. Returns \"Alice\" if the square's area is larger, \n    and \"Bob\" if the rectangle's area is larger.\n\n    # Examples\n    - `compare_area(5, 4, 6)` returns \"Alice\" because the area of the square (25) is greater than the area of the rectangle (24).\n    - `compare_area(7, 5, 10)` returns \"Bob\" because the area of the rectangle (50) is greater than the area of the square (49).", "level": "easy"}
{"task_id": "Julia/45", "prompt": "function max_product_partition(n::Int, m::Int) :: Vector{Int}\n    \"\"\"\n    Find `m` positive integers whose sum is `n`, and their product is as large as possible. Return the partition in lexicographically smallest order.\n\n    # Examples\n    - `max_product_partition(6, 3)` should return `[2, 2, 2]` because 2*2*2 is the largest product you can get from three numbers that add up to 6.\n    - `max_product_partition(8, 3)` should return `[2, 3, 3]` since 2*3*3 = 18 is the largest product from three numbers that add up to 8.\n\n    # Arguments\n    - `n`: The sum of the numbers.\n    - `m`: The number of positive integers.\n\n    # Returns\n    - A vector of integers representing the partition.\n    \"\"\"", "canonical_solution": "    # Base case when each number must be at least 1\n    if n == m\n        return ones(Int, m)\n    end\n    result = Int[]\n    while m > 0\n        # Aim for as even a split as possible\n        part = ceil(Int, n / m)\n        push!(result, part)\n        n -= part\n        m -= 1\n    end\n    sort!(result)  # Ensure lexicographically smallest order\n    return result\nend", "test": "@assert max_product_partition(6, 3) == [2, 2, 2]\n@assert max_product_partition(8, 3) == [2, 3, 3]\n@assert max_product_partition(10, 2) == [5, 5]\n@assert max_product_partition(7, 3) == [2, 2, 3]", "entry_point": "max_product_partition", "signature": "function max_product_partition(n::Int, m::Int) :: Vector{Int}", "docstring": "Find `m` positive integers whose sum is `n`, and their product is as large as possible. Return the partition in lexicographically smallest order.\n\n    # Examples\n    - `max_product_partition(6, 3)` should return `[2, 2, 2]` because 2*2*2 is the largest product you can get from three numbers that add up to 6.\n    - `max_product_partition(8, 3)` should return `[2, 3, 3]` since 2*3*3 = 18 is the largest product from three numbers that add up to 8.\n\n    # Arguments\n    - `n`: The sum of the numbers.\n    - `m`: The number of positive integers.\n\n    # Returns\n    - A vector of integers representing the partition.", "instruction": "Write a Julia function `function max_product_partition(n::Int, m::Int) :: Vector{Int}` to solve the following problem:\nFind `m` positive integers whose sum is `n`, and their product is as large as possible. Return the partition in lexicographically smallest order.\n\n    # Examples\n    - `max_product_partition(6, 3)` should return `[2, 2, 2]` because 2*2*2 is the largest product you can get from three numbers that add up to 6.\n    - `max_product_partition(8, 3)` should return `[2, 3, 3]` since 2*3*3 = 18 is the largest product from three numbers that add up to 8.\n\n    # Arguments\n    - `n`: The sum of the numbers.\n    - `m`: The number of positive integers.\n\n    # Returns\n    - A vector of integers representing the partition.", "level": "middle"}
{"task_id": "Julia/46", "prompt": "function count_composition_title_chars(title::String) :: Int\n\n    \"\"\"\n    Count the number of characters in a composition title, excluding spaces and newline characters.\n    \n    # Examples\n    - `count_composition_title_chars(\"234\")` returns `3`.\n    - `count_composition_title_chars(\"Ca 45\")` returns `4`.\n    - `count_composition_title_chars(\"Hello\\nWorld\")` returns `10`.\n    - `count_composition_title_chars(\" A B C \")` returns `3`.\n    \"\"\"", "canonical_solution": "    count = 0\n    for char in title\n        if char != ' ' && char != '\\n'\n            count += 1\n        end\n    end\n    return count\nend", "test": "@assert count_composition_title_chars(\"234\") == 3\n@assert count_composition_title_chars(\"Ca 45\") == 4\n@assert count_composition_title_chars(\"Hello\\nWorld\") == 10\n@assert count_composition_title_chars(\" A B C \") == 3\n@assert count_composition_title_chars(\"\\n\\n\") == 0", "entry_point": "count_composition_title_chars", "signature": "function count_composition_title_chars(title::String) :: Int", "docstring": "Count the number of characters in a composition title, excluding spaces and newline characters.\n    \n    # Examples\n    - `count_composition_title_chars(\"234\")` returns `3`.\n    - `count_composition_title_chars(\"Ca 45\")` returns `4`.\n    - `count_composition_title_chars(\"Hello\\nWorld\")` returns `10`.\n    - `count_composition_title_chars(\" A B C \")` returns `3`.", "instruction": "Write a Julia function `function count_composition_title_chars(title::String) :: Int` to solve the following problem:\nCount the number of characters in a composition title, excluding spaces and newline characters.\n    \n    # Examples\n    - `count_composition_title_chars(\"234\")` returns `3`.\n    - `count_composition_title_chars(\"Ca 45\")` returns `4`.\n    - `count_composition_title_chars(\"Hello\\nWorld\")` returns `10`.\n    - `count_composition_title_chars(\" A B C \")` returns `3`.", "level": "easy"}
{"task_id": "Julia/47", "prompt": "function count_common_students(a::Vector{Int}, b::Vector{Int}) :: Int\n    \"\"\"\n    Counts the number of students who have enrolled in both course A and course B.\n\n    # Arguments\n    - `a::Vector{Int}`: A vector of student IDs enrolled in course A.\n    - `b::Vector{Int}`: A vector of student IDs enrolled in course B.\n\n    # Returns\n    - `Int`: The count of students enrolled in both courses.\n\n    # Examples\n    ```jldoctest\n    julia> count_common_students([1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n    4\n\n    julia> count_common_students([10, 11, 12], [13, 14, 15])\n    0\n    \"\"\"", "canonical_solution": "    # Convert the lists to sets to remove any duplicates and to use set intersection\n    set_a = Set(a)\n    set_b = Set(b)\n\n    # Find the intersection of both sets\n    common_students = intersect(set_a, set_b)\n\n    # Return the number of common elements\n    return length(common_students)\nend", "test": "@assert count_common_students([1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) == 4\n@assert count_common_students([10, 11, 12], [13, 14, 15]) == 0\n@assert count_common_students([1, 2, 3], [3, 4, 5, 6]) == 1\n@assert count_common_students([7, 8, 9, 10], [10, 11, 12, 7]) == 2", "entry_point": "count_common_students", "signature": "function count_common_students(a::Vector{Int}, b::Vector{Int}) :: Int", "docstring": "Counts the number of students who have enrolled in both course A and course B.\n\n    # Arguments\n    - `a::Vector{Int}`: A vector of student IDs enrolled in course A.\n    - `b::Vector{Int}`: A vector of student IDs enrolled in course B.\n\n    # Returns\n    - `Int`: The count of students enrolled in both courses.\n\n    # Examples\n    ```jldoctest\n    julia> count_common_students([1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n    4\n\n    julia> count_common_students([10, 11, 12], [13, 14, 15])\n    0", "instruction": "Write a Julia function `function count_common_students(a::Vector{Int}, b::Vector{Int}) :: Int` to solve the following problem:\nCounts the number of students who have enrolled in both course A and course B.\n\n    # Arguments\n    - `a::Vector{Int}`: A vector of student IDs enrolled in course A.\n    - `b::Vector{Int}`: A vector of student IDs enrolled in course B.\n\n    # Returns\n    - `Int`: The count of students enrolled in both courses.\n\n    # Examples\n    ```jldoctest\n    julia> count_common_students([1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n    4\n\n    julia> count_common_students([10, 11, 12], [13, 14, 15])\n    0", "level": "easy"}
{"task_id": "Julia/48", "prompt": "function remaining_apples(m::Int, t::Int, s::Int) :: Int\n    \"\"\"\n    Determine the number of whole apples remaining after eating them over a given period.\n\n    Yuki loves eating apples and can finish one in `t` minutes, immediately starting the next one after finishing. Given `m` apples and a period of `s` minutes, calculate how many whole apples remain.\n\n    # Examples\n    - `remaining_apples(50, 10, 200)` returns `30`.\n    - `remaining_apples(5, 5, 20)` returns `1`.\n    \"\"\"", "canonical_solution": "    if t == 0\n        return 0\n    else\n        apples_eaten = div(s, t)\n        # Check if there's a partial apple being eaten\n        if s % t != 0\n            apples_eaten += 1\n        end\n        return max(m - apples_eaten, 0)\n    end\nend", "test": "@assert remaining_apples(50, 10, 200) == 30\n@assert remaining_apples(5, 5, 20) == 1\n@assert remaining_apples(10, 0, 100) == 0\n@assert remaining_apples(3, 10, 30) == 0\n@assert remaining_apples(4, 10, 25) == 1", "entry_point": "remaining_apples", "signature": "function remaining_apples(m::Int, t::Int, s::Int) :: Int", "docstring": "Determine the number of whole apples remaining after eating them over a given period.\n\n    Yuki loves eating apples and can finish one in `t` minutes, immediately starting the next one after finishing. Given `m` apples and a period of `s` minutes, calculate how many whole apples remain.\n\n    # Examples\n    - `remaining_apples(50, 10, 200)` returns `30`.\n    - `remaining_apples(5, 5, 20)` returns `1`.", "instruction": "Write a Julia function `function remaining_apples(m::Int, t::Int, s::Int) :: Int` to solve the following problem:\nDetermine the number of whole apples remaining after eating them over a given period.\n\n    Yuki loves eating apples and can finish one in `t` minutes, immediately starting the next one after finishing. Given `m` apples and a period of `s` minutes, calculate how many whole apples remain.\n\n    # Examples\n    - `remaining_apples(50, 10, 200)` returns `30`.\n    - `remaining_apples(5, 5, 20)` returns `1`.", "level": "easy"}
{"task_id": "Julia/49", "prompt": "function find_error_ids(ids::Vector{Int}) :: Tuple{Int, Int}\n    \"\"\"\n    Given a vector of ID numbers where ID numbers are supposed to be consecutive but due to an error, one ID is missing (creating a gap) and one ID is duplicated (creating a repeat). This function finds the missing (gap) ID and the duplicated (repeat) ID.\n\n    # Examples\n    - `find_error_ids([5, 6, 8, 11, 9, 10, 12, 9])` should return `(7, 9)`, indicating that 7 is missing and 9 is repeated.\n    - `find_error_ids([1, 2, 4, 4, 5])` should return `(3, 4)`, indicating that 3 is missing and 4 is repeated.\n    \"\"\"", "canonical_solution": "    sort!(ids)\n    duplicate = -1\n    missing = -1\n\n    for i in 2:length(ids)\n        if ids[i] == ids[i-1]\n            duplicate = ids[i]\n        elseif ids[i] > ids[i-1] + 1\n            missing = ids[i-1] + 1\n        end\n    end\n\n    # Edge case for the last missing ID\n    if missing == -1\n        missing = ids[end] + 1\n    end\n\n    return (missing, duplicate)\nend", "test": "@assert find_error_ids([5, 6, 8, 11, 9, 10, 12, 9]) == (7, 9)\n@assert find_error_ids([1, 2, 4, 4, 5]) == (3, 4)\n@assert find_error_ids([10, 11, 12, 13, 14, 15, 16, 18, 17, 17]) == (19, 17)\n@assert find_error_ids([22, 23, 24, 25, 27, 27]) == (26, 27)", "entry_point": "find_error_ids", "signature": "function find_error_ids(ids::Vector{Int}) :: Tuple{Int, Int}", "docstring": "Given a vector of ID numbers where ID numbers are supposed to be consecutive but due to an error, one ID is missing (creating a gap) and one ID is duplicated (creating a repeat). This function finds the missing (gap) ID and the duplicated (repeat) ID.\n\n    # Examples\n    - `find_error_ids([5, 6, 8, 11, 9, 10, 12, 9])` should return `(7, 9)`, indicating that 7 is missing and 9 is repeated.\n    - `find_error_ids([1, 2, 4, 4, 5])` should return `(3, 4)`, indicating that 3 is missing and 4 is repeated.", "instruction": "Write a Julia function `function find_error_ids(ids::Vector{Int}) :: Tuple{Int, Int}` to solve the following problem:\nGiven a vector of ID numbers where ID numbers are supposed to be consecutive but due to an error, one ID is missing (creating a gap) and one ID is duplicated (creating a repeat). This function finds the missing (gap) ID and the duplicated (repeat) ID.\n\n    # Examples\n    - `find_error_ids([5, 6, 8, 11, 9, 10, 12, 9])` should return `(7, 9)`, indicating that 7 is missing and 9 is repeated.\n    - `find_error_ids([1, 2, 4, 4, 5])` should return `(3, 4)`, indicating that 3 is missing and 4 is repeated.", "level": "middle"}
{"task_id": "Julia/50", "prompt": "function count_chars_types(s::String):: Tuple{Int, Int, Int}\n    \"\"\"\n    Count the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n\n    # Arguments\n    - `s`: A string of exactly 8 characters.\n\n    # Returns\n    - A tuple of three integers: the number of digits, the number of lowercase letters, and the number of uppercase letters in the string.\n\n    # Examples\n    count_chars_types(\"1n2s0e1s\") == (4, 4, 0)\n    \"\"\"", "canonical_solution": "    digit_count = sum(isdigit(c) for c in s)\n    lowercase_count = sum(islowercase(c) for c in s)\n    uppercase_count = sum(isuppercase(c) for c in s)\n    return (digit_count, lowercase_count, uppercase_count)\nend", "test": "@assert count_chars_types(\"yLOI2022\") == (4, 1, 3)\n@assert count_chars_types(\"IAKIOIOI\") == (0, 0, 8)\n@assert count_chars_types(\"1n2s0e1s\") == (4, 4, 0)\n@assert count_chars_types(\"1234AbCD\") == (4, 1, 3)", "entry_point": "count_chars_types", "signature": "function count_chars_types(s::String):: Tuple{Int, Int, Int}", "docstring": "Count the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n\n    # Arguments\n    - `s`: A string of exactly 8 characters.\n\n    # Returns\n    - A tuple of three integers: the number of digits, the number of lowercase letters, and the number of uppercase letters in the string.\n\n    # Examples\n    count_chars_types(\"1n2s0e1s\") == (4, 4, 0)", "instruction": "Write a Julia function `function count_chars_types(s::String):: Tuple{Int, Int, Int}` to solve the following problem:\nCount the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n\n    # Arguments\n    - `s`: A string of exactly 8 characters.\n\n    # Returns\n    - A tuple of three integers: the number of digits, the number of lowercase letters, and the number of uppercase letters in the string.\n\n    # Examples\n    count_chars_types(\"1n2s0e1s\") == (4, 4, 0)", "level": "easy"}
