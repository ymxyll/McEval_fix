{"task_id": "Fortran/1", "prompt": "! Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n! >>> has_close_elements([1.0, 2.0, 3.0], 3,0.5)\n! false\n! >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 6, 0.3)\n! true\n\n  logical function has_close_elements(numbers, size, threshold)", "canonical_solution": "    real(4), intent(in) :: numbers(:)\n    integer, intent(in) :: size\n    real(4), intent(in) :: threshold\n    integer :: i, j\n\n    has_close_elements = .false.\n\n    do i = 1, size - 1\n      do j = i + 1, size\n        if (abs(numbers(i) - numbers(j)) < threshold) then\n          has_close_elements = .true.\n          return\n        end if\n      end do\n    end do\n\n  end function has_close_elements\n\n\n\nend program CloseElements", "test": "program CloseElements\n  implicit none\n\n  integer, parameter :: max_size = 5\n  real(4), dimension(max_size) :: a, b, c, d\n  integer :: size_a, size_b, size_c, size_d\n\n  ! Initialize arrays\n  a = [1.0, 2.0, 3.9, 4.0, 5.0]\n  b = [1.0, 2.0, 5.9, 4.0, 5.0]\n  c = [1.0, 2.0, 3.0, 4.0, 5.0]\n  d = [1.1, 2.2, 3.1, 4.1, 5.1]\n\n  ! Get sizes of arrays\n  size_a = size(a)\n  size_b = size(b)\n  size_c = size(c)\n  size_d = size(d)\n\n  ! Run tests\n  call assert(has_close_elements(a, size_a, 0.3)  .eqv. .true.)\n  call assert(has_close_elements(a, size_a, 0.05) .eqv. .false.)\n  call assert(has_close_elements(b, size_b, 0.95) .eqv. .true.)\n  call assert(has_close_elements(b, size_b, 0.8)  .eqv. .false.)\n  call assert(has_close_elements(c, size_c, 2.0)  .eqv. .true.)\n  call assert(has_close_elements(d, size_d, 1.0)  .eqv. .true.)\n  call assert(has_close_elements(d, size_d, 0.5)  .eqv. .false.)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "has_close_elements", "signature": "logical function has_close_elements(numbers, size, threshold)", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than the given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 3,0.5)\nfalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 6, 0.3)\ntrue", "instruction": "Write a Fortran function `logical function has_close_elements(numbers, size, threshold)` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than the given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 3,0.5)\nfalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 6, 0.3)\ntrue", "level": "easy"}
{"task_id": "Fortran/2", "prompt": "  ! Calculates the sum of two integers A and B.\n  ! \n  ! The function takes two integers as input and returns their sum. \n  ! \n  ! Arguments:\n  ! - a: An integer.\n  ! - b: An integer.\n  !\n  ! Returns:\n  ! - The sum of a and b.\n  !\n  ! Example:\n  ! - sum_integers(1, 1) returns 2\n  ! - sum_integers(10, 20) returns 30\n    function sum_integers(a, b) result(sum)", "canonical_solution": "        integer, intent(in) :: a, b\n        integer :: sum\n\n        sum = a + b\n    end function sum_integers\n\n    \nend program main", "test": "program main\n    implicit none\n    integer :: result\n\n    ! Test case 1\n    result = sum_integers(1, 1)\n    call assert(result == 2)\n\n    ! Test case 2\n    result = sum_integers(10, 20)\n    call assert(result == 30)\n\n    ! Test case 3: Exceeding range\n    ! Uncomment to test exceeding range scenario\n    result = sum_integers(2000, 3000)\n    call assert(result == 5000)\n\n  contains\n  \n  subroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "sum_integers", "signature": "function sum_integers(a, b) result(sum)", "docstring": "Calculates the sum of two integers A and B.\n\nThe function takes two integers as input and returns their sum.\n\nArguments:\n- a: An integer.\n- b: An integer.\n\nReturns:\n- The sum of a and b.\n\nExample:\n- sum_integers(1, 1) returns 2\n- sum_integers(10, 20) returns 30", "instruction": "Write a Fortran function `function sum_integers(a, b) result(sum)` to solve the following problem:\nCalculates the sum of two integers A and B.\n\nThe function takes two integers as input and returns their sum.\n\nArguments:\n- a: An integer.\n- b: An integer.\n\nReturns:\n- The sum of a and b.\n\nExample:\n- sum_integers(1, 1) returns 2\n- sum_integers(10, 20) returns 30", "level": "easy"}
{"task_id": "Fortran/3", "prompt": "! Encrypts a given message by replacing each letter with the fourth letter following it in the alphabet.\n! The encryption rule is: for each letter in the original message, use the fourth subsequent letter in the alphabet as its replacement.\n! The function assumes that the message contains only uppercase letters.\n\n! Arguments:\n! - original: A string representing the original message to be encrypted.\n! - encrypted: A string representing the encrypted message.\n\n! Example:\n! - Given the input \"ABCD\", the output should be \"EFGH\".\n! - For the input \"XYZA\", the output should be \"BCDE\".\nsubroutine encrypt_message(original, encrypted)", "canonical_solution": "  character(len=*), intent(in) :: original\n  character(len=len(original)) :: encrypted\n  integer :: i\n\n  do i = 1, len(original)\n      encrypted(i:i) = char(mod(iachar(original(i:i)) - iachar('A') + 4, 26) + iachar('A'))\n  end do\nend subroutine encrypt_message\n\n\n\n\nend program main", "test": "program main\n  implicit none\n\n  character(len=5) :: original\n  character(len=5) :: encrypted\n\n  ! Test case 1\n  original = \"CHINA\"\n  call encrypt_message(original, encrypted)\n  call assert(encrypted == \"GLMRE\")\n\n  original = \"ABCDE\"\n\n  call encrypt_message(original, encrypted)\n  call assert(encrypted == \"EFGHI\")\n\n  ! Test case 2\n  original = \"XYZAA\"\n  call encrypt_message(original, encrypted)\n  call assert(encrypted == \"BCDEE\")\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "encrypt_message", "signature": "subroutine encrypt_message(original, encrypted)", "docstring": "Encrypts a given message by replacing each letter with the fourth letter following it in the alphabet.\nThe encryption rule is: for each letter in the original message, use the fourth subsequent letter in the alphabet as its replacement.\nThe function assumes that the message contains only uppercase letters.\nArguments:\n- original: A string representing the original message to be encrypted.\n- encrypted: A string representing the encrypted message.\nExample:\n- Given the input \"ABCD\", the output should be \"EFGH\".\n- For the input \"XYZA\", the output should be \"BCDE\".", "instruction": "Write a Fortran function `subroutine encrypt_message(original, encrypted)` to solve the following problem:\nEncrypts a given message by replacing each letter with the fourth letter following it in the alphabet.\nThe encryption rule is: for each letter in the original message, use the fourth subsequent letter in the alphabet as its replacement.\nThe function assumes that the message contains only uppercase letters.\nArguments:\n- original: A string representing the original message to be encrypted.\n- encrypted: A string representing the encrypted message.\nExample:\n- Given the input \"ABCD\", the output should be \"EFGH\".\n- For the input \"XYZA\", the output should be \"BCDE\".", "level": "easy"}
{"task_id": "Fortran/4", "prompt": "! Converts a given Fahrenheit temperature to Celsius.\n! The conversion formula used is C = 5 * (F - 32) / 9.\n! The result is rounded to two decimal places.\n\n! Arguments:\n! - fahrenheit_temp: A real number representing the temperature in Fahrenheit.\n\n! Returns:\n! - celsius_temp: A real number representing the converted temperature in Celsius, rounded to two decimal places.\n\n! Example:\n! - fahrenheit_to_celsius(-40.0) returns -40.00\nfunction fahrenheit_to_celsius(fahrenheit_temp) result(celsius_temp)", "canonical_solution": "  real(4), intent(in) :: fahrenheit_temp\n  real(4) :: celsius_temp\n\n  celsius_temp = 5.0 * (fahrenheit_temp - 32.0) / 9.0\n  ! Rounding to two decimal places\n  celsius_temp = nint(celsius_temp * 100.0) / 100.0\nend function fahrenheit_to_celsius\n\nend program main", "test": "program main\n  implicit none\n  real(4) :: fahrenheit, celsius\n\n  ! Test case 1\n  fahrenheit = -40.0\n  celsius = fahrenheit_to_celsius(fahrenheit)\n  ! print *, 'Fahrenheit:', fahrenheit, '-> Celsius:', celsius  ! Expected output: -40.00\n  call assert(celsius == -40.00)\n\n  ! Test case 2\n  fahrenheit = 32.0\n  celsius = fahrenheit_to_celsius(fahrenheit)\n  ! print *, 'Fahrenheit:', fahrenheit, '-> Celsius:', celsius  ! Expected output: 0.00\n\n  call assert(celsius == 0.00)\n\n  ! Test case 3\n  fahrenheit = 212.0\n  celsius = fahrenheit_to_celsius(fahrenheit)\n  ! print *, 'Fahrenheit:', fahrenheit, '-> Celsius:', celsius  ! Expected output: 100.00\n  call assert(celsius == 100.00)\n  \ncontains\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "fahrenheit_to_celsius", "signature": "function fahrenheit_to_celsius(fahrenheit_temp) result(celsius_temp)", "docstring": "Converts a given Fahrenheit temperature to Celsius.\nThe conversion formula used is C = 5 * (F - 32) / 9.\nThe result is rounded to two decimal places.\nArguments:\n- fahrenheit_temp: A real number representing the temperature in Fahrenheit.\nReturns:\n- celsius_temp: A real number representing the converted temperature in Celsius, rounded to two decimal places.\nExample:\n- fahrenheit_to_celsius(-40.0) returns -40.00", "instruction": "Write a Fortran function `function fahrenheit_to_celsius(fahrenheit_temp) result(celsius_temp)` to solve the following problem:\nConverts a given Fahrenheit temperature to Celsius.\nThe conversion formula used is C = 5 * (F - 32) / 9.\nThe result is rounded to two decimal places.\nArguments:\n- fahrenheit_temp: A real number representing the temperature in Fahrenheit.\nReturns:\n- celsius_temp: A real number representing the converted temperature in Celsius, rounded to two decimal places.\nExample:\n- fahrenheit_to_celsius(-40.0) returns -40.00", "level": "easy"}
{"task_id": "Fortran/5", "prompt": "! Counts the number of English letters, digits, spaces, and other characters in a given string.\n!\n! Arguments:\n! - input_str: A string whose characters are to be counted.\n! - len_str: The length of the input string.\n!\n! Output:\n! - count_letters: The number of English letters in the string.\n! - count_digits: The number of digits in the string.\n! - count_spaces: The number of spaces in the string.\n! - count_others: The number of other characters in the string.\n!\n! Example:\n! - Given \"Hello 123!\", the subroutine should set count_letters to 5, count_digits to 3, count_spaces to 1, and count_others to 1.\nsubroutine count_characters(input_str, len_str, count_letters, count_digits, count_spaces, count_others)", "canonical_solution": "  character(len=*), intent(in) :: input_str\n  integer, intent(in) :: len_str\n  integer, intent(out) :: count_letters, count_digits, count_spaces, count_others\n  integer :: i\n\n  count_letters = 0\n  count_digits = 0\n  count_spaces = 0\n  count_others = 0\n\n  do i = 1, len_str\n      select case(input_str(i:i))\n      case ('A':'Z', 'a':'z')\n          count_letters = count_letters + 1\n      case ('0':'9')\n          count_digits = count_digits + 1\n      case (' ')\n          count_spaces = count_spaces + 1\n      case default\n          count_others = count_others + 1\n      end select\n  end do\nend subroutine count_characters\n\nend program main", "test": "program main\n  implicit none\n  character(len=200) :: test_str\n  integer :: len_str, letters, digits, spaces, others\n\n  test_str = 'Hello 123!'\n  len_str = len_trim(test_str)\n\n  ! Call the subroutine\n  call count_characters(test_str, len_str, letters, digits, spaces, others)\n  call assert(letters == 5 .and. digits == 3 .and. spaces == 1 .and. others == 1)\n\n  ! Initialize test string\n  test_str = 'aklsjflj123 sadf918u324 asdf91u32oasdf/.'';123'\n  len_str = len_trim(test_str)\n\n  ! Call the subroutine\n  call count_characters(test_str, len_str, letters, digits, spaces, others)\n  call assert(letters == 23 .and. digits == 16 .and. spaces == 2 .and. others == 4)\n\ncontains\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "count_characters", "signature": "subroutine count_characters(input_str, len_str, count_letters, count_digits, count_spaces, count_others)", "docstring": "Counts the number of English letters, digits, spaces, and other characters in a given string.\n\nArguments:\n- input_str: A string whose characters are to be counted.\n- len_str: The length of the input string.\n\nOutput:\n- count_letters: The number of English letters in the string.\n- count_digits: The number of digits in the string.\n- count_spaces: The number of spaces in the string.\n- count_others: The number of other characters in the string.\n\nExample:\n- Given \"Hello 123\", the subroutine should set count_letters to 5, count_digits to 3, count_spaces to 1, and count_others to 1.", "instruction": "Write a Fortran function `subroutine count_characters(input_str, len_str, count_letters, count_digits, count_spaces, count_others)` to solve the following problem:\nCounts the number of English letters, digits, spaces, and other characters in a given string.\n\nArguments:\n- input_str: A string whose characters are to be counted.\n- len_str: The length of the input string.\n\nOutput:\n- count_letters: The number of English letters in the string.\n- count_digits: The number of digits in the string.\n- count_spaces: The number of spaces in the string.\n- count_others: The number of other characters in the string.\n\nExample:\n- Given \"Hello 123\", the subroutine should set count_letters to 5, count_digits to 3, count_spaces to 1, and count_others to 1.", "level": "middle"}
{"task_id": "Fortran/6", "prompt": "! Calculates the sum of a sequence where each term is a repeated digit. \n! The sequence is formed as follows: a + aa + aaa + ... + aa...a (n times).\n\n! Arguments:\n! - digit: An integer representing the digit to be repeated.\n! - n: An integer representing the number of terms in the sequence.\n\n! Returns:\n! - The sum of the sequence formed by repeating 'digit' for each term up to 'n' terms.\n\n! Example:\n! - sum_repeated_digits(2, 5) returns 24690, as the sequence is 2 + 22 + 222 + 2222 + 22222.\nfunction sum_repeated_digits(digit, n) result(sum)", "canonical_solution": "  integer, intent(in) :: digit\n  integer, intent(in) :: n\n  integer :: sum, i, current_term\n\n  sum = 0\n  current_term = 0\n\n  do i = 1, n\n      current_term = current_term * 10 + digit\n      sum = sum + current_term\n  end do\nend function sum_repeated_digits\n\nend program main", "test": "program main\n  implicit none\n\n  integer :: result\n\n  result = sum_repeated_digits(2, 5)\n  call assert(result == 24690)\n\n  result = sum_repeated_digits(3, 3)\n  call assert(result == 369)\n\n  result = sum_repeated_digits(1, 4)\n  call assert(result == 1234)\n\ncontains\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "sum_repeated_digits", "signature": "function sum_repeated_digits(digit, n) result(sum)", "docstring": "Calculates the sum of a sequence where each term is a repeated digit.\nThe sequence is formed as follows: a + aa + aaa + ... + aa...a (n times).\nArguments:\n- digit: An integer representing the digit to be repeated.\n- n: An integer representing the number of terms in the sequence.\nReturns:\n- The sum of the sequence formed by repeating 'digit' for each term up to 'n' terms.\nExample:\n- sum_repeated_digits(2, 5) returns 24690, as the sequence is 2 + 22 + 222 + 2222 + 22222.", "instruction": "Write a Fortran function `function sum_repeated_digits(digit, n) result(sum)` to solve the following problem:\nCalculates the sum of a sequence where each term is a repeated digit.\nThe sequence is formed as follows: a + aa + aaa + ... + aa...a (n times).\nArguments:\n- digit: An integer representing the digit to be repeated.\n- n: An integer representing the number of terms in the sequence.\nReturns:\n- The sum of the sequence formed by repeating 'digit' for each term up to 'n' terms.\nExample:\n- sum_repeated_digits(2, 5) returns 24690, as the sequence is 2 + 22 + 222 + 2222 + 22222.", "level": "easy"}
{"task_id": "Fortran/7", "prompt": "! Finds all Narcissistic (or Armstrong) numbers between 100 and 999.\n! A Narcissistic number is a three-digit number where the sum of the cubes of its digits equals the number itself.\n! For example, 153 is a Narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n\n! Returns:\n! - An array of integers containing all the Narcissistic numbers between 100 and 999.\n\n! Example:\n! - find_narcissistic_numbers() returns [153, 370, 371, 407]\nfunction find_narcissistic_numbers() result(narcissistic_nums)", "canonical_solution": "  integer, dimension(:), allocatable :: narcissistic_nums\n  integer :: i, count, digit, sum, temp\n  integer, dimension(:), allocatable :: temp_arr\n  integer, dimension(:), allocatable :: new_arr\n  count = 0\n  allocate(temp_arr(5))\n  \n  do i = 100, 999\n      sum = 0\n      temp = i\n      ! Extract and cube each digit\n      do while (temp > 0)\n          digit = mod(temp, 10)\n          sum = sum + digit**3\n          temp = temp / 10\n      end do\n\n      ! Check if number is a Narcissistic number\n      if (sum == i) then\n          count = count + 1\n          if (count > size(temp_arr)) then\n              ! Resize the array by allocating a new one and moving data    \n              allocate(new_arr(size(temp_arr) + 5))\n              new_arr(:size(temp_arr)) = temp_arr\n              call move_alloc(from=new_arr, to=temp_arr)\n          end if\n          temp_arr(count) = i\n      end if\n  end do\n\n  ! Allocate the exact size for the result\n  allocate(narcissistic_nums(count))\n  narcissistic_nums = temp_arr(:count)\nend function find_narcissistic_numbers\n\nend program main", "test": "program main\n  implicit none\n  integer, dimension(:), allocatable :: nums\n  integer :: i\n  integer, dimension(4):: expected\n  expected = [153, 370, 371, 407]\n\n  ! Call the function\n  nums = find_narcissistic_numbers()\n\n  do i = 1, size(nums)\n    call assert(nums(i) == expected(i))\n  end do\n  \ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "find_narcissistic_numbers", "signature": "function find_narcissistic_numbers() result(narcissistic_nums)", "docstring": "Finds all Narcissistic (or Armstrong) numbers between 100 and 999.\nA Narcissistic number is a three-digit number where the sum of the cubes of its digits equals the number itself.\nFor example, 153 is a Narcissistic number because 153 = 1^3 + 5^3 + 3^3.\nReturns:\n- An array of integers containing all the Narcissistic numbers between 100 and 999.\nExample:\n- find_narcissistic_numbers() returns [153, 370, 371, 407]", "instruction": "Write a Fortran function `function find_narcissistic_numbers() result(narcissistic_nums)` to solve the following problem:\nFinds all Narcissistic (or Armstrong) numbers between 100 and 999.\nA Narcissistic number is a three-digit number where the sum of the cubes of its digits equals the number itself.\nFor example, 153 is a Narcissistic number because 153 = 1^3 + 5^3 + 3^3.\nReturns:\n- An array of integers containing all the Narcissistic numbers between 100 and 999.\nExample:\n- find_narcissistic_numbers() returns [153, 370, 371, 407]", "level": "hard"}
{"task_id": "Fortran/8", "prompt": "! Reverses the contents of the given string 'input_str' and stores the result in 'output_str'.\n! The 'input_str' is a string whose length does not exceed 100 characters.\n! The reversed string is stored in 'output_str'.\n\n! Arguments:\n! - input_str: A string to be reversed.\n! - output_str: A string variable to store the reversed string, with a maximum length of 100 characters.\n\n! Example:\n! - Given input_str = \"I am a student\", the output_str will be \"tneduts a ma I\".\n\nsubroutine reverse_string(input_str, output_str)", "canonical_solution": "  character(len=*), intent(in) :: input_str\n  character(len=100) :: output_str\n  integer :: i, str_len\n\n  str_len = len_trim(input_str)\n  output_str = \"\"  ! Initialize the output string\n\n  do i = str_len, 1, -1\n      output_str(str_len - i + 1:str_len - i + 1) = input_str(i:i)\n  end do\nend subroutine reverse_string\n\nend program main", "test": "program main\n  implicit none\n  character(len=100) :: test_str, reversed_str\n\n  test_str = \"I am a student\"\n  call reverse_string(test_str, reversed_str)\n  call  assert(reversed_str == \"tneduts a ma I\")\n\n  test_str = \"A string variable to store the reversed string, with a maximum length of 100 characters.\"\n  call reverse_string(test_str, reversed_str)\n  ! print *, reversed_str\n  call  assert(reversed_str == \".sretcarahc 001 fo htgnel mumixam a htiw ,gnirts desrever eht erots ot elbairav gnirts A\")\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "reverse_string", "signature": "subroutine reverse_string(input_str, output_str)", "docstring": "Reverses the contents of the given string 'input_str' and stores the result in 'output_str'.\nThe 'input_str' is a string whose length does not exceed 100 characters.\nThe reversed string is stored in 'output_str'.\nArguments:\n- input_str: A string to be reversed.\n- output_str: A string variable to store the reversed string, with a maximum length of 100 characters.\nExample:\n- Given input_str = \"I am a student\", the output_str will be \"tneduts a ma I\".", "instruction": "Write a Fortran function `subroutine reverse_string(input_str, output_str)` to solve the following problem:\nReverses the contents of the given string 'input_str' and stores the result in 'output_str'.\nThe 'input_str' is a string whose length does not exceed 100 characters.\nThe reversed string is stored in 'output_str'.\nArguments:\n- input_str: A string to be reversed.\n- output_str: A string variable to store the reversed string, with a maximum length of 100 characters.\nExample:\n- Given input_str = \"I am a student\", the output_str will be \"tneduts a ma I\".", "level": "easy"}
{"task_id": "Fortran/9", "prompt": "! This subroutine converts a time value in seconds to hours, minutes, and seconds without leading zeros.\n! The time is given as an integer and is then converted to hours, minutes, and seconds.\n! The converted values are returned as separate integer values.\n\n! Arguments:\n! - t: An integer representing time in seconds (0 <= t <= 86399).\n\n! Returns:\n! - hours: The hour component of the time.\n! - minutes: The minute component of the time.\n! - seconds: The second component of the time.\n\n! Example:\n! - If t = 5436, then hours = 1, minutes = 30, seconds = 36.\nsubroutine convert_seconds_to_hms(t, hours, minutes, seconds)", "canonical_solution": "  integer, intent(in) :: t\n  integer, intent(out) :: hours, minutes, seconds\n\n  ! Calculate hours, minutes, and seconds\n  hours = t / 3600\n  minutes = (t - hours * 3600) / 60\n  seconds = t - hours * 3600 - minutes * 60\nend subroutine convert_seconds_to_hms\n\n\nend program main", "test": "program main\n  implicit none\n  integer :: h, m, s\n\n  ! Test case 1: t = 5436\n  call convert_seconds_to_hms(5436, h, m, s)\n  call assert(h == 1 .and. m == 30 .and. s == 36)\n\n  ! Test case 2: t = 3661\n  call convert_seconds_to_hms(3661, h, m, s)\n  call assert(h == 1 .and. m == 1 .and. s == 1)\n\n  ! Test case 3: t = 0\n  call convert_seconds_to_hms(0, h, m, s)\n  call assert(h == 0 .and. m == 0 .and. s == 0) \n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "convert_seconds_to_hms", "signature": "subroutine convert_seconds_to_hms(t, hours, minutes, seconds)", "docstring": "This subroutine converts a time value in seconds to hours, minutes, and seconds without leading zeros.\nThe time is given as an integer and is then converted to hours, minutes, and seconds.\nThe converted values are returned as separate integer values.\nArguments:\n- t: An integer representing time in seconds (0 <= t <= 86399).\nReturns:\n- hours: The hour component of the time.\n- minutes: The minute component of the time.\n- seconds: The second component of the time.\nExample:\n- If t = 5436, then hours = 1, minutes = 30, seconds = 36.", "instruction": "Write a Fortran function `subroutine convert_seconds_to_hms(t, hours, minutes, seconds)` to solve the following problem:\nThis subroutine converts a time value in seconds to hours, minutes, and seconds without leading zeros.\nThe time is given as an integer and is then converted to hours, minutes, and seconds.\nThe converted values are returned as separate integer values.\nArguments:\n- t: An integer representing time in seconds (0 <= t <= 86399).\nReturns:\n- hours: The hour component of the time.\n- minutes: The minute component of the time.\n- seconds: The second component of the time.\nExample:\n- If t = 5436, then hours = 1, minutes = 30, seconds = 36.", "level": "easy"}
{"task_id": "Fortran/10", "prompt": "! Finds the top ten highest values from a given array of scores.\n!\n! This subroutine sorts an array of integers in descending order and selects the top ten values.\n! It handles cases where there are fewer than ten scores by returning as many scores as available.\n!\n! Arguments:\n! - scores: An array of integers representing the scores.\n! - n: The number of elements in the scores array.\n!\n! Returns:\n! - result: An array of the top ten scores in descending order.\n!\n! Example:\n! - Given scores array [54, 27, 87, 16, 63, 40, 22, 61, 6, 57, 70, 42, 11, 50, 13, 5, 56, 7, 8, 86, 56, 91, 68, 59] and n=24,\n!   top_ten_scores should return [91, 87, 86, 70, 68, 63, 61, 59, 57, 56]\nsubroutine top_ten_scores(scores, n, result)", "canonical_solution": "  integer, intent(in) :: scores(:), n\n  integer, intent(out) :: result(10)\n  integer :: i, j, temp, count\n\n  ! Create a copy of scores to avoid modifying the input array\n  integer :: scores_copy(n)\n  scores_copy = scores\n\n  ! Sort scores_copy in descending order\n  do i = 1, n-1\n      do j = i+1, n\n          if (scores_copy(i) < scores_copy(j)) then\n              temp = scores_copy(i)\n              scores_copy(i) = scores_copy(j)\n              scores_copy(j) = temp\n          end if\n      end do\n  end do\n\n  ! Select the top ten scores\n  count = min(10, n)\n  result = scores_copy(1:count)\nend subroutine top_ten_scores\n\nend program main", "test": "program main\n  implicit none\n  integer, dimension(24) :: scores\n  integer, dimension(10) :: result\n  integer, dimension(10) :: expected \n  integer :: i\n\n\n  ! Initialize the scores array\n  scores = [54, 27, 87, 16, 63, 40, 22, 61, 6, 57, 70, 42, 11, 50, 13, 5, 56, 7, 8, 86, 56, 91, 68, 59]\n  expected = [91, 87, 86, 70, 68, 63, 61, 59, 57, 56]\n\n  ! Call the subroutine\n  call top_ten_scores(scores, 24, result)\n  ! do i = 1, 10\n  !   print *, result(i)\n  ! end do\n\n  do i = 1, size(result)\n    call assert(result(i) == expected(i))\n  end do\n  \ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "top_ten_scores", "signature": "subroutine top_ten_scores(scores, n, result)", "docstring": "Finds the top ten highest values from a given array of scores.\n\nThis subroutine sorts an array of integers in descending order and selects the top ten values.\nIt handles cases where there are fewer than ten scores by returning as many scores as available.\n\nArguments:\n- scores: An array of integers representing the scores.\n- n: The number of elements in the scores array.\n\nReturns:\n- result: An array of the top ten scores in descending order.\n\nExample:\n- Given scores array [54, 27, 87, 16, 63, 40, 22, 61, 6, 57, 70, 42, 11, 50, 13, 5, 56, 7, 8, 86, 56, 91, 68, 59] and n=24,\ntop_ten_scores should return [91, 87, 86, 70, 68, 63, 61, 59, 57, 56]", "instruction": "Write a Fortran function `subroutine top_ten_scores(scores, n, result)` to solve the following problem:\nFinds the top ten highest values from a given array of scores.\n\nThis subroutine sorts an array of integers in descending order and selects the top ten values.\nIt handles cases where there are fewer than ten scores by returning as many scores as available.\n\nArguments:\n- scores: An array of integers representing the scores.\n- n: The number of elements in the scores array.\n\nReturns:\n- result: An array of the top ten scores in descending order.\n\nExample:\n- Given scores array [54, 27, 87, 16, 63, 40, 22, 61, 6, 57, 70, 42, 11, 50, 13, 5, 56, 7, 8, 86, 56, 91, 68, 59] and n=24,\ntop_ten_scores should return [91, 87, 86, 70, 68, 63, 61, 59, 57, 56]", "level": "middle"}
{"task_id": "Fortran/11", "prompt": "! Counts the number of words in a given string. A word is defined as a sequence of characters separated by spaces.\n! This function assumes that words are separated by exactly one space and there are no leading or trailing spaces.\n\n! Arguments:\n! - input_string: A string with a maximum length of 80 characters, containing words separated by spaces.\n\n! Returns:\n! - word_count: The total number of words in the input string.\n\n! Example:\n! - count_words_in_string(\"this is a book\") returns 4\nfunction count_words_in_string(input_string) result(word_count)", "canonical_solution": "  character(len=80), intent(in) :: input_string\n  integer :: word_count\n  integer :: i\n\n  word_count = 0\n  if (len_trim(input_string) > 0) then\n      word_count = 1\n      do i = 1, len_trim(input_string) - 1\n          if (input_string(i:i) == ' ' .and. input_string(i+1:i+1) /= ' ') then\n              word_count = word_count + 1\n          end if\n      end do\n  end if\nend function count_words_in_string\n\nend program main", "test": "program main\n  implicit none\n\n  character(len=80) :: test_string\n  integer :: result\n\n  ! Test 1\n  test_string = \"this is a book\"\n  result = count_words_in_string(test_string)\n  ! print*, \"Test 1 (Expected 4): \", result\n  call assert(result == 4)\n\n  ! Test 2\n  test_string = \"hello world\"\n  result = count_words_in_string(test_string)\n  ! print*, \"Test 2 (Expected 2): \", result\n  call assert(result == 2)\n\n  ! Test 3\n  test_string = \"single\"\n  result = count_words_in_string(test_string)\n  ! print*, \"Test 3 (Expected 1): \", result\n  call assert(result == 1)\n\n  ! Test 4\n  test_string = \"\"\n  result = count_words_in_string(test_string)\n  ! print*, \"Test 4 (Expected 0): \", result\n  call assert(result == 0)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "count_words_in_string", "signature": "function count_words_in_string(input_string) result(word_count)", "docstring": "Counts the number of words in a given string. A word is defined as a sequence of characters separated by spaces.\nThis function assumes that words are separated by exactly one space and there are no leading or trailing spaces.\nArguments:\n- input_string: A string with a maximum length of 80 characters, containing words separated by spaces.\nReturns:\n- word_count: The total number of words in the input string.\nExample:\n- count_words_in_string(\"this is a book\") returns 4", "instruction": "Write a Fortran function `function count_words_in_string(input_string) result(word_count)` to solve the following problem:\nCounts the number of words in a given string. A word is defined as a sequence of characters separated by spaces.\nThis function assumes that words are separated by exactly one space and there are no leading or trailing spaces.\nArguments:\n- input_string: A string with a maximum length of 80 characters, containing words separated by spaces.\nReturns:\n- word_count: The total number of words in the input string.\nExample:\n- count_words_in_string(\"this is a book\") returns 4", "level": "easy"}
{"task_id": "Fortran/12", "prompt": "! Compares two strings lexicographically (like the standard strcmp function in C).\n! The function returns 1 if the first string is greater than the second, -1 if it is less, and 0 if they are equal.\n\n! Arguments:\n! - str1: A character string.\n! - str2: A character string.\n\n! Returns:\n! - An integer indicating the result of comparison:\n! - 1 if str1 > str2,\n! - -1 if str1 < str2,\n! - 0 if str1 == str2.\n\n! Example:\n! - strcmp_custom(\"apple\", \"banana\") returns -1\n! - strcmp_custom(\"cherry\", \"apple\") returns 1\n! - strcmp_custom(\"date\", \"date\") returns 0\nfunction strcmp_custom(str1, str2) result(comparison_result)", "canonical_solution": "  character(len=*), intent(in) :: str1, str2\n  integer :: comparison_result\n  integer :: i, len1, len2, min_len\n\n  len1 = len_trim(str1)\n  len2 = len_trim(str2)\n  min_len = min(len1, len2)\n\n  comparison_result = 0\n  do i = 1, min_len\n      if (str1(i:i) < str2(i:i)) then\n          comparison_result = -1\n          return\n      else if (str1(i:i) > str2(i:i)) then\n          comparison_result = 1\n          return\n      end if\n  end do\n\n  if (len1 < len2) then\n      comparison_result = -1\n  else if (len1 > len2) then\n      comparison_result = 1\n  end if\nend function strcmp_custom\n\nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  result = strcmp_custom(\"apple\", \"banana\")\n  call assert(result == -1)\n\n  result = strcmp_custom(\"cherry\", \"apple\")\n  call assert(result == 1)\n\n  result = strcmp_custom(\"date\", \"date\")\n  call assert(result == 0)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "strcmp_custom", "signature": "function strcmp_custom(str1, str2) result(comparison_result)", "docstring": "Compares two strings lexicographically (like the standard strcmp function in C).\nThe function returns 1 if the first string is greater than the second, -1 if it is less, and 0 if they are equal.\nArguments:\n- str1: A character string.\n- str2: A character string.\nReturns:\n- An integer indicating the result of comparison:\n- 1 if str1 > str2,\n- -1 if str1 < str2,\n- 0 if str1 == str2.\nExample:\n- strcmp_custom(\"apple\", \"banana\") returns -1\n- strcmp_custom(\"cherry\", \"apple\") returns 1\n- strcmp_custom(\"date\", \"date\") returns 0", "instruction": "Write a Fortran function `function strcmp_custom(str1, str2) result(comparison_result)` to solve the following problem:\nCompares two strings lexicographically (like the standard strcmp function in C).\nThe function returns 1 if the first string is greater than the second, -1 if it is less, and 0 if they are equal.\nArguments:\n- str1: A character string.\n- str2: A character string.\nReturns:\n- An integer indicating the result of comparison:\n- 1 if str1 > str2,\n- -1 if str1 < str2,\n- 0 if str1 == str2.\nExample:\n- strcmp_custom(\"apple\", \"banana\") returns -1\n- strcmp_custom(\"cherry\", \"apple\") returns 1\n- strcmp_custom(\"date\", \"date\") returns 0", "level": "easy"}
{"task_id": "Fortran/13", "prompt": "! This subroutine takes a given name and translates it into a specific output based on predefined mappings.\n! The mappings are as follows:\n! - \"WYS\" translates to \"KXZSMR\".\n! - \"CQ\" translates to \"CHAIQIANG\".\n! - \"LC\" translates to \"DRAGONNET\". \n! - \"SYT\", \"SSD\", \"LSS\", or \"LYF\" translate to \"STUDYFATHER\".\n! - Any other name translates to \"DENOMINATOR\".\n\n! Arguments:\n! - name: A string representing the name to be translated. It should consist only of uppercase letters and have a maximum length of 5.\n! - translated_name: A string that will hold the translated name, with a maximum length of 11 characters.\n\n! Example:\n! - Given the name \"WYS\", the subroutine will set translated_name to \"KXZSMR\".\nsubroutine translate_name(name, translated_name)", "canonical_solution": "  character(len=*), intent(in) :: name\n  character(len=100) :: translated_name\n\n  select case(name)\n  case(\"WYS\")\n      translated_name = \"KXZSMR\"\n  case(\"CQ\")\n      translated_name = \"CHAIQIANG\"\n  case(\"LC\")\n      translated_name = \"DRAGONNET\"\n  case(\"SYT\", \"SSD\", \"LSS\", \"LYF\")\n      translated_name = \"STUDYFATHER\"\n  case default\n      translated_name = \"DENOMINATOR\"\n  end select\nend subroutine translate_name\n\nend program main\n", "test": "program main\n  implicit none\n  character(len=100) :: result\n\n  ! Test 1: WYS\n  call translate_name(\"WYS\", result)\n  ! print *, result\n  call assert(result == \"KXZSMR\")\n\n  ! Test 2: CQ\n  call translate_name(\"CQ\", result)\n  call assert(result == \"CHAIQIANG\")\n\n  ! Test 3: LC\n  call translate_name(\"LC\", result)\n  call assert(result == \"DRAGONNET\")\n\n  ! Test 4: SYT\n  call translate_name(\"SYT\", result)\n  call assert(result == \"STUDYFATHER\")\n\n  ! Test 5: SSD\n  call translate_name(\"SSD\", result)\n  call assert(result == \"STUDYFATHER\")\n\n  ! Test 6: LSS\n  call translate_name(\"LSS\", result)\n  call assert(result == \"STUDYFATHER\")\n\n  ! Test 7: LYF\n  call translate_name(\"LYF\", result)\n  call assert(result == \"STUDYFATHER\")\n\n  ! Test 8: ZBY\n  call translate_name(\"ZBY\", result)\n  call assert(result == \"DENOMINATOR\")\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "translate_name", "signature": "subroutine translate_name(name, translated_name)", "docstring": "This subroutine takes a given name and translates it into a specific output based on predefined mappings.\nThe mappings are as follows:\n- \"WYS\" translates to \"KXZSMR\".\n- \"CQ\" translates to \"CHAIQIANG\".\n- \"LC\" translates to \"DRAGONNET\".\n- \"SYT\", \"SSD\", \"LSS\", or \"LYF\" translate to \"STUDYFATHER\".\n- Any other name translates to \"DENOMINATOR\".\nArguments:\n- name: A string representing the name to be translated. It should consist only of uppercase letters and have a maximum length of 5.\n- translated_name: A string that will hold the translated name, with a maximum length of 11 characters.\nExample:\n- Given the name \"WYS\", the subroutine will set translated_name to \"KXZSMR\".", "instruction": "Write a Fortran function `subroutine translate_name(name, translated_name)` to solve the following problem:\nThis subroutine takes a given name and translates it into a specific output based on predefined mappings.\nThe mappings are as follows:\n- \"WYS\" translates to \"KXZSMR\".\n- \"CQ\" translates to \"CHAIQIANG\".\n- \"LC\" translates to \"DRAGONNET\".\n- \"SYT\", \"SSD\", \"LSS\", or \"LYF\" translate to \"STUDYFATHER\".\n- Any other name translates to \"DENOMINATOR\".\nArguments:\n- name: A string representing the name to be translated. It should consist only of uppercase letters and have a maximum length of 5.\n- translated_name: A string that will hold the translated name, with a maximum length of 11 characters.\nExample:\n- Given the name \"WYS\", the subroutine will set translated_name to \"KXZSMR\".", "level": "easy"}
{"task_id": "Fortran/14", "prompt": "! Counts the number of apples that cannot be reached by TaoTao.\n! TaoTao can reach apples within her maximum reach height, and she has a 30cm high stool to assist.\n!\n! Arguments:\n! - apple_heights: An array containing the heights of the apples from the ground (in centimeters).\n! - num_apples: The total number of apples on the tree.\n! - max_reach: TaoTao's maximum reach height without the stool (in centimeters).\n!\n! Returns:\n! - The number of apples that TaoTao cannot reach, even with the stool.\n!\n! Example:\n! - count_unreachable_apples([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 10, 110) returns 5\ninteger function count_unreachable_apples(apple_heights, num_apples, max_reach) result(unreachable)", "canonical_solution": "    integer, intent(in) :: apple_heights(:)\n    integer, intent(in) :: num_apples, max_reach\n    integer :: i\n    unreachable = 0\n\n    do i = 1, num_apples\n        if (apple_heights(i) > max_reach + 30) then\n            unreachable = unreachable + 1\n        end if\n    end do\nend function count_unreachable_apples\n\n\nend program main", "test": "program main\n  implicit none\n  integer, dimension(10) :: apple_heights\n  integer, dimension(5) :: apple_heights2\n  integer :: num_unreachable\n\n  ! Initialize the apple heights\n  apple_heights = [100, 200, 150, 140, 129, 134, 167, 198, 200, 111]\n\n  ! Call the function and test\n  num_unreachable = count_unreachable_apples(apple_heights, 10, 110)\n  call assert(num_unreachable == 5)\n\n\n  ! Initialize the apple heights\n  apple_heights2 = [432, 156, 123, 999, 421]\n\n  ! Call the function and test\n  num_unreachable = count_unreachable_apples(apple_heights2, 5, 150)\n  call assert(num_unreachable == 3)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "count_unreachable_apples", "signature": "integer function count_unreachable_apples(apple_heights, num_apples, max_reach) result(unreachable)", "docstring": "Counts the number of apples that cannot be reached by TaoTao.\nTaoTao can reach apples within her maximum reach height, and she has a 30cm high stool to assist.\n\nArguments:\n- apple_heights: An array containing the heights of the apples from the ground (in centimeters).\n- num_apples: The total number of apples on the tree.\n- max_reach: TaoTao's maximum reach height without the stool (in centimeters).\n\nReturns:\n- The number of apples that TaoTao cannot reach, even with the stool.\n\nExample:\n- count_unreachable_apples([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 10, 110) returns 5", "instruction": "Write a Fortran function `integer function count_unreachable_apples(apple_heights, num_apples, max_reach) result(unreachable)` to solve the following problem:\nCounts the number of apples that cannot be reached by TaoTao.\nTaoTao can reach apples within her maximum reach height, and she has a 30cm high stool to assist.\n\nArguments:\n- apple_heights: An array containing the heights of the apples from the ground (in centimeters).\n- num_apples: The total number of apples on the tree.\n- max_reach: TaoTao's maximum reach height without the stool (in centimeters).\n\nReturns:\n- The number of apples that TaoTao cannot reach, even with the stool.\n\nExample:\n- count_unreachable_apples([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 10, 110) returns 5", "level": "easy"}
{"task_id": "Fortran/15", "prompt": "! Extracts the middle bits (4th to 7th from the right, start counting from 0) of a given decimal number's binary representation \n! and returns their decimal value.\n\n! Arguments:\n! - number: A positive integer in decimal format.\n\n! Returns:\n! - The decimal value of the 4th to 7th bits (from the right,start counting from 0) of the binary representation of 'number'.\n\n! Example:\n! - extract_middle_bits(217) returns 13, because the binary representation of 217 is 11011001, \n!   and the 4th to 7th bits from the right are 1101, which is 13 in decimal.\nfunction extract_middle_bits(number) result(middle_bits)", "canonical_solution": "  integer, intent(in) :: number\n  integer :: middle_bits\n  integer :: shifted_number\n\n  ! Shift the number 3 bits to the right to align the 7th bit with the least significant bit\n  shifted_number = ishft(number, -4)\n\n  ! Mask the shifted number with 15 (1111 in binary) to extract only the last 4 bits\n  middle_bits = iand(shifted_number, 15)\n\nend function extract_middle_bits\n\n\nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test case 1\n  result = extract_middle_bits(217)\n  call assert(result == 13)\n\n  ! Test case 2\n  result = extract_middle_bits(255)  ! Binary: 11111111, Middle bits: 1111\n  call assert(result == 15)\n\n  ! Test case 3\n  result = extract_middle_bits(34)   ! Binary: 100010, Middle bits: 0010\n  call assert(result == 2)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "extract_middle_bits", "signature": "function extract_middle_bits(number) result(middle_bits)", "docstring": "Extracts the middle bits (4th to 7th from the right, start counting from 0) of a given decimal number's binary representation\nand returns their decimal value.\nArguments:\n- number: A positive integer in decimal format.\nReturns:\n- The decimal value of the 4th to 7th bits (from the right,start counting from 0) of the binary representation of 'number'.\nExample:\n- extract_middle_bits(217) returns 13, because the binary representation of 217 is 11011001,\nand the 4th to 7th bits from the right are 1101, which is 13 in decimal.", "instruction": "Write a Fortran function `function extract_middle_bits(number) result(middle_bits)` to solve the following problem:\nExtracts the middle bits (4th to 7th from the right, start counting from 0) of a given decimal number's binary representation\nand returns their decimal value.\nArguments:\n- number: A positive integer in decimal format.\nReturns:\n- The decimal value of the 4th to 7th bits (from the right,start counting from 0) of the binary representation of 'number'.\nExample:\n- extract_middle_bits(217) returns 13, because the binary representation of 217 is 11011001,\nand the 4th to 7th bits from the right are 1101, which is 13 in decimal.", "level": "middle"}
{"task_id": "Fortran/16", "prompt": "! Calculates the sum of elements on the two main diagonals of a square matrix.\n! The function handles a square matrix of size 'size' and returns the sums of its two diagonals. \n! The first sum is from the top-left to bottom-right diagonal, and the second sum is from the top-right to bottom-left diagonal.\n\n! Arguments:\n! - matrix: A 2D integer array representing a square matrix.\n! - size: The size of the dimensions of the square matrix.\n\n! Returns:\n! - sum1: The sum of the elements on the diagonal from top-left to bottom-right.\n! - sum2: The sum of the elements on the diagonal from top-right to bottom-left.\n\n! Example:\n! Given a 3x3 matrix:\n! 1 2 3\n! 4 5 6\n! 7 8 9\n! sum_diagonals(matrix, 3, sum1, sum2) will set sum1 to 15 (1+5+9) and sum2 to 15 (3+5+7).\n\nsubroutine sum_diagonals(matrix, size, sum1, sum2)", "canonical_solution": "  integer, intent(in) :: matrix(:,:)\n  integer, intent(in) :: size\n  integer, intent(out) :: sum1, sum2\n  integer :: i\n\n  sum1 = 0\n  sum2 = 0\n\n  do i = 1, size\n      sum1 = sum1 + matrix(i, i)\n      sum2 = sum2 + matrix(i, size-i+1)\n  end do\nend subroutine sum_diagonals\n\n\nend program main", "test": "program main\n  implicit none\n  integer, parameter :: size = 5\n  integer, parameter :: size2 = 3\n  integer :: matrix(size, size)\n  integer :: matrix2(size2, size2)\n  integer :: sum1, sum2\n\n  ! Initialize matrix\n  matrix = reshape([&\n      1, 0, 0, 0, 2, &\n      0, 1, 0, 2, 0, &\n      0, 0, 1, 0, 0, &\n      0, 2, 0, 1, 0, &\n      2, 0, 0, 0, 1 &\n  ], shape(matrix))\n\n\n  \n  ! Call function\n  call sum_diagonals(matrix, size, sum1, sum2)\n\n  ! Test cases\n  call assert(sum1 .eq. 5)\n  call assert(sum2 .eq. 9)\n\n\n  matrix2 = reshape([&\n      1, 2, 3, &\n      4, 5, 6, &\n      7, 8, 9 &\n  ], shape(matrix2))\n  ! Call function\n  call sum_diagonals(matrix2, size2, sum1, sum2)\n\n  ! Test cases\n  call assert(sum1 .eq. 15)\n  call assert(sum2 .eq. 15)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "sum_diagonals", "signature": "subroutine sum_diagonals(matrix, size, sum1, sum2)", "docstring": "Calculates the sum of elements on the two main diagonals of a square matrix.\nThe function handles a square matrix of size 'size' and returns the sums of its two diagonals.\nThe first sum is from the top-left to bottom-right diagonal, and the second sum is from the top-right to bottom-left diagonal.\nArguments:\n- matrix: A 2D integer array representing a square matrix.\n- size: The size of the dimensions of the square matrix.\nReturns:\n- sum1: The sum of the elements on the diagonal from top-left to bottom-right.\n- sum2: The sum of the elements on the diagonal from top-right to bottom-left.\nExample:\nGiven a 3x3 matrix:\n1 2 3\n4 5 6\n7 8 9\nsum_diagonals(matrix, 3, sum1, sum2) will set sum1 to 15 (1+5+9) and sum2 to 15 (3+5+7).", "instruction": "Write a Fortran function `subroutine sum_diagonals(matrix, size, sum1, sum2)` to solve the following problem:\nCalculates the sum of elements on the two main diagonals of a square matrix.\nThe function handles a square matrix of size 'size' and returns the sums of its two diagonals.\nThe first sum is from the top-left to bottom-right diagonal, and the second sum is from the top-right to bottom-left diagonal.\nArguments:\n- matrix: A 2D integer array representing a square matrix.\n- size: The size of the dimensions of the square matrix.\nReturns:\n- sum1: The sum of the elements on the diagonal from top-left to bottom-right.\n- sum2: The sum of the elements on the diagonal from top-right to bottom-left.\nExample:\nGiven a 3x3 matrix:\n1 2 3\n4 5 6\n7 8 9\nsum_diagonals(matrix, 3, sum1, sum2) will set sum1 to 15 (1+5+9) and sum2 to 15 (3+5+7).", "level": "easy"}
{"task_id": "Fortran/17", "prompt": "! This function removes middle and trailing asterisks (*) from a string while preserving leading asterisks and alphabetic characters.\n! Leading asterisks are defined as consecutive asterisks at the beginning of the string.\n\n! Arguments:\n! - input_str: A string containing letters and asterisks. The string must have leading asterisks, and asterisks between each letter.\n\n! Returns:\n! - output_str: The modified string with middle and trailing asterisks removed.\n\n! Example:\n! - remove_middle_stars(\"****a*bc*def*g****\") returns \"****abcdefg\"\nfunction remove_middle_stars(input_str) result(output_str)", "canonical_solution": "  character(len=*), intent(in) :: input_str\n  character(len=:), allocatable :: output_str\n  integer :: i, len_str, output_index\n  character(len=1) :: current_char\n  logical :: past_leading_asterisks\n\n  len_str = len_trim(input_str)\n  allocate(character(len=len_str) :: output_str)\n  output_index = 0\n  past_leading_asterisks = .false.\n\n  do i = 1, len_str\n      current_char = input_str(i:i)\n      if (current_char == '*' .and. .not. past_leading_asterisks) then\n          output_index = output_index + 1\n          output_str(output_index:output_index) = current_char\n      else if (current_char /= '*') then\n          past_leading_asterisks = .true.\n          output_index = output_index + 1\n          output_str(output_index:output_index) = current_char\n      end if\n  end do\n\n  if (output_index < len_str) then\n      output_str = output_str(1:output_index)\n  end if\nend function remove_middle_stars\n\n\nend program main", "test": "program main\n  use, intrinsic :: iso_fortran_env, only: stderr => error_unit\n  implicit none\n\n  character(len=:), allocatable :: result\n\n  result = remove_middle_stars(\"****a*bc*def*g****\")\n  call assert(trim(result) == \"****abcdefg\")\n\n  result = remove_middle_stars(\"*****h*i*j***\")\n  call assert(trim(result) == \"*****hij\")\n\n  result = remove_middle_stars(\"***x*y*z\")\n  call assert(trim(result) == \"***xyz\")\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "remove_middle_stars", "signature": "function remove_middle_stars(input_str) result(output_str)", "docstring": "This function removes middle and trailing asterisks (*) from a string while preserving leading asterisks and alphabetic characters.\nLeading asterisks are defined as consecutive asterisks at the beginning of the string.\nArguments:\n- input_str: A string containing letters and asterisks. The string must have leading asterisks, and asterisks between each letter.\nReturns:\n- output_str: The modified string with middle and trailing asterisks removed.\nExample:\n- remove_middle_stars(\"****a*bc*def*g****\") returns \"****abcdefg\"", "instruction": "Write a Fortran function `function remove_middle_stars(input_str) result(output_str)` to solve the following problem:\nThis function removes middle and trailing asterisks (*) from a string while preserving leading asterisks and alphabetic characters.\nLeading asterisks are defined as consecutive asterisks at the beginning of the string.\nArguments:\n- input_str: A string containing letters and asterisks. The string must have leading asterisks, and asterisks between each letter.\nReturns:\n- output_str: The modified string with middle and trailing asterisks removed.\nExample:\n- remove_middle_stars(\"****a*bc*def*g****\") returns \"****abcdefg\"", "level": "hard"}
{"task_id": "Fortran/18", "prompt": "! This function converts a numeric score into a letter grade based on predefined criteria.\n! The grading scale is as follows:\n! 90-100 -> 'A', 80-89 -> 'B', 70-79 -> 'C', 60-69 -> 'D', 0-59 -> 'E'.\n! If the score is outside the 0-100 range, the function returns an error message.\n\n! Arguments:\n! - score: An integer representing the score in the range 0 to 100.\n\n! Returns:\n! - A single character string representing the grade ('A', 'B', 'C', 'D', 'E'), \n!   or 'X' if the score is outside the valid range.\n\n! Examples:\n! - convert_score_to_grade(85) returns 'B'\n! - convert_score_to_grade(101) returns 'X' (indicating an error)\nfunction convert_score_to_grade(score) result(grade)", "canonical_solution": "  integer, intent(in) :: score\n  character(len=1) :: grade\n\n  select case(score)\n      case(90:100)\n          grade = 'A'\n      case(80:89)\n          grade = 'B'\n      case(70:79)\n          grade = 'C'\n      case(60:69)\n          grade = 'D'\n      case(0:59)\n          grade = 'E'\n      case default\n          grade = 'X' ! Error indicator for scores outside 0-100 range\n  end select\nend function convert_score_to_grade\n\nend program main", "test": "program main\n  implicit none\n\n  integer :: scores(5)\n  character(len=1) :: expected_grades(5)\n  character(len=1) :: grade\n  integer :: i\n\n  ! Test data\n  scores = [56, 67, 100, 123, 85]\n  expected_grades = ['E', 'D', 'A', 'X', 'B']\n\n  ! Testing\n  do i = 1, size(scores)\n      grade = convert_score_to_grade(scores(i))\n      call assert(grade == expected_grades(i))\n  end do\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "convert_score_to_grade", "signature": "function convert_score_to_grade(score) result(grade)", "docstring": "This function converts a numeric score into a letter grade based on predefined criteria.\nThe grading scale is as follows:\n90-100 -> 'A', 80-89 -> 'B', 70-79 -> 'C', 60-69 -> 'D', 0-59 -> 'E'.\nIf the score is outside the 0-100 range, the function returns an error message.\nArguments:\n- score: An integer representing the score in the range 0 to 100.\nReturns:\n- A single character string representing the grade ('A', 'B', 'C', 'D', 'E'),\nor 'X' if the score is outside the valid range.\nExamples:\n- convert_score_to_grade(85) returns 'B'\n- convert_score_to_grade(101) returns 'X' (indicating an error)", "instruction": "Write a Fortran function `function convert_score_to_grade(score) result(grade)` to solve the following problem:\nThis function converts a numeric score into a letter grade based on predefined criteria.\nThe grading scale is as follows:\n90-100 -> 'A', 80-89 -> 'B', 70-79 -> 'C', 60-69 -> 'D', 0-59 -> 'E'.\nIf the score is outside the 0-100 range, the function returns an error message.\nArguments:\n- score: An integer representing the score in the range 0 to 100.\nReturns:\n- A single character string representing the grade ('A', 'B', 'C', 'D', 'E'),\nor 'X' if the score is outside the valid range.\nExamples:\n- convert_score_to_grade(85) returns 'B'\n- convert_score_to_grade(101) returns 'X' (indicating an error)", "level": "easy"}
{"task_id": "Fortran/19", "prompt": "! Determines the day of the year for a given date in the format YYYY/MM/DD.\n\n! Arguments:\n! - date_string: A string representing a date in the format YYYY/MM/DD.\n\n! Returns:\n! - The day count as an integer, representing the day of the year.\n\n! Example:\n! - day_of_year(\"1985/1/20\") returns 20\n! - day_of_year(\"2006/3/12\") returns 71\ninteger function day_of_year(date_string) result(day_count)", "canonical_solution": "    character(len=*), intent(in) :: date_string\n    integer :: year, month, day\n    integer, dimension(12) :: days_in_month\n    integer :: first_slash_pos, second_slash_pos\n\n    ! Initialize the days in each month\n    days_in_month = (/ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 /)\n\n    ! Find the positions of the slashes\n    first_slash_pos = index(date_string, '/')\n    second_slash_pos = index(date_string, '/', .true.)\n\n    ! Extract year, month, day from the date_string\n    read(date_string(1:first_slash_pos-1), *) year\n    read(date_string(first_slash_pos+1:second_slash_pos-1), *) month\n    read(date_string(second_slash_pos+1:), *) day\n\n    ! Check for leap year and adjust February days\n    if ((mod(year, 4) == 0 .and. mod(year, 100) /= 0) .or. mod(year, 400) == 0) then\n        days_in_month(2) = 29\n    endif\n\n    ! Calculate the day of the year\n    day_count = sum(days_in_month(1:month-1)) + day\nend function day_of_year\n\n\nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test cases\n  result = day_of_year(\"1985/1/20\")\n  ! print *, result\n  call assert(result == 20)\n\n  result = day_of_year(\"2006/3/12\")\n  call assert(result == 71)\n\n  result = day_of_year(\"2000/3/1\")\n  call assert(result == 61)  ! Leap year test\n\n  result = day_of_year(\"2100/3/1\")\n  call assert(result == 60)  ! Non-leap year test (divisible by 100 but not 400)\n\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "day_of_year", "signature": "integer function day_of_year(date_string) result(day_count)", "docstring": "Determines the day of the year for a given date in the format YYYY/MM/DD.\nArguments:\n- date_string: A string representing a date in the format YYYY/MM/DD.\nReturns:\n- The day count as an integer, representing the day of the year.\nExample:\n- day_of_year(\"1985/1/20\") returns 20\n- day_of_year(\"2006/3/12\") returns 71", "instruction": "Write a Fortran function `integer function day_of_year(date_string) result(day_count)` to solve the following problem:\nDetermines the day of the year for a given date in the format YYYY/MM/DD.\nArguments:\n- date_string: A string representing a date in the format YYYY/MM/DD.\nReturns:\n- The day count as an integer, representing the day of the year.\nExample:\n- day_of_year(\"1985/1/20\") returns 20\n- day_of_year(\"2006/3/12\") returns 71", "level": "hard"}
{"task_id": "Fortran/20", "prompt": "! Sorts a given array of integers in ascending order.\n!\n! This subroutine takes an array of integers and its size as input and returns a new array \n! that contains the elements of the input array sorted in ascending order. The sorting is \n! done using a simple sorting algorithm, such as bubble sort or insertion sort.\n!\n! Arguments:\n! - numbers: An array of integers, each with an absolute value less than 10000.\n! - n: The size of the input array.\n! - sorted_numbers: An array of integers that will contain the sorted elements.\n!\n! Examples:\n! - Given numbers = [8, 3, 6, 4, 9] and n = 5, the subroutine will output sorted_numbers = [3, 4, 6, 8, 9].\n\n\nsubroutine sort_array(numbers, n, sorted_numbers)", "canonical_solution": "  integer, intent(in) :: n\n  integer, intent(in) :: numbers(n)\n  integer, intent(out) :: sorted_numbers(n)\n  integer :: i, j, temp\n\n  ! Copy input array to sorted_numbers\n  sorted_numbers = numbers\n\n  ! Bubble sort algorithm\n  do i = 1, n - 1\n      do j = 1, n - i\n          if (sorted_numbers(j) > sorted_numbers(j + 1)) then\n              temp = sorted_numbers(j)\n              sorted_numbers(j) = sorted_numbers(j + 1)\n              sorted_numbers(j + 1) = temp\n          end if\n      end do\n  end do\nend subroutine sort_array\n\nend program main", "test": "program main\n  implicit none\n  integer, parameter :: max_size = 200\n  integer :: test_array(max_size), sorted_array(max_size), n\n  integer :: i\n\n  ! Test case 1\n  n = 5\n  test_array = 0\n  test_array(1:n) = [8, 3, 6, 4, 9]\n  call sort_array(test_array, n, sorted_array)\n\n  ! Validate the sorted array\n  call assert(all(sorted_array(1:n) == [3, 4, 6, 8, 9]))\n\n\n  ! Test case 1\n  n = 10\n  test_array = 0\n  test_array(1:n) = [112, 223, 5443, 2, 435, 8, 3, 6, 4, 9]\n  call sort_array(test_array, n, sorted_array)\n\n  ! Validate the sorted array\n  call assert(all(sorted_array(1:n) == [2, 3, 4, 6, 8, 9, 112, 223, 435, 5443]))\n\ncontains\n\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "sort_array", "signature": "subroutine sort_array(numbers, n, sorted_numbers)", "docstring": "Sorts a given array of integers in ascending order.\n\nThis subroutine takes an array of integers and its size as input and returns a new array\nthat contains the elements of the input array sorted in ascending order. The sorting is\ndone using a simple sorting algorithm, such as bubble sort or insertion sort.\n\nArguments:\n- numbers: An array of integers, each with an absolute value less than 10000.\n- n: The size of the input array.\n- sorted_numbers: An array of integers that will contain the sorted elements.\n\nExamples:\n- Given numbers = [8, 3, 6, 4, 9] and n = 5, the subroutine will output sorted_numbers = [3, 4, 6, 8, 9].", "instruction": "Write a Fortran function `subroutine sort_array(numbers, n, sorted_numbers)` to solve the following problem:\nSorts a given array of integers in ascending order.\n\nThis subroutine takes an array of integers and its size as input and returns a new array\nthat contains the elements of the input array sorted in ascending order. The sorting is\ndone using a simple sorting algorithm, such as bubble sort or insertion sort.\n\nArguments:\n- numbers: An array of integers, each with an absolute value less than 10000.\n- n: The size of the input array.\n- sorted_numbers: An array of integers that will contain the sorted elements.\n\nExamples:\n- Given numbers = [8, 3, 6, 4, 9] and n = 5, the subroutine will output sorted_numbers = [3, 4, 6, 8, 9].", "level": "easy"}
{"task_id": "Fortran/21", "prompt": "! This function calculates the sum of all positive integers less than or equal to 'n' that are not related to the number 2.\n! A number is considered unrelated to 2 if it is not divisible by 2 and does not contain the digit 2 in its decimal representation.\n\n! Arguments:\n! - n: An integer in the range of 2 to 1000.\n\n! Returns:\n! - The sum of all positive integers less than or equal to 'n' that are unrelated to the number 2.\n\n! Example:\n! - sum_unrelated_to_two(8) returns 16, as the numbers unrelated to 2 are 1, 3, 5, and 7.\nfunction sum_unrelated_to_two(n) result(sum)", "canonical_solution": "  integer, intent(in) :: n\n  integer :: sum, i\n\n  sum = 0\n  do i = 1, n\n      if (mod(i, 2) /= 0 .and. .not. contains_digit_two(i)) then\n          sum = sum + i\n      end if\n  end do\nend function sum_unrelated_to_two\n\nlogical function contains_digit_two(num)\n  integer, intent(in) :: num\n  integer :: current\n\n  contains_digit_two = .false.\n  current = num\n  do while (current > 0)\n      if (mod(current, 10) == 2) then\n          contains_digit_two = .true.\n          return\n      end if\n      current = current / 10\n  end do\nend function contains_digit_two\n\nend program main\n", "test": "program main\n  implicit none\n\n  ! Test cases\n  call assert(sum_unrelated_to_two(8) == 16)\n  call assert(sum_unrelated_to_two(10) == 25)\n  call assert(sum_unrelated_to_two(20) == 100)\n  call assert(sum_unrelated_to_two(2) == 1)\n  call assert(sum_unrelated_to_two(15) == 64)\n\n  print *, \"All tests passed successfully.\"\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "sum_unrelated_to_two", "signature": "function sum_unrelated_to_two(n) result(sum)", "docstring": "This function calculates the sum of all positive integers less than or equal to 'n' that are not related to the number 2.\nA number is considered unrelated to 2 if it is not divisible by 2 and does not contain the digit 2 in its decimal representation.\nArguments:\n- n: An integer in the range of 2 to 1000.\nReturns:\n- The sum of all positive integers less than or equal to 'n' that are unrelated to the number 2.\nExample:\n- sum_unrelated_to_two(8) returns 16, as the numbers unrelated to 2 are 1, 3, 5, and 7.", "instruction": "Write a Fortran function `function sum_unrelated_to_two(n) result(sum)` to solve the following problem:\nThis function calculates the sum of all positive integers less than or equal to 'n' that are not related to the number 2.\nA number is considered unrelated to 2 if it is not divisible by 2 and does not contain the digit 2 in its decimal representation.\nArguments:\n- n: An integer in the range of 2 to 1000.\nReturns:\n- The sum of all positive integers less than or equal to 'n' that are unrelated to the number 2.\nExample:\n- sum_unrelated_to_two(8) returns 16, as the numbers unrelated to 2 are 1, 3, 5, and 7.", "level": "middle"}
{"task_id": "Fortran/22", "prompt": "! Calculates the number of ways to exchange a given amount of money using coins of 1 and 2 units.\n! This function employs a recursive approach to determine all possible combinations.\n\n! Arguments:\n! - n: An integer representing the value of the money to be exchanged. It should be between 1 and 10.\n\n! Returns:\n! - The total number of different ways to exchange the given amount of money.\n\n! Example:\n! - count_coin_change_ways(4) returns 5, as there are 5 ways to exchange a 4-unit bill:\n!   1) 1+1+1+1, 2) 2+1+1, 3) 1+2+1, 4) 1+1+2, 5) 2+2\nrecursive integer function count_coin_change_ways(n) result(ways)", "canonical_solution": "    integer, intent(in) :: n\n    ways = 0\n\n    if (n < 0) then\n        ways = 0\n        return\n    elseif (n == 0) then\n        ways = 1\n        return\n    else\n        ways = count_coin_change_ways(n - 1) + count_coin_change_ways(n - 2)\n    end if\nend function count_coin_change_ways\n\nend program main\n", "test": "program main\n  implicit none\n  integer :: result\n    ! Test cases\n  result = count_coin_change_ways(4)\n  call assert(result == 5)\n\n  result = count_coin_change_ways(5)\n  call assert(result == 8)\n\n  result = count_coin_change_ways(3)\n  call assert(result == 3)\n\n  result = count_coin_change_ways(2)\n  call assert(result == 2)\n\n  result = count_coin_change_ways(15)\n  call assert(result == 987)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "count_coin_change_ways", "signature": "recursive integer function count_coin_change_ways(n) result(ways)", "docstring": "Calculates the number of ways to exchange a given amount of money using coins of 1 and 2 units.\nThis function employs a recursive approach to determine all possible combinations.\nArguments:\n- n: An integer representing the value of the money to be exchanged. It should be between 1 and 10.\nReturns:\n- The total number of different ways to exchange the given amount of money.\nExample:\n- count_coin_change_ways(4) returns 5, as there are 5 ways to exchange a 4-unit bill:\n1) 1+1+1+1, 2) 2+1+1, 3) 1+2+1, 4) 1+1+2, 5) 2+2", "instruction": "Write a Fortran function `recursive integer function count_coin_change_ways(n) result(ways)` to solve the following problem:\nCalculates the number of ways to exchange a given amount of money using coins of 1 and 2 units.\nThis function employs a recursive approach to determine all possible combinations.\nArguments:\n- n: An integer representing the value of the money to be exchanged. It should be between 1 and 10.\nReturns:\n- The total number of different ways to exchange the given amount of money.\nExample:\n- count_coin_change_ways(4) returns 5, as there are 5 ways to exchange a 4-unit bill:\n1) 1+1+1+1, 2) 2+1+1, 3) 1+2+1, 4) 1+1+2, 5) 2+2", "level": "easy"}
{"task_id": "Fortran/23", "prompt": "! Reverses the digits of a given three-digit number and returns the result.\n!\n! Arguments:\n! - number: An integer representing a three-digit number (100 <= number <= 999).\n!\n! Returns:\n! - The reversed number as an integer.\n!\n! Example:\n! - reverse_digits(127) returns 721\n! - reverse_digits(305) returns 503\n! - reverse_digits(450) returns 54\nfunction reverse_digits(number) result(reversed_number)", "canonical_solution": "  integer, intent(in) :: number\n  integer :: reversed_number\n  integer :: hundreds, tens, units\n\n  ! Extracting digits\n  hundreds = number / 100\n  tens = mod(number / 10, 10)\n  units = mod(number, 10)\n\n  ! Reconstructing in reverse\n  reversed_number = units * 100 + tens * 10 + hundreds\n\nend function reverse_digits\n\nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test 1\n  result = reverse_digits(127)\n  call assert(result == 721)\n\n  ! Test 2\n  result = reverse_digits(305)\n  call assert(result == 503)\n\n  ! Test 3\n  result = reverse_digits(450)\n  call assert(result == 54)\n\n  ! Test 4\n  result = reverse_digits(999)\n  call assert(result == 999)\n\n  ! Test 5\n  result = reverse_digits(100)\n  call assert(result == 1)\n\ncontains\n\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "reverse_digits", "signature": "function reverse_digits(number) result(reversed_number)", "docstring": "Reverses the digits of a given three-digit number and returns the result.\n\nArguments:\n- number: An integer representing a three-digit number (100 <= number <= 999).\n\nReturns:\n- The reversed number as an integer.\n\nExample:\n- reverse_digits(127) returns 721\n- reverse_digits(305) returns 503\n- reverse_digits(450) returns 54", "instruction": "Write a Fortran function `function reverse_digits(number) result(reversed_number)` to solve the following problem:\nReverses the digits of a given three-digit number and returns the result.\n\nArguments:\n- number: An integer representing a three-digit number (100 <= number <= 999).\n\nReturns:\n- The reversed number as an integer.\n\nExample:\n- reverse_digits(127) returns 721\n- reverse_digits(305) returns 503\n- reverse_digits(450) returns 54", "level": "easy"}
{"task_id": "Fortran/24", "prompt": "! Determines the character that appears the most in a given string composed of lowercase English letters ('a' to 'z').\n! In case of a tie, returns the character with the smallest ASCII value.\n!\n! Arguments:\n! - input_string: A string consisting of lowercase English letters.\n! - max_char: The character that appears the most.\n! - max_count: The number of times max_char appears in the string.\n!\n! Examples:\n! - Calling most_frequent_character(\"abbccc\", max_char, max_count) will set max_char to 'c' and max_count to 3.\n! - Calling most_frequent_character(\"adfadffasdf\", max_char, max_count) will set max_char to 'f' and max_count to 4.\nsubroutine most_frequent_character(input_string, max_char, max_count)", "canonical_solution": "  character(len=*), intent(in) :: input_string\n  character :: max_char\n  integer :: max_count\n  integer :: counts(26)\n  integer :: i, ascii_value\n\n  ! Initialize counts to zero\n  counts = 0\n\n  ! Count occurrences of each character\n  do i = 1, len_trim(input_string)\n      ascii_value = ichar(input_string(i:i)) - ichar('a') + 1\n      if (ascii_value >= 1 .and. ascii_value <= 26) then\n          counts(ascii_value) = counts(ascii_value) + 1\n      end if\n  end do\n\n  ! Find the most frequent character\n  max_count = maxval(counts)\n  max_char = 'a'\n  do i = 1, 26\n      if (counts(i) == max_count) then\n          max_char = char(i + ichar('a') - 1)\n          return\n      end if\n  end do\nend subroutine most_frequent_character\n\nend program main", "test": "program main\n  implicit none\n  character :: max_char\n  integer :: max_count\n\n  ! Test 1\n  call most_frequent_character(\"abbccc\", max_char, max_count)\n  call assert(max_char == 'c' .and. max_count == 3)\n\n  ! Test 2\n  call most_frequent_character(\"adfadffasdf\", max_char, max_count)\n  call assert(max_char == 'f' .and. max_count == 4)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "most_frequent_character", "signature": "subroutine most_frequent_character(input_string, max_char, max_count)", "docstring": "Determines the character that appears the most in a given string composed of lowercase English letters ('a' to 'z').\nIn case of a tie, returns the character with the smallest ASCII value.\n\nArguments:\n- input_string: A string consisting of lowercase English letters.\n- max_char: The character that appears the most.\n- max_count: The number of times max_char appears in the string.\n\nExamples:\n- Calling most_frequent_character(\"abbccc\", max_char, max_count) will set max_char to 'c' and max_count to 3.\n- Calling most_frequent_character(\"adfadffasdf\", max_char, max_count) will set max_char to 'f' and max_count to 4.", "instruction": "Write a Fortran function `subroutine most_frequent_character(input_string, max_char, max_count)` to solve the following problem:\nDetermines the character that appears the most in a given string composed of lowercase English letters ('a' to 'z').\nIn case of a tie, returns the character with the smallest ASCII value.\n\nArguments:\n- input_string: A string consisting of lowercase English letters.\n- max_char: The character that appears the most.\n- max_count: The number of times max_char appears in the string.\n\nExamples:\n- Calling most_frequent_character(\"abbccc\", max_char, max_count) will set max_char to 'c' and max_count to 3.\n- Calling most_frequent_character(\"adfadffasdf\", max_char, max_count) will set max_char to 'f' and max_count to 4.", "level": "easy"}
{"task_id": "Fortran/25", "prompt": "! Solves the classic 'Chicken and Rabbit' problem.\n! Given the total number of animals (chickens and rabbits) and the total number of legs, the subroutine calculates the number of chickens and rabbits.\n\n! Arguments:\n! - total_count: Total number of animals (chickens and rabbits combined).\n! - total_legs: Total number of legs of all animals.\n! - chickens: Number of chickens (output).\n! - rabbits: Number of rabbits (output).\n! - solvable: A logical flag indicating if the problem has a solution (output).\n\n! Returns:\n! - This subroutine does not return a value but updates the 'chickens', 'rabbits', and 'solvable' variables.\n\n! Example:\n! - For total_count=14 and total_legs=32, chickens=12 and rabbits=2.\n! - For total_count=10 and total_legs=16, the output is 'No answer' (unsolvable).\nsubroutine solve_chicken_rabbit(total_count, total_legs, chickens, rabbits, solvable)", "canonical_solution": "  integer, intent(in) :: total_count, total_legs\n  integer, intent(out) :: chickens, rabbits\n  logical, intent(out) :: solvable\n  integer :: legs_diff\n\n  solvable = .false.\n  legs_diff = total_legs - 2 * total_count\n\n  if (mod(legs_diff, 2) == 0 .and. legs_diff >= 0 .and. legs_diff / 2 <= total_count) then\n      rabbits = legs_diff / 2\n      chickens = total_count - rabbits\n      solvable = .true.\n  end if\nend subroutine solve_chicken_rabbit\n\nend program main", "test": "program main\n  implicit none\n\n    integer :: chickens, rabbits\n    logical :: solvable\n\n    ! Test case 1: Solvable scenario\n    call solve_chicken_rabbit(14, 32, chickens, rabbits, solvable)\n    call assert(chickens == 12 .and. rabbits == 2 .and. solvable)\n\n    ! Test case 2: Unsolvable scenario\n    call solve_chicken_rabbit(10, 16, chickens, rabbits, solvable)\n    call assert(.not. solvable)\n\n    ! Additional Test case: Another solvable scenario\n    call solve_chicken_rabbit(20, 56, chickens, rabbits, solvable)\n    call assert(chickens == 12 .and. rabbits == 8 .and. solvable)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "solve_chicken_rabbit", "signature": "subroutine solve_chicken_rabbit(total_count, total_legs, chickens, rabbits, solvable)", "docstring": "Solves the classic 'Chicken and Rabbit' problem.\nGiven the total number of animals (chickens and rabbits) and the total number of legs, the subroutine calculates the number of chickens and rabbits.\nArguments:\n- total_count: Total number of animals (chickens and rabbits combined).\n- total_legs: Total number of legs of all animals.\n- chickens: Number of chickens (output).\n- rabbits: Number of rabbits (output).\n- solvable: A logical flag indicating if the problem has a solution (output).\nReturns:\n- This subroutine does not return a value but updates the 'chickens', 'rabbits', and 'solvable' variables.\nExample:\n- For total_count=14 and total_legs=32, chickens=12 and rabbits=2.\n- For total_count=10 and total_legs=16, the output is 'No answer' (unsolvable).", "instruction": "Write a Fortran function `subroutine solve_chicken_rabbit(total_count, total_legs, chickens, rabbits, solvable)` to solve the following problem:\nSolves the classic 'Chicken and Rabbit' problem.\nGiven the total number of animals (chickens and rabbits) and the total number of legs, the subroutine calculates the number of chickens and rabbits.\nArguments:\n- total_count: Total number of animals (chickens and rabbits combined).\n- total_legs: Total number of legs of all animals.\n- chickens: Number of chickens (output).\n- rabbits: Number of rabbits (output).\n- solvable: A logical flag indicating if the problem has a solution (output).\nReturns:\n- This subroutine does not return a value but updates the 'chickens', 'rabbits', and 'solvable' variables.\nExample:\n- For total_count=14 and total_legs=32, chickens=12 and rabbits=2.\n- For total_count=10 and total_legs=16, the output is 'No answer' (unsolvable).", "level": "easy"}
{"task_id": "Fortran/26", "prompt": "! Calculates either the sum or the square sum of two integers based on a condition.\n!\n! If the sum of the squares of 'a' and 'b' (a^2 + b^2) is greater than 100, \n! the function returns the square sum. Otherwise, it returns the sum of 'a' and 'b'.\n!\n! Arguments:\n! - a: An integer value.\n! - b: An integer value.\n!\n! Returns:\n! - The sum of 'a' and 'b' if their square sum is less than or equal to 100, \n!   otherwise their square sum.\n!\n! Example:\n! - sum_or_square_sum(5, 9) returns 106\n! - sum_or_square_sum(3, 4) returns 7\n\ninteger function sum_or_square_sum(a, b) result(res)", "canonical_solution": "    integer, intent(in) :: a, b\n    integer :: square_sum\n\n    square_sum = a**2 + b**2\n    if (square_sum > 100) then\n        res = square_sum\n    else\n        res = a + b\n    end if\nend function sum_or_square_sum\n\nend program main", "test": "program main\n  implicit none\n\n  ! Test cases\n  call assert(sum_or_square_sum(5, 9) == 106)\n  call assert(sum_or_square_sum(3, 4) == 7)\n  call assert(sum_or_square_sum(10, 0) == 10)\n  call assert(sum_or_square_sum(10, 10) == 200)\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "sum_or_square_sum", "signature": "integer function sum_or_square_sum(a, b) result(res)", "docstring": "Calculates either the sum or the square sum of two integers based on a condition.\n\nIf the sum of the squares of 'a' and 'b' (a^2 + b^2) is greater than 100,\nthe function returns the square sum. Otherwise, it returns the sum of 'a' and 'b'.\n\nArguments:\n- a: An integer value.\n- b: An integer value.\n\nReturns:\n- The sum of 'a' and 'b' if their square sum is less than or equal to 100,\notherwise their square sum.\n\nExample:\n- sum_or_square_sum(5, 9) returns 106\n- sum_or_square_sum(3, 4) returns 7", "instruction": "Write a Fortran function `integer function sum_or_square_sum(a, b) result(res)` to solve the following problem:\nCalculates either the sum or the square sum of two integers based on a condition.\n\nIf the sum of the squares of 'a' and 'b' (a^2 + b^2) is greater than 100,\nthe function returns the square sum. Otherwise, it returns the sum of 'a' and 'b'.\n\nArguments:\n- a: An integer value.\n- b: An integer value.\n\nReturns:\n- The sum of 'a' and 'b' if their square sum is less than or equal to 100,\notherwise their square sum.\n\nExample:\n- sum_or_square_sum(5, 9) returns 106\n- sum_or_square_sum(3, 4) returns 7", "level": "easy"}
{"task_id": "Fortran/27", "prompt": "! Calculates the value of y based on the given integer x according to a piecewise function.\n! The function is defined as follows:\n! y = 2x for x < 3\n! y = 2x + 1 for 3 <= x < 20\n! y = 3x - 1 for x >= 20\n\n! Arguments:\n! - x: An integer representing the input value.\n\n! Returns:\n! - y: The calculated integer value based on the piecewise function.\n\n! Examples:\n! - calculate_y(2) returns 4\n! - calculate_y(4) returns 9\n! - calculate_y(20) returns 59\ninteger function calculate_y(x) result(y)", "canonical_solution": "    integer, intent(in) :: x\n\n    ! Implementing the piecewise function\n    if (x < 3) then\n        y = 2 * x\n    else if (x >= 3 .and. x < 20) then\n        y = 2 * x + 1\n    else\n        y = 3 * x - 1\n    end if\nend function calculate_y\n\nend program main\n", "test": "program main\n  implicit none\n  integer :: result\n    ! Test 1\n  result = calculate_y(2)\n  call assert(result .eq. 4)\n\n  ! Test 2\n  result = calculate_y(4)\n  call assert(result .eq. 9)\n\n  ! Test 3\n  result = calculate_y(20)\n  call assert(result .eq. 59)\n\n  ! Additional tests\n  result = calculate_y(3)\n  call assert(result .eq. 7)\n\n  result = calculate_y(19)\n  call assert(result .eq. 39)\n\n  result = calculate_y(21)\n  call assert(result .eq. 62)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "calculate_y", "signature": "integer function calculate_y(x) result(y)", "docstring": "Calculates the value of y based on the given integer x according to a piecewise function.\nThe function is defined as follows:\ny = 2x for x < 3\ny = 2x + 1 for 3 <= x < 20\ny = 3x - 1 for x >= 20\nArguments:\n- x: An integer representing the input value.\nReturns:\n- y: The calculated integer value based on the piecewise function.\nExamples:\n- calculate_y(2) returns 4\n- calculate_y(4) returns 9\n- calculate_y(20) returns 59", "instruction": "Write a Fortran function `integer function calculate_y(x) result(y)` to solve the following problem:\nCalculates the value of y based on the given integer x according to a piecewise function.\nThe function is defined as follows:\ny = 2x for x < 3\ny = 2x + 1 for 3 <= x < 20\ny = 3x - 1 for x >= 20\nArguments:\n- x: An integer representing the input value.\nReturns:\n- y: The calculated integer value based on the piecewise function.\nExamples:\n- calculate_y(2) returns 4\n- calculate_y(4) returns 9\n- calculate_y(20) returns 59", "level": "easy"}
{"task_id": "Fortran/28", "prompt": "! Checks if a given number (represented as a string) is a palindrome.\n! A palindrome is a sequence of characters that reads the same forward and backward.\n\n! Arguments:\n! - number_string: A string representing a positive integer.\n\n! Returns:\n! - A logical value indicating whether the number is a palindrome (.true.) or not (.false.).\n\n! Example:\n! - is_palindrome(\"12321\") returns .true.\n! - is_palindrome(\"12345\") returns .false.\nlogical function is_palindrome(number_string)", "canonical_solution": "    character(len=*), intent(in) :: number_string\n    integer :: i, str_length\n\n    str_length = len_trim(number_string)\n    is_palindrome = .true.\n\n    do i = 1, str_length / 2\n        if (number_string(i:i) /= number_string(str_length - i + 1:str_length - i + 1)) then\n            is_palindrome = .false.\n            return\n        end if\n    end do\nend function is_palindrome\n\nend program main", "test": "program main\n  implicit none\n  call assert(is_palindrome(\"12321\")  .eqv. .true.)\n  call assert(is_palindrome(\"12345\")  .eqv. .false.)\n  call assert(is_palindrome(\"44\")     .eqv. .true.)\n  call assert(is_palindrome(\"2332\")   .eqv. .true.)\n  call assert(is_palindrome(\"3\")      .eqv. .true.)\n  call assert(is_palindrome(\"123321\") .eqv. .true.)\n  call assert(is_palindrome(\"1234321\").eqv. .true.)\n  call assert(is_palindrome(\"12345432\").eqv. .false.)\n\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "is_palindrome", "signature": "logical function is_palindrome(number_string)", "docstring": "Checks if a given number (represented as a string) is a palindrome.\nA palindrome is a sequence of characters that reads the same forward and backward.\nArguments:\n- number_string: A string representing a positive integer.\nReturns:\n- A logical value indicating whether the number is a palindrome (.true.) or not (.false.).\nExample:\n- is_palindrome(\"12321\") returns .true.\n- is_palindrome(\"12345\") returns .false.", "instruction": "Write a Fortran function `logical function is_palindrome(number_string)` to solve the following problem:\nChecks if a given number (represented as a string) is a palindrome.\nA palindrome is a sequence of characters that reads the same forward and backward.\nArguments:\n- number_string: A string representing a positive integer.\nReturns:\n- A logical value indicating whether the number is a palindrome (.true.) or not (.false.).\nExample:\n- is_palindrome(\"12321\") returns .true.\n- is_palindrome(\"12345\") returns .false.", "level": "easy"}
{"task_id": "Fortran/29", "prompt": "! Removes all spaces from the provided input string and returns the modified string without spaces.\n!\n! Arguments:\n! - input_string: A character string from which spaces are to be removed.\n!\n! Returns:\n! - A new string with all spaces removed from the input string.\n!\n! Example:\n! - Calling remove_spaces(\"happy new year 2019\") will return \"happynewyear2019\".\nfunction remove_spaces(input_string) result(output_string)", "canonical_solution": "  character(len=*), intent(in) :: input_string\n  character(len=:), allocatable :: output_string\n  integer :: i\n  character(len=1) :: current_char\n\n  output_string = \"\"  ! Initialize the output string\n\n  do i = 1, len(input_string)\n      current_char = input_string(i:i)\n      if (current_char /= ' ') then\n          output_string = trim(output_string) // current_char\n      end if\n  end do\nend function remove_spaces\n\n\n\nend program main", "test": "program main\n  implicit none\n  character(len=100) :: test_string\n  character(len=:), allocatable :: result_string\n\n  ! Test case 1\n  test_string = \"happy new year 2019\"\n  result_string = remove_spaces(test_string)\n  call assert(result_string == \"happynewyear2019\")\n\n  ! Test case 2\n  test_string = \"Fortran 90/95\"\n  result_string = remove_spaces(test_string)\n  call assert(result_string == \"Fortran90/95\")\n\n  ! Test case 3\n  test_string = \" No Leading or Trailing Spaces \"\n  result_string = remove_spaces(test_string)\n  call assert(result_string == \"NoLeadingorTrailingSpaces\")\n\n  ! Test case 4\n  test_string = \" \"\n  result_string = remove_spaces(test_string)\n  call assert(result_string == \"\")\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "remove_spaces", "signature": "function remove_spaces(input_string) result(output_string)", "docstring": "Removes all spaces from the provided input string and returns the modified string without spaces.\n\nArguments:\n- input_string: A character string from which spaces are to be removed.\n\nReturns:\n- A new string with all spaces removed from the input string.\n\nExample:\n- Calling remove_spaces(\"happy new year 2019\") will return \"happynewyear2019\".", "instruction": "Write a Fortran function `function remove_spaces(input_string) result(output_string)` to solve the following problem:\nRemoves all spaces from the provided input string and returns the modified string without spaces.\n\nArguments:\n- input_string: A character string from which spaces are to be removed.\n\nReturns:\n- A new string with all spaces removed from the input string.\n\nExample:\n- Calling remove_spaces(\"happy new year 2019\") will return \"happynewyear2019\".", "level": "easy"}
{"task_id": "Fortran/30", "prompt": "! Converts a hexadecimal string (base-16) to an octal string (base-8).\n! The input hexadecimal string is composed of characters 0-9 and uppercase A-F.\n! The output octal string should not have leading zeros.\n\n! Arguments:\n! - hex_string: A character string representing the hexadecimal number. \n!   The string consists of characters from 0-9 and A-F, with a maximum length of 100000.\n\n! Returns:\n! - oct_string: A character string representing the octal number corresponding to the input hexadecimal number.\n\n! Example:\n! - hex_to_oct(\"39\") returns \"71\"\n! - hex_to_oct(\"123ABC\") returns \"4435274\"\nfunction hex_to_oct(hex_string) result(oct_string)", "canonical_solution": "  character(len=*), intent(in) :: hex_string\n  character(len=300000) :: oct_string\n  integer :: i, decimal_number\n  character(len=1) :: ch\n  integer, dimension(100000) :: hex_values\n\n  ! Convert hex string to decimal\n  decimal_number = 0\n  do i = 1, len_trim(hex_string)\n      ch = hex_string(i:i)\n      select case (ch)\n          case ('0' : '9')\n              hex_values(i) = ichar(ch) - ichar('0')\n          case ('A' : 'F')\n              hex_values(i) = ichar(ch) - ichar('A') + 10\n      end select\n      decimal_number = decimal_number * 16 + hex_values(i)\n  end do\n\n  ! Convert decimal to octal\n  oct_string = ''\n  do while (decimal_number > 0)\n      ch = char(mod(decimal_number, 8) + ichar('0'))\n      oct_string = ch // oct_string\n      decimal_number = decimal_number / 8\n  end do\n\n  if (oct_string == '') oct_string = '0'\nend function hex_to_oct\n\n\nend program main", "test": "program main\n  implicit none\n  character(len=100000) :: test_hex\n  character(len=300000) :: result_oct\n\n  ! Test case 1\n  test_hex = \"39\"\n  result_oct = hex_to_oct(test_hex)\n  call assert(trim(result_oct) == \"71\")\n\n  ! Test case 2\n  test_hex = \"123ABC\"\n  result_oct = hex_to_oct(test_hex)\n  call assert(trim(result_oct) == \"4435274\")\n\n  ! Additional test cases\n  test_hex = \"1\"\n  result_oct = hex_to_oct(test_hex)\n  call assert(trim(result_oct) == \"1\")\n\n  test_hex = \"A\"\n  result_oct = hex_to_oct(test_hex)\n  call assert(trim(result_oct) == \"12\")\n\n  test_hex = \"FFFF\"\n  result_oct = hex_to_oct(test_hex)\n  call assert(trim(result_oct) == \"177777\")\n\n  print *, \"All tests passed!\"\n\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "hex_to_oct", "signature": "function hex_to_oct(hex_string) result(oct_string)", "docstring": "Converts a hexadecimal string (base-16) to an octal string (base-8).\nThe input hexadecimal string is composed of characters 0-9 and uppercase A-F.\nThe output octal string should not have leading zeros.\nArguments:\n- hex_string: A character string representing the hexadecimal number.\nThe string consists of characters from 0-9 and A-F, with a maximum length of 100000.\nReturns:\n- oct_string: A character string representing the octal number corresponding to the input hexadecimal number.\nExample:\n- hex_to_oct(\"39\") returns \"71\"\n- hex_to_oct(\"123ABC\") returns \"4435274\"", "instruction": "Write a Fortran function `function hex_to_oct(hex_string) result(oct_string)` to solve the following problem:\nConverts a hexadecimal string (base-16) to an octal string (base-8).\nThe input hexadecimal string is composed of characters 0-9 and uppercase A-F.\nThe output octal string should not have leading zeros.\nArguments:\n- hex_string: A character string representing the hexadecimal number.\nThe string consists of characters from 0-9 and A-F, with a maximum length of 100000.\nReturns:\n- oct_string: A character string representing the octal number corresponding to the input hexadecimal number.\nExample:\n- hex_to_oct(\"39\") returns \"71\"\n- hex_to_oct(\"123ABC\") returns \"4435274\"", "level": "hard"}
{"task_id": "Fortran/31", "prompt": "! Computes the length of the longest common subsequence (LCS) between two strings.\n!\n! This function determines the length of the longest subsequence present in both strings. \n! A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous, \n! in both strings.\n!\n! Arguments:\n! - str1: First string, consisting of lowercase English letters.\n! - str2: Second string, consisting of lowercase English letters.\n! - length1: The length of the first string.\n! - length2: The length of the second string.\n!\n! Returns:\n! - The length of the longest common subsequence between str1 and str2.\n!\n! Example:\n! - longest_common_subsequence_length(\"abcdgh\", \"aedfhb\", 6, 6) returns 3\nfunction longest_common_subsequence_length(str1, str2, length1, length2) result(lcs_length)", "canonical_solution": "  character(len=*), intent(in) :: str1, str2\n  integer, intent(in) :: length1, length2\n  integer :: lcs_length\n  integer :: i, j\n  integer, allocatable :: dp(:,:)\n\n  allocate(dp(length1+1, length2+1))\n  dp = 0\n\n  do i = 1, length1\n      do j = 1, length2\n          if (str1(i:i) == str2(j:j)) then\n              dp(i+1, j+1) = dp(i, j) + 1\n          else\n              dp(i+1, j+1) = max(dp(i+1, j), dp(i, j+1))\n          end if\n      end do\n  end do\n\n  lcs_length = dp(length1+1, length2+1)\n  deallocate(dp)\nend function longest_common_subsequence_length\n\nend program main", "test": "program main\n  implicit none\n\n  character(len=100) :: str1, str2\n  integer :: length1, length2, result\n\n  ! Test case 1\n  str1 = \"abcdgh\"\n  str2 = \"aedfhb\"\n  length1 = len_trim(str1)\n  length2 = len_trim(str2)\n  result = longest_common_subsequence_length(str1, str2, length1, length2)\n  call assert(result == 3)\n\n  ! Test case 2\n  str1 = \"aggtab\"\n  str2 = \"gxtxayb\"\n  length1 = len_trim(str1)\n  length2 = len_trim(str2)\n  result = longest_common_subsequence_length(str1, str2, length1, length2)\n  call assert(result == 4)\n\n  ! Test case 3\n  str1 = \"cdsdsd\"\n  str2 = \"aaaaa\"\n  length1 = len_trim(str1)\n  length2 = len_trim(str2)\n  result = longest_common_subsequence_length(str1, str2, length1, length2)\n  call assert(result == 0)\n\n  ! Test case 4\n  str1 = \"abcde\"\n  str2 = \"abcde\"\n  length1 = len_trim(str1)\n  length2 = len_trim(str2)\n  result = longest_common_subsequence_length(str1, str2, length1, length2)\n  call assert(result == 5)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "longest_common_subsequence_length", "signature": "function longest_common_subsequence_length(str1, str2, length1, length2) result(lcs_length)", "docstring": "Computes the length of the longest common subsequence (LCS) between two strings.\n\nThis function determines the length of the longest subsequence present in both strings.\nA subsequence is a sequence that appears in the same relative order, but not necessarily contiguous,\nin both strings.\n\nArguments:\n- str1: First string, consisting of lowercase English letters.\n- str2: Second string, consisting of lowercase English letters.\n- length1: The length of the first string.\n- length2: The length of the second string.\n\nReturns:\n- The length of the longest common subsequence between str1 and str2.\n\nExample:\n- longest_common_subsequence_length(\"abcdgh\", \"aedfhb\", 6, 6) returns 3", "instruction": "Write a Fortran function `function longest_common_subsequence_length(str1, str2, length1, length2) result(lcs_length)` to solve the following problem:\nComputes the length of the longest common subsequence (LCS) between two strings.\n\nThis function determines the length of the longest subsequence present in both strings.\nA subsequence is a sequence that appears in the same relative order, but not necessarily contiguous,\nin both strings.\n\nArguments:\n- str1: First string, consisting of lowercase English letters.\n- str2: Second string, consisting of lowercase English letters.\n- length1: The length of the first string.\n- length2: The length of the second string.\n\nReturns:\n- The length of the longest common subsequence between str1 and str2.\n\nExample:\n- longest_common_subsequence_length(\"abcdgh\", \"aedfhb\", 6, 6) returns 3", "level": "middle"}
{"task_id": "Fortran/32", "prompt": "! Calculates the score of a given word based on the position of each letter in the alphabet.\n! Each letter's score is its position in the alphabet (A/a = 1, B/b = 2, ..., Z/z = 26).\n! The function sums these values to compute the total score of the word.\n\n! Arguments:\n! - word: A string containing only uppercase and lowercase English letters.\n\n! Returns:\n! - The total score of the word as an integer.\n\n! Examples:\n! - word_score(\"Knowledge\") returns 96\n! - word_score(\"Workhard\") returns 98\n! - word_score(\"AttiTude\") returns 100\nfunction word_score(word) result(score)", "canonical_solution": "  implicit none\n  character(len=*), intent(in) :: word\n  integer :: score, i, letter_score\n  character(len=1) :: char\n\n  score = 0\n  do i = 1, len_trim(word)\n      char = word(i:i)\n      letter_score = get_letter_score(char)\n      score = score + letter_score\n     \n  end do\nend function word_score\n\n! Function to get the score of each letter\nfunction get_letter_score(char) result(score)\n  implicit none\n  character(len=1), intent(in) :: char\n  character(len=1):: tmp\n  \n  integer :: score\n  tmp = char \n  if (iachar(tmp) >= iachar('a') .and. iachar(tmp) <= iachar('z')) then\n    tmp = achar(iachar(tmp) - 32)\n  end if \n  ! print *, tmp\n  ! print *, adjustl(achar(iachar(char)))\n\n  ! Convert character to uppercase to simplify calculations\n  select case (iachar(adjustl(achar(iachar(tmp)))) - iachar('A') + 1)\n  case (1:26)\n      score = iachar(adjustl(achar(iachar(tmp)))) - iachar('A') + 1\n  case default\n      score = 0\n  end select\nend function get_letter_score\n\nend program main\n", "test": "program main\n  implicit none\n  character(len=1000) :: test_word1, test_word2, test_word3\n! Initialize test words\n  test_word1 = \"Knowledge\"\n  test_word2 = \"Workhard\"\n  test_word3 = \"AttiTude\"\n  \n  ! Run tests\n  call assert(word_score(test_word1) == 96)\n  call assert(word_score(test_word2) == 98)\n  call assert(word_score(test_word3) == 100)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "word_score", "signature": "function word_score(word) result(score)", "docstring": "Calculates the score of a given word based on the position of each letter in the alphabet.\nEach letter's score is its position in the alphabet (A/a = 1, B/b = 2, ..., Z/z = 26).\nThe function sums these values to compute the total score of the word.\nArguments:\n- word: A string containing only uppercase and lowercase English letters.\nReturns:\n- The total score of the word as an integer.\nExamples:\n- word_score(\"Knowledge\") returns 96\n- word_score(\"Workhard\") returns 98\n- word_score(\"AttiTude\") returns 100", "instruction": "Write a Fortran function `function word_score(word) result(score)` to solve the following problem:\nCalculates the score of a given word based on the position of each letter in the alphabet.\nEach letter's score is its position in the alphabet (A/a = 1, B/b = 2, ..., Z/z = 26).\nThe function sums these values to compute the total score of the word.\nArguments:\n- word: A string containing only uppercase and lowercase English letters.\nReturns:\n- The total score of the word as an integer.\nExamples:\n- word_score(\"Knowledge\") returns 96\n- word_score(\"Workhard\") returns 98\n- word_score(\"AttiTude\") returns 100", "level": "hard"}
{"task_id": "Fortran/33", "prompt": "! Calculates the sum of all prime numbers in a given array of integers.\n!\n! Arguments:\n! - numbers: An array of integers.\n! - count: The number of elements in the 'numbers' array.\n!\n! Returns:\n! - The sum of all prime numbers found in the 'numbers' array.\n!\n! Example:\n! - Given the array [3, 4, 5], the function would return 8, as 3 and 5 are prime numbers.\n\ninteger function sum_of_primes(numbers, count) result(sum)", "canonical_solution": "    integer, intent(in) :: count\n    integer, intent(in) :: numbers(count)\n    integer :: i, j\n    logical :: is_prime\n\n    sum = 0\n    do i = 1, count\n        is_prime = .true.\n        if (numbers(i) < 2) then\n            is_prime = .false.\n        else if (numbers(i) > 2) then\n            if (mod(numbers(i), 2) == 0) then\n                is_prime = .false.\n            else\n                do j = 3, int(sqrt(real(numbers(i)))), 2\n                    if (mod(numbers(i), j) == 0) then\n                        is_prime = .false.\n                        exit\n                    end if\n                end do\n            end if\n        end if\n        if (is_prime) sum = sum + numbers(i)\n    end do\nend function sum_of_primes\n\nend program main", "test": "program main\n  implicit none\n  integer, parameter :: size = 30\n  integer :: numbers(size)\n  integer :: result\n\n  ! Test 1\n  numbers(1:3) = [3, 4, 5]\n  result = sum_of_primes(numbers, 3)\n  call assert(result == 8)\n\n  ! Test 2\n  numbers(1:5) = [2, 3, 5, 7, 11]\n  result = sum_of_primes(numbers, 5)\n  call assert(result == 28)\n\n  ! Test 3\n  numbers(1:3) = [10, 20, 30]\n  result = sum_of_primes(numbers, 3)\n  call assert(result == 0)\n\ncontains\n\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "sum_of_primes", "signature": "integer function sum_of_primes(numbers, count) result(sum)", "docstring": "Calculates the sum of all prime numbers in a given array of integers.\n\nArguments:\n- numbers: An array of integers.\n- count: The number of elements in the 'numbers' array.\n\nReturns:\n- The sum of all prime numbers found in the 'numbers' array.\n\nExample:\n- Given the array [3, 4, 5], the function would return 8, as 3 and 5 are prime numbers.", "instruction": "Write a Fortran function `integer function sum_of_primes(numbers, count) result(sum)` to solve the following problem:\nCalculates the sum of all prime numbers in a given array of integers.\n\nArguments:\n- numbers: An array of integers.\n- count: The number of elements in the 'numbers' array.\n\nReturns:\n- The sum of all prime numbers found in the 'numbers' array.\n\nExample:\n- Given the array [3, 4, 5], the function would return 8, as 3 and 5 are prime numbers.", "level": "middle"}
{"task_id": "Fortran/34", "prompt": "! This subroutine implements the Quick Sort algorithm in Fortran. Quick Sort is an efficient, in-place, comparison-based, divide and conquer sorting algorithm.\n\n! Arguments:\n! - arr: An integer array that needs to be sorted.\n! - left: The starting index of the array/sub-array.\n! - right: The ending index of the array/sub-array.\n\n! Example:\n! - Given an array arr = [5, 2, 6, 1, 7, 3, 4], calling quick_sort(arr, 1, size(arr)) will sort the array in ascending order.\nrecursive subroutine quick_sort(arr, left, right)", "canonical_solution": "    integer, intent(inout) :: arr(:)\n    integer, intent(in) :: left, right\n    integer :: pivot, i, j, temp\n\n    if (left < right) then\n        pivot = left\n        i = left\n        j = right\n\n        do while (i < j)\n            do while (arr(i) <= arr(pivot) .and. i < right)\n                i = i + 1\n            end do\n\n            do while (arr(j) > arr(pivot))\n                j = j - 1\n            end do\n\n            if (i < j) then\n                temp = arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n            end if\n        end do\n\n        temp = arr(pivot)\n        arr(pivot) = arr(j)\n        arr(j) = temp\n\n        call quick_sort(arr, left, j - 1)\n        call quick_sort(arr, j + 1, right)\n    end if\nend subroutine quick_sort\n\nend program main", "test": "program main\n  implicit none\n\n  integer, dimension(7) :: arr\n  integer, dimension(10) :: arr2, ex2\n  integer :: i\n\n  ! Initialize array\n  arr = [5, 2, 6, 1, 7, 3, 4]\n\n  ! Call quick_sort\n  call quick_sort(arr, 1, size(arr))\n\n  ! Expected sorted array: [1, 2, 3, 4, 5, 6, 7]\n  ! Test\n  do i = 1, size(arr)\n      call assert(arr(i) == i)\n  end do\n\n\n  arr2 = [4, 3, 4, 3, 1, 2, 11, 21, 12, 11]\n  ex2 = [1, 2, 3, 3, 4, 4, 11, 11, 12, 21]\n  ! Call quick_sort\n  call quick_sort(arr2, 1, size(arr2))\n\n  ! Expected sorted array: [1, 2, 3, 3, 4, 4, 11, 11, 12, 21]\n  ! Test\n\n  do i = 1, size(arr2)\n      call assert(arr2(i) == ex2(i))\n  end do\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "quick_sort", "signature": "recursive subroutine quick_sort(arr, left, right)", "docstring": "This subroutine implements the Quick Sort algorithm in Fortran. Quick Sort is an efficient, in-place, comparison-based, divide and conquer sorting algorithm.\nArguments:\n- arr: An integer array that needs to be sorted.\n- left: The starting index of the array/sub-array.\n- right: The ending index of the array/sub-array.\nExample:\n- Given an array arr = [5, 2, 6, 1, 7, 3, 4], calling quick_sort(arr, 1, size(arr)) will sort the array in ascending order.", "instruction": "Write a Fortran function `recursive subroutine quick_sort(arr, left, right)` to solve the following problem:\nThis subroutine implements the Quick Sort algorithm in Fortran. Quick Sort is an efficient, in-place, comparison-based, divide and conquer sorting algorithm.\nArguments:\n- arr: An integer array that needs to be sorted.\n- left: The starting index of the array/sub-array.\n- right: The ending index of the array/sub-array.\nExample:\n- Given an array arr = [5, 2, 6, 1, 7, 3, 4], calling quick_sort(arr, 1, size(arr)) will sort the array in ascending order.", "level": "middle"}
{"task_id": "Fortran/35", "prompt": "! Counts the number of times the digit '1' appears in all numbers from 1 to n.\n!\n! Arguments:\n! - n: A positive integer (n <= 30000).\n!\n! Returns:\n! - The count of the digit '1' from 1 to n.\n!\n! Example:\n! - count_ones(15) returns 8, as '1' appears in 1, 10, 11 (twice), 12, 13, 14, 15.\n\ninteger function count_ones(n) result(count)", "canonical_solution": "    integer, intent(in) :: n\n    integer :: i, j\n    character(len=10) :: num_str\n    integer :: str_len\n\n    count = 0\n\n    do i = 1, n\n        write(num_str, '(I10)') i\n        str_len = len_trim(num_str)\n        do j = 1, str_len\n            if (num_str(j:j) == '1') then\n                count = count + 1\n            end if\n        end do\n    end do\nend function count_ones\n\nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test 1\n  result = count_ones(15)\n  call assert(result == 8)\n\n  ! Test 2\n  result = count_ones(20)\n \n  call assert(result == 12)\n\n  ! Test 3\n  result = count_ones(100)\n \n  call assert(result == 21)\n\n  ! Test 4\n  result = count_ones(5)\n\n  call assert(result == 1)\n\n  ! Test 5\n  result = count_ones(30000)\n  call assert(result == 22000) ! This value needs to be calculated for correctness\n\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "count_ones", "signature": "integer function count_ones(n) result(count)", "docstring": "Counts the number of times the digit '1' appears in all numbers from 1 to n.\n\nArguments:\n- n: A positive integer (n <= 30000).\n\nReturns:\n- The count of the digit '1' from 1 to n.\n\nExample:\n- count_ones(15) returns 8, as '1' appears in 1, 10, 11 (twice), 12, 13, 14, 15.", "instruction": "Write a Fortran function `integer function count_ones(n) result(count)` to solve the following problem:\nCounts the number of times the digit '1' appears in all numbers from 1 to n.\n\nArguments:\n- n: A positive integer (n <= 30000).\n\nReturns:\n- The count of the digit '1' from 1 to n.\n\nExample:\n- count_ones(15) returns 8, as '1' appears in 1, 10, 11 (twice), 12, 13, 14, 15.", "level": "easy"}
{"task_id": "Fortran/36", "prompt": "! Calculates the total number of '1's in the binary representations of all integers within a given range [l, r].\n!\n! Arguments:\n! - l: The lower bound of the range (inclusive).\n! - r: The upper bound of the range (inclusive).\n!\n! Returns:\n! - The total number of '1's in the binary representations of all integers within the range [l, r].\n!\n! Example:\n! - count_binary_ones_in_range(2, 3) returns 3, as the binary representations are 10 and 11, which contain three '1's in total.\ninteger function count_binary_ones_in_range(l, r) result(total_ones)", "canonical_solution": "    integer, intent(in) :: l, r\n    integer :: i, n, bit_count\n\n    total_ones = 0\n\n    do i = l, r\n        n = i\n        bit_count = 0\n\n        ! Count '1's in binary representation of n\n        do while (n > 0)\n            if (iand(n, 1) == 1) then\n                bit_count = bit_count + 1\n            end if\n            n = ishft(n, -1)\n        end do\n\n        total_ones = total_ones + bit_count\n    end do\nend function count_binary_ones_in_range\n\nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test 1: Range 2 to 3\n  result = count_binary_ones_in_range(2, 3)\n  call assert(result == 3)\n\n  ! Test 2: Range 5 to 5\n  result = count_binary_ones_in_range(5, 5)\n  call assert(result == 2)\n\n  ! Test 3: Range 0 to 1\n  result = count_binary_ones_in_range(0, 1)\n  call assert(result == 1)\n\n  ! Test 4: Range 10 to 12\n  result = count_binary_ones_in_range(10, 12)\n  call assert(result == 7)\n\ncontains\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "count_binary_ones_in_range", "signature": "integer function count_binary_ones_in_range(l, r) result(total_ones)", "docstring": "Calculates the total number of '1's in the binary representations of all integers within a given range [l, r].\n\nArguments:\n- l: The lower bound of the range (inclusive).\n- r: The upper bound of the range (inclusive).\n\nReturns:\n- The total number of '1's in the binary representations of all integers within the range [l, r].\n\nExample:\n- count_binary_ones_in_range(2, 3) returns 3, as the binary representations are 10 and 11, which contain three '1's in total.", "instruction": "Write a Fortran function `integer function count_binary_ones_in_range(l, r) result(total_ones)` to solve the following problem:\nCalculates the total number of '1's in the binary representations of all integers within a given range [l, r].\n\nArguments:\n- l: The lower bound of the range (inclusive).\n- r: The upper bound of the range (inclusive).\n\nReturns:\n- The total number of '1's in the binary representations of all integers within the range [l, r].\n\nExample:\n- count_binary_ones_in_range(2, 3) returns 3, as the binary representations are 10 and 11, which contain three '1's in total.", "level": "middle"}
{"task_id": "Fortran/37", "prompt": "! Calculates the smallest perfect square that is greater than or equal to the given integer n.\n! A perfect square is a number that can be expressed as the square of an integer.\n\n! Arguments:\n! - n: An integer value.\n\n! Returns:\n! - The smallest perfect square greater than or equal to n.\n\n! Example:\n! - smallest_perfect_square_greater_than_or_equal_to(71711) returns 71824\nfunction smallest_perfect_square_greater_than_or_equal_to(n) result(square)", "canonical_solution": "  integer, intent(in) :: n\n  integer :: square\n  integer :: root\n\n  root = ceiling(sqrt(real(n)))\n\n  square = root**2\nend function smallest_perfect_square_greater_than_or_equal_to\n\nend program main", "test": "program main\n  implicit none\n\n  ! Test cases\n  call assert(smallest_perfect_square_greater_than_or_equal_to(71711) == 71824)\n  call assert(smallest_perfect_square_greater_than_or_equal_to(16) == 16)\n  call assert(smallest_perfect_square_greater_than_or_equal_to(17) == 25)\n  call assert(smallest_perfect_square_greater_than_or_equal_to(1) == 1)\n  call assert(smallest_perfect_square_greater_than_or_equal_to(99999) == 100489)\n\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "smallest_perfect_square_greater_than_or_equal_to", "signature": "function smallest_perfect_square_greater_than_or_equal_to(n) result(square)", "docstring": "Calculates the smallest perfect square that is greater than or equal to the given integer n.\nA perfect square is a number that can be expressed as the square of an integer.\nArguments:\n- n: An integer value.\nReturns:\n- The smallest perfect square greater than or equal to n.\nExample:\n- smallest_perfect_square_greater_than_or_equal_to(71711) returns 71824", "instruction": "Write a Fortran function `function smallest_perfect_square_greater_than_or_equal_to(n) result(square)` to solve the following problem:\nCalculates the smallest perfect square that is greater than or equal to the given integer n.\nA perfect square is a number that can be expressed as the square of an integer.\nArguments:\n- n: An integer value.\nReturns:\n- The smallest perfect square greater than or equal to n.\nExample:\n- smallest_perfect_square_greater_than_or_equal_to(71711) returns 71824", "level": "easy"}
{"task_id": "Fortran/38", "prompt": "! Determines the most frequently occurring element in a sorted array of integers.\n! If two or more elements are equally frequent, the smallest element is returned.\n\n! Arguments:\n! - numbers: An array of integers sorted in ascending order.\n! - n: The number of elements in the array.\n\n! Returns:\n! - The most frequently occurring element in the array.\n\n! Example:\n! - most_frequent_element([100, 150, 150, 200, 250], 5) returns 150\ninteger function most_frequent_element(numbers, n) result(frequent_element)", "canonical_solution": "    integer, intent(in) :: numbers(:)\n    integer, intent(in) :: n\n    integer :: current_count, max_count, current_element\n    integer :: i\n\n    frequent_element = numbers(1)\n    current_count = 1\n    max_count = 1\n    current_element = numbers(1)\n\n    do i = 2, n\n        if (numbers(i) == current_element) then\n            current_count = current_count + 1\n        else\n            if (current_count > max_count) then\n                max_count = current_count\n                frequent_element = current_element\n            end if\n            current_element = numbers(i)\n            current_count = 1\n        end if\n    end do\n\n    if (current_count > max_count) then\n        frequent_element = current_element\n    end if\nend function most_frequent_element\n\nend program main", "test": "program main\n  implicit none\n  integer, dimension(100) :: numbers\n  integer :: n, result\n   ! Test case 1\n  n = 5\n  numbers(1:5) = [100, 150, 150, 200, 250]\n  result = most_frequent_element(numbers, n)\n  call assert(result == 150)\n\n  ! Test case 2\n  n = 6\n  numbers(1:6) = [10, 10, 20, 30, 30, 30]\n  result = most_frequent_element(numbers, n)\n  call assert(result == 30)\n\n  ! Test case 3\n  n = 4\n  numbers(1:4) = [5, 5, 5, 10]\n  result = most_frequent_element(numbers, n)\n  call assert(result == 5)\n\n  ! Test case 4\n  n = 7\n  numbers(1:7) = [1, 1, 1, 2, 2, 3, 3]\n  result = most_frequent_element(numbers, n)\n  call assert(result == 1)\n\ncontains\n\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "most_frequent_element", "signature": "integer function most_frequent_element(numbers, n) result(frequent_element)", "docstring": "Determines the most frequently occurring element in a sorted array of integers.\nIf two or more elements are equally frequent, the smallest element is returned.\nArguments:\n- numbers: An array of integers sorted in ascending order.\n- n: The number of elements in the array.\nReturns:\n- The most frequently occurring element in the array.\nExample:\n- most_frequent_element([100, 150, 150, 200, 250], 5) returns 150", "instruction": "Write a Fortran function `integer function most_frequent_element(numbers, n) result(frequent_element)` to solve the following problem:\nDetermines the most frequently occurring element in a sorted array of integers.\nIf two or more elements are equally frequent, the smallest element is returned.\nArguments:\n- numbers: An array of integers sorted in ascending order.\n- n: The number of elements in the array.\nReturns:\n- The most frequently occurring element in the array.\nExample:\n- most_frequent_element([100, 150, 150, 200, 250], 5) returns 150", "level": "middle"}
{"task_id": "Fortran/39", "prompt": "! Transposes a given n x m matrix.\n!\n! The subroutine 'transpose_matrix' takes a two-dimensional matrix 'input_matrix' of size n x m and returns its transpose, which is a m x n matrix. The transposed matrix is stored in 'output_matrix'.\n! \n! Arguments:\n! - input_matrix: An integer matrix of dimensions n (rows) by m (columns).\n! - n: The number of rows in 'input_matrix'.\n! - m: The number of columns in 'input_matrix'.\n! - output_matrix: An integer matrix of dimensions m (rows) by n (columns) to store the transposed matrix.\n!\n! Example:\n! Input matrix:\n!  1  2\n!  3  4\n!  5  6\n! Transposed matrix:\n!  1  3  5\n!  2  4  6\n\nsubroutine transpose_matrix(input_matrix, n, m, output_matrix)", "canonical_solution": "  integer, intent(in) :: n, m\n  integer, intent(in) :: input_matrix(n, m)\n  integer, intent(out) :: output_matrix(m, n)\n  integer :: i, j\n\n  do i = 1, n\n      do j = 1, m\n          output_matrix(j, i) = input_matrix(i, j)\n      end do\n  end do\nend subroutine transpose_matrix\n\n\nend program main", "test": "program main\n  implicit none\n\n  integer, parameter :: n = 2, m = 3\n  integer :: input_matrix(n, m), output_matrix(m, n), expected_output(m, n)\n  integer :: i, j\n\n  ! Initialize input matrix\n  input_matrix = reshape([1, 2, 3, 4, 5, 6], shape(input_matrix))\n  print *, input_matrix\n  ! Expected output matrix\n  expected_output = reshape([1, 3, 5, 2, 4, 6], shape(expected_output))\n\n  ! Call the transpose subroutine\n  call transpose_matrix(input_matrix, n, m, output_matrix)\n\n  ! Testing\n  do i = 1, m\n      do j = 1, n\n          call assert(output_matrix(i, j) == expected_output(i, j))\n      end do\n  end do\n\ncontains\nsubroutine assert(condition)\n  logical, intent(in) :: condition\n  if (.not. condition) then\n    write(*, *) 'Assertion failed!'\n    stop\n  end if\nend subroutine assert", "entry_point": "transpose_matrix", "signature": "subroutine transpose_matrix(input_matrix, n, m, output_matrix)", "docstring": "Transposes a given n x m matrix.\n\nThe subroutine 'transpose_matrix' takes a two-dimensional matrix 'input_matrix' of size n x m and returns its transpose, which is a m x n matrix. The transposed matrix is stored in 'output_matrix'.\n\nArguments:\n- input_matrix: An integer matrix of dimensions n (rows) by m (columns).\n- n: The number of rows in 'input_matrix'.\n- m: The number of columns in 'input_matrix'.\n- output_matrix: An integer matrix of dimensions m (rows) by n (columns) to store the transposed matrix.\n\nExample:\nInput matrix:\n1  2\n3  4\n5  6\nTransposed matrix:\n1  3  5\n2  4  6", "instruction": "Write a Fortran function `subroutine transpose_matrix(input_matrix, n, m, output_matrix)` to solve the following problem:\nTransposes a given n x m matrix.\n\nThe subroutine 'transpose_matrix' takes a two-dimensional matrix 'input_matrix' of size n x m and returns its transpose, which is a m x n matrix. The transposed matrix is stored in 'output_matrix'.\n\nArguments:\n- input_matrix: An integer matrix of dimensions n (rows) by m (columns).\n- n: The number of rows in 'input_matrix'.\n- m: The number of columns in 'input_matrix'.\n- output_matrix: An integer matrix of dimensions m (rows) by n (columns) to store the transposed matrix.\n\nExample:\nInput matrix:\n1  2\n3  4\n5  6\nTransposed matrix:\n1  3  5\n2  4  6", "level": "easy"}
{"task_id": "Fortran/40", "prompt": "! This function performs basic arithmetic operations - addition, subtraction, multiplication, division, and modulo - on two integers.\n! It takes a single string argument representing the arithmetic expression, which must be in the format: \"operand1 operator operand2\".\n! Valid operators are '+', '-', '*', '/', and '%'. The operands should be integers.\n\n! Arguments:\n! - expression: A string containing the arithmetic expression.\n\n! Returns:\n! - The result of the arithmetic operation as a string. If the operator is invalid or division by zero occurs, it returns \"Error\".\n\n! Example:\n! - calculate(\"3+5\") returns \"8\"\n! - calculate(\"10%3\") returns \"1\"\n! - calculate(\"10/0\") returns \"Error\"\n! - calculate(\"10a3\") returns \"Error\"\nfunction calculate(expression) result(output)", "canonical_solution": "  character(len=*), intent(in) :: expression\n  character(len=100) :: output\n  integer :: operand1, operand2, i\n  character :: operator\n  logical :: operatorFound\n  character(len=100) :: tempOperand\n\n  operand1 = 0\n  operand2 = 0\n  operator = ' '\n  operatorFound = .false.\n  output = \"Error\"\n  tempOperand = \"\"\n\n  ! Parse the expression\n  do i = 1, len_trim(expression)\n      if (expression(i:i) >= '0' .and. expression(i:i) <= '9') then\n          tempOperand = trim(tempOperand) // expression(i:i)\n      else if (expression(i:i) == '+' .or. expression(i:i) == '-' .or. &\n               expression(i:i) == '*' .or. expression(i:i) == '/' .or. &\n               expression(i:i) == '%') then\n          if (.not. operatorFound) then\n              read(tempOperand, *) operand1\n              operator = expression(i:i)\n              operatorFound = .true.\n              tempOperand = \"\"\n          else\n              ! Second operator found, invalid expression\n              return\n          end if\n      else\n          ! Invalid character in expression\n          return\n      end if\n  end do\n\n  if (operatorFound .and. len_trim(tempOperand) > 0) then\n      read(tempOperand, *) operand2\n  else\n      ! Operator not found or second operand missing\n      return\n  end if\n\n  ! Perform the operation\n  select case (operator)\n  case ('+')\n      operand1 = operand1 + operand2\n  case ('-')\n      operand1 = operand1 - operand2\n  case ('*')\n      operand1 = operand1 * operand2\n  case ('/')\n      if (operand2 == 0) then\n          output = \"Error\"\n          return\n      else\n          operand1 = operand1 / operand2\n      end if\n  case ('%')\n      if (operand2 == 0) then\n          output = \"Error\"\n          return\n      else\n          operand1 = mod(operand1, operand2)\n      end if\n  case default\n      output = \"Error\"\n      return\n  end select\n\n  write(output, '(*(I0))') operand1\nend function calculate\n\nend program main\n", "test": "program main\n  implicit none\n  call assert(calculate(\"3+5\") == \"8\")\n  call assert(calculate(\"10-3\") == \"7\")\n  call assert(calculate(\"10%3\") == \"1\")\n  call assert(calculate(\"10/0\") == \"Error\")\n  call assert(calculate(\"5*2\") == \"10\")\n  call assert(calculate(\"10-3\") == \"7\")\n  call assert(calculate(\"10a3\") == \"Error\")\n  call assert(calculate(\"9/3\") == \"3\")\n  call assert(calculate(\"123+456\") == \"579\")\n  call assert(calculate(\"789-32\") == \"757\")\n  call assert(calculate(\"27*8\") == \"216\")\n  call assert(calculate(\"144/12\") == \"12\")\n\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "calculate", "signature": "function calculate(expression) result(output)", "docstring": "This function performs basic arithmetic operations - addition, subtraction, multiplication, division, and modulo - on two integers.\nIt takes a single string argument representing the arithmetic expression, which must be in the format: \"operand1 operator operand2\".\nValid operators are '+', '-', '*', '/', and '%'. The operands should be integers.\nArguments:\n- expression: A string containing the arithmetic expression.\nReturns:\n- The result of the arithmetic operation as a string. If the operator is invalid or division by zero occurs, it returns \"Error\".\nExample:\n- calculate(\"3+5\") returns \"8\"\n- calculate(\"10%3\") returns \"1\"\n- calculate(\"10/0\") returns \"Error\"\n- calculate(\"10a3\") returns \"Error\"", "instruction": "Write a Fortran function `function calculate(expression) result(output)` to solve the following problem:\nThis function performs basic arithmetic operations - addition, subtraction, multiplication, division, and modulo - on two integers.\nIt takes a single string argument representing the arithmetic expression, which must be in the format: \"operand1 operator operand2\".\nValid operators are '+', '-', '*', '/', and '%'. The operands should be integers.\nArguments:\n- expression: A string containing the arithmetic expression.\nReturns:\n- The result of the arithmetic operation as a string. If the operator is invalid or division by zero occurs, it returns \"Error\".\nExample:\n- calculate(\"3+5\") returns \"8\"\n- calculate(\"10%3\") returns \"1\"\n- calculate(\"10/0\") returns \"Error\"\n- calculate(\"10a3\") returns \"Error\"", "level": "hard"}
{"task_id": "Fortran/41", "prompt": "! This function counts the number of pairs of students who are considered \"closely matched\".\n! Two students are \"closely matched\" if the difference in each of their subject scores (Chinese, Mathematics, English)\n! does not exceed 5 points and the difference in their total scores does not exceed 10 points.\n\n! Arguments:\n! - scores: An integer array of dimensions (n, 3) where n is the number of students.\n!           Each row represents a student's scores in the three subjects.\n! - n: The number of students.\n\n! Returns:\n! - The count of pairs of students who are considered \"closely matched\".\n\n! Example:\n! - Given scores = [(90, 90, 90), (85, 95, 90), (80, 100, 91)] and n = 3,\n!   the function returns 2 because there are two pairs of \"closely matched\" students.\n\nfunction count_matched_pairs(scores, n) result(matched_pairs)", "canonical_solution": "    implicit none\n    integer, intent(in) :: n\n    integer, dimension(n,3), intent(in) :: scores\n    integer :: matched_pairs\n    integer :: i, j\n    integer :: total_diff, chinese_diff, math_diff, english_diff\n\n    matched_pairs = 0\n\n    do i = 1, n-1\n        do j = i+1, n\n            ! print *, i, j\n           \n            ! Calculate the absolute differences in each subject\n            chinese_diff = abs(scores(i, 1) - scores(j, 1))\n            math_diff = abs(scores(i, 2) - scores(j, 2))\n            english_diff = abs(scores(i, 3) - scores(j, 3))\n            ! Calculate the difference in total scores\n            total_diff = abs(sum(scores(i, :)) - sum(scores(j, :)))\n            \n            ! Check if the pair matches the criteria\n            if (chinese_diff <= 5 .and. math_diff <= 5 .and. english_diff <= 5 .and. total_diff <= 10) then\n                matched_pairs = matched_pairs + 1\n            end if\n        end do\n    end do\n\nend function count_matched_pairs\n\n\n\nend program main\n", "test": "program main\n    implicit none\n    integer, parameter :: n = 3\n    integer :: scores(n,3)\n    integer :: result\n\n    ! Initialize scores\n    scores = reshape([90, 85, 80,&\n                        90, 95, 100, &\n                        90, 90, 91], shape(scores))\n    ! Expected result is 2\n    result = count_matched_pairs(scores, n)\n    call assert(result == 2)\n\n\n    ! Initialize scores\n    scores = reshape([100, 85, 60,&\n                        90, 95, 100, &\n                        120, 90, 91], shape(scores))\n    result = count_matched_pairs(scores, n)\n    call assert(result == 0)\n\n\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "count_matched_pairs", "signature": "function count_matched_pairs(scores, n) result(matched_pairs)", "docstring": "This function counts the number of pairs of students who are considered \"closely matched\".\nTwo students are \"closely matched\" if the difference in each of their subject scores (Chinese, Mathematics, English)\ndoes not exceed 5 points and the difference in their total scores does not exceed 10 points.\n\nArguments:\n- scores: An integer array of dimensions (n, 3) where n is the number of students.\n          Each row represents a student's scores in the three subjects.\n- n: The number of students.\n\nReturns:\n- The count of pairs of students who are considered \"closely matched\".\n\nExample:\n- Given scores = [(90, 90, 90), (85, 95, 90), (80, 100, 91)] and n = 3,\n  the function returns 2 because there are two pairs of \"closely matched\" students.", "instruction": "Write a Fortran function `function count_matched_pairs(scores, n) result(matched_pairs)` to solve the following problem:\nThis function counts the number of pairs of students who are considered \"closely matched\".\nTwo students are \"closely matched\" if the difference in each of their subject scores (Chinese, Mathematics, English)\ndoes not exceed 5 points and the difference in their total scores does not exceed 10 points.\n\nArguments:\n- scores: An integer array of dimensions (n, 3) where n is the number of students.\n          Each row represents a student's scores in the three subjects.\n- n: The number of students.\n\nReturns:\n- The count of pairs of students who are considered \"closely matched\".\n\nExample:\n- Given scores = [(90, 90, 90), (85, 95, 90), (80, 100, 91)] and n = 3,\n  the function returns 2 because there are two pairs of \"closely matched\" students.", "level": "hard"}
{"task_id": "Fortran/42", "prompt": "! Calculates the total number of cigarettes Peter can smoke given a starting number of cigarettes and a conversion rate of butts to new cigarettes.\n!\n! Arguments:\n! - n: The initial number of cigarettes Peter has.\n! - k: The number of cigarette butts required to exchange for one new cigarette.\n!\n! Returns:\n! - The total number of cigarettes Peter can smoke.\n!\n! Example:\n! - If Peter starts with 4 cigarettes and needs 3 butts to get a new one, he can smoke a total of 5 cigarettes.\n! - If Peter starts with 10 cigarettes and needs 3 butts to get a new one, he can smoke a total of 14 cigarettes.\n\n  function total_smoked_cigarettes(n, k) result(total)", "canonical_solution": "    implicit none\n    integer, intent(in) :: n   ! Initial number of cigarettes\n    integer, intent(in) :: k   ! Number of butts required for a new cigarette\n    integer :: total           ! Total cigarettes smoked\n    integer :: current_butts   ! Current number of butts\n\n    total = n                  ! Start with the initial number of cigarettes\n    current_butts = n          ! All cigarettes will turn into butts\n\n    ! Continue as long as current butts can be exchanged for at least one cigarette\n    do while (current_butts >= k)\n        ! Exchange butts for cigarettes\n        total = total + (current_butts / k)           ! Add new cigarettes to total\n        current_butts = (current_butts / k) + mod(current_butts, k)  ! Update butts\n    end do\n\nend function total_smoked_cigarettes\n\n\n  \nend program main\n", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test case 1\n  result = total_smoked_cigarettes(4, 3)\n  call assert(result == 5)\n\n  ! Test case 2\n  result = total_smoked_cigarettes(10, 3)\n  call assert(result == 14)\n\n  ! Additional test case\n  result = total_smoked_cigarettes(20, 4)\n  call assert(result == 26)\n\n  print *, \"All test cases passed.\"\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "total_smoked_cigarettes", "signature": "function total_smoked_cigarettes(n, k) result(total)", "docstring": "Calculates the total number of cigarettes Peter can smoke given a starting number of cigarettes and a conversion rate of butts to new cigarettes.\n\nArguments:\n- n: The initial number of cigarettes Peter has.\n- k: The number of cigarette butts required to exchange for one new cigarette.\n\nReturns:\n- The total number of cigarettes Peter can smoke.\n\nExample:\n- If Peter starts with 4 cigarettes and needs 3 butts to get a new one, he can smoke a total of 5 cigarettes.\n- If Peter starts with 10 cigarettes and needs 3 butts to get a new one, he can smoke a total of 14 cigarettes.", "instruction": "Write a Fortran function `function total_smoked_cigarettes(n, k) result(total)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given a starting number of cigarettes and a conversion rate of butts to new cigarettes.\n\nArguments:\n- n: The initial number of cigarettes Peter has.\n- k: The number of cigarette butts required to exchange for one new cigarette.\n\nReturns:\n- The total number of cigarettes Peter can smoke.\n\nExample:\n- If Peter starts with 4 cigarettes and needs 3 butts to get a new one, he can smoke a total of 5 cigarettes.\n- If Peter starts with 10 cigarettes and needs 3 butts to get a new one, he can smoke a total of 14 cigarettes.", "level": "middle"}
{"task_id": "Fortran/43", "prompt": "! Calculates the length of the longest sequence of consecutive numbers in an array.\n! The sequence does not need to start at the beginning of the array but must consist of consecutive integers.\n!\n! Arguments:\n! - numbers: An array of integers.\n! - n: The number of elements in the array.\n!\n! Returns:\n! - The length of the longest sequence of consecutive numbers.\n!\n! Example:\n! - For an array containing [1, 5, 6, 2, 3, 4, 5, 6, 8, 9] the function returns 5, as the longest sequence is [1, 2, 3, 4, 5, 6].\n\n\n  function longest_consecutive_sequence(numbers, n) result(length)", "canonical_solution": "    integer, intent(inout) :: numbers(:)\n    integer, intent(in) :: n\n    integer :: length, i, count\n\n    ! First, sort the array\n    call bubble_sort(numbers, n)\n\n    length = 0\n    count = 1\n\n    do i = 1, n-1\n        if (numbers(i) + 1 == numbers(i+1)) then\n            count = count + 1\n            length = max(length, count)\n        else if (numbers(i) /= numbers(i+1)) then\n            count = 1\n        end if\n    end do\n\n    length = max(length, count)\nend function longest_consecutive_sequence\n\nsubroutine bubble_sort(array, n)\n    integer, intent(inout) :: array(:)\n    integer, intent(in) :: n\n    integer :: i, j, temp\n    logical :: swapped\n\n    do\n        swapped = .false.\n        do j = 1, n-1\n            if (array(j) > array(j+1)) then\n                temp = array(j)\n                array(j) = array(j+1)\n                array(j+1) = temp\n                swapped = .true.\n            end if\n        end do\n        if (.not. swapped) exit\n    end do\nend subroutine bubble_sort\n\n  \nend program main", "test": "program main\n  implicit none\n  integer, parameter :: n = 10\n  integer :: sequence(n) = [1, 5, 6, 2, 3, 4, 5, 6, 8, 9]\n  integer :: sequence2(3) = [4, 1, 0]\n  integer :: sequence3(3) = [9, 1, 7]\n  integer :: length\n\n  length = longest_consecutive_sequence(sequence, n)\n\n  ! Test the function\n  call assert(length == 6)\n\n  call assert(longest_consecutive_sequence(sequence2, 3)== 2)\n  call assert(longest_consecutive_sequence(sequence3, 3)== 1)\n\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "longest_consecutive_sequence", "signature": "function count_matched_pairs(scores, n) result(matched_pairs)", "docstring": "Calculates the length of the longest sequence of consecutive numbers in an array.\nThe sequence does not need to start at the beginning of the array but must consist of consecutive integers.\n\nArguments:\n- numbers: An array of integers.\n- n: The number of elements in the array.\n\nReturns:\n- The length of the longest sequence of consecutive numbers.\n\nExample:\n- For an array containing [1, 5, 6, 2, 3, 4, 5, 6, 8, 9] the function returns 5, as the longest sequence is [1, 2, 3, 4, 5, 6].", "instruction": "Write a Fortran function `function count_matched_pairs(scores, n) result(matched_pairs)` to solve the following problem:\nCalculates the length of the longest sequence of consecutive numbers in an array.\nThe sequence does not need to start at the beginning of the array but must consist of consecutive integers.\n\nArguments:\n- numbers: An array of integers.\n- n: The number of elements in the array.\n\nReturns:\n- The length of the longest sequence of consecutive numbers.\n\nExample:\n- For an array containing [1, 5, 6, 2, 3, 4, 5, 6, 8, 9] the function returns 5, as the longest sequence is [1, 2, 3, 4, 5, 6].", "level": "hard"}
{"task_id": "Fortran/44", "prompt": "! Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n! Determines which of the two, Alice (who owns the square) or Bob (who owns the rectangle), has a larger area.\n\n! Arguments:\n! - a: An integer representing the side length of Alice's square.\n! - b: An integer representing the length of Bob's rectangle.\n! - c: An integer representing the width of Bob's rectangle.\n\n! Returns:\n! - A string indicating the owner of the shape with the larger area. Returns 'Alice' if the square has a larger or equal area, 'Bob' otherwise.\n\n! Example:\n! - compare_area(5, 4, 6) returns 'Alice'\n! - compare_area(7, 5, 10) returns 'Bob'\n\ncharacter(len=5) function compare_area(a, b, c) result(winner)", "canonical_solution": "    integer, intent(in) :: a, b, c\n    integer :: square_area, rectangle_area\n    \n    square_area = a * a\n    rectangle_area = b * c\n    \n    if (square_area >= rectangle_area) then\n        winner = 'Alice'\n    else\n        winner = 'Bob'\n    end if\nend function compare_area\n\n\n  \nend program main", "test": "program main\n  implicit none\n  character(len=5) :: result\n  \n  ! Test Case 1\n  result = compare_area(5, 4, 6)\n  call assert(result == 'Alice')\n  \n  ! Test Case 2\n  result = compare_area(7, 5, 10)\n  call assert(result == 'Bob')\n  \n  ! Additional Test Case\n  result = compare_area(6, 2, 6)\n  call assert(result == 'Alice')  ! Square and rectangle have the same area, Alice wins by default.\n\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "compare_area", "signature": "character(len=5) function compare_area(a, b, c) result(winner)", "docstring": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\nDetermines which of the two, Alice (who owns the square) or Bob (who owns the rectangle), has a larger area.\n\nArguments:\n- a: An integer representing the side length of Alice's square.\n- b: An integer representing the length of Bob's rectangle.\n- c: An integer representing the width of Bob's rectangle.\n\nReturns:\n- A string indicating the owner of the shape with the larger area. Returns 'Alice' if the square has a larger or equal area, 'Bob' otherwise.\n\nExample:\n- compare_area(5, 4, 6) returns 'Alice'\n- compare_area(7, 5, 10) returns 'Bob'", "instruction": "Write a Fortran function `character(len=5) function compare_area(a, b, c) result(winner)` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\nDetermines which of the two, Alice (who owns the square) or Bob (who owns the rectangle), has a larger area.\n\nArguments:\n- a: An integer representing the side length of Alice's square.\n- b: An integer representing the length of Bob's rectangle.\n- c: An integer representing the width of Bob's rectangle.\n\nReturns:\n- A string indicating the owner of the shape with the larger area. Returns 'Alice' if the square has a larger or equal area, 'Bob' otherwise.\n\nExample:\n- compare_area(5, 4, 6) returns 'Alice'\n- compare_area(7, 5, 10) returns 'Bob'", "level": "easy"}
{"task_id": "Fortran/45", "prompt": "! Finds M positive integers that sum up to N and have the maximum possible product.\n! The output is arranged in lexicographically smallest order.\n\n! Arguments:\n! - n: The sum that the M integers should equal to. (Positive Integer)\n! - m: The number of integers. (Positive Integer)\n! - result: An array to store the M integers that meet the criteria.\n! - size: The size of the result array.\n\n! Example:\n! - For N=6 and M=3, the output should be [2, 2, 2] since 2*2*2 is the maximum product\n!   possible with three numbers summing up to 6, and it's also lexicographically the smallest combination.\n  subroutine max_product_distribution(n, m, result, size)", "canonical_solution": "    implicit none\n    integer, intent(in) :: n, m\n    integer, intent(out) :: result(m)\n    integer, intent(out) :: size\n    integer :: i, quotient, remainder\n  \n    ! Initialize the output size\n    size = m\n  \n    ! Calculate the quotient and remainder of n divided by m\n    quotient = n / m\n    remainder = mod(n, m)\n  \n    ! Distribute the quotient to each part and add 1 to the first 'remainder' parts\n    do i = 1, m\n      if (i <= remainder) then\n        result(i) = quotient + 1\n      else\n        result(i) = quotient\n      end if\n    end do\n  \n    ! Ensure the result is in lexicographically smallest order\n    ! (This step might be redundant given the current logic, but included for clarity and completeness)\n    call sort(result, m)\n  end subroutine max_product_distribution\n  \n  ! A simple sort subroutine, assuming ascending order is needed\n  subroutine sort(array, size)\n    integer, intent(inout) :: array(size)\n    integer, intent(in) :: size\n    integer :: i, j, temp\n  \n    do i = 1, size-1\n      do j = i+1, size\n        if (array(i) > array(j)) then\n          temp = array(i)\n          array(i) = array(j)\n          array(j) = temp\n        end if\n      end do\n    end do\n  end subroutine sort\n\n  \nend program main\n", "test": "program main\n  implicit none\n  integer, parameter :: max_m = 3\n  integer :: result(max_m), size, n, m\n\n  ! Test case 1\n  n = 6\n  m = 3\n  call max_product_distribution(n, m, result, size)\n  call assert(all(result == [2, 2, 2]))\n\n  ! Test case 2\n  n = 8\n  m = 3\n  call max_product_distribution(n, m, result, size)\n  call assert(all(result == [2, 3, 3]))\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "max_product_distribution", "signature": "subroutine max_product_distribution(n, m, result, size)", "docstring": "Finds M positive integers that sum up to N and have the maximum possible product.\nThe output is arranged in lexicographically smallest order.\n\nArguments:\n- n: The sum that the M integers should equal to. (Positive Integer)\n- m: The number of integers. (Positive Integer)\n- result: An array to store the M integers that meet the criteria.\n- size: The size of the result array.\n\nExample:\n- For N=6 and M=3, the output should be [2, 2, 2] since 2*2*2 is the maximum product\n  possible with three numbers summing up to 6, and it's also lexicographically the smallest combination.", "instruction": "Write a Fortran function `subroutine max_product_distribution(n, m, result, size)` to solve the following problem:\nFinds M positive integers that sum up to N and have the maximum possible product.\nThe output is arranged in lexicographically smallest order.\n\nArguments:\n- n: The sum that the M integers should equal to. (Positive Integer)\n- m: The number of integers. (Positive Integer)\n- result: An array to store the M integers that meet the criteria.\n- size: The size of the result array.\n\nExample:\n- For N=6 and M=3, the output should be [2, 2, 2] since 2*2*2 is the maximum product\n  possible with three numbers summing up to 6, and it's also lexicographically the smallest combination.", "level": "hard"}
{"task_id": "Fortran/46", "prompt": "! Calculates the number of characters in a composition's title, excluding spaces and newline characters.\n! The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n!\n! Arguments:\n! - title: A string representing the title of the composition.\n!\n! Returns:\n! - An integer representing the count of characters in the title, excluding spaces and newline characters.\n!\n! Example:\n! - count_title_characters(\"Ca 45\") returns 4.\n  function count_title_characters(title) result(count)", "canonical_solution": "    character(len=*), intent(in) :: title\n    integer :: count\n    integer :: i\n\n    count = 0\n\n    do i = 1, len_trim(title)\n        ! Increment count for uppercase and lowercase letters and digits\n        if ((title(i:i) >= 'A' .and. title(i:i) <= 'Z') .or. &\n            (title(i:i) >= 'a' .and. title(i:i) <= 'z') .or. &\n            (title(i:i) >= '0' .and. title(i:i) <= '9')) then\n            count = count + 1\n        endif\n    enddo\nend function count_title_characters\n\n  \nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test 1\n  result = count_title_characters(\"234\")\n  call assert(result == 3)\n\n  ! Test 2\n  result = count_title_characters(\"Ca 45\")\n  call assert(result == 4)\n\n  ! Test 3\n  result = count_title_characters(\" A B \")\n\n  call assert(result == 2)\n\n  ! Test 4\n  result = count_title_characters(\"123\")\n  call assert(result == 3)\n\n  print *, \"All tests passed successfully.\"\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "count_title_characters", "signature": "function count_title_characters(title) result(count)", "docstring": "Calculates the number of characters in a composition's title, excluding spaces and newline characters.\n The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n Arguments:\n - title: A string representing the title of the composition.\n\n Returns:\n - An integer representing the count of characters in the title, excluding spaces and newline characters.\n\n Example:\n - count_title_characters(\"Ca 45\") returns 4.", "instruction": "Write a Fortran function `function count_title_characters(title) result(count)` to solve the following problem:\nCalculates the number of characters in a composition's title, excluding spaces and newline characters.\n The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n Arguments:\n - title: A string representing the title of the composition.\n\n Returns:\n - An integer representing the count of characters in the title, excluding spaces and newline characters.\n\n Example:\n - count_title_characters(\"Ca 45\") returns 4.", "level": "easy"}
{"task_id": "Fortran/47", "prompt": "! Calculates the number of students who have enrolled in both course A and B.\n! Each course has a unique set of student IDs, and the function counts how many IDs are common between the two sets.\n!\n! Arguments:\n! - n: Number of students enrolled in course A.\n! - m: Number of students enrolled in course B.\n! - a(n): Array containing the IDs of students enrolled in course A.\n! - b(m): Array containing the IDs of students enrolled in course B.\n! Returns:\n! - The number of students who are enrolled in both courses.\n! Example:\n! - Given n=5, m=5, a=[1, 2, 3, 4, 5], and b=[1, 3, 4, 5, 6], the function returns 4.\ninteger function count_shared_students(n, m, a, b) result(shared_count)", "canonical_solution": "  integer, intent(in) :: n, m\n  integer, intent(in) :: a(n), b(m)\n  integer :: i, j\n  shared_count = 0\n\n  do i = 1, n\n      do j = 1, m\n          if (a(i) == b(j)) then\n              shared_count = shared_count + 1\n              exit\n          end if\n      end do\n  end do\nend function count_shared_students\n  \nend program main", "test": "program main\n  implicit none\n  integer :: shared\n  integer, parameter :: n=5, m=5\n  integer, dimension(n) :: a = [1, 2, 3, 4, 5]\n  integer, dimension(m) :: b = [1, 3, 4, 5, 6]\n\n  shared = count_shared_students(n, m, a, b)\n  call assert(shared == 4)\n\n\n  a = [1, 2, 3, 7, 5]\n  b = [1, 3, 4, 5, 6]\n\n  shared = count_shared_students(n, m, a, b)\n  call assert(shared == 3)\n\n  a = [1, 2, 3, 4, 5]\n  b = [1, 3, 4, 5, 2]\n\n  shared = count_shared_students(n, m, a, b)\n  call assert(shared == 5)\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "count_shared_students", "signature": "integer function count_shared_students(n, m, a, b) result(shared_count)", "docstring": "Calculates the number of students who have enrolled in both course A and B.\n Each course has a unique set of student IDs, and the function counts how many IDs are common between the two sets.\n\n Arguments:\n - n: Number of students enrolled in course A.\n - m: Number of students enrolled in course B.\n - a(n): Array containing the IDs of students enrolled in course A.\n - b(m): Array containing the IDs of students enrolled in course B.\n Returns:\n - The number of students who are enrolled in both courses.\n Example:\n - Given n=5, m=5, a=[1, 2, 3, 4, 5], and b=[1, 3, 4, 5, 6], the function returns 4.", "instruction": "Write a Fortran function `integer function count_shared_students(n, m, a, b) result(shared_count)` to solve the following problem:\nCalculates the number of students who have enrolled in both course A and B.\n Each course has a unique set of student IDs, and the function counts how many IDs are common between the two sets.\n\n Arguments:\n - n: Number of students enrolled in course A.\n - m: Number of students enrolled in course B.\n - a(n): Array containing the IDs of students enrolled in course A.\n - b(m): Array containing the IDs of students enrolled in course B.\n Returns:\n - The number of students who are enrolled in both courses.\n Example:\n - Given n=5, m=5, a=[1, 2, 3, 4, 5], and b=[1, 3, 4, 5, 6], the function returns 4.", "level": "easy"}
{"task_id": "Fortran/48", "prompt": "! Calculates the number of whole apples remaining after eating apples for a certain amount of time.\n! Each apple takes a specific amount of time to eat, and apples are eaten one after another without pause.\n\n! Arguments:\n! - m: The total number of apples (1 <= m <= 100).\n! - t: The time in minutes it takes to eat one apple (0 <= t <= 100).\n! - s: The time in minutes that has passed (1 <= s <= 10000).\n\n! Returns:\n! - The number of whole apples remaining.\n\n! Example:\n! - If you start with 50 apples, each taking 10 minutes to eat, and 200 minutes have passed, \n!   then the function should return 30, indicating that 30 apples remain.\n\n  function remaining_apples(m, t, s) result(remaining)", "canonical_solution": "    integer, intent(in) :: m, t, s\n    integer :: remaining\n\n    if (t .eq. 0) then\n        remaining = 0\n    else\n        remaining = m - (s / t)\n        if (mod(s, t) > 0) then \n          remaining= remaining-1\n        end if \n        if (remaining < 0) then\n            remaining = 0\n        end if\n    end if\nend function remaining_apples\n\nend program main", "test": "program main\n  implicit none\n  integer :: result\n\n  ! Test Case 1\n  result = remaining_apples(50, 10, 200)\n  call assert(result == 30)\n\n  ! Test Case 2\n  result = remaining_apples(10, 5, 25)\n  call assert(result == 5)\n\n  ! Test Case 3\n  result = remaining_apples(100, 1, 100)\n  call assert(result == 0)\n\n  ! Test Case 4 - Edge case where time to eat an apple is 0\n  result = remaining_apples(50, 0, 100)\n  call assert(result == 0)\n\n  ! Test Case 5 - Edge case where no time has passed\n  result = remaining_apples(50, 10, 0)\n  call assert(result == 50)\n\n\n  result = remaining_apples(50, 10, 3)\n  ! print *, result\n  call assert(result == 49)\n\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "remaining_apples", "signature": "function remaining_apples(m, t, s) result(remaining)", "docstring": "Calculates the number of whole apples remaining after eating apples for a certain amount of time.\n Each apple takes a specific amount of time to eat, and apples are eaten one after another without pause.\n\n Arguments:\n - m: The total number of apples (1 <= m <= 100).\n - t: The time in minutes it takes to eat one apple (0 <= t <= 100).\n - s: The time in minutes that has passed (1 <= s <= 10000).\n\n Returns:\n - The number of whole apples remaining.\n\n Example:\n - If you start with 50 apples, each taking 10 minutes to eat, and 200 minutes have passed, \n   then the function should return 30, indicating that 30 apples remain.", "instruction": "Write a Fortran function `function remaining_apples(m, t, s) result(remaining)` to solve the following problem:\nCalculates the number of whole apples remaining after eating apples for a certain amount of time.\n Each apple takes a specific amount of time to eat, and apples are eaten one after another without pause.\n\n Arguments:\n - m: The total number of apples (1 <= m <= 100).\n - t: The time in minutes it takes to eat one apple (0 <= t <= 100).\n - s: The time in minutes that has passed (1 <= s <= 10000).\n\n Returns:\n - The number of whole apples remaining.\n\n Example:\n - If you start with 50 apples, each taking 10 minutes to eat, and 200 minutes have passed, \n   then the function should return 30, indicating that 30 apples remain.", "level": "easy"}
{"task_id": "Fortran/49", "prompt": "! This subroutine finds the missing (discontinuous) and duplicate ID in a sequence of ticket IDs.\n! It takes a list of IDs and the total number of IDs as input, and returns both the missing and duplicate ID.\n!\n! Arguments:\n! - ids: An array of integers representing the ticket IDs.\n! - n: The total number of ticket IDs.\n!\n! Returns:\n! - missing_id: The ID that is missing in the sequence.\n! - duplicate_id: The ID that appears more than once in the sequence.\n!\n! Example:\n! Given IDs: [5, 6, 8, 11, 9, 10, 12, 9]\n! The subroutine would return missing_id = 7 and duplicate_id = 9, as 7 is missing and 9 is duplicated.\nsubroutine find_missing_and_duplicate_ids(ids, n, missing_id, duplicate_id)", "canonical_solution": "    integer, intent(in) :: ids(:), n\n    integer, intent(out) :: missing_id, duplicate_id\n    integer :: sorted_ids(n), i\n\n    ! Copy and sort the input array to avoid modifying the original array\n    sorted_ids = ids\n    call sort(sorted_ids, n)\n\n    ! Initialize output variables\n    missing_id = -1\n    duplicate_id = -1\n\n    ! Iterate through sorted array to find duplicate\n    do i = 1, n - 1\n        if (sorted_ids(i) == sorted_ids(i + 1)) then\n            duplicate_id = sorted_ids(i)\n            exit\n        end if\n    end do\n\n    ! Calculate the expected sum of the sequence and find the missing ID\n    missing_id = ((sorted_ids(n) * (sorted_ids(n) + 1)) / 2) - &\n                 ((sorted_ids(1) * (sorted_ids(1) - 1)) / 2) - &\n                 (sum(sorted_ids) - duplicate_id)\n\nend subroutine find_missing_and_duplicate_ids\n\n! Auxiliary subroutine to sort the array (simple selection sort for demonstration)\nsubroutine sort(array, n)\n    integer, intent(inout) :: array(:)\n    integer, intent(in) :: n\n    integer :: i, j, min_idx, temp\n\n    do i = 1, n - 1\n        min_idx = i\n        do j = i + 1, n\n            if (array(j) < array(min_idx)) then\n                min_idx = j\n            end if\n        end do\n        temp = array(i)\n        array(i) = array(min_idx)\n        array(min_idx) = temp\n    end do\nend subroutine sort\n\nend program main", "test": "program main\n  implicit none\n  integer, parameter :: n1 = 8, n2 = 4\n  integer :: ids1(n1) = [5, 6, 8, 11, 9, 10, 12, 9]\n  integer :: ids2(n2) = [1, 1, 2, 4]\n  integer :: missing_id, duplicate_id\n\n  ! Test Case 1\n  call find_missing_and_duplicate_ids(ids1, n1, missing_id, duplicate_id)\n  call assert(missing_id == 7 .and. duplicate_id == 9)\n\n  ! Test Case 2\n  call find_missing_and_duplicate_ids(ids2, n2, missing_id, duplicate_id)\n  call assert(missing_id == 3 .and. duplicate_id == 1)\n\n  print *, \"All test cases passed.\"\n\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "find_missing_and_duplicate_ids", "signature": "subroutine find_missing_and_duplicate_ids(ids, n, missing_id, duplicate_id)", "docstring": "This subroutine finds the missing (discontinuous) and duplicate ID in a sequence of ticket IDs.\n It takes a list of IDs and the total number of IDs as input, and returns both the missing and duplicate ID.\n\n Arguments:\n - ids: An array of integers representing the ticket IDs.\n - n: The total number of ticket IDs.\n\n Returns:\n - missing_id: The ID that is missing in the sequence.\n - duplicate_id: The ID that appears more than once in the sequence.\n\n Example:\n Given IDs: [5, 6, 8, 11, 9, 10, 12, 9]\n The subroutine would return missing_id = 7 and duplicate_id = 9, as 7 is missing and 9 is duplicated.", "instruction": "Write a Fortran function `subroutine find_missing_and_duplicate_ids(ids, n, missing_id, duplicate_id)` to solve the following problem:\nThis subroutine finds the missing (discontinuous) and duplicate ID in a sequence of ticket IDs.\n It takes a list of IDs and the total number of IDs as input, and returns both the missing and duplicate ID.\n\n Arguments:\n - ids: An array of integers representing the ticket IDs.\n - n: The total number of ticket IDs.\n\n Returns:\n - missing_id: The ID that is missing in the sequence.\n - duplicate_id: The ID that appears more than once in the sequence.\n\n Example:\n Given IDs: [5, 6, 8, 11, 9, 10, 12, 9]\n The subroutine would return missing_id = 7 and duplicate_id = 9, as 7 is missing and 9 is duplicated.", "level": "hard"}
{"task_id": "Fortran/50", "prompt": "! Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n! Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n! Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n! Arguments:\n! - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n! - failed: The number of failed deliveries (0 <= failed <= 100).\n\n! Returns:\n! - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n! Examples:\n! - calculate_droid_earnings(5, 2) returns 730.\n! - calculate_droid_earnings(0, 10) returns -100.\n\nfunction calculate_droid_earnings(delivered, failed) result(earnings)", "canonical_solution": "    integer, intent(in) :: delivered, failed\n    integer :: earnings\n\n    earnings = delivered * 50 - failed * 10\n    if (delivered > failed) then\n        earnings = earnings + 500\n    end if\nend function calculate_droid_earnings\n  \nend program main", "test": "program main\n \n  implicit none\n  integer :: result\n\n  ! Test Case 1\n  result = calculate_droid_earnings(5, 2)\n  call assert(result == 730)\n\n  ! Test Case 2\n  result = calculate_droid_earnings(0, 10)\n  call assert(result == -100)\n\n  ! Additional Test Cases\n  result = calculate_droid_earnings(10, 0)\n  call assert(result == 1000)\n\n  result = calculate_droid_earnings(3, 4)\n  call assert(result == 110)\n  \n  print *, 'All tests passed successfully!'\ncontains\n\nsubroutine assert(condition)\n    logical, intent(in) :: condition\n    if (.not. condition) then\n      write(*, *) 'Assertion failed!'\n      stop\n    end if\n  end subroutine assert", "entry_point": "calculate_droid_earnings", "signature": "function calculate_droid_earnings(delivered, failed) result(earnings)", "docstring": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n - failed: The number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n - calculate_droid_earnings(5, 2) returns 730.\n - calculate_droid_earnings(0, 10) returns -100.", "instruction": "Write a Fortran function `function calculate_droid_earnings(delivered, failed) result(earnings)` to solve the following problem:\nCalculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n - failed: The number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n - calculate_droid_earnings(5, 2) returns 730.\n - calculate_droid_earnings(0, 10) returns -100.", "level": "easy"}
