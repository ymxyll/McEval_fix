{"task_id": "PowerShell/1", "prompt": "function Has-CloseElements {\n<#\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n#> param (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "canonical_solution": "\n\nfor ($i = 0; $i -lt $numbers.Count; $i++) {\nfor ($j = 0; $j -lt $numbers.Count; $j++) {\nif ($i -ne $j) {\n$distance = [Math]::Abs($numbers[$i] - $numbers[$j])\nif ($distance -lt $threshold) {\nreturn $true\n}\n}\n}\n}\n\nreturn $false\n}", "test": "# Test cases\nfunction Check-CloseElements() {\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.3) -ne $true) { throw \"Test case 1 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.9, 4.0, 5.0, 2.2)))) 0.05) -ne $false) { throw \"Test case 2 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.95) -ne $true) { throw \"Test case 3 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 5.9, 4.0, 5.0)))) 0.8) -ne $false) { throw \"Test case 4 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.0, 2.0, 3.0, 4.0, 5.0, 2.0)))) 0.1) -ne $true) { throw \"Test case 5 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 1.0) -ne $true) { throw \"Test case 6 failed\" }\nif ((Has-CloseElements (New-Object 'System.Collections.Generic.List[float]' (,([float[]](1.1, 2.2, 3.1, 4.1, 5.1)))) 0.5) -ne $false) { throw \"Test case 7 failed\" }\n}\n\nCheck-CloseElements", "entry_point": "Has-CloseElements", "signature": "function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Write a PowerShell function `function Has-CloseElements {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[float]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[float]$threshold\n)` to solve the following problem:\n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "level": "easy"}
{"task_id": "PowerShell/2", "prompt": "function Remove-DuplicatesFromSortedArray {\n<#\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "canonical_solution": "if ($nums.Count -le 1) {\nreturn $nums.Count\n}\n\n$i = 0\nfor ($j = 1; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $nums[$i]) {\n$i++\n$nums[$i] = $nums[$j]\n}\n}\n\nreturn $i + 1\n}", "test": "function Check-RemoveDuplicatesFromSortedArray() {\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 2)) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(0,0,1,1,1,2,2,3,3,4)) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 2, 3)) -ne 3) { throw \"Test case 3 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(2, 2, 2)) -ne 1) { throw \"Test case 4 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1)) -ne 1) { throw \"Test case 5 failed\" }\nif ((Remove-DuplicatesFromSortedArray @(1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4)) -ne 4) { throw \"Test case 6 failed\" }\n}\n\nCheck-RemoveDuplicatesFromSortedArray", "entry_point": "Remove-DuplicatesFromSortedArray", "signature": "function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)", "docstring": "\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "instruction": "Write a PowerShell function `function Remove-DuplicatesFromSortedArray {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums\n)` to solve the following problem:\n\n.SYNOPSIS\nRemoves duplicates from a sorted array and returns the new length.\n\n.DESCRIPTION\nGiven a non-strictly increasing sorted array nums, this function removes duplicates in place such that\neach element appears only once. The function returns the new length of the array, which is the count of\nunique elements. The relative order of the elements should be maintained.\n\n.EXAMPLE\n>>> $nums = @(1, 1, 2)\n>>> Remove-DuplicatesFromSortedArray $nums\n2\n\n>>> $nums = @(0,0,1,1,1,2,2,3,3,4)\n>>> Remove-DuplicatesFromSortedArray $nums\n5\n\n", "level": "easy"}
{"task_id": "PowerShell/3", "prompt": "function Get-LongestUniqueSubstringLength {\n<#\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$start = 0\n$maxLength = 0\n$charMap = @{}\n\nfor ($end = 0; $end -lt $s.Length; $end++) {\nif ($charMap.ContainsKey($s[$end])) {\n$start = [Math]::Max($start, $charMap[$s[$end]] + 1)\n}\n\n$charMap[$s[$end]] = $end\n$maxLength = [Math]::Max($maxLength, $end - $start + 1)\n}\n\nreturn $maxLength\n}", "test": "function Check-LongestUniqueSubstringLength() {\nif ((Get-LongestUniqueSubstringLength \"abcabcbb\") -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-LongestUniqueSubstringLength \"bbbbb\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-LongestUniqueSubstringLength \"pwwkew\") -ne 3) { throw \"Test case 3 failed\" }\nif ((Get-LongestUniqueSubstringLength \" \") -ne 1) { throw \"Test case 4 failed\" }\nif ((Get-LongestUniqueSubstringLength \"dvdf\") -ne 3) { throw \"Test case 5 failed\" }\nif ((Get-LongestUniqueSubstringLength \"anviaj\") -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-LongestUniqueSubstringLength \"abba\") -ne 2) { throw \"Test case 7 failed\" }\n}\n\nCheck-LongestUniqueSubstringLength", "entry_point": "Get-LongestUniqueSubstringLength", "signature": "function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "instruction": "Write a PowerShell function `function Get-LongestUniqueSubstringLength {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)` to solve the following problem:\n\n.SYNOPSIS\nFinds the length of the longest substring without repeating characters in a given string.\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"abcabcbb\"\n3\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"bbbbb\"\n1\n\n.EXAMPLE\n>>> Get-LongestUniqueSubstringLength \"pwwkew\"\n3\n\n", "level": "middle"}
{"task_id": "PowerShell/4", "prompt": "function Get-LongestPalindromicSubstring {\n<#\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "if (-not $s) { return \"\" }\n$start = 0\n$end = 0\n\nfor ($i = 0; $i -lt $s.Length; $i++) {\n$len1 = ExpandAroundCenter $s $i $i\n$len2 = ExpandAroundCenter $s $i ($i + 1)\n$len = [Math]::Max($len1, $len2)\n\nif ($len -gt ($end - $start)) {\nif ($len -eq $len1) {\n$start = [Math]::Floor($i - ($len - 1) / 2)\n} else {\n$start = [Math]::Floor($i - $len / 2 + 1)\n}\n$end = $i + [Math]::Floor($len / 2)\n}\n}\n\nreturn $s.Substring($start, $end - $start + 1)\n}\n\n\nfunction ExpandAroundCenter([string]$s, [int]$left, [int]$right) {\nwhile ($left -ge 0 -and $right -lt $s.Length -and $s[$left] -eq $s[$right]) {\n$left--\n$right++\n}\n\nreturn $right - $left - 1\n}", "test": "function Check-LongestPalindromicSubstring() {\n$result1 = Get-LongestPalindromicSubstring \"babad\"\nif (-not ($result1 -eq \"bab\" -or $result1 -eq \"aba\")) { throw \"Test case 1 failed\" }\nif ((Get-LongestPalindromicSubstring \"cbbd\") -ne \"bb\") { throw \"Test case 2 failed\" }\nif ((Get-LongestPalindromicSubstring \"a\") -ne \"a\") { throw \"Test case 3 failed\" }\nif ((Get-LongestPalindromicSubstring \"racecar\") -ne \"racecar\") { throw \"Test case 4 failed\" }\nif ((Get-LongestPalindromicSubstring \"madam\") -ne \"madam\") { throw \"Test case 5 failed\" }\nif ((Get-LongestPalindromicSubstring \"abcdcba\") -ne \"abcdcba\") { throw \"Test case 6 failed\" }\n}\n\nCheck-LongestPalindromicSubstring", "entry_point": "Get-LongestPalindromicSubstring", "signature": "function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "instruction": "Write a PowerShell function `function Get-LongestPalindromicSubstring {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)` to solve the following problem:\n\n.SYNOPSIS\nFinds the longest palindromic substring in a given string.\n\n.DESCRIPTION\nA palindrome is a string that reads the same forward and backward.\n\n.EXAMPLE\n>>> Get-LongestPalindromicSubstring \"cbbd\"\n\"bb\"\n\n", "level": "hard"}
{"task_id": "PowerShell/5", "prompt": "function MyAtoi {\n<#\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "canonical_solution": "$s = $s.Trim()\nif (-not $s) { return 0 }\n\n$sign = 1\n$base = 0\n$i = 0\n\nif ($s[0] -eq \"-\" -or $s[0] -eq \"+\") {\n$sign = if ($s[0] -eq \"-\") { -1 } else { 1 }\n$i++\n}\n\nwhile ($i -lt $s.Length -and $s[$i] -ge \"0\" -and $s[$i] -le \"9\") {\n$base = $base * 10 + [int]::Parse($s[$i])\n\nif ($base -gt [int]::MaxValue) {\nreturn [int]::MaxValue * $sign\n} elseif (-$base -lt [int]::MinValue) {\nreturn [int]::MinValue\n}\n\n$i++\n}\n\nreturn $base * $sign\n}", "test": "# Test cases\nfunction Check-MyAtoi() {\nif ((MyAtoi \"42\") -ne 42) { throw \"Test case 1 failed\" }\nif ((MyAtoi \" -42\") -ne -42) { throw \"Test case 2 failed\" }\nif ((MyAtoi \"4193 with words\") -ne 4193) { throw \"Test case 3 failed\" }\nif ((MyAtoi \"words and 987\") -ne 0) { throw \"Test case 4 failed\" }\n}\nCheck-MyAtoi", "entry_point": "MyAtoi", "signature": "function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)", "docstring": "\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "instruction": "Write a PowerShell function `function MyAtoi {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s\n)` to solve the following problem:\n\n.SYNOPSIS\nConverts a string to a 32-bit signed integer.\n\n.DESCRIPTION\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\nThen, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible,\nand interprets them as a numerical value.\n\n.EXAMPLE\n>>> MyAtoi \"42\"\n42\n\n.EXAMPLE\n>>> MyAtoi \" -42\"\n-42\n\n.EXAMPLE\n>>> MyAtoi \"4193 with words\"\n4193\n\n", "level": "hard"}
{"task_id": "PowerShell/6", "prompt": "function FindLongestCommonPrefix {\n<#\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "canonical_solution": "if ($strs.Length -eq 0) { return \"\" }\nif ($strs.Length -eq 1) { return $strs[0] }\nif ($strs -contains \"\") { return \"\" } # \u68c0\u67e5\u5e76\u5904\u7406\u5305\u542b\u7a7a\u5b57\u7b26\u4e32\u7684\u60c5\u51b5\n\n$prefix = $strs[0]\n\nforeach ($str in $strs) {\nwhile ($str.IndexOf($prefix) -ne 0) {\n$prefix = $prefix.Substring(0, $prefix.Length - 1)\nif (-not $prefix) { return \"\" }\n}\n}\n\nreturn $prefix\n}", "test": "function Check-FindLongestCommonPrefix() {\nif ((FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")) -ne \"fl\") { throw \"Test case 1 failed\" }\nif ((FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")) -ne \"\") { throw \"Test case 2 failed\" }\nif ((FindLongestCommonPrefix @(\"interspecies\",\"interstellar\",\"interstate\")) -ne \"inters\") { throw \"Test case 3 failed\" }\nif ((FindLongestCommonPrefix @(\"throne\",\"throne\")) -ne \"throne\") { throw \"Test case 4 failed\" }\nif ((FindLongestCommonPrefix @(\"a\",\"ab\")) -ne \"a\") { throw \"Test case 5 failed\" }\nif ((FindLongestCommonPrefix @(\"abc\",\"abcd\",\"ab\")) -ne \"ab\") { throw \"Test case 6 failed\" }\nif ((FindLongestCommonPrefix @(\"complete\",\"compliment\",\"complex\")) -ne \"compl\") { throw \"Test case 7 failed\" }\nif ((FindLongestCommonPrefix @(\"nomatch\",\"nomadic\",\"noir\")) -ne \"no\") { throw \"Test case 8 failed\" }\n}\n\nCheck-FindLongestCommonPrefix", "entry_point": "FindLongestCommonPrefix", "signature": "function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)", "docstring": "\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "instruction": "Write a PowerShell function `function FindLongestCommonPrefix {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$strs\n)` to solve the following problem:\n\n.SYNOPSIS\nFinds the longest common prefix among an array of strings.\n\n.DESCRIPTION\nThis function iterates through the characters of the strings to find the common prefix. \nIf there is no common prefix, it returns an empty string.\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"flower\",\"flow\",\"flight\")\n\"fl\"\n\n.EXAMPLE\n>>> FindLongestCommonPrefix @(\"dog\",\"racecar\",\"car\")\n\"\"\n", "level": "middle"}
{"task_id": "PowerShell/7", "prompt": "function Find-NeedleInHaystack {\n<#\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)", "canonical_solution": "return $haystack.IndexOf($needle)\n}", "test": "function Check-NeedleInHaystack() {\nif ((Find-NeedleInHaystack \"hello world\" \"world\") -ne 6) { throw \"Test case 1 failed\" }\nif ((Find-NeedleInHaystack \"hello world\" \"goodbye\") -ne -1) { throw \"Test case 2 failed\" }\nif ((Find-NeedleInHaystack \"openai\" \"ai\") -ne 4) { throw \"Test case 3 failed\" }\nif ((Find-NeedleInHaystack \"chatbot\" \"bot\") -ne 4) { throw \"Test case 4 failed\" }\nif ((Find-NeedleInHaystack \"chatbot\" \"hello\") -ne -1) { throw \"Test case 5 failed\" }\nif ((Find-NeedleInHaystack \"abcdefg\" \"cd\") -ne 2) { throw \"Test case 6 failed\" }\nif ((Find-NeedleInHaystack \"abcdefg\" \"xyz\") -ne -1) { throw \"Test case 7 failed\" }\n}\n\nCheck-NeedleInHaystack", "entry_point": "Find-NeedleInHaystack", "signature": "function Find-NeedleInHaystack {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)", "docstring": "\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n", "instruction": "Write a PowerShell function `function Find-NeedleInHaystack {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$haystack,\n\n[Parameter(Mandatory=$true)]\n[string]$needle\n)` to solve the following problem:\n\n.SYNOPSIS\nSearches for the first occurrence of a substring (needle) within a string (haystack).\n\n.DESCRIPTION\nGiven two strings, haystack and needle, this function finds the first occurrence of \nneedle in haystack and returns its index. If needle is not a part of haystack, it returns -1.\n\n.EXAMPLE\n>>> Find-NeedleInHaystack \"hello world\" \"world\"\n6\n\n>>> Find-NeedleInHaystack \"hello world\" \"goodbye\"\n-1\n\n", "level": "easy"}
{"task_id": "PowerShell/8", "prompt": "function Find-ConcatenatedSubstrings {\n<#\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "canonical_solution": "$wordLength = $words[0].Length\n$totalLength = $wordLength * $words.Count\n$wordMap = @{}\n\nforeach ($word in $words) {\n$wordMap[$word] = $wordMap[$word] + 1\n}\n\n$result = @()\n\nfor ($i = 0; $i -le ($s.Length - $totalLength); $i++) {\n$seen = @{}\n$j = 0\nwhile ($j -lt $words.Count) {\n$wordIndex = $i + $j * $wordLength\n$word = $s.Substring($wordIndex, $wordLength)\nif (-not $wordMap.ContainsKey($word) -or $seen[$word] -ge $wordMap[$word]) {\nbreak\n}\n$seen[$word] = $seen[$word] + 1\n$j++\n}\nif ($j -eq $words.Count) {\n$result += $i\n}\n}\n\nreturn $result\n}", "test": "function Check-ConcatenatedSubstrings() {\n$result = Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\nif (($result -join ',') -ne '0,9') { throw \"Test case 1 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\nif (($result -join ',') -ne '') { throw \"Test case 2 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcabcabc\" @(\"abc\",\"abc\")\nif (($result -join ',') -ne '0,3') { throw \"Test case 3 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"ab\",\"cd\")\nif (($result -join ',') -ne '0') { throw \"Test case 4 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcd\" @(\"cd\",\"ab\")\nif (($result -join ',') -ne '0') { throw \"Test case 5 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abababab\" @(\"ab\",\"ba\")\nif (($result -join ',') -ne '') { throw \"Test case 6 failed\" }\n\n$result = Find-ConcatenatedSubstrings \"abcdef\" @(\"gh\",\"ij\")\nif (($result -join ',') -ne '') { throw \"Test case 7 failed\" }\n}\n\nCheck-ConcatenatedSubstrings", "entry_point": "Find-ConcatenatedSubstrings", "signature": "function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)", "docstring": "\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "instruction": "Write a PowerShell function `function Find-ConcatenatedSubstrings {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$s,\n\n[Parameter(Mandatory=$true)]\n[string[]]$words\n)` to solve the following problem:\n\n.SYNOPSIS\nFinds starting indices of all substrings in a given string that are concatenations\nof all strings in an array, where all strings in the array have the same length.\n\n.DESCRIPTION\nGiven a string s and an array of strings words, where all strings in words have the same length,\nthis function returns all starting indices of substrings in s that are concatenations of all strings\nin words in any order.\n\n.EXAMPLE\n>>> Find-ConcatenatedSubstrings \"barfoothefoobarman\" @(\"foo\",\"bar\")\n0, 9\n\n>>> Find-ConcatenatedSubstrings \"wordgoodgoodgoodbestword\" @(\"word\",\"good\",\"best\",\"word\")\n8\n\n", "level": "hard"}
{"task_id": "PowerShell/9", "prompt": "function Find-MedianOfTwoSortedArrays {\n<#\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "canonical_solution": "$merged = [System.Collections.Generic.List[int]]@()\n$merged.AddRange($nums1)\n$merged.AddRange($nums2)\n$merged.Sort()\n\n$count = $merged.Count\nif ($count % 2 -eq 1) {\nreturn $merged[($count / 2) - 0.5]\n} else {\nreturn ($merged[($count / 2) - 1] + $merged[$count / 2]) / 2.0\n}\n}", "test": "function Check-MedianOfTwoSortedArrays() {\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))) -ne 2.0) { throw \"Test case 1 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))) -ne 2.5) { throw \"Test case 2 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5, 7)) @([int[]](2, 4, 6, 8))) -ne 4.5) { throw \"Test case 3 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1)) @([int[]](1))) -ne 1.0) { throw \"Test case 4 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 3, 5)) @([int[]](2))) -ne 2.5) { throw \"Test case 5 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](10, 20, 30, 40, 50)) @([int[]](5, 15, 25, 35, 45))) -ne 27.5) { throw \"Test case 6 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 12, 15, 26, 38)) @([int[]](2, 13, 17, 30, 45, 50))) -ne 17.0) { throw \"Test case 7 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 4, 5)) @([int[]](2, 3, 6, 7, 8))) -ne 4.5) { throw \"Test case 8 failed\" }\nif ((Find-MedianOfTwoSortedArrays @([int[]](1, 1, 1)) @([int[]](1, 1, 1, 1))) -ne 1.0) { throw \"Test case 10 failed\" }\n}\n\nCheck-MedianOfTwoSortedArrays", "entry_point": "Find-MedianOfTwoSortedArrays", "signature": "function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)", "docstring": "\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "instruction": "Write a PowerShell function `function Find-MedianOfTwoSortedArrays {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums1,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums2\n)` to solve the following problem:\n\n.SYNOPSIS\nFinds the median of two sorted arrays.\n\n.DESCRIPTION\nGiven two sorted arrays nums1 and nums2 of sizes m and n respectively, this function\nfinds and returns the median of the two sorted arrays.\n\n.EXAMPLE\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 3)) @([int[]](2))\n2.0\n\n>>> Find-MedianOfTwoSortedArrays @([int[]](1, 2)) @([int[]](3, 4))\n2.5\n\n", "level": "middle"}
{"task_id": "PowerShell/10", "prompt": "function Reverse-Integer {\n<#\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "\n$isNegative = $x -lt 0\nif ($isNegative) {\n$x = [Math]::Abs($x)\n}\n\n[long]$reversed = 0\n\nwhile ($x -gt 0) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nif ($isNegative) {\n$reversed = -$reversed\n}\n\nif ($reversed -lt [int]::MinValue -or $reversed -gt [int]::MaxValue) {\nreturn 0\n}\n\nreturn [int]$reversed\n}", "test": "function Check-ReverseInteger() {\nif ((Reverse-Integer 123) -ne 321) { throw \"Test case 1 failed\" }\nif ((Reverse-Integer -123) -ne -321) { throw \"Test case 2 failed\" }\nif ((Reverse-Integer 120) -ne 21) { throw \"Test case 3 failed\" }\nif ((Reverse-Integer 0) -ne 0) { throw \"Test case 4 failed\" }\nif ((Reverse-Integer 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Reverse-Integer -10) -ne -1) { throw \"Test case 6 failed\" }\n\n}\n\nCheck-ReverseInteger", "entry_point": "Reverse-Integer", "signature": "function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "instruction": "Write a PowerShell function `function Reverse-Integer {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)` to solve the following problem:\n\n.SYNOPSIS\nReverses the digits of a 32-bit signed integer.\n\n.DESCRIPTION\nGiven a 32-bit signed integer x, this function returns an integer which is the reverse of the \ndigit part of x. If the reversed integer exceeds the range of a 32-bit signed integer, \nit returns 0.\n\n.EXAMPLE\n>>> Reverse-Integer 123\n321\n\n>>> Reverse-Integer -123\n-321\n\n>>> Reverse-Integer 120\n21\n\n.EXAMPLE\n>>> Reverse-Integer 0\n0\n\n", "level": "middle"}
{"task_id": "PowerShell/11", "prompt": "function Is-PalindromeNumber {\n<#\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "canonical_solution": "if ($x -lt 0 -or ($x % 10 -eq 0 -and $x -ne 0)) {\nreturn $false\n}\n\n[int]$reversed = 0\nwhile ($x -gt $reversed) {\n$reversed = $reversed * 10 + $x % 10\n$x = [int]($x / 10)\n}\n\nreturn $x -eq $reversed -or $x -eq [int]($reversed / 10)\n}", "test": "function Check-PalindromeNumber() {\nif ((Is-PalindromeNumber 121) -ne $true) { throw \"Test case 1 failed\" }\nif ((Is-PalindromeNumber -121) -ne $false) { throw \"Test case 2 failed\" }\nif ((Is-PalindromeNumber 10) -ne $false) { throw \"Test case 3 failed\" }\nif ((Is-PalindromeNumber 1221) -ne $true) { throw \"Test case 4 failed\" }\nif ((Is-PalindromeNumber 12321) -ne $true) { throw \"Test case 5 failed\" }\nif ((Is-PalindromeNumber 123321) -ne $true) { throw \"Test case 6 failed\" }\nif ((Is-PalindromeNumber 0) -ne $true) { throw \"Test case 7 failed\" }\nif ((Is-PalindromeNumber 123) -ne $false) { throw \"Test case 8 failed\" }\nif ((Is-PalindromeNumber 1) -ne $true) { throw \"Test case 9 failed\" }\nif ((Is-PalindromeNumber 1000021) -ne $false) { throw \"Test case 10 failed\" }\n}\n\nCheck-PalindromeNumber", "entry_point": "Is-PalindromeNumber", "signature": "function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)", "docstring": "\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "instruction": "Write a PowerShell function `function Is-PalindromeNumber {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$x\n)` to solve the following problem:\n\n.SYNOPSIS\nChecks if an integer is a palindrome.\n\n.DESCRIPTION\nGiven an integer x, this function returns true if x is a palindrome integer; otherwise, it returns false.\nA palindrome number is one that reads the same backward as forward.\n\n.EXAMPLE\n>>> Is-PalindromeNumber 121\nTrue\n\n>>> Is-PalindromeNumber -121\nFalse\n\n.EXAMPLE\n>>> Is-PalindromeNumber 10\nFalse\n\n", "level": "easy"}
{"task_id": "PowerShell/12", "prompt": "function Max-WaterContainer {\n<#\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "canonical_solution": "$left = 0\n$right = $height.Count - 1\n$maxWater = 0\n\nwhile ($left -lt $right) {\n$width = $right - $left\n$ht = [Math]::Min($height[$left], $height[$right])\n$maxWater = [Math]::Max($maxWater, $width * $ht)\n\nif ($height[$left] -lt $height[$right]) {\n$left++\n} else {\n$right--\n}\n}\n\nreturn $maxWater\n}", "test": "function Check-MaxWaterContainer() {\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))) -ne 49) { throw \"Test case 1 failed\" }\nif ((Max-WaterContainer @([int[]](1, 1))) -ne 1) { throw \"Test case 2 failed\" }\nif ((Max-WaterContainer @([int[]](4, 3, 2, 1, 4))) -ne 16) { throw \"Test case 3 failed\" }\nif ((Max-WaterContainer @([int[]](1, 2, 4, 3))) -ne 4) { throw \"Test case 4 failed\" }\nif ((Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 25, 7))) -ne 49) { throw \"Test case 5 failed\" }\nif ((Max-WaterContainer @([int[]](1, 3, 2, 5, 25, 24, 5))) -ne 24) { throw \"Test case 6 failed\" }\n}\n\nCheck-MaxWaterContainer", "entry_point": "Max-WaterContainer", "signature": "function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)", "docstring": "\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "instruction": "Write a PowerShell function `function Max-WaterContainer {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$height\n)` to solve the following problem:\n\n.SYNOPSIS\nFinds the maximum water that can be contained within two lines.\n\n.DESCRIPTION\nGiven an array of integers height representing the heights of n vertical lines, \nthis function finds two lines that form a container with the x-axis that can store \nthe maximum amount of water and returns this maximum water amount.\n\n.EXAMPLE\n>>> Max-WaterContainer @([int[]](1, 8, 6, 2, 5, 4, 8, 3, 7))\n49\n\n>>> Max-WaterContainer @([int[]](1, 1))\n1\n\n", "level": "middle"}
{"task_id": "PowerShell/13", "prompt": "function Remove-Element {\n<#\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "canonical_solution": "$i = 0\nfor ($j = 0; $j -lt $nums.Count; $j++) {\nif ($nums[$j] -ne $val) {\n$nums[$i] = $nums[$j]\n$i++\n}\n}\n\n$nums.RemoveRange($i, $nums.Count - $i) # \u79fb\u9664\u591a\u4f59\u7684\u5143\u7d20\n\nreturn $i\n}", "test": "function Check-RemoveElement() {\n#if ((Remove-Element @(3, 2, 2, 3) 3) -ne 2) { throw \"Test case 1 failed\" }\nif ((Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2) -ne 5) { throw \"Test case 2 failed\" }\nif ((Remove-Element @(1, 2, 3, 4, 5) 6) -ne 5) { throw \"Test case 3 failed\" }\nif ((Remove-Element @(1, 1, 1) 1) -ne 0) { throw \"Test case 4 failed\" }\nif ((Remove-Element @(2, 2, 3, 3) 2) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nCheck-RemoveElement", "entry_point": "Remove-Element", "signature": "function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)", "docstring": "\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "instruction": "Write a PowerShell function `function Remove-Element {\nparam (\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$nums,\n\n[Parameter(Mandatory=$true)]\n[int]$val\n)` to solve the following problem:\n\n.SYNOPSIS\nRemoves all instances of a specified value from an array and returns the new length.\n\n.DESCRIPTION\nGiven an array nums and a value val, this function removes all instances of val in nums in place.\nThe function returns the new length of the array after the removals.\n\n.EXAMPLE\n>>> Remove-Element @(3, 2, 2, 3) 3\n2\n\n>>> Remove-Element @(0, 1, 2, 2, 3, 0, 4, 2) 2\n5\n\n", "level": "easy"}
{"task_id": "PowerShell/14", "prompt": "function Count-GoodIntegers {\n<#\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n#>\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "canonical_solution": "$mod = 1000000007\n$count = 0\n\nfor ($i = [int]$num1; $i -le [int]$num2; $i++) {\n$digitSum = [Linq.Enumerable]::Sum([char[]](\"$i\".ToCharArray()), [Func[char,int]]{ param($c) [int]$c - 48 })\nif ($digitSum -ge $min_sum -and $digitSum -le $max_sum) {\n$count++\n}\n}\n\nreturn $count % $mod\n}", "test": "function Check-GoodIntegers() {\nif ((Count-GoodIntegers \"25\" \"30\" 7 5) -ne 1) { throw \"Test case 1 failed\" }\nif ((Count-GoodIntegers \"1\" \"12\" 8 1) -ne 11) { throw \"Test case 2 failed\" }\nif ((Count-GoodIntegers \"1\" \"5\" 5 1) -ne 5) { throw \"Test case 3 failed\" }\n}\n\nCheck-GoodIntegers", "entry_point": "Count-GoodIntegers", "signature": "function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)", "docstring": "\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "instruction": "Write a PowerShell function `function Count-GoodIntegers {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$num1,\n\n[Parameter(Mandatory=$true)]\n[string]$num2,\n\n[Parameter(Mandatory=$true)]\n[int]$max_sum,\n\n[Parameter(Mandatory=$true)]\n[int]$min_sum\n)` to solve the following problem:\n\n.SYNOPSIS\nCounts the number of good integers within a specified range and digit sum constraints.\n\n.DESCRIPTION\nGiven two numeric strings num1 and num2, and two integers max_sum and min_sum, this function\nreturns the count of \"good integers\" x that satisfy the conditions:\n- num1 <= x <= num2\n- min_sum <= digit_sum(x) <= max_sum\nThe result is returned modulo 10^9 + 7.\n\n.EXAMPLE\n>>> Count-GoodIntegers \"25\" \"30\" 7 5\n4\n\n", "level": "middle"}
{"task_id": "PowerShell/15", "prompt": "function Count-WordFrequency {\n<# Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"#>", "canonical_solution": "$words = Get-Content frequency.txt -Raw -ErrorAction SilentlyContinue | Out-String | ForEach-Object { $_ -split '\\s+' }\n$wordCount = @{}\n\nforeach ($word in $words) {\nif (!$word) { continue }\nif ($wordCount.ContainsKey($word)) {\n$wordCount[$word]++\n} else {\n$wordCount[$word] = 1\n}\n}\n\n$wordCount.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {\n\"$($_.Key) $($_.Value)\"\n}\n}", "test": "function Test-CountWordFrequency {\n# Test function for Count-WordFrequency\n# Create a sample frequency.txt file\n\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n\n# Expected output\n$expected_output = \"apple 3\\nbanana 3\" -split \"\\n\"\n\n# Actual output from the function\n$actual_output = Count-WordFrequency\n\n# Compare actual output to expected output\nif ($actual_output -join \"`n\" -eq $expected_output -join \"`n\") {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item frequency.txt\n}\n\n# Call the test function\nTest-CountWordFrequency", "entry_point": "Count-WordFrequency", "signature": "function Count-WordFrequency {\n", "docstring": " Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "instruction": "Write a PowerShell function `function Count-WordFrequency {\n` to solve the following problem:\n Count the frequency of each word in frequency.txt\n# example\n# in:\"apple banana apple\\nbanana banana apple\" | Set-Content frequency.txt\n# out:\"apple 3\\nbanana 3\"", "level": "middle"}
{"task_id": "PowerShell/16", "prompt": "function Find-ValidNumbers {\n<# Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"#>", "canonical_solution": "Get-Content file.txt | Where-Object { $_ -match '^\\(\\d{3}\\) \\d{3}-\\d{4}$|^\\d{3}-\\d{3}-\\d{4}$' }\n}", "test": "function Test-FindValidNumbers {\n# Test function for Find-ValidNumbers\n# Create a sample file.txt file\n\"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"123-456-7890\", \"(123) 456-7890\"\n\n# Actual output from the function\n$actual_output = Find-ValidNumbers\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-FindValidNumbers", "entry_point": "Find-ValidNumbers", "signature": "function Find-ValidNumbers {\n", "docstring": " Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"", "instruction": "Write a PowerShell function `function Find-ValidNumbers {\n` to solve the following problem:\n Single-line script to output all valid phone numbers from file.txt\n# example\n# in \"123-456-7890\", \"(123) 456-7890\", \"123 456 7890\", \"(123)-456-7890\" | Set-Content file.txt\n# out:\"123-456-7890\", \"(123) 456-7890\"", "level": "easy"}
{"task_id": "PowerShell/17", "prompt": "function Transpose-File {\n<# Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"#>", "canonical_solution": "$lines = Get-Content file.txt\n$transpose = @()\n\nforeach ($line in $lines) {\n$words = $line -split ' '\nfor ($i = 0; $i -lt $words.Length; $i++) {\nif ($transpose.Length -le $i) {\n$transpose += ,@()\n}\n$transpose[$i] += $words[$i]\n}\n}\n\n$transpose | ForEach-Object { $_ -join ' ' }\n}", "test": "function Test-TransposeFile {\n# Test function for Transpose-File\n# Create a sample file.txt file\n\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n\n# Expected output\n$expected_output = \"1 4 7\", \"2 5 8\", \"3 6 9\"\n\n# Actual output from the function\n$actual_output = Transpose-File\n\n# Compare actual output to expected output\nif (($actual_output -join \"`n\") -eq ($expected_output -join \"`n\")) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-TransposeFile", "entry_point": "Transpose-File", "signature": "function Transpose-File {\n", "docstring": " Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "instruction": "Write a PowerShell function `function Transpose-File {\n` to solve the following problem:\n Transpose the content of file.txt\n# example\n# in:\"1 2 3\", \"4 5 6\", \"7 8 9\" | Set-Content file.txt\n# out:\"1 4 7\", \"2 5 8\", \"3 6 9\"", "level": "middle"}
{"task_id": "PowerShell/18", "prompt": "function Extract-TenthLine {\n<# Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"#>", "canonical_solution": "Get-Content file.txt | Select-Object -Index 9\n}", "test": "function Test-ExtractTenthLine {\n# Test function for Extract-TenthLine\n# Create a sample file.txt file\n1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n\n# Expected output\n$expected_output = \"Line 10\"\n\n# Actual output from the function\n$actual_output = Extract-TenthLine\n\n# Compare actual output to expected output\nif ($actual_output -eq $expected_output) {\n\"Test 1 passed\"\n} else {\nWrite-Error \"Test 1 failed\"\nexit 1\n}\n\n# Clean up\nRemove-Item file.txt\n}\n\n# Call the test function\nTest-ExtractTenthLine", "entry_point": "Extract-TenthLine", "signature": "function Extract-TenthLine {\n", "docstring": " Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"", "instruction": "Write a PowerShell function `function Extract-TenthLine {\n` to solve the following problem:\n Extract the tenth line from file.txt\n# example\n# in: 1..20 | ForEach-Object { \"Line $_\" } | Set-Content file.txt\n# out:\"Line 10\"", "level": "easy"}
{"task_id": "PowerShell/19", "prompt": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n<#\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n#>", "canonical_solution": "$totalCoins = 0\n$currentCoins = 1\n$currentDayCount = 0\n\nfor ($i = 1; $i -le $days; $i++) {\n$totalCoins += $currentCoins\n$currentDayCount++\n\nif ($currentDayCount -eq $currentCoins) {\n$currentCoins++\n$currentDayCount = 0\n}\n}\n\nreturn $totalCoins\n}", "test": "function Test-TotalCoins() {\nif ((Get-TotalCoins -days 7) -ne 18) { throw \"Test case 1 failed\" }\nif ((Get-TotalCoins -days 10) -ne 30) { throw \"Test case 2 failed\" }\nif ((Get-TotalCoins -days 15) -ne 55) { throw \"Test case 3 failed\" }\nif ((Get-TotalCoins -days 20) -ne 85) { throw \"Test case 4 failed\" }\nif ((Get-TotalCoins -days 1) -ne 1) { throw \"Test case 5 failed\" }\nif ((Get-TotalCoins -days 3) -ne 5) { throw \"Test case 6 failed\" }\nif ((Get-TotalCoins -days 5) -ne 11) { throw \"Test case 7 failed\" }\n}\n\nTest-TotalCoins", "entry_point": "Get-TotalCoins", "signature": "function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n", "docstring": "\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "instruction": "Write a PowerShell function `function Get-TotalCoins {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$days\n)\n` to solve the following problem:\n\nCalculates the total number of coins a knight receives over a given number of days. \nThe coins are distributed in a pattern where the knight receives n coins each day \nfor n consecutive days, followed by n+1 coins each day for the next n+1 days, and so on.\n\nExample:\n>>> Get-TotalCoins -days 7\n18\n>>> Get-TotalCoins -days 10\n30\n", "level": "easy"}
{"task_id": "PowerShell/20", "prompt": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n<#\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n#>", "canonical_solution": "$outputGrid = New-Object string[] $n\n\nfor ($row = 0; $row -lt $n; $row++) {\n$outputRow = \"\"\n\nfor ($col = 0; $col -lt $m; $col++) {\nif ($grid[$row][$col] -eq '*') {\n$outputRow += '*'\ncontinue\n}\n\n$mineCount = 0\n\nforeach ($dRow in -1..1) {\nforeach ($dCol in -1..1) {\nif ($dRow -eq 0 -and $dCol -eq 0) {\ncontinue\n}\n\n$neighbourRow = $row + $dRow\n$neighbourCol = $col + $dCol\n\nif ($neighbourRow -ge 0 -and $neighbourRow -lt $n -and $neighbourCol -ge 0 -and $neighbourCol -lt $m) {\nif ($grid[$neighbourRow][$neighbourCol] -eq '*') {\n$mineCount++\n}\n}\n}\n}\n\n$outputRow += $mineCount\n}\n\n$outputGrid[$row] = $outputRow\n}\n\nreturn $outputGrid\n}", "test": "# Test cases\nfunction Test-MinesweeperGrid() {\n$test1 = Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n$expected1 = @(\"*10\", \"221\", \"1*1\")\n\n$test2 = Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n$expected2 = @(\"2*1\", \"*21\")\n\nif (Compare-Object $test1 $expected1) { throw \"Test case 1 failed\" }\nif (Compare-Object $test2 $expected2) { throw \"Test case 2 failed\" }\n}\n\nTest-MinesweeperGrid", "entry_point": "Get-MinesweeperGrid", "signature": "function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n", "docstring": "\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "instruction": "Write a PowerShell function `function Get-MinesweeperGrid {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[string[]]$grid\n)\n` to solve the following problem:\n\nGenerates a Minesweeper grid based on given mine locations. In the input grid, '*' represents a mine and '?' represents a safe cell. \nThe output grid replaces '?' with the number of mines adjacent to that cell (including diagonals).\n\nExample:\n>>> Get-MinesweeperGrid -n 3 -m 3 -grid @(\"*??\", \"???\", \"?*?\")\n@(\"*10\", \"221\", \"1*1\")\n\n>>> Get-MinesweeperGrid -n 2 -m 3 -grid @(\"?*?\", \"*??\")\n@(\"2*1\", \"*21\")\n", "level": "hard"}
{"task_id": "PowerShell/21", "prompt": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n<#\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n#>", "canonical_solution": "$sortedHeights = $cowHeights | Sort-Object -Descending\n$totalHeight = 0\n$cowCount = 0\n\nforeach ($height in $sortedHeights) {\nif ($totalHeight -ge $shelfHeight) {\nbreak\n}\n$totalHeight += $height\n$cowCount++\n}\n\nreturn $cowCount\n}", "test": "function Test-MinimumCowsForHeight() {\nif ((Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5))))) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18))))) -ne 3) { throw \"Test case 2 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 45 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](9, 15, 8, 17, 6))))) -ne 4) { throw \"Test case 3 failed\" }\nif ((Get-MinimumCowsForHeight -shelfHeight 70 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](22, 27, 15, 10, 18))))) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MinimumCowsForHeight", "entry_point": "Get-MinimumCowsForHeight", "signature": "function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n", "docstring": "\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "instruction": "Write a PowerShell function `function Get-MinimumCowsForHeight {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$shelfHeight,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[int]]$cowHeights\n)\n` to solve the following problem:\n\nCalculates the minimum number of cows needed to reach a specified shelf height by stacking them. \nEach cow has a certain height, and cows can be stacked on top of each other to reach the height of the shelf.\n\nExample:\n>>> Get-MinimumCowsForHeight -shelfHeight 30 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](10, 12, 8, 5)))\n3\n>>> Get-MinimumCowsForHeight -shelfHeight 50 -cowHeights (New-Object 'System.Collections.Generic.List[int]' (,([int[]](15, 20, 10, 18)))\n3\n", "level": "easy"}
{"task_id": "PowerShell/22", "prompt": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n<#\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n#>", "canonical_solution": "$maxScore = 0\n\n# \u8ba1\u7b97\u540c\u8272\u653e\u7f6e\u5f97\u5206\n$sameColorScore = ($redBoxes * $scoreRedInRed) + ($blueBoxes * $scoreBlueInBlue)\n# \u8ba1\u7b97\u4ea4\u53c9\u653e\u7f6e\u5f97\u5206\n$crossColorScore = [Math]::Min($redBoxes, $blueBoxes) * $scoreCrossColor * 2 + \n[Math]::Abs($redBoxes - $blueBoxes) * \n[Math]::Max($scoreRedInRed, $scoreBlueInBlue)\n\n# \u53d6\u4e24\u79cd\u60c5\u51b5\u4e2d\u7684\u6700\u5927\u503c\n$maxScore = [Math]::Max($sameColorScore, $crossColorScore)\n\nreturn $maxScore\n}", "test": "# Test cases\nfunction Test-MaximumScore() {\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 200) -ne 1400) { throw \"Test case 1 failed\" }\nif ((Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 400 -scoreCrossColor 300) -ne 1600) { throw \"Test case 2 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 150 -scoreBlueInBlue 200 -scoreCrossColor 100) -ne 850) { throw \"Test case 3 failed\" }\nif ((Get-MaximumScore -redBoxes 3 -blueBoxes 3 -scoreRedInRed 150 -scoreBlueInBlue 300 -scoreCrossColor 200) -ne 1350) { throw \"Test case 4 failed\" }\n}\n\nTest-MaximumScore", "entry_point": "Get-MaximumScore", "signature": "function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n", "docstring": "\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "instruction": "Write a PowerShell function `function Get-MaximumScore {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$redBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$blueBoxes,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreRedInRed,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreBlueInBlue,\n\n[Parameter(Mandatory=$true)]\n[int]$scoreCrossColor\n)\n` to solve the following problem:\n\nCalculates the maximum total score for placing red and blue balls in red and blue boxes. \nEach ball must be placed in a box, and each box can only contain one ball. Scores are assigned based on the color match or mismatch.\n\nExample:\n>>> Get-MaximumScore -redBoxes 3 -blueBoxes 2 -scoreRedInRed 100 -scoreBlueInBlue 200 -scoreCrossColor 150\n800\n>>> Get-MaximumScore -redBoxes 2 -blueBoxes 3 -scoreRedInRed 100 -scoreBlueInBlue 300 -scoreCrossColor 50\n1000\n", "level": "middle"}
{"task_id": "PowerShell/23", "prompt": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n<#\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n#>", "canonical_solution": "$sumFrequency = @{}\n\nfor ($i = 1; $i -le $s1; $i++) {\nfor ($j = 1; $j -le $s2; $j++) {\nfor ($k = 1; $k -le $s3; $k++) {\n$sum = $i + $j + $k\n$sumFrequency[$sum] = $sumFrequency[$sum] + 1\n}\n}\n}\n\n$maxFrequency = [int]::MinValue\n$resultSum = [int]::MaxValue\n\nforeach ($key in $sumFrequency.Keys) {\nif ($sumFrequency[$key] -gt $maxFrequency -or ($sumFrequency[$key] -eq $maxFrequency -and $key -lt $resultSum)) {\n$maxFrequency = $sumFrequency[$key]\n$resultSum = $key\n}\n}\n\nreturn $resultSum\n}", "test": "function Test-MostFrequentDiceSum() {\nif ((Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3) -ne 5) { throw \"Test case 1 failed\" }\nif ((Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6) -ne 8) { throw \"Test case 2 failed\" }\nif ((Get-MostFrequentDiceSum -s1 6 -s2 6 -s3 6) -ne 10) { throw \"Test case 3 failed\" }\nif ((Get-MostFrequentDiceSum -s1 2 -s2 2 -s3 2) -ne 4) { throw \"Test case 4 failed\" }\n}\n\nTest-MostFrequentDiceSum", "entry_point": "Get-MostFrequentDiceSum", "signature": "function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n", "docstring": "\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "instruction": "Write a PowerShell function `function Get-MostFrequentDiceSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$s1,\n\n[Parameter(Mandatory=$true)]\n[int]$s2,\n\n[Parameter(Mandatory=$true)]\n[int]$s3\n)\n` to solve the following problem:\n\nDetermines the most frequently occurring sum when rolling three dice with specified numbers of sides. \nThe dice have $s1$, $s2$, and $s3$ sides, respectively. The function calculates all possible sums and \nreturns the smallest sum that appears most frequently.\n\nExample:\n>>> Get-MostFrequentDiceSum -s1 3 -s2 2 -s3 3\n5\n>>> Get-MostFrequentDiceSum -s1 4 -s2 3 -s3 6\n7\n", "level": "hard"}
{"task_id": "PowerShell/24", "prompt": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n<#\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n#>", "canonical_solution": "$result = @()\n\nforeach ($number in $numbers) {\nif ([int]($number[-1]) % 2 -eq 0) {\n$result += \"even\"\n} else {\n$result += \"odd\"\n}\n}\n\nreturn $result\n}", "test": "function Test-DetermineParity() {\n$result1 = Determine-Parity @(\"1024\", \"5931\")\n\nif (Compare-Object $result1 @(\"even\", \"odd\")) { throw \"Test case 1 failed\" }\n\n$result2 = Determine-Parity @(\"123456789012345678901234567890\", \"123456789012345678901234567891\")\nif (Compare-Object $result2 @(\"even\", \"odd\")) { throw \"Test case 2 failed\" }\n}\n\nTest-DetermineParity", "entry_point": "Determine-Parity", "signature": "function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n", "docstring": "\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "instruction": "Write a PowerShell function `function Determine-Parity {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$numbers\n)\n` to solve the following problem:\n\nDetermines whether each number in a list of large integers is even or odd. \nThe function takes an array of strings representing the numbers, as the numbers can be very large (up to 10^60). \nIt returns an array of strings with each entry being 'even' or 'odd' corresponding to each number's parity.\n\nExample:\n>>> Determine-Parity @(\"1234\", \"56789\")\n@(\"even\", \"odd\")\n>>> Determine-Parity @(\"100000000000000000000000000000000\", \"333333333333333333333333333333333\")\n@(\"even\", \"odd\")\n", "level": "easy"}
{"task_id": "PowerShell/25", "prompt": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n<#\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n#>", "canonical_solution": "$results = @()\n\nforeach ($query in $queries) {\n$results += $studentIDs[$query - 1]\n}\n\nreturn $results\n}", "test": "function Test-StudentIDsByOrder() {\n$result1 = Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\nif (Compare-Object $result1 @(1, 8, 5)) { throw \"Test case 1 failed\" }\n\n$result2 = Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\nif (Compare-Object $result2 @(15, 22)) { throw \"Test case 2 failed\" }\n}\n\nTest-StudentIDsByOrder", "entry_point": "Get-StudentIDsByOrder", "signature": "function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n", "docstring": "\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "instruction": "Write a PowerShell function `function Get-StudentIDsByOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$studentIDs,\n\n[Parameter(Mandatory=$true)]\n[int[]]$queries\n)\n` to solve the following problem:\n\nRetrieves the student IDs based on the order in which they entered the classroom. \nThe function takes two arrays: one with the student IDs in the order they entered, \nand the other with queries indicating the entry order number of the student.\n\nExample:\n>>> Get-StudentIDsByOrder -studentIDs @(1, 9, 2, 60, 8, 17, 11, 4, 5, 14) -queries @(1, 5, 9)\n@(1, 8, 5)\n>>> Get-StudentIDsByOrder -studentIDs @(7, 15, 3, 22, 9) -queries @(2, 4)\n@(15, 22)\n", "level": "easy"}
{"task_id": "PowerShell/26", "prompt": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n<#\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n#>", "canonical_solution": "$vkCount = ([regex]::Matches($inputString, \"VK\")).Count\n$canIncrease = ($inputString -match \"VV\" -or $inputString -match \"KK\")\n\nif ($canIncrease) {\n$vkCount++\n}\n\nreturn $vkCount\n}", "test": "function Test-MaximizeVKOccurrences() {\nif ((Maximize-VKOccurrences -inputString \"VK\") -ne 1) { throw \"Test case 1 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VV\") -ne 1) { throw \"Test case 2 failed\" }\nif ((Maximize-VKOccurrences -inputString \"V\") -ne 0) { throw \"Test case 3 failed\" }\nif ((Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\") -ne 3) { throw \"Test case 4 failed\" }\nif ((Maximize-VKOccurrences -inputString \"KVKV\") -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-MaximizeVKOccurrences", "entry_point": "Maximize-VKOccurrences", "signature": "function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n", "docstring": "\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "instruction": "Write a PowerShell function `function Maximize-VKOccurrences {\nparam (\n[Parameter(Mandatory=$true)]\n[string]$inputString\n)\n` to solve the following problem:\n\nMaximizes the occurrences of the substring \"VK\" in the given string by changing at most one character \n(or making no changes). The function returns the maximum number of \"VK\" occurrences that can be achieved.\n\nExample:\n>>> Maximize-VKOccurrences -inputString \"VK\"\n1\n>>> Maximize-VKOccurrences -inputString \"VV\"\n1\n>>> Maximize-VKOccurrences -inputString \"V\"\n0\n>>> Maximize-VKOccurrences -inputString \"VKKKKKKKKKVVVVVVVVVK\"\n3\n>>> Maximize-VKOccurrences -inputString \"KVKV\"\n1\n", "level": "easy"}
{"task_id": "PowerShell/27", "prompt": "function Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n<#\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n#>", "canonical_solution": "$finalGrade = [math]::Round(($homeworkScore * 0.2) + ($quizScore * 0.3) + ($finalExamScore * 0.5))\nreturn $finalGrade\n}", "test": "function Test-CalculateFinalGrade() {\nif ((Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80) -ne 90) { throw \"Test case 1 failed\" }\nif ((Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80) -ne 79) { throw \"Test case 2 failed\" }\n}\n\nTest-CalculateFinalGrade", "entry_point": "Calculate-FinalGrade", "signature": "function Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n", "docstring": "\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n", "instruction": "Write a PowerShell function `function Calculate-FinalGrade {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$homeworkScore,\n\n[Parameter(Mandatory=$true)]\n[int]$quizScore,\n\n[Parameter(Mandatory=$true)]\n[int]$finalExamScore\n)\n` to solve the following problem:\n\nCalculates the final grade based on homework, quiz, and final exam scores.\nThe final grade is computed as 20% of the homework score, 30% of the quiz score, \nand 50% of the final exam score.\n\nExample:\n>>> Calculate-FinalGrade -homeworkScore 100 -quizScore 100 -finalExamScore 80\n90\n>>> Calculate-FinalGrade -homeworkScore 60 -quizScore 90 -finalExamScore 80\n79\n", "level": "easy"}
{"task_id": "PowerShell/28", "prompt": "function Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n<#\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n#>", "canonical_solution": "$remainders = $numbers | ForEach-Object { $_ % 42 } | Sort-Object -Unique\nreturn $remainders.Count\n}", "test": "function Test-GetDistinctRemainders() {\nif ((Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) -ne 10) { throw \"Test case 1 failed\" }\nif ((Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)) -ne 1) { throw \"Test case 2 failed\" }\nif ((Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)) -ne 6) { throw \"Test case 3 failed\" }\n}\n\nTest-GetDistinctRemainders", "entry_point": "Get-DistinctRemainders", "signature": "function Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n", "docstring": "\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n", "instruction": "Write a PowerShell function `function Get-DistinctRemainders {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers\n)\n` to solve the following problem:\n\nCalculates the number of distinct remainders when each number in a list of integers is divided by 42.\nThe function takes an array of integers as input and returns the count of unique remainders.\n\nExample:\n>>> Get-DistinctRemainders -numbers @(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n10\n>>> Get-DistinctRemainders -numbers @(42, 84, 252, 420, 840, 126, 42, 84, 420, 126)\n1\n>>> Get-DistinctRemainders -numbers @(39, 40, 41, 42, 43, 44, 82, 83, 84, 85)\n6\n", "level": "easy"}
{"task_id": "PowerShell/29", "prompt": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n<#\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n#>", "canonical_solution": "$segmentCount = 0\n$currentSum = 0\n\nforeach ($num in $numbers) {\nif ($currentSum + $num -gt $maxSum) {\n$segmentCount++\n$currentSum = $num\n} else {\n$currentSum += $num\n}\n}\n\nif ($currentSum -gt 0) {\n$segmentCount++\n}\n\nreturn $segmentCount\n}", "test": "function Test-MinimumSegments() {\nif ((Get-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6) -ne 3) { throw \"Test case 1 failed\" }\nif ((Get-MinimumSegments -numbers @(1, 2, 3, 4, 5) -maxSum 10) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MinimumSegments -numbers @(10, 10, 10) -maxSum 10) -ne 3) { throw \"Test case 3 failed\" }\n}\n\nTest-MinimumSegments", "entry_point": "Get-MinimumSegments", "signature": "function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n", "docstring": "\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "instruction": "Write a PowerShell function `function Get-MinimumSegments {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$numbers,\n\n[Parameter(Mandatory=$true)]\n[int]$maxSum\n)\n` to solve the following problem:\n\nSYNOPSIS\nCalculates the minimum number of contiguous segments into which a sequence of positive integers can be divided, such that the sum of each segment does not exceed a given maximum.\n\nDESCRIPTION\nGiven a sequence of positive integers and a maximum sum M, this function divides the sequence into the minimum number of contiguous segments where the sum of each segment is less than or equal to M.\n\nEXAMPLE\nGet-MinimumSegments -numbers @(4, 2, 4, 5, 1) -maxSum 6\nReturns 3\n", "level": "easy"}
{"task_id": "PowerShell/30", "prompt": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n<#\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n#>", "canonical_solution": "$convenientSet = [System.Collections.Generic.HashSet[string]]::new($convenientLocations)\n$daysTogether = 0\n\nforeach ($location in $herLocations) {\nif ($convenientSet.Contains($location)) {\n$daysTogether++\n}\n}\n\nreturn $daysTogether\n}", "test": "function Test-MaxDaysTogether() {\nif ((Get-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")) -ne 1) { throw \"Test case 1 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Park\", \"Mall\") -herLocations @(\"Park\", \"School\", \"Mall\", \"Home\")) -ne 2) { throw \"Test case 2 failed\" }\nif ((Get-MaxDaysTogether -convenientLocations @(\"Library\", \"Cafe\") -herLocations @(\"Home\", \"School\", \"Gym\")) -ne 0) { throw \"Test case 3 failed\" }\n}\n\nTest-MaxDaysTogether", "entry_point": "Get-MaxDaysTogether", "signature": "function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n", "docstring": "\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "instruction": "Write a PowerShell function `function Get-MaxDaysTogether {\nparam (\n[Parameter(Mandatory=$true)]\n[string[]]$convenientLocations,\n\n[Parameter(Mandatory=$true)]\n[string[]]$herLocations\n)\n` to solve the following problem:\n\nSYNOPSIS\nCalculates the maximum number of days a person can be with another at convenient locations.\n\nDESCRIPTION\nGiven a list of convenient locations and another list of locations where someone will be each day, this function determines the number of days they can be at the same place. Convenient locations are the ones where the person can easily go.\n\n.EXAMPLE\nGet-MaxDaysTogether -convenientLocations @(\"WC\") -herLocations @(\"CLASS\", \"WC\")\nReturns 1\n", "level": "easy"}
{"task_id": "PowerShell/31", "prompt": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n<#\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n#>", "canonical_solution": "$totalArea = 0\n\nfor ($i = 0; $i -lt $n; $i++) {\nfor ($j = 0; $j -lt $m; $j++) {\n$currentHeight = $grid[$i][$j]\nif ($currentHeight -gt 0) {\n# Top and bottom\n$totalArea += 2\n\n# Left\n$totalArea += $i -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i - 1][$j], 0)\n\n# Right\n$totalArea += $i -eq $n - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i + 1][$j], 0)\n\n# Front\n$totalArea += $j -eq 0 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j - 1], 0)\n\n# Back\n$totalArea += $j -eq $m - 1 ? $currentHeight : [Math]::Max($currentHeight - $grid[$i][$j + 1], 0)\n}\n}\n}\n\nreturn $totalArea\n}", "test": "function Test-ModelSurfaceArea {\nif ((Calculate-ModelSurfaceArea 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))) -ne 38) { throw \"Test case 1 failed\" }\nif ((Calculate-ModelSurfaceArea 2 2 @(@(1,0), @(0,1))) -ne 12) { throw \"Test case 2 failed\" }\nif ((Calculate-ModelSurfaceArea 2 3 @(@(2,3,2), @(1,0,1))) -ne 34) { throw \"Test case 3 failed\" }\nif ((Calculate-ModelSurfaceArea 4 4 @(@(0,0,0,0), @(0,2,2,0), @(0,2,2,0), @(0,0,0,0))) -ne 24) { throw \"Test case 4 failed\" }\n}\n\nTest-ModelSurfaceArea", "entry_point": "Calculate-ModelSurfaceArea", "signature": "function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n", "docstring": "\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "instruction": "Write a PowerShell function `function Calculate-ModelSurfaceArea {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[][]]$grid\n)\n` to solve the following problem:\n\nCalculate the total surface area of a city model based on a grid of buildings.\nEach building in the grid is represented by its height (number of 1x1x1 cubes).\n\nParameters:\n$n (int): The number of rows in the grid.\n$m (int): The number of columns in the grid.\n$grid (int[][]): A 2D array representing the grid of buildings, where each value is the height of the building.\n\nReturns:\nint: The total surface area of the city model.\n\nExample:\n>>> calculate_model_surface_area 3 3 @(@(1,1,1), @(2,1,2), @(1,1,1))\n38\n\n>>> calculate_model_surface_area 2 2 @(@(1,0), @(0,1))\n12\n", "level": "hard"}
{"task_id": "PowerShell/32", "prompt": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n<#\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n#>", "canonical_solution": "$queue = New-Object System.Collections.Queue\n$totalTime = 0\n$activeTaps = 0\n\nforeach ($amount in $waterAmounts) {\n$queue.Enqueue($amount)\n}\n\nwhile ($queue.Count -gt 0) {\n$totalTime++\n$activeTaps = [Math]::Min($m, $queue.Count)\nfor ($i = 0; $i -lt $activeTaps; $i++) {\n$currentAmount = $queue.Dequeue()\n$currentAmount--\nif ($currentAmount -gt 0) {\n$queue.Enqueue($currentAmount)\n}\n}\n}\n\nreturn $totalTime\n}", "test": "function Test-WaterCollectionTime {\nif ((Calculate-WaterCollectionTime 4 2 @(3, 3, 4, 4)) -ne 7) { throw \"Test case 1 failed\" }\nif ((Calculate-WaterCollectionTime 3 1 @(2, 3, 4)) -ne 9) { throw \"Test case 2 failed\" }\nif ((Calculate-WaterCollectionTime 6 3 @(1, 2, 2, 3, 1, 4)) -ne 6) { throw \"Test case 3 failed\" }\nif ((Calculate-WaterCollectionTime 2 2 @(5, 6)) -ne 6) { throw \"Test case 4 failed\" }\nif ((Calculate-WaterCollectionTime 5 3 @(1, 1, 1, 1, 1)) -ne 2) { throw \"Test case 5 failed\" }\n}\n\nTest-WaterCollectionTime", "entry_point": "Calculate-WaterCollectionTime", "signature": "function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n", "docstring": "\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "instruction": "Write a PowerShell function `function Calculate-WaterCollectionTime {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$n,\n\n[Parameter(Mandatory=$true)]\n[int]$m,\n\n[Parameter(Mandatory=$true)]\n[int[]]$waterAmounts\n)\n` to solve the following problem:\n\nCalculates the total time taken for all students to collect water from a set number of taps.\n\nParameters:\n$n (int): The number of students.\n$m (int): The number of taps.\n$waterAmounts (int[]): An array representing the amount of water each student needs to collect.\n\nReturns:\nint: The total time taken for all students to collect their water.\n\nExample:\n>>> calculate_water_collection_time 4 2 @(3, 3, 4, 4)\n7\n(Explanation: In the first 2 seconds, two students start collecting water. After 3 seconds, the first two students finish and the next two start. Total time = 3 + 4 = 7 seconds)\n\n>>> calculate_water_collection_time 3 1 @(2, 3, 4)\n9\n(Explanation: Only one tap is available, so students collect water one after another. Total time = 2 + 3 + 4 = 9 seconds)\n", "level": "hard"}
{"task_id": "PowerShell/33", "prompt": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n<#\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n#>", "canonical_solution": "$mod = 100003\n$ways = New-Object int[] ($N + 1)\n$ways[0] = 1\n\nfor ($i = 1; $i -le $N; $i++) {\n$ways[$i] = 0\nfor ($j = 1; $j -le $K; $j++) {\nif ($i - $j -ge 0) {\n$ways[$i] = ($ways[$i] + $ways[$i - $j]) % $mod\n}\n}\n}\n\nreturn $ways[$N]\n}", "test": "# Test cases\nfunction Test-WaysToClimb {\nif ((Calculate-WaysToClimb 4 2) -ne 5) { throw \"Test case 1 failed\" }\nif ((Calculate-WaysToClimb 3 3) -ne 4) { throw \"Test case 2 failed\" }\nif ((Calculate-WaysToClimb 6 3) -ne 24) { throw \"Test case 3 failed\" }\nif ((Calculate-WaysToClimb 7 4) -ne 56) { throw \"Test case 4 failed\" }\nif ((Calculate-WaysToClimb 10 5) -ne 464) { throw \"Test case 5 failed\" }\n}\n\nTest-WaysToClimb", "entry_point": "Calculate-WaysToClimb", "signature": "function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n", "docstring": "\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "instruction": "Write a PowerShell function `function Calculate-WaysToClimb {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$N,\n\n[Parameter(Mandatory=$true)]\n[int]$K\n)\n` to solve the following problem:\n\nCalculates the number of different ways to climb to the top of a staircase with $N steps,\nwhere you can climb between 1 and $K steps at a time.\n\nParameters:\n$N (int): Total number of steps in the staircase.\n$K (int): Maximum number of steps that can be climbed in a single move.\n\nReturns:\nint: The total number of different ways to reach the top, modulo 100003.\n\nExample:\n>>> calculate_ways_to_climb 4 2\n5\n(Explanation: The ways to climb 4 steps with a maximum of 2 steps at a time are: 1-1-1-1, 2-1-1, 1-2-1, 1-1-2, and 2-2)\n\n>>> calculate_ways_to_climb 3 3\n4\n(Explanation: The ways to climb 3 steps with a maximum of 3 steps at a time are: 1-1-1, 1-2, 2-1, and 3)\n", "level": "easy"}
{"task_id": "PowerShell/34", "prompt": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n<#\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n#>", "canonical_solution": "$farmers = $farmers | Sort-Object price\n\n$totalCost = 0\nforeach ($farmer in $farmers) {\nif ($requiredMilk -le 0) { break }\n\n$milkToBuy = [Math]::Min($requiredMilk, $farmer.quantity)\n$totalCost += $milkToBuy * $farmer.price\n$requiredMilk -= $milkToBuy\n}\n\nreturn $totalCost\n}", "test": "function Test-MinimumMilkCost() {\n$farmers1 = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n$result1 = Get-MinimumMilkCost 100 $farmers1\nGet-MinimumMilkCost 100 $farmers1\nif ($result1 -ne 570) { throw \"Test case 1 failed: Expected 580, got $result1\" }\n\n$farmers2 = @([PSCustomObject]@{price=10; quantity=30}, [PSCustomObject]@{price=7; quantity=60}, [PSCustomObject]@{price=2; quantity=40})\n$result2 = Get-MinimumMilkCost 50 $farmers2\nif ($result2 -ne 150) { throw \"Test case 2 failed: Expected 140, got $result2\" }\n\n$farmers3 = @([PSCustomObject]@{price=8; quantity=25}, [PSCustomObject]@{price=5; quantity=55}, [PSCustomObject]@{price=6; quantity=20})\n$result3 = Get-MinimumMilkCost 75 $farmers3\nif ($result3 -ne 395) { throw \"Test case 3 failed: Expected 430, got $result3\" }\n}\n\nTest-MinimumMilkCost", "entry_point": "Get-MinimumMilkCost", "signature": "function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n", "docstring": "\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "instruction": "Write a PowerShell function `function Get-MinimumMilkCost {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$requiredMilk,\n\n[Parameter(Mandatory=$true)]\n[System.Collections.Generic.List[object]]$farmers\n)\n` to solve the following problem:\n\nThis function calculates the minimum cost to purchase a specified amount of milk from a list of farmers. Each farmer offers a certain quantity of milk at a specific price. The goal is to meet the milk requirement at the lowest possible cost.\n\nParameters:\n- requiredMilk (int): The total amount of milk needed.\n- farmers (List[object]): A list of farmer offerings, where each offering is an object with properties 'price' (int) and 'quantity' (int).\n\nReturns:\nint: The minimum cost to purchase the required amount of milk.\n\nExample:\n>>> $farmers = @([PSCustomObject]@{price=5; quantity=20}, [PSCustomObject]@{price=9; quantity=40}, [PSCustomObject]@{price=4; quantity=50})\n>>> Get-MinimumMilkCost 100 $farmers\n570\n", "level": "easy"}
{"task_id": "PowerShell/35", "prompt": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n<#\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n#>", "canonical_solution": "\nfor ($i = $pyramid.Length - 2; $i -ge 0; $i--) {\nfor ($j = 0; $j -lt $pyramid[$i].Length; $j++) {\n$pyramid[$i][$j] += [Math]::Max($pyramid[$i + 1][$j], $pyramid[$i + 1][$j + 1])\n}\n}\n\nreturn $pyramid[0][0]\n}", "test": "function Test-MaxPathSum() {\n$pyramid1 = @( @(3), @(7, 4), @(2, 4, 6), @(8, 5, 9, 3) )\n$result1 = Get-MaxPathSum $pyramid1\nif ($result1 -ne 23) { throw \"Test case 1 failed: Expected 23, got $result1\" }\n\n$pyramid2 = @( @(1), @(2, 1), @(1, 2, 1) )\n$result2 = Get-MaxPathSum $pyramid2\nif ($result2 -ne 5) { throw \"Test case 2 failed: Expected 4, got $result2\" }\n\n$pyramid3 = @( @(1) )\n$result3 = Get-MaxPathSum $pyramid3\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 1, got $result3\" }\n}\n\nTest-MaxPathSum", "entry_point": "Get-MaxPathSum", "signature": "function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n", "docstring": "\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "instruction": "Write a PowerShell function `function Get-MaxPathSum {\nparam (\n[Parameter(Mandatory=$true)]\n[int[][]]$pyramid\n)\n` to solve the following problem:\n\nThis function calculates the maximum sum of a path from the top to the bottom of a number pyramid. Each step in the path can move diagonally to either of the two adjacent numbers below.\n\nParameters:\n- pyramid (int[][]): A jagged array representing the number pyramid, where each sub-array contains the numbers for that row.\n\nReturns:\nint: The maximum sum possible for any path from the top to the bottom of the pyramid.\n\nExample:\n>>> $pyramid = @( @(1), @(2, 3), @(4, 5, 6) )\n>>> Get-MaxPathSum $pyramid\n10 # The path 1 -> 3 -> 6\n", "level": "easy"}
{"task_id": "PowerShell/36", "prompt": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n<#\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n#>", "canonical_solution": "$indexedTimes = $waitingTimes |\nSelect-Object -Property @{Name='Time'; Expression={$_}}, @{Name='Index'; Expression={[Array]::IndexOf($waitingTimes, $_)}}\n\n$sortedIndices = $indexedTimes | Sort-Object -Property Time | Select-Object -ExpandProperty Index\n\n$totalTime = 0\n$cumulativeTime = 0\nforeach ($index in $sortedIndices) {\n$cumulativeTime += $waitingTimes[$index]\n$totalTime += $cumulativeTime\n}\n\nreturn $sortedIndices\n}", "test": "function Test-OptimalQueueOrder() {\n$result1 = Get-OptimalQueueOrder @(20, 10, 30)\nif ((Compare-Object $result1 @(1, 0, 2))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-OptimalQueueOrder @(5, 3, 8)\nif ((Compare-Object $result2 @(1, 0, 2))) { throw \"Test case 2 failed\" }\n\n$result3 = Get-OptimalQueueOrder @(15, 5, 3, 7)\nif ((Compare-Object $result3 @(2, 1, 3, 0))) { throw \"Test case 3 failed\" }\n}\n\nTest-OptimalQueueOrder", "entry_point": "Get-OptimalQueueOrder", "signature": "function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n", "docstring": "\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "instruction": "Write a PowerShell function `function Get-OptimalQueueOrder {\nparam (\n[Parameter(Mandatory=$true)]\n[int[]]$waitingTimes\n)\n` to solve the following problem:\n\nThis function determines the optimal order in which people should queue to minimize the average waiting time. The waiting time for each person is provided.\n\nParameters:\n- waitingTimes (int[]): An array of integers where each integer represents the time it takes for each person to fill water.\n\nReturns:\nObject: An object with two properties: 'order' (an array representing the optimal queue order) \n\nExample:\n>>> Get-OptimalQueueOrder @(30, 10, 20)\n@{order = @(2, 3, 1);\n# The optimal order is for the second person to go first, then the third, and finally the first person.\n", "level": "hard"}
{"task_id": "PowerShell/37", "prompt": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n<#\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n#>", "canonical_solution": "function Is-Prime {\nparam ([int]$number)\nif ($number -le 1) { return $false }\nif ($number -le 3) { return $true }\nif ($number % 2 -eq 0 -or $number % 3 -eq 0) { return $false }\nfor ($i = 5; $i * $i -le $number; $i += 6) {\nif ($number % $i -eq 0 -or $number % ($i + 2) -eq 0) {\nreturn $false\n}\n}\nreturn $true\n}\n\nfunction Is-SpecialPrime {\nparam ([int]$number)\nwhile ($number -gt 0) {\nif (-not (Is-Prime $number)) {\nreturn $false\n}\n$number = [math]::Floor($number / 10)\n}\nreturn $true\n}\n\n$start = [math]::Pow(10, $length - 1)\n$end = [math]::Pow(10, $length) - 1\n$specialPrimes = @()\nfor ($i = $start; $i -le $end; $i++) {\nif (Is-SpecialPrime $i) {\n$specialPrimes += $i\n}\n}\n\nreturn $specialPrimes\n}", "test": "function Test-SpecialPrimes() {\n$result1 = Get-SpecialPrimes 2\nif (-not (Compare-Object $result1 @(23, 29, 31, 37, 53, 59, 71, 73, 79, 97))) { throw \"Test case 1 failed\" }\n\n$result2 = Get-SpecialPrimes 3\nif ($result2.Count -eq 0) { throw \"Test case 2 failed: No special primes found\" }\n}\n\nTest-SpecialPrimes", "entry_point": "Get-SpecialPrimes", "signature": "function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n", "docstring": "\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "instruction": "Write a PowerShell function `function Get-SpecialPrimes {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$length\n)\n` to solve the following problem:\n\nThis function finds all special prime numbers of a given length. A special prime is defined as a number where each right-truncated version is also a prime. For example, 2339 is a special prime of length 4 because 2339, 233, 23, and 2 are all primes.\n\nParameters:\n- length (int): The length of the special prime numbers to find.\n\nReturns:\n[int[]]: An array of special prime numbers of the specified length.\n\nExample:\n>>> Get-SpecialPrimes 2\n@(23, 29, 31, 37, 53, 59, 71, 73, 79, 97)\n# Returns all 2-digit special prime numbers.\n", "level": "hard"}
{"task_id": "PowerShell/38", "prompt": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n<#\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n#>", "canonical_solution": "$result = 1\n$a = $a % $p\n\nwhile ($b -gt 0) {\nif ($b % 2 -eq 1) {\n$result = ($result * $a) % $p\n}\n$b = [math]::Floor($b / 2)\n$a = ($a * $a) % $p\n}\n\nreturn $result\n}", "test": "function Test-ModPower() {\n$result1 = Calculate-ModPower 2 10 9\nif ($result1 -ne 7) { throw \"Test case 1 failed: Expected 2^10 mod 9=7, got $result1\" }\n\n$result2 = Calculate-ModPower 3 7 5\nif ($result2 -ne 2) { throw \"Test case 2 failed: Expected 3^7 mod 5=2, got $result2\" }\n\n$result3 = Calculate-ModPower 5 3 4\nif ($result3 -ne 1) { throw \"Test case 3 failed: Expected 5^3 mod 4=1, got $result3\" }\n}\n\nTest-ModPower", "entry_point": "Calculate-ModPower", "signature": "function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n", "docstring": "\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "instruction": "Write a PowerShell function `function Calculate-ModPower {\nparam (\n[Parameter(Mandatory=$true)]\n[int]$a,\n\n[Parameter(Mandatory=$true)]\n[int]$b,\n\n[Parameter(Mandatory=$true)]\n[int]$p\n)\n` to solve the following problem:\n\nThis function calculates the result of a^b mod p, which is the remainder when a^b is divided by p.\n\nParameters:\n- a (int): The base of the exponentiation.\n- b (int): The exponent.\n- p (int): The modulus.\n\nReturns:\nint result.\n\nExample:\n>>> Calculate-ModPower 2 10 9\n7\n# Computes 2 to the power of 10 modulo 9, which equals 7.\n", "level": "easy"}
{"task_id": "PowerShell/39", "prompt": "function Find-MinimumSeriesSum {\n    <#\n    This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\n    The function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\n    Example:\n    >>> Find-MinimumSeriesSum -k 2\n    Returns the value of n for which the sum S_n exceeds 2.\n\n    >>> Find-MinimumSeriesSum -k 3\n    Returns the value of n for which the sum S_n exceeds 3.\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$k\n    )\n\n    $n = 1\n    $sum = 0\n\n    while ($sum -le $k) {\n        $sum += 1 / $n\n        $n++\n    }\n\n    return $n - 1 # Subtract 1 because $n is incremented one time too many in the loop\n}", "test": "function Test-FindMinimumSeriesSum {\n    if ((Find-MinimumSeriesSum -k 2) -ne 4) { throw \"Test case 1 failed\" }\n    if ((Find-MinimumSeriesSum -k 3) -ne 11) { throw \"Test case 2 failed\" }\n    if ((Find-MinimumSeriesSum -k 4) -ne 31) { throw \"Test case 3 failed\" }\n    if ((Find-MinimumSeriesSum -k 5) -ne 83) { throw \"Test case 4 failed\" }\n    if ((Find-MinimumSeriesSum -k 6) -ne 227) { throw \"Test case 5 failed\" }\n}\n\nTest-FindMinimumSeriesSum", "entry_point": "Find-MinimumSeriesSum", "signature": "function Find-MinimumSeriesSum {", "docstring": "This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "instruction": "Write a PowerShell function `function Find-MinimumSeriesSum {` to solve the following problem:This function computes the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n\nThe function takes an integer k as input and returns the smallest integer n for which S_n > k.\n\nExample:\n>>> Find-MinimumSeriesSum -k 2\nReturns the value of n for which the sum S_n exceeds 2.\n\n>>> Find-MinimumSeriesSum -k 3\nReturns the value of n for which the sum S_n exceeds 3.", "level": "easy"}
{"task_id": "PowerShell/40", "prompt": "function Get-MaxPens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n        [Parameter(Mandatory=$true)]\n        [int]$b\n    )\n\n    $totalJiao = $a * 10 + $b  # Convert total amount to Jiao\n    $pricePerPenJiao = 19      # Price of one pen in Jiao\n\n    return [math]::Floor($totalJiao / $pricePerPenJiao)\n}", "test": "function Test-GetMaxPens {\n    if ((Get-MaxPens -a 10 -b 3) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-MaxPens -a 20 -b 5) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-MaxPens -a 5 -b 9) -ne 3) { throw \"Test case 3 failed\" }\n    if ((Get-MaxPens -a 0 -b 19) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Get-MaxPens -a 7 -b 2) -ne 3) { throw \"Test case 5 failed\" }\n}\n\nTest-GetMaxPens", "entry_point": "Get-MaxPens", "signature": "function Get-MaxPens {", "docstring": "# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Write a PowerShell function `function Get-MaxPens {` to solve the following problem:# This function calculates the maximum number of pens that can be bought with a given amount of money.\n# The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n# The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n# It returns the maximum number of pens that can be purchased.\n# For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "level": "middle"}
{"task_id": "PowerShell/41", "prompt": "function Get-AbsoluteValue {\n    <#\n    This function takes an integer as input and returns its absolute value.\n\n    >>> Get-AbsoluteValue -n 5\n    5\n    >>> Get-AbsoluteValue -n -10\n    10\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -lt 0) {\n        return -$n\n    } else {\n        return $n\n    }\n}", "test": "function Test-GetAbsoluteValue {\n    if ((Get-AbsoluteValue -n 5) -ne 5) { throw \"Test case 1 failed\" }\n    if ((Get-AbsoluteValue -n -10) -ne 10) { throw \"Test case 2 failed\" }\n    if ((Get-AbsoluteValue -n 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Get-AbsoluteValue -n -20000) -ne 20000) { throw \"Test case 4 failed\" }\n    if ((Get-AbsoluteValue -n 10000) -ne 10000) { throw \"Test case 5 failed\" }\n}\n\nTest-GetAbsoluteValue", "entry_point": "Get-AbsoluteValue", "signature": "function Get-AbsoluteValue {", "docstring": "This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "instruction": "Write a PowerShell function `function Get-AbsoluteValue {` to solve the following problem:This function takes an integer as input and returns its absolute value.\n\n>>> Get-AbsoluteValue -n 5\n5\n>>> Get-AbsoluteValue -n -10\n10", "level": "easy"}
{"task_id": "PowerShell/42", "prompt": "function Test-NumberSign {\n    <#\n    This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n    >>> Test-NumberSign -n 5\n    positive\n    >>> Test-NumberSign -n -10\n    negative\n    >>> Test-NumberSign -n 0\n    zero\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    if ($n -gt 0) {\n        return \"positive\"\n    } elseif ($n -lt 0) {\n        return \"negative\"\n    } else {\n        return \"zero\"\n    }\n}", "test": "function Test-TestNumberSign {\n    if ((Test-NumberSign -n 5) -ne \"positive\") { throw \"Test case 1 failed\" }\n    if ((Test-NumberSign -n -10) -ne \"negative\") { throw \"Test case 2 failed\" }\n    if ((Test-NumberSign -n 0) -ne \"zero\") { throw \"Test case 3 failed\" }\n    if ((Test-NumberSign -n 1000000000) -ne \"positive\") { throw \"Test case 4 failed\" }\n    if ((Test-NumberSign -n -1000000000) -ne \"negative\") { throw \"Test case 5 failed\" }\n}\n\nTest-TestNumberSign", "entry_point": "Test-NumberSign", "signature": "function Test-NumberSign {", "docstring": "This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "instruction": "Write a PowerShell function `function Test-NumberSign {` to solve the following problem:This function takes an integer as input and returns a string indicating whether the number is positive, negative, or zero.\n\n>>> Test-NumberSign -n 5\npositive\n>>> Test-NumberSign -n -10\nnegative\n>>> Test-NumberSign -n 0\nzero", "level": "easy"}
{"task_id": "PowerShell/43", "prompt": "function Get-PowerOfTwo {\n    <#\n    This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n    >>> Get-PowerOfTwo -n 3\n    8\n    >>> Get-PowerOfTwo -n 0\n    1\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    return [Math]::Pow(2, $n)\n}", "test": "function Test-GetPowerOfTwo {\n    if ((Get-PowerOfTwo -n 3) -ne 8) { throw \"Test case 1 failed\" }\n    if ((Get-PowerOfTwo -n 0) -ne 1) { throw \"Test case 2 failed\" }\n    if ((Get-PowerOfTwo -n 10) -ne 1024) { throw \"Test case 3 failed\" }\n    if ((Get-PowerOfTwo -n 15) -ne 32768) { throw \"Test case 4 failed\" }\n    if ((Get-PowerOfTwo -n 20) -ne 1048576) { throw \"Test case 5 failed\" }\n}\n\nTest-GetPowerOfTwo", "entry_point": "Get-PowerOfTwo", "signature": "function Get-PowerOfTwo {", "docstring": "This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "instruction": "Write a PowerShell function `function Get-PowerOfTwo {` to solve the following problem:This function takes a non-negative integer as input and returns 2 raised to the power of that integer.\n\n>>> Get-PowerOfTwo -n 3\n8\n>>> Get-PowerOfTwo -n 0\n1", "level": "easy"}
{"task_id": "PowerShell/44", "prompt": "function Multiply-TwoNumbers {\n    <#\n    This function takes two positive integers as input and returns their product.\n\n    >>> Multiply-TwoNumbers -A 3 -B 4\n    12\n    >>> Multiply-TwoNumbers -A 10 -B 20\n    200\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$A,\n\n        [Parameter(Mandatory=$true)]\n        [int]$B\n    )\n\n    return $A * $B\n}", "test": "function Test-MultiplyTwoNumbers {\n    if ((Multiply-TwoNumbers -A 3 -B 4) -ne 12) { throw \"Test case 1 failed\" }\n    if ((Multiply-TwoNumbers -A 10 -B 20) -ne 200) { throw \"Test case 2 failed\" }\n    if ((Multiply-TwoNumbers -A 50000 -B 1) -ne 50000) { throw \"Test case 3 failed\" }\n    if ((Multiply-TwoNumbers -A 1 -B 50000) -ne 50000) { throw \"Test case 4 failed\" }\n    if ((Multiply-TwoNumbers -A 25000 -B 2) -ne 50000) { throw \"Test case 5 failed\" }\n}\n\nTest-MultiplyTwoNumbers", "entry_point": "Multiply-TwoNumbers", "signature": "function Multiply-TwoNumbers {", "docstring": "This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "instruction": "Write a PowerShell function `function Multiply-TwoNumbers {` to solve the following problem:This function takes two positive integers as input and returns their product.\n\n>>> Multiply-TwoNumbers -A 3 -B 4\n12\n>>> Multiply-TwoNumbers -A 10 -B 20\n200", "level": "easy"}
{"task_id": "PowerShell/45", "prompt": "function Get-ArithmeticSeriesTerm {\n    <#\n    This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n    >>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n    298\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a1,\n\n        [Parameter(Mandatory=$true)]\n        [int]$a2,\n\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $d = $a2 - $a1\n    $an = $a1 + ($n - 1) * $d\n\n    return $an\n}", "test": "function Test-GetArithmeticSeriesTerm {\n    if ((Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100) -ne 298) { throw \"Test case 1 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 5 -a2 10 -n 50) -ne 250) { throw \"Test case 2 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 100 -a2 99 -n 50) -ne 51) { throw \"Test case 3 failed\" }\n    if ((Get-ArithmeticSeriesTerm -a1 0 -a2 0 -n 1000) -ne 0) { throw \"Test case 4 failed\" }\n}\n\nTest-GetArithmeticSeriesTerm", "entry_point": "Get-ArithmeticSeriesTerm", "signature": "function Get-ArithmeticSeriesTerm {", "docstring": "This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "instruction": "Write a PowerShell function `function Get-ArithmeticSeriesTerm {` to solve the following problem:This function takes the first two terms and the term number of an arithmetic series as input and returns the value of the nth term.\n\n>>> Get-ArithmeticSeriesTerm -a1 1 -a2 4 -n 100\n298", "level": "easy"}
{"task_id": "PowerShell/46", "prompt": "function Reverse-ThreeDigitNumber {\n<#\nThis function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876\n#>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$n\n    )\n\n    $reversed = \"\"\n    foreach ($digit in $n.ToString().ToCharArray()) {\n        $reversed = $digit + $reversed\n    }\n\n    return [int]$reversed\n}", "test": "function Test-ReverseThreeDigitNumber {\n    if ((Reverse-ThreeDigitNumber -n 100) -ne 001) { throw \"Test case 1 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 678) -ne 876) { throw \"Test case 2 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 987) -ne 789) { throw \"Test case 3 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 321) -ne 123) { throw \"Test case 4 failed\" }\n    if ((Reverse-ThreeDigitNumber -n 123) -ne 321) { throw \"Test case 5 failed\" }\n}\n\nTest-ReverseThreeDigitNumber", "entry_point": "Reverse-ThreeDigitNumber", "signature": "function Reverse-ThreeDigitNumber {", "docstring": "This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "instruction": "Write a PowerShell function `function Reverse-ThreeDigitNumber {` to solve the following problem:This function takes a three-digit integer as input and returns the integer with its digits reversed.\n\n>>> Reverse-ThreeDigitNumber -n 100\n001\n>>> Reverse-ThreeDigitNumber -n 678\n876", "level": "easy"}
{"task_id": "PowerShell/47", "prompt": "function Convert-IntToBoolAndBack {\n    <#\n    This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n    >>> Convert-IntToBoolAndBack -intValue 3\n    1\n    >>> Convert-IntToBoolAndBack -intValue 0\n    0\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$intValue\n    )\n\n    # Convert the integer to a boolean\n    $boolValue = [bool]$intValue\n\n    # Convert the boolean back to an integer\n    $result = [int]$boolValue\n\n    return $result\n}", "test": "function Test-ConvertIntToBoolAndBack {\n    if ((Convert-IntToBoolAndBack -intValue 3) -ne 1) { throw \"Test case 1 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 0) -ne 0) { throw \"Test case 2 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 1) -ne 1) { throw \"Test case 3 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue -1) -ne 1) { throw \"Test case 4 failed\" }\n    if ((Convert-IntToBoolAndBack -intValue 100) -ne 1) { throw \"Test case 5 failed\" }\n}\n\nTest-ConvertIntToBoolAndBack", "entry_point": "Convert-IntToBoolAndBack", "signature": "function Convert-IntToBoolAndBack {", "docstring": "This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "instruction": "Write a PowerShell function `function Convert-IntToBoolAndBack {` to solve the following problem:This function takes an integer as input, converts it to a boolean, and then converts the boolean back to an integer.\n\n>>> Convert-IntToBoolAndBack -intValue 3\n1\n>>> Convert-IntToBoolAndBack -intValue 0\n0", "level": "easy"}
{"task_id": "PowerShell/48", "prompt": "function Get-ASCIIChar {\n    <#\n    This function takes an ASCII code as input and returns the corresponding character.\n\n    >>> Get-ASCIIChar -asciiCode 65\n    A\n    >>> Get-ASCIIChar -asciiCode 97\n    a\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$asciiCode\n    )\n\n    return [char]$asciiCode\n}", "test": "function Test-GetASCIIChar {\n    if ((Get-ASCIIChar -asciiCode 65) -ne 'A') { throw \"Test case 1 failed\" }\n    if ((Get-ASCIIChar -asciiCode 97) -ne 'a') { throw \"Test case 2 failed\" }\n    if ((Get-ASCIIChar -asciiCode 48) -ne '0') { throw \"Test case 3 failed\" }\n    if ((Get-ASCIIChar -asciiCode 33) -ne '!') { throw \"Test case 4 failed\" }\n    if ((Get-ASCIIChar -asciiCode 126) -ne '~') { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIIChar", "entry_point": "Get-ASCIIChar", "signature": "function Get-ASCIIChar {", "docstring": "This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "instruction": "Write a PowerShell function `function Get-ASCIIChar {` to solve the following problem:This function takes an ASCII code as input and returns the corresponding character.\n\n>>> Get-ASCIIChar -asciiCode 65\nA\n>>> Get-ASCIIChar -asciiCode 97\na", "level": "easy"}
{"task_id": "PowerShell/49", "prompt": "function Get-ASCIICode {\n    <#\n    This function takes a character as input and returns its ASCII code.\n\n    >>> Get-ASCIICode -char 'A'\n    65\n    >>> Get-ASCIICode -char 'a'\n    97\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [char]$char\n    )\n\n    return [int][char]$char\n}", "test": "function Test-GetASCIICode {\n    if ((Get-ASCIICode -char 'A') -ne 65) { throw \"Test case 1 failed\" }\n    if ((Get-ASCIICode -char 'a') -ne 97) { throw \"Test case 2 failed\" }\n    if ((Get-ASCIICode -char '0') -ne 48) { throw \"Test case 3 failed\" }\n    if ((Get-ASCIICode -char '!') -ne 33) { throw \"Test case 4 failed\" }\n    if ((Get-ASCIICode -char '~') -ne 126) { throw \"Test case 5 failed\" }\n}\n\nTest-GetASCIICode", "entry_point": "Get-ASCIICode", "signature": "function Get-ASCIICode {", "docstring": "This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "instruction": "Write a PowerShell function `function Get-ASCIICode {` to solve the following problem:This function takes a character as input and returns its ASCII code.\n\n>>> Get-ASCIICode -char 'A'\n65\n>>> Get-ASCIICode -char 'a'\n97", "level": "easy"}
{"task_id": "PowerShell/50", "prompt": "function Calculate-Expression {\n    <#\n    This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n    >>> Calculate-Expression -a 2 -b 3 -c 5\n    25\n    >>> Calculate-Expression -a 1 -b 1 -c 1\n    2\n    #>", "canonical_solution": "    param (\n        [Parameter(Mandatory=$true)]\n        [int]$a,\n\n        [Parameter(Mandatory=$true)]\n        [int]$b,\n\n        [Parameter(Mandatory=$true)]\n        [int]$c\n    )\n\n    return ($a + $b) * $c\n}", "test": "function Test-CalculateExpression {\n    if ((Calculate-Expression -a 2 -b 3 -c 5) -ne 25) { throw \"Test case 1 failed\" }\n    if ((Calculate-Expression -a 1 -b 1 -c 1) -ne 2) { throw \"Test case 2 failed\" }\n    if ((Calculate-Expression -a 0 -b 0 -c 0) -ne 0) { throw \"Test case 3 failed\" }\n    if ((Calculate-Expression -a -1 -b -1 -c -1) -ne 2) { throw \"Test case 4 failed\" }\n    if ((Calculate-Expression -a 10000 -b 10000 -c 10000) -ne 200000000) { throw \"Test case 5 failed\" }\n    if ((Calculate-Expression -a -10000 -b -10000 -c -10000) -ne 200000000) { throw \"Test case 6 failed\" }\n}", "entry_point": "Calculate-Expression", "signature": "function Calculate-Expression {", "docstring": "This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "instruction": "Write a PowerShell function `function Calculate-Expression {` to solve the following problem:This function takes three integers a, b, and c as input and calculates the value of the expression (a+b)*c.\n\n>>> Calculate-Expression -a 2 -b 3 -c 5\n25\n>>> Calculate-Expression -a 1 -b 1 -c 1\n2", "level": "easy"}
