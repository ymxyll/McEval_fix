{"task_id": "Shell/1", "prompt": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Check if in given list of numbers, are any two numbers closer to each other than\n#given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True", "canonical_solution": "local n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}", "test": "# Testing function\ntest_close_elements() {\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.3) == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.05) == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.95) == \"true\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.8) == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.0 4.0 5.0 2.0\" 0.1) == \"true\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 1.0) == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 0.5) == \"false\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_close_elements", "entry_point": "has_close_elements", "signature": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Write a Shell function `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "level": "easy"}
{"task_id": "Shell/2", "prompt": "#!/bin/bash\n\n# Function to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)", "canonical_solution": "local n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}", "test": "test_third_largest_number() {\n[[ $(third_largest_number \"4 5 1 3 2\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(third_largest_number \"10 5 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(third_largest_number \"7 7 7 7\") == \"7\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(third_largest_number \"9 8 7 6 5\") == \"7\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(third_largest_number \"1 2\") == \"2\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(third_largest_number \"3 3 3 2 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(third_largest_number \"1\") == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_third_largest_number", "entry_point": "third_largest_number", "signature": "third_largest_number() {\nlocal numbers=($1)", "docstring": "\nFunction to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n", "instruction": "Write a Shell function `third_largest_number() {\nlocal numbers=($1)` to solve the following problem:\n\nFunction to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n", "level": "middle"}
{"task_id": "Shell/3", "prompt": "#!/bin/bash\n\n# Calculate taxes based on a progressive tax bracket system.\n# The function takes two arguments:\n# 1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n# 2. An integer representing the total income.\n# It returns the total tax amount.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2", "canonical_solution": "local tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}", "test": "# Testing function\ntest_calculate_tax() {\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 25000) == \"4500\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 15000) == \"2000\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 12000) == \"1150\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 5000) == \"250\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20\" 0) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_tax", "entry_point": "calculate_tax", "signature": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2", "docstring": "\nCalculate taxes based on a progressive tax bracket system.\nThe function takes two arguments:\n1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n2. An integer representing the total income.\nIt returns the total tax amount.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n", "instruction": "Write a Shell function `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` to solve the following problem:\n\nCalculate taxes based on a progressive tax bracket system.\nThe function takes two arguments:\n1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n2. An integer representing the total income.\nIt returns the total tax amount.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n", "level": "easy"}
{"task_id": "Shell/4", "prompt": "#!/bin/bash\n\n# Check if a given square matrix is an X Matrix.\n# An X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\n# The function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\n# Returns true if it's an X Matrix, false otherwise.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"", "canonical_solution": "local n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}", "test": "# Testing function\ntest_is_x_matrix() {\n[[ $(is_x_matrix \"1 0 0;0 1 0;0 0 1\") == \"false\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 2;0 1 0;3 0 1\") == \"true\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(is_x_matrix \"2 0 0 0;0 3 0 0;0 0 5 0;0 0 0 7\") == \"false\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 0;0 0 0;0 0 1\") == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(is_x_matrix \"0\") == \"false\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(is_x_matrix \"5\") == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 1;0 1 0;1 0 1\") == \"true\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_is_x_matrix", "entry_point": "is_x_matrix", "signature": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"", "docstring": "\nCheck if a given square matrix is an X Matrix.\nAn X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\nThe function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\nReturns true if it's an X Matrix, false otherwise.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n", "instruction": "Write a Shell function `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` to solve the following problem:\n\nCheck if a given square matrix is an X Matrix.\nAn X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\nThe function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\nReturns true if it's an X Matrix, false otherwise.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n", "level": "easy"}
{"task_id": "Shell/5", "prompt": "#!/bin/bash\n\n# Perform operations on an array to remove pairs of equal integers.\n# Returns a two-element array: [number of pairs formed, number of remaining integers].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)", "canonical_solution": "local -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}", "test": "# Testing function\ntest_process_array() {\n[[ $(process_array \"3 1 2 3 2\") == \"2 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(process_array \"1 2 3 4\") == \"0 4\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(process_array \"5 5 5 5 5\") == \"2 1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(process_array \"1 1 2 2 3 3 4 4\") == \"4 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(process_array \"1\") == \"0 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(process_array \"\") == \"0 0\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(process_array \"2 2 2 2 3 3 3\") == \"3 1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_process_array", "entry_point": "process_array", "signature": "process_array() {\nlocal nums=($1)", "docstring": "\nPerform operations on an array to remove pairs of equal integers.\nReturns a two-element array: [number of pairs formed, number of remaining integers].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4\n", "instruction": "Write a Shell function `process_array() {\nlocal nums=($1)` to solve the following problem:\n\nPerform operations on an array to remove pairs of equal integers.\nReturns a two-element array: [number of pairs formed, number of remaining integers].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4\n", "level": "easy"}
{"task_id": "Shell/6", "prompt": "#!/bin/bash\n\n# Evaluate poker hands based on given ranks and suits.\n# The function takes two strings: one for ranks and one for suits, each value separated by spaces.\n# Returns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)", "canonical_solution": "local -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand", "test": "# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand", "entry_point": "evaluate_hand", "signature": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)", "docstring": "\nEvaluate poker hands based on given ranks and suits.\nThe function takes two strings: one for ranks and one for suits, each value separated by spaces.\nReturns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind\n", "instruction": "Write a Shell function `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` to solve the following problem:\n\nEvaluate poker hands based on given ranks and suits.\nThe function takes two strings: one for ranks and one for suits, each value separated by spaces.\nReturns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind\n", "level": "hard"}
{"task_id": "Shell/7", "prompt": "#!/bin/bash\n\n# Calculate the minimum number of operations to reduce all elements of an array to zero.\n# Each operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the minimum number of operations required.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)", "canonical_solution": "local operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}", "test": "test_min_operations_to_zero() {\n[[ $(min_operations_to_zero \"3 3 2 2 1\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"4 0 0 4\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 2 3 4 5\") == \"5\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"5 5 5 5 5\") == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 1 1 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"10 10 10 10 20\") == \"2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_min_operations_to_zero", "entry_point": "min_operations_to_zero", "signature": "min_operations_to_zero() {\nlocal nums=($1)", "docstring": "\nCalculate the minimum number of operations to reduce all elements of an array to zero.\nEach operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the minimum number of operations required.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n", "instruction": "Write a Shell function `min_operations_to_zero() {\nlocal nums=($1)` to solve the following problem:\n\nCalculate the minimum number of operations to reduce all elements of an array to zero.\nEach operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the minimum number of operations required.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n", "level": "hard"}
{"task_id": "Shell/8", "prompt": "#!/bin/bash\n\n# Merge two sets of items and sum the weights of items with the same value.\n# Each item is represented as [value, weight].\n# The function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\n# Returns a sorted array of unique values and their cumulative weights.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })", "canonical_solution": "local -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}", "test": "test_merge_items() {\n[[ $(merge_items \"10 5;15 10\" \"15 15;20 20\") == \"10 5;15 25;20 20;\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(merge_items \"1 2;3 4\" \"5 6;7 8\") == \"1 2;3 4;5 6;7 8;\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(merge_items \"2 2;4 4\" \"2 3;4 5\") == \"2 5;4 9;\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(merge_items \"\" \"\") == \"\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(merge_items \"10 10\" \"10 10\") == \"10 20;\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(merge_items \"1 1;2 2;3 3\" \"4 4;5 5;6 6\") == \"1 1;2 2;3 3;4 4;5 5;6 6;\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(merge_items \"9 9;8 8\" \"7 7;6 6\") == \"6 6;7 7;8 8;9 9;\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_merge_items", "entry_point": "merge_items", "signature": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })", "docstring": "\nMerge two sets of items and sum the weights of items with the same value.\nEach item is represented as [value, weight].\nThe function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\nReturns a sorted array of unique values and their cumulative weights.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20\n", "instruction": "Write a Shell function `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` to solve the following problem:\n\nMerge two sets of items and sum the weights of items with the same value.\nEach item is represented as [value, weight].\nThe function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\nReturns a sorted array of unique values and their cumulative weights.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20\n", "level": "middle"}
{"task_id": "Shell/9", "prompt": "#!/bin/bash\n\n# Count the number of distinct arithmetic triplets in a strictly increasing integer array.\n# A triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\n# The function takes a string representing the array and an integer diff, with elements separated by spaces.\n# Returns the count of distinct arithmetic triplets.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2", "canonical_solution": "local count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}", "test": "test_count_arithmetic_triplets() {\n[[ $(count_arithmetic_triplets \"1 2 3 4 5\" 1) == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 3 5 7 9\" 2) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"2 4 6 8 10\" 2) == \"3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 4 7 10 13\" 3) == \"3\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 2 4 5 7\" 2) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 5 9 13 17\" 4) == \"3\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"10 20 30 40 50\" 10) == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_arithmetic_triplets", "entry_point": "count_arithmetic_triplets", "signature": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2", "docstring": "\nCount the number of distinct arithmetic triplets in a strictly increasing integer array.\nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\nThe function takes a string representing the array and an integer diff, with elements separated by spaces.\nReturns the count of distinct arithmetic triplets.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n", "instruction": "Write a Shell function `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` to solve the following problem:\n\nCount the number of distinct arithmetic triplets in a strictly increasing integer array.\nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\nThe function takes a string representing the array and an integer diff, with elements separated by spaces.\nReturns the count of distinct arithmetic triplets.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n", "level": "easy"}
{"task_id": "Shell/10", "prompt": "#!/bin/bash\n\n# Generate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\n# The function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\n# Returns the (n-2) x (n-2) matrix of maximum values.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"", "canonical_solution": "local -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}", "test": "# Testing function\ntest_generate_max_local() {\n[[ $(generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\") == \"11 12 15 16\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_max_local \"9 1 7;4 8 2;3 6 5\") == \"9\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_max_local \"1 2 3;4 5 6;7 8 9\") == \"9\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_max_local \"5 6 7;8 9 10;11 12 13\") == \"13\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_max_local \"10 20 30;40 50 60;70 80 90\") == \"90\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_max_local", "entry_point": "generate_max_local", "signature": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"", "docstring": "\nGenerate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\nThe function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\nReturns the (n-2) x (n-2) matrix of maximum values.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n", "instruction": "Write a Shell function `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` to solve the following problem:\n\nGenerate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\nThe function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\nReturns the (n-2) x (n-2) matrix of maximum values.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n", "level": "easy"}
{"task_id": "Shell/11", "prompt": "#!/bin/bash\n\n# Find the maximum amount of water that can be contained between two lines.\n# The function takes a string representing the array of line heights, with elements separated by spaces.\n# Returns the maximum water container capacity.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)", "canonical_solution": "local max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}", "test": "test_max_water_container() {\n[[ $(max_water_container \"1 8 6 2 5 4 8 3 7\") == \"49\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(max_water_container \"1 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(max_water_container \"4 3 2 1 4\") == \"16\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 1\") == \"2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(max_water_container \"2 3 4 5 18 17 6\") == \"17\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 4 3\") == \"4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(max_water_container \"3 9 3 4 7 2 12 6\") == \"45\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_max_water_container", "entry_point": "max_water_container", "signature": "max_water_container() {\nlocal -a heights=($1)", "docstring": "\nFind the maximum amount of water that can be contained between two lines.\nThe function takes a string representing the array of line heights, with elements separated by spaces.\nReturns the maximum water container capacity.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n", "instruction": "Write a Shell function `max_water_container() {\nlocal -a heights=($1)` to solve the following problem:\n\nFind the maximum amount of water that can be contained between two lines.\nThe function takes a string representing the array of line heights, with elements separated by spaces.\nReturns the maximum water container capacity.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n", "level": "middle"}
{"task_id": "Shell/12", "prompt": "#!/bin/bash\n\n# Find the next permutation of the array in lexicographic order.\n# If the array is in descending order, rearrange it to the first permutation (ascending order).\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the next permutation of the array.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)", "canonical_solution": "local i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}", "test": "test_next_permutation() {\n[[ $(next_permutation \"1 2 3\") == \"1 3 2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(next_permutation \"3 2 1\") == \"1 2 3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(next_permutation \"1 3 2\") == \"2 1 3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(next_permutation \"2 3 1\") == \"3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(next_permutation \"1 1 5\") == \"1 5 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(next_permutation \"2 1 3\") == \"2 3 1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(next_permutation \"5 4 3 2 1\") == \"1 2 3 4 5\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_next_permutation", "entry_point": "next_permutation", "signature": "next_permutation() {\nlocal -a nums=($1)", "docstring": "\nFind the next permutation of the array in lexicographic order.\nIf the array is in descending order, rearrange it to the first permutation (ascending order).\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the next permutation of the array.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n", "instruction": "Write a Shell function `next_permutation() {\nlocal -a nums=($1)` to solve the following problem:\n\nFind the next permutation of the array in lexicographic order.\nIf the array is in descending order, rearrange it to the first permutation (ascending order).\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the next permutation of the array.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n", "level": "hard"}
{"task_id": "Shell/13", "prompt": "#!/bin/bash\n\n# Perform modified binary search to find the target in a rotated sorted array.\n# The function takes a string representing the rotated array and an integer target.\n# Returns the index of the target if found, otherwise -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2", "canonical_solution": "local left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}", "test": "test_search_rotated_array() {\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 0) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 3) == \"-1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(search_rotated_array \"0 1 2 4 5 6 7\" 3) == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(search_rotated_array \"6 7 0 1 2 4 5\" 3) == \"-1\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(search_rotated_array \"7 0 1 2 4 5 6\" 0) == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(search_rotated_array \"1\" 0) == \"-1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(search_rotated_array \"1 3\" 3) == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_search_rotated_array", "entry_point": "search_rotated_array", "signature": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2", "docstring": "\nPerform modified binary search to find the target in a rotated sorted array.\nThe function takes a string representing the rotated array and an integer target.\nReturns the index of the target if found, otherwise -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1\n", "instruction": "Write a Shell function `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` to solve the following problem:\n\nPerform modified binary search to find the target in a rotated sorted array.\nThe function takes a string representing the rotated array and an integer target.\nReturns the index of the target if found, otherwise -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1\n", "level": "middle"}
{"task_id": "Shell/14", "prompt": "#!/bin/bash\n\n# Find the start and end positions of the target value in a non-decreasing array.\n# The function takes a string representing the array and an integer target.\n# Returns the start and end positions of the target, or [-1, -1] if not found.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2", "canonical_solution": "local n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}", "test": "test_find_target_positions() {\n[[ $(find_target_positions \"5 7 7 8 8 10\" 8) == \"3 4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_target_positions \"5 7 7 8 8 10\" 6) == \"-1 -1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 5) == \"4 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 1) == \"0 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_target_positions \"1 1 1 1 1\" 1) == \"0 4\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 3 3 4 5\" 3) == \"2 4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 2 3 4 5\" 2) == \"1 2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_target_positions", "entry_point": "find_target_positions", "signature": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2", "docstring": "\nFind the start and end positions of the target value in a non-decreasing array.\nThe function takes a string representing the array and an integer target.\nReturns the start and end positions of the target, or [-1, -1] if not found.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1\n", "instruction": "Write a Shell function `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` to solve the following problem:\n\nFind the start and end positions of the target value in a non-decreasing array.\nThe function takes a string representing the array and an integer target.\nReturns the start and end positions of the target, or [-1, -1] if not found.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1\n", "level": "hard"}
{"task_id": "Shell/15", "prompt": "#!/bin/bash\n\n# Validate a 9x9 Sudoku board.\n# The function takes a 9x9 Sudoku board as a string, where rows are separated by semicolons and elements by spaces.\n# Returns \"true\" if the Sudoku is valid, \"false\" otherwise.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"", "canonical_solution": "for i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}", "test": "# Testing function\ntest_is_valid_sudoku() {\nlocal validSudoku=\"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\nlocal invalidSudoku=\"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n\n[[ $(is_valid_sudoku \"$validSudoku\") == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_valid_sudoku \"$invalidSudoku\") == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_is_valid_sudoku", "entry_point": "is_valid_sudoku", "signature": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n", "docstring": "Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"", "instruction": "Write a Shell function `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` to solve the following problem:\nConvert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"", "level": "middle"}
{"task_id": "Shell/16", "prompt": "#!/bin/bash\n\n# Count the number of strings that appear exactly once in both arrays.\n# The function takes two strings representing the arrays, where elements are separated by spaces.\n# Returns the count of strings that appear exactly once in both arrays.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)", "canonical_solution": "local -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}", "test": "# Testing function\ntest_count_unique_strings() {\n[[ $(count_unique_strings \"apple banana mango\" \"banana fruits apple\") == \"2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_unique_strings \"hello world\" \"world hello planet\") == \"2\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two three\" \"four five six\") == \"0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two two\" \"two one one\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_unique_strings \"a b c d e\" \"a b c d e\") == \"5\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_unique_strings \"dog cat\" \"cat dog bird\") == \"2\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_unique_strings \"x y z\" \"x y z a b c\") == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_unique_strings", "entry_point": "count_unique_strings", "signature": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)", "docstring": "\nCount the number of strings that appear exactly once in both arrays.\nThe function takes two strings representing the arrays, where elements are separated by spaces.\nReturns the count of strings that appear exactly once in both arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n", "instruction": "Write a Shell function `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` to solve the following problem:\n\nCount the number of strings that appear exactly once in both arrays.\nThe function takes two strings representing the arrays, where elements are separated by spaces.\nReturns the count of strings that appear exactly once in both arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n", "level": "middle"}
{"task_id": "Shell/17", "prompt": "#!/bin/bash\n\n# Count the frequency of each word in frequency.txt\n# example\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {", "canonical_solution": "tr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}", "test": "# Test function for count_word_frequency\ntest_count_word_frequency() {\n# Create a sample frequency.txt file\necho -e \"apple banana apple\\nbanana banana apple\" > frequency.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"apple 3\\nbanana 3\")\n\n# Actual output from the function\nlocal actual_output=$(count_word_frequency)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm frequency.txt\n}\n\n# Call the test function\ntest_count_word_frequency", "entry_point": "count_word_frequency", "signature": "count_word_frequency() {", "docstring": "\nCount the frequency of each word in frequency.txt\nexample\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3\n\n", "instruction": "Write a Shell function `count_word_frequency() {` to solve the following problem:\n\nCount the frequency of each word in frequency.txt\nexample\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3\n\n", "level": "easy"}
{"task_id": "Shell/18", "prompt": "#!/bin/bash\n\n# Single-line script to output all valid phone numbers from file.txt\n# example\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {", "canonical_solution": "grep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}", "test": "test_find_valid_numbers() {\n# Create a sample file.txt file\necho -e \"123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"123-456-7890\\n(123) 456-7890\")\n\n# Actual output from the function\nlocal actual_output=$(find_valid_numbers)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_find_valid_numbers", "entry_point": "find_valid_numbers", "signature": "find_valid_numbers() {", "docstring": "\nSingle-line script to output all valid phone numbers from file.txt\nexample\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890\n", "instruction": "Write a Shell function `find_valid_numbers() {` to solve the following problem:\n\nSingle-line script to output all valid phone numbers from file.txt\nexample\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890\n", "level": "easy"}
{"task_id": "Shell/19", "prompt": "#!/bin/bash\n\n# Transpose the content of file.txt\n# example\n# input:1 2 3\\n4 5 6\\n7 8 9\n# output:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {", "canonical_solution": "awk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}", "test": "# Test function for transpose_file\ntest_transpose_file() {\n# Create a sample file.txt file\necho -e \"1 2 3\\n4 5 6\\n7 8 9\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"1 4 7\\n2 5 8\\n3 6 9\")\n\n# Actual output from the function\nlocal actual_output=$(transpose_file)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_transpose_file", "entry_point": "transpose_file", "signature": "transpose_file() {", "docstring": "\nTranspose the content of file.txt\nexample\ninput:1 2 3\\n4 5 6\\n7 8 9\noutput:1 4 7\\n2 5 8\\n3 6 9\n", "instruction": "Write a Shell function `transpose_file() {` to solve the following problem:\n\nTranspose the content of file.txt\nexample\ninput:1 2 3\\n4 5 6\\n7 8 9\noutput:1 4 7\\n2 5 8\\n3 6 9\n", "level": "easy"}
{"task_id": "Shell/20", "prompt": "#!/bin/bash\n\n# Extract the tenth line from file.txt\n# example\n# input: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# output:Line 10\nextract_tenth_line() {", "canonical_solution": "sed -n '10p' file.txt\n}", "test": "test_extract_tenth_line() {\n# Create a sample file.txt file\nfor i in {1..20}; do echo \"Line $i\"; done > file.txt\n\n# Expected output\nlocal expected_output=\"Line 10\"\n\n# Actual output from the function\nlocal actual_output=$(extract_tenth_line)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_extract_tenth_line", "entry_point": "extract_tenth_line", "signature": "extract_tenth_line() {", "docstring": "\nExtract the tenth line from file.txt\nexample\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\noutput:Line 10\n", "instruction": "Write a Shell function `extract_tenth_line() {` to solve the following problem:\n\nExtract the tenth line from file.txt\nexample\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\noutput:Line 10\n", "level": "easy"}
{"task_id": "Shell/21", "prompt": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4", "canonical_solution": "# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}", "test": "test_find_substring_index() {\n[[ $(find_substring_index \"hello\" \"ll\") -eq 2 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"e\") -eq -1 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_substring_index \"openai\" \"ai\") -eq 4 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_substring_index \"apple\" \"pp\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_substring_index \"banana\" \"na\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_substring_index \"teststring\" \"string\") -eq 4 ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"\") -eq 0 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_substring_index", "entry_point": "find_substring_index", "signature": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n", "docstring": "This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\nIt returns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', it returns -1.\nExample Usage:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4", "instruction": "Write a Shell function `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` to solve the following problem:\nThis function finds the first occurrence of the substring 'needle' in the string 'haystack'.\nIt returns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', it returns -1.\nExample Usage:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4", "level": "hard"}
{"task_id": "Shell/22", "prompt": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# This function simulates a sequence of toggling lights. Initially, all lights are off. \n# In each round, a person toggles the state of lights that are multiples of their number. \n# For example, the first person toggles all lights, the second person toggles every second light, and so on.\n# The function outputs the numbers of the lights that remain on after N rounds.\n# Example Usage:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9", "canonical_solution": "local lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}", "test": "test_toggle_lights() {\n[[ $(toggle_lights 5) == \"1 4 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(toggle_lights 6) == \"1 4 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(toggle_lights 10) == \"1 4 9 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(toggle_lights 3) == \"1 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(toggle_lights 7) == \"1 4 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_toggle_lights", "entry_point": "toggle_lights", "signature": "toggle_lights() {\nlocal n=$1\n", "docstring": "This function simulates a sequence of toggling lights. Initially, all lights are off. \nIn each round, a person toggles the state of lights that are multiples of their number. \nFor example, the first person toggles all lights, the second person toggles every second light, and so on.\nThe function outputs the numbers of the lights that remain on after N rounds.\nExample Usage:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9", "instruction": "Write a Shell function `toggle_lights() {\nlocal n=$1\n` to solve the following problem:\nThis function simulates a sequence of toggling lights. Initially, all lights are off. \nIn each round, a person toggles the state of lights that are multiples of their number. \nFor example, the first person toggles all lights, the second person toggles every second light, and so on.\nThe function outputs the numbers of the lights that remain on after N rounds.\nExample Usage:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9", "level": "easy"}
{"task_id": "Shell/23", "prompt": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# This function finds M positive integers that sum up to N and have the maximum possible product.\n# The function outputs the integers in a lexicographically smallest order.\n# If no such combination exists, it outputs an error message.\n# Example Usage:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4", "canonical_solution": "if (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}", "test": "test_maximize_product() {\n[[ $(maximize_product 6 3) == \"2 2 2 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(maximize_product 8 3) == \"2 3 3 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(maximize_product 10 2) == \"5 5 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(maximize_product 20 5) == \"4 4 4 4 4 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(maximize_product 7 3) == \"2 2 3 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(maximize_product 12 4) == \"3 3 3 3 \" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(maximize_product 5 6) == \"Error: Cannot divide 5 into 6 parts\" ]] && { echo \"Test 7 passed\"; } || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_maximize_product", "entry_point": "maximize_product", "signature": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n", "docstring": "This function finds M positive integers that sum up to N and have the maximum possible product.\nThe function outputs the integers in a lexicographically smallest order.\nIf no such combination exists, it outputs an error message.\nExample Usage:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4", "instruction": "Write a Shell function `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` to solve the following problem:\nThis function finds M positive integers that sum up to N and have the maximum possible product.\nThe function outputs the integers in a lexicographically smallest order.\nIf no such combination exists, it outputs an error message.\nExample Usage:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4", "level": "middle"}
{"task_id": "Shell/24", "prompt": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\n# It outputs the sine value in reduced fraction format.\n# The Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\n# The function assumes that the input numbers form a valid Pythagorean triplet.\n# Example Usage:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17", "canonical_solution": "local -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}", "test": "test_calculate_sine() {\n[[ $(calculate_sine 3 5 4) == \"3/5\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_sine 5 12 13) == \"5/13\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_sine 8 15 17) == \"8/17\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_sine 7 24 25) == \"7/25\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_sine 9 40 41) == \"9/41\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_sine", "entry_point": "calculate_sine", "signature": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n", "docstring": "This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\nIt outputs the sine value in reduced fraction format.\nThe Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\nThe function assumes that the input numbers form a valid Pythagorean triplet.\nExample Usage:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17", "instruction": "Write a Shell function `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` to solve the following problem:\nThis function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\nIt outputs the sine value in reduced fraction format.\nThe Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\nThe function assumes that the input numbers form a valid Pythagorean triplet.\nExample Usage:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17", "level": "hard"}
{"task_id": "Shell/25", "prompt": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# This function calculates the minimum cost needed to buy at least 'n' pencils,\n# where pencils are available in three different packaging options, each with its own quantity and price.\n# The function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\n# Each packaging option is given in the format 'quantity price'.\n# Input: Number of pencils needed and three packaging options.\n# Output: Minimum cost to buy at least 'n' pencils.\n# Example Usage:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18", "canonical_solution": "local min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}", "test": "test_calculate_minimum_cost() {\n[[ $(calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\") -eq 54 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\") -eq 40 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\") -eq 27 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 80 \"8 4\" \"40 19\" \"60 28\") -eq 38 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 120 \"12 6\" \"24 9\" \"48 18\") -eq 45 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_minimum_cost", "entry_point": "calculate_minimum_cost", "signature": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n", "docstring": "This function calculates the minimum cost needed to buy at least 'n' pencils,\nwhere pencils are available in three different packaging options, each with its own quantity and price.\nThe function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\nEach packaging option is given in the format 'quantity price'.\nInput: Number of pencils needed and three packaging options.\nOutput: Minimum cost to buy at least 'n' pencils.\nExample Usage:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18", "instruction": "Write a Shell function `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` to solve the following problem:\nThis function calculates the minimum cost needed to buy at least 'n' pencils,\nwhere pencils are available in three different packaging options, each with its own quantity and price.\nThe function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\nEach packaging option is given in the format 'quantity price'.\nInput: Number of pencils needed and three packaging options.\nOutput: Minimum cost to buy at least 'n' pencils.\nExample Usage:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18", "level": "middle"}
{"task_id": "Shell/26", "prompt": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\n# The shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\n# Input: Shift amount 'n' and the original string.\n# Output: Transformed string representing the password.\n# Example Usage:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab", "canonical_solution": "local shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}", "test": "test_generate_password() {\n[[ $(generate_password 1 \"qwe\") == \"rxf\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_password 3 \"abc\") == \"def\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_password 2 \"xyz\") == \"zab\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_password 4 \"hello\") == \"lipps\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_password 5 \"password\") == \"ufxxbtwi\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_password", "entry_point": "generate_password", "signature": "generate_password() {\nlocal shift=$1\nlocal string=$2\n", "docstring": "This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\nThe shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\nInput: Shift amount 'n' and the original string.\nOutput: Transformed string representing the password.\nExample Usage:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab", "instruction": "Write a Shell function `generate_password() {\nlocal shift=$1\nlocal string=$2\n` to solve the following problem:\nThis function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\nThe shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\nInput: Shift amount 'n' and the original string.\nOutput: Transformed string representing the password.\nExample Usage:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab", "level": "middle"}
{"task_id": "Shell/27", "prompt": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# generate shell function\n# This function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\n# Input: Upper limit of the range 'n' and the digit 'x' to be counted.\n# Output: Number of occurrences of the digit 'x'.\n# Example Usage:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20", "canonical_solution": "local count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}", "test": "test_count_digit_occurrences() {\n[[ $(count_digit_occurrences 11 1) -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_digit_occurrences 20 2) -eq 3 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_digit_occurrences 100 3) -eq 20 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_digit_occurrences 50 4) -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_digit_occurrences 99 5) -eq 20 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_count_digit_occurrences", "entry_point": "count_digit_occurrences", "signature": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n", "docstring": "generate shell function\nThis function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\nInput: Upper limit of the range 'n' and the digit 'x' to be counted.\nOutput: Number of occurrences of the digit 'x'.\nExample Usage:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20", "instruction": "Write a Shell function `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` to solve the following problem:\ngenerate shell function\nThis function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\nInput: Upper limit of the range 'n' and the digit 'x' to be counted.\nOutput: Number of occurrences of the digit 'x'.\nExample Usage:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20", "level": "easy"}
{"task_id": "Shell/28", "prompt": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# This function converts a number 'N' from base 'M' to its decimal representation as an expression.\n# It outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\n# Coefficients that are zero are omitted in the output.\n# Input: Base 'M' and number 'N' in base 'M'.\n# Output: Decimal representation as an expression.\n# Example Usage:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0", "canonical_solution": "local length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}", "test": "test_convert_to_decimal_expression() {\n[[ $(convert_to_decimal_expression 2 10101) == \"1*2^4+1*2^2+1*2^0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 3 102) == \"1*3^2+2*3^0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 5 143) == \"1*5^2+4*5^1+3*5^0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 8 123) == \"1*8^2+2*8^1+3*8^0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 4 1302) == \"1*4^3+3*4^2+2*4^0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_convert_to_decimal_expression", "entry_point": "convert_to_decimal_expression", "signature": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n", "docstring": "This function converts a number 'N' from base 'M' to its decimal representation as an expression.\nIt outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\nCoefficients that are zero are omitted in the output.\nInput: Base 'M' and number 'N' in base 'M'.\nOutput: Decimal representation as an expression.\nExample Usage:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0", "instruction": "Write a Shell function `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` to solve the following problem:\nThis function converts a number 'N' from base 'M' to its decimal representation as an expression.\nIt outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\nCoefficients that are zero are omitted in the output.\nInput: Base 'M' and number 'N' in base 'M'.\nOutput: Decimal representation as an expression.\nExample Usage:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0", "level": "easy"}
{"task_id": "Shell/29", "prompt": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\n# If it's not possible to form such a number, the function returns -1.\n# Input: A string of numbers (only 0s and 5s) representing the cards.\n# Output: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\n# Example Usage:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1", "canonical_solution": "local count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}", "test": "test_arrange_cards_for_max_number() {\n[[ $(arrange_cards_for_max_number \"5 0 5 0\") == \"0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\") == \"5555555550\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5\") == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 5 0\") == \"5555555550\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_arrange_cards_for_max_number", "entry_point": "arrange_cards_for_max_number", "signature": "arrange_cards_for_max_number() {\nlocal cards=($1)\n", "docstring": "This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\nIf it's not possible to form such a number, the function returns -1.\nInput: A string of numbers (only 0s and 5s) representing the cards.\nOutput: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\nExample Usage:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1", "instruction": "Write a Shell function `arrange_cards_for_max_number() {\nlocal cards=($1)\n` to solve the following problem:\nThis function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\nIf it's not possible to form such a number, the function returns -1.\nInput: A string of numbers (only 0s and 5s) representing the cards.\nOutput: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\nExample Usage:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1", "level": "hard"}
{"task_id": "Shell/30", "prompt": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\n# Input: The number of elements 'N' and the permutation 'X' as a string.\n# Output: The lexicographical rank of the permutation.\n# The permutation is considered as a sequence of digits without spaces.\n# Example Usage:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8", "canonical_solution": "local rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}", "test": "test_calculate_lexicographical_rank() {\n[[ $(calculate_lexicographical_rank 3 \"231\") -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"2143\") -eq 8 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 5 \"31245\") -eq 49 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 3 \"123\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"4321\") -eq 24 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_lexicographical_rank", "entry_point": "calculate_lexicographical_rank", "signature": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n", "docstring": "This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\nInput: The number of elements 'N' and the permutation 'X' as a string.\nOutput: The lexicographical rank of the permutation.\nThe permutation is considered as a sequence of digits without spaces.\nExample Usage:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8", "instruction": "Write a Shell function `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` to solve the following problem:\nThis function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\nInput: The number of elements 'N' and the permutation 'X' as a string.\nOutput: The lexicographical rank of the permutation.\nThe permutation is considered as a sequence of digits without spaces.\nExample Usage:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8", "level": "middle"}
{"task_id": "Shell/31", "prompt": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\n# Input: A string of integers representing the sequence.\n# Output: The maximum sum of a continuous non-empty subsequence.\n# Example Usage:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11", "canonical_solution": "local max_so_far=0\n    local max_ending_here=0\n\n    for num in \"${sequence[@]}\"; do\n        max_ending_here=$((max_ending_here + num))\n        if (( max_ending_here < 0 )); then\n            max_ending_here=0\n        elif (( max_so_far < max_ending_here )); then\n            max_so_far=$max_ending_here\n        fi\n    done\n\n    if (( max_so_far == 0 )); then\n        max_so_far=${sequence[0]}\n        for num in \"${sequence[@]}\"; do\n            if (( num > max_so_far )); then\n                max_so_far=$num\n            fi\n        done\n    fi\n\n    echo $max_so_far\n}", "test": "test_calculate_max_subsequence_sum() {\n    [[ $(calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\") -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"-1 -2 -3 -4\") -eq -1 ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\") -eq 11 ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"1 2 3 4 5 6\") -eq 21 ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"-1 -2 -3 -4 -5 -6\") -eq -1 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_max_subsequence_sum", "entry_point": "calculate_max_subsequence_sum", "signature": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n", "docstring": "This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\nInput: A string of integers representing the sequence.\nOutput: The maximum sum of a continuous non-empty subsequence.\nExample Usage:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11", "instruction": "Write a Shell function `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` to solve the following problem:\nThis function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\nInput: A string of integers representing the sequence.\nOutput: The maximum sum of a continuous non-empty subsequence.\nExample Usage:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11", "level": "easy"}
{"task_id": "Shell/32", "prompt": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# This function calculates the minimum number of bridge rotations required to sort train carriages.\n# The bridge can hold two carriages at a time and rotate 180 degrees to swap them.\n# Input: Number of carriages 'N' and a string representing the initial order of carriages.\n# Output: The minimum number of bridge rotations needed to sort the carriages in ascending order.\n# Example Usage:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2", "canonical_solution": "local count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}", "test": "test_calculate_min_bridge_rotations() {\n[[ $(calculate_min_bridge_rotations 4 \"4 3 2 1\") -eq 6 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 5 \"5 4 3 2 1\") -eq 10 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 3 \"3 1 2\") -eq 2 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 6 \"6 5 4 3 2 1\") -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n}\n\ntest_calculate_min_bridge_rotations", "entry_point": "calculate_min_bridge_rotations", "signature": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n", "docstring": "This function calculates the minimum number of bridge rotations required to sort train carriages.\nThe bridge can hold two carriages at a time and rotate 180 degrees to swap them.\nInput: Number of carriages 'N' and a string representing the initial order of carriages.\nOutput: The minimum number of bridge rotations needed to sort the carriages in ascending order.\nExample Usage:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2", "instruction": "Write a Shell function `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` to solve the following problem:\nThis function calculates the minimum number of bridge rotations required to sort train carriages.\nThe bridge can hold two carriages at a time and rotate 180 degrees to swap them.\nInput: Number of carriages 'N' and a string representing the initial order of carriages.\nOutput: The minimum number of bridge rotations needed to sort the carriages in ascending order.\nExample Usage:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2", "level": "easy"}
{"task_id": "Shell/33", "prompt": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# This function checks if the given word is a \"Lucky Word\".\n# A word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\n# Input: A single word consisting of lowercase letters and with a length less than 100.\n# Output: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\n# Example Usage:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0", "canonical_solution": "local max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}", "test": "test_is_lucky_word() {\nlocal result\nresult=$(is_lucky_word \"error\")\n[[ $result == $'Lucky Word\\n2' ]] || { echo \"Test 1 failed\"; exit 1; }\nresult=$(is_lucky_word \"olympic\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 2 failed\"; exit 1; }\nresult=$(is_lucky_word \"apple\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_is_lucky_word", "entry_point": "is_lucky_word", "signature": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n", "docstring": "This function checks if the given word is a \"Lucky Word\".\nA word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\nInput: A single word consisting of lowercase letters and with a length less than 100.\nOutput: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\nExample Usage:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0", "instruction": "Write a Shell function `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` to solve the following problem:\nThis function checks if the given word is a \"Lucky Word\".\nA word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\nInput: A single word consisting of lowercase letters and with a length less than 100.\nOutput: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\nExample Usage:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0", "level": "hard"}
{"task_id": "Shell/34", "prompt": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# This function finds the kth smallest unique number from a list of positive integers. \n# Duplicate numbers are only counted once. If k is greater than the number of unique elements, \n# it returns 'NO RESULT'.\n# Args:\n# $1: A string of space-separated positive integers.\n# $2: An integer representing the value of k.\n# Returns:\n# The kth smallest unique number or 'NO RESULT' if k is too large.\n# Example:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Returns: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Returns: NO RESULT", "canonical_solution": "local sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}", "test": "test_kth_smallest_unique_number() {\n[[ $(find_kth_smallest_unique_number \"5 1 3 5 2 4 1\" 4) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"8 7 6 5 4 3 2 1\" 3) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"9 9 8 8 7 7\" 2) == \"8\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"10 20 30 40 50\" 5) == \"50\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"15 15 15 15 15\" 1) == \"15\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"1 2 3 4 5\" 6) == \"NO RESULT\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"3 3 3 3 3\" 2) == \"NO RESULT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_kth_smallest_unique_number", "entry_point": "find_kth_smallest_unique_number", "signature": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n", "docstring": "This function finds the kth smallest unique number from a list of positive integers. \nDuplicate numbers are only counted once. If k is greater than the number of unique elements, \nit returns 'NO RESULT'.\nArgs:\n$1: A string of space-separated positive integers.\n$2: An integer representing the value of k.\nReturns:\nThe kth smallest unique number or 'NO RESULT' if k is too large.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT", "instruction": "Write a Shell function `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` to solve the following problem:\nThis function finds the kth smallest unique number from a list of positive integers. \nDuplicate numbers are only counted once. If k is greater than the number of unique elements, \nit returns 'NO RESULT'.\nArgs:\n$1: A string of space-separated positive integers.\n$2: An integer representing the value of k.\nReturns:\nThe kth smallest unique number or 'NO RESULT' if k is too large.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT", "level": "easy"}
{"task_id": "Shell/35", "prompt": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# This function converts a number from one base to another.\n# The function accepts three arguments: the base of the input number (2 to 16),\n# the number to be converted (in string format), and the base to which it should be converted (2 to 16).\n# The function returns the converted number in string format.\n# The input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\n# If the input number or the base is invalid, the function returns 'INVALID INPUT'.\n# Examples:\n# convert_bases 10 \"255\" 2\n# # Returns: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Returns: \"A\"\n# convert_bases 8 \"17\" 10\n# # Returns: \"15\"", "canonical_solution": "if [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}", "test": "test_convert_bases() {\n[[ $(convert_bases 10 \"1024\" 2) == \"10000000000\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_bases 16 \"1A3\" 8) == \"643\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_bases 2 \"1101\" 10) == \"13\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_bases 16 \"ABC\" 2) == \"101010111100\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_bases 8 \"777\" 16) == \"1FF\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(convert_bases 4 \"123\" 10) == \"27\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(convert_bases 20 \"1A\" 2) == \"INVALID INPUT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_convert_bases", "entry_point": "convert_bases", "signature": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n", "docstring": "This function converts a number from one base to another.\nThe function accepts three arguments: the base of the input number (2 to 16),\nthe number to be converted (in string format), and the base to which it should be converted (2 to 16).\nThe function returns the converted number in string format.\nThe input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\nIf the input number or the base is invalid, the function returns 'INVALID INPUT'.\nExamples:\nconvert_bases 10 \"255\" 2\nReturns: \"11111111\"\nconvert_bases 2 \"1010\" 16\nReturns: \"A\"\nconvert_bases 8 \"17\" 10\nReturns: \"15\"", "instruction": "Write a Shell function `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` to solve the following problem:\nThis function converts a number from one base to another.\nThe function accepts three arguments: the base of the input number (2 to 16),\nthe number to be converted (in string format), and the base to which it should be converted (2 to 16).\nThe function returns the converted number in string format.\nThe input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\nIf the input number or the base is invalid, the function returns 'INVALID INPUT'.\nExamples:\nconvert_bases 10 \"255\" 2\nReturns: \"11111111\"\nconvert_bases 2 \"1010\" 16\nReturns: \"A\"\nconvert_bases 8 \"17\" 10\nReturns: \"15\"", "level": "easy"}
{"task_id": "Shell/36", "prompt": "find_sum_segments() {\nlocal M=$1\n# This function identifies all the continuous segments of positive integers that sum to a given integer M.\n# Each segment must contain at least two consecutive numbers.\n# Args:\n# $1: A positive integer M, the target sum (10 <= M <= 2,000,000).\n# Returns:\n# The output consists of several lines, each containing two positive integers separated by a space.\n# These integers represent the first and last numbers in a continuous segment that sums to M.\n# The lines are sorted in ascending order based on the starting number of each segment.\n# Example:\n# find_sum_segments 21\n# # Returns:\n# # 6 8\n# # 10 11", "canonical_solution": "local start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}", "test": "test_find_sum_segments() {\nlocal result=$(find_sum_segments 10000)\nlocal expected=\"18 142\n297 328\n388 412\n1998 2002\"\n[[ $result == \"$expected\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(find_sum_segments 100)\nexpected=\"9 16\n18 22\"\n[[ $result == \"$expected\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_find_sum_segments", "entry_point": "find_sum_segments", "signature": "find_sum_segments() {\nlocal M=$1\n", "docstring": "This function identifies all the continuous segments of positive integers that sum to a given integer M.\nEach segment must contain at least two consecutive numbers.\nArgs:\n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).\nReturns:\nThe output consists of several lines, each containing two positive integers separated by a space.\nThese integers represent the first and last numbers in a continuous segment that sums to M.\nThe lines are sorted in ascending order based on the starting number of each segment.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11", "instruction": "Write a Shell function `find_sum_segments() {\nlocal M=$1\n` to solve the following problem:\nThis function identifies all the continuous segments of positive integers that sum to a given integer M.\nEach segment must contain at least two consecutive numbers.\nArgs:\n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).\nReturns:\nThe output consists of several lines, each containing two positive integers separated by a space.\nThese integers represent the first and last numbers in a continuous segment that sums to M.\nThe lines are sorted in ascending order based on the starting number of each segment.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11", "level": "easy"}
{"task_id": "Shell/37", "prompt": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\n# Example Cases:\n\n# count_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).", "canonical_solution": "local dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}", "test": "test_meal_combinations() {\n[[ $(count_meal_combinations 3 5 \"1 2 3\") -eq 1 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 6 \"1 2 3 1\") -eq 2 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_meal_combinations 5 10 \"2 2 2 2 2\") -eq 1 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_meal_combinations 3 3 \"1 1 1\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 8 \"1 2 3 5\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_meal_combinations", "entry_point": "count_meal_combinations", "signature": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n", "docstring": "This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\nExample Cases:\n\ncount_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).", "instruction": "Write a Shell function `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` to solve the following problem:\nThis function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\nExample Cases:\n\ncount_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).", "level": "easy"}
{"task_id": "Shell/38", "prompt": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# This function finds the previous lexicographical permutation of a given sequence.\n# If the current permutation is the first one in lexicographical order, it returns 'ERROR'.\n# The function takes the number of elements and the current permutation as arguments.\n# Example usage:\n# previous_permutation 3 \"1 2 3\"\n# This would return 'ERROR', as '1 2 3' is the first permutation.\n\n# previous_permutation 4 \"1 3 4 2\"\n# This would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n", "canonical_solution": "for (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}", "test": "test_previous_permutation() {\n[[ $(previous_permutation 3 \"1 3 2\") == \"1 2 3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(previous_permutation 3 \"1 2 3\") == \"ERROR\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"2 1 4 3\") == \"2 1 3 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(previous_permutation 5 \"5 4 3 2 1\") == \"5 4 3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"1 4 3 2\") == \"1 4 2 3\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_previous_permutation", "entry_point": "previous_permutation", "signature": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n", "docstring": "This function finds the previous lexicographical permutation of a given sequence.\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nThe function takes the number of elements and the current permutation as arguments.\nExample usage:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n", "instruction": "Write a Shell function `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` to solve the following problem:\nThis function finds the previous lexicographical permutation of a given sequence.\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nThe function takes the number of elements and the current permutation as arguments.\nExample usage:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n", "level": "hard"}
{"task_id": "Shell/39", "prompt": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# This function checks the number of matches each lottery ticket has with the winning numbers\n# and categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\n# The function takes the winning numbers and the lottery tickets as arguments.\n# Example usage:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# This would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# This would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.", "canonical_solution": "shift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}", "test": "test_check_lottery_winnings() {\nlocal result\nresult=$(check_lottery_winnings \"23 31 1 14 19 17 18\" \"12 8 9 23 1 16 7\" \"11 7 10 21 2 9 31\")\n[[ $result == \"0 0 0 0 0 1 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"5 6 7 8 9 10 11\" \"1 2 3 4 5 6 7\" \"5 6 7 12 13 14 15\")\n[[ $result == \"0 0 0 0 2 0 0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"15 16 17 18 19 20 21\" \"22 23 24 25 26 27 28\" \"29 30 31 32 33 1 2\")\n[[ $result == \"0 0 0 0 0 0 0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_check_lottery_winnings", "entry_point": "check_lottery_winnings", "signature": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n", "docstring": "This function checks the number of matches each lottery ticket has with the winning numbers\nand categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\nThe function takes the winning numbers and the lottery tickets as arguments.\nExample usage:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nThis would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nThis would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.", "instruction": "Write a Shell function `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` to solve the following problem:\nThis function checks the number of matches each lottery ticket has with the winning numbers\nand categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\nThe function takes the winning numbers and the lottery tickets as arguments.\nExample usage:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nThis would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nThis would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.", "level": "easy"}
{"task_id": "Shell/40", "prompt": "calculate_max_pens() {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}", "test": "test_calculate_max_pens() {\n    local result\n\n    result=$(calculate_max_pens 5 5)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 1 failed: Expected 2, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 20 1)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 2 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 3 8)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 11 0)\n    [[ \"$result\" -eq 5 ]] || { echo \"Test 4 failed: Expected 5, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 100 5)\n    [[ \"$result\" -eq 52 ]] || { echo \"Test 5 failed: Expected 52, got $result\"; exit 1; }\n}\n\ntest_calculate_max_pens", "entry_point": "calculate_max_pens", "signature": "calculate_max_pens() {", "docstring": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Write a Shell function `calculate_max_pens() {` to solve the following problem: This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "level": "easy"}
{"task_id": "Shell/41", "prompt": "calculate_expression() {\n    # Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n    # Args:\n    #     a (int): The first integer.\n    #     b (int): The second integer.\n    #     c (int): The third integer.\n    #\n    # Returns:\n    #     The result of the expression (a+b)*c.\n    #\n    # Examples:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3", "canonical_solution": "    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}", "test": "test_calculate_expression() {\n    local result\n\n    result=$(calculate_expression 1 2 3)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_expression -1 2 -3)\n    [[ \"$result\" -eq -3 ]] || { echo \"Test 2 failed: Expected -3, got $result\"; exit 1; }\n\n    result=$(calculate_expression 0 0 1)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 3 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(calculate_expression 10 -5 2)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 4 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_expression 100 200 -1)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 5 failed: Expected -300, got $result\"; exit 1; }\n}\n\ntest_calculate_expression", "entry_point": "calculate_expression", "signature": "calculate_expression() {", "docstring": " Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n Args:\n a (int): The first integer.\n b (int): The second integer.\n c (int): The third integer.\n\n Returns:\n The result of the expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3", "instruction": "Write a Shell function `calculate_expression() {` to solve the following problem: Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n Args:\n a (int): The first integer.\n b (int): The second integer.\n c (int): The third integer.\n\n Returns:\n The result of the expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3", "level": "easy"}
{"task_id": "Shell/42", "prompt": "print_ascii_code() {\n    # Prints the ASCII code of a given visible character (excluding space).\n    # Args:\n    #     char (string): A single character for which the ASCII code will be printed.\n    #\n    # Output:\n    #     Prints the ASCII code of the given character.\n    #\n    # Examples:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122", "canonical_solution": "    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}", "test": "test_print_ascii_code() {\n    local result\n\n    result=$(print_ascii_code 'B')\n    [[ \"$result\" -eq 66 ]] || { echo \"Test 1 failed: Expected 66, got $result\"; exit 1; }\n\n    result=$(print_ascii_code 'z')\n    [[ \"$result\" -eq 122 ]] || { echo \"Test 2 failed: Expected 122, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '1')\n    [[ \"$result\" -eq 49 ]] || { echo \"Test 3 failed: Expected 49, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '%')\n    [[ \"$result\" -eq 37 ]] || { echo \"Test 4 failed: Expected 37, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '?')\n    [[ \"$result\" -eq 63 ]] || { echo \"Test 5 failed: Expected 63, got $result\"; exit 1; }\n}\n\ntest_print_ascii_code", "entry_point": "print_ascii_code", "signature": "print_ascii_code() {", "docstring": " Prints the ASCII code of a given visible character (excluding space).\n Args:\n char (string): A single character for which the ASCII code will be printed.\n\n Output:\n Prints the ASCII code of the given character.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122", "instruction": "Write a Shell function `print_ascii_code() {` to solve the following problem: Prints the ASCII code of a given visible character (excluding space).\n Args:\n char (string): A single character for which the ASCII code will be printed.\n\n Output:\n Prints the ASCII code of the given character.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122", "level": "easy"}
{"task_id": "Shell/43", "prompt": "ascii_to_char() {\n    # Converts an ASCII code to its corresponding character.\n    # Args:\n    #     ascii_code (int): The ASCII code to be converted.\n    #\n    # Output:\n    #     Prints the character corresponding to the given ASCII code.\n    #\n    # Examples:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a", "canonical_solution": "    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}", "test": "test_ascii_to_char() {\n    local result\n\n    result=$(ascii_to_char 66)\n    [[ \"$result\" == \"B\" ]] || { echo \"Test 1 failed: Expected B, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 97)\n    [[ \"$result\" == \"a\" ]] || { echo \"Test 2 failed: Expected a, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 36)\n    [[ \"$result\" == \"$\" ]] || { echo \"Test 3 failed: Expected $, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 57)\n    [[ \"$result\" == \"9\" ]] || { echo \"Test 4 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 32)\n    [[ \"$result\" == \" \" ]] || { echo \"Test 5 failed: Expected space, got $result\"; exit 1; }\n}\n\ntest_ascii_to_char", "entry_point": "ascii_to_char", "signature": "ascii_to_char() {", "docstring": " Converts an ASCII code to its corresponding character.\n Args:\n ascii_code (int): The ASCII code to be converted.\n\n Output:\n Prints the character corresponding to the given ASCII code.\n\n Examples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a", "instruction": "Write a Shell function `ascii_to_char() {` to solve the following problem: Converts an ASCII code to its corresponding character.\n Args:\n ascii_code (int): The ASCII code to be converted.\n\n Output:\n Prints the character corresponding to the given ASCII code.\n\n Examples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a", "level": "easy"}
{"task_id": "Shell/44", "prompt": "int_to_bool_to_int() {\n    # Converts an integer to a boolean value, then converts this boolean back to an integer.\n    # The process involves assigning an integer value to a boolean variable and then\n    # assigning this boolean value back to an integer variable.\n    # Args:\n    #     initial_int (int): The initial integer value.\n    #\n    # Output:\n    #     Prints the integer value obtained after conversion from integer to boolean and back to integer.\n    #\n    # Examples:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1", "canonical_solution": "    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}", "test": "test_int_to_bool_to_int() {\n    local result\n\n    result=$(int_to_bool_to_int 0)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 1 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -5)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 2 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 10)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 4 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 5 failed: Expected 1, got $result\"; exit 1; }\n}\n\ntest_int_to_bool_to_int", "entry_point": "int_to_bool_to_int", "signature": "int_to_bool_to_int() {", "docstring": " Converts an integer to a boolean value, then converts this boolean back to an integer.\n The process involves assigning an integer value to a boolean variable and then\n assigning this boolean value back to an integer variable.\n Args:\n initial_int (int): The initial integer value.\n\n Output:\n Prints the integer value obtained after conversion from integer to boolean and back to integer.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1", "instruction": "Write a Shell function `int_to_bool_to_int() {` to solve the following problem: Converts an integer to a boolean value, then converts this boolean back to an integer.\n The process involves assigning an integer value to a boolean variable and then\n assigning this boolean value back to an integer variable.\n Args:\n initial_int (int): The initial integer value.\n\n Output:\n Prints the integer value obtained after conversion from integer to boolean and back to integer.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1", "level": "easy"}
{"task_id": "Shell/45", "prompt": "reverse_number() {\n    # Reverses a three-digit number.\n    # This function takes a three-digit number as input and prints its reverse.\n    # The output maintains leading zeros if present.\n    # Args:\n    #     number (int): A three-digit number to be reversed.\n    #\n    # Output:\n    #     Prints the reversed number, maintaining any leading zeros.\n    #\n    # Examples:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040", "canonical_solution": "    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}", "test": "test_reverse_number() {\n    local result\n\n    result=$(reverse_number 123)\n    [[ \"$result\" == \"321\" ]] || { echo \"Test 1 failed: Expected 321, got $result\"; exit 1; }\n\n    result=$(reverse_number 040)\n    [[ \"$result\" == \"040\" ]] || { echo \"Test 2 failed: Expected 040, got $result\"; exit 1; }\n\n    result=$(reverse_number 500)\n    [[ \"$result\" == \"005\" ]] || { echo \"Test 3 failed: Expected 005, got $result\"; exit 1; }\n\n    result=$(reverse_number 999)\n    [[ \"$result\" == \"999\" ]] || { echo \"Test 4 failed: Expected 999, got $result\"; exit 1; }\n\n    result=$(reverse_number 100)\n    [[ \"$result\" == \"001\" ]] || { echo \"Test 5 failed: Expected 001, got $result\"; exit 1; }\n}\n\ntest_reverse_number", "entry_point": "reverse_number", "signature": "reverse_number() {", "docstring": " Reverses a three-digit number.\n This function takes a three-digit number as input and prints its reverse.\n The output maintains leading zeros if present.\n Args:\n number (int): A three-digit number to be reversed.\n\n Output:\n Prints the reversed number, maintaining any leading zeros.\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040", "instruction": "Write a Shell function `reverse_number() {` to solve the following problem: Reverses a three-digit number.\n This function takes a three-digit number as input and prints its reverse.\n The output maintains leading zeros if present.\n Args:\n number (int): A three-digit number to be reversed.\n\n Output:\n Prints the reversed number, maintaining any leading zeros.\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040", "level": "easy"}
{"task_id": "Shell/46", "prompt": "calculate_nth_term() {\n    # Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n    # The difference between any two consecutive terms is constant.\n    # Args:\n    #     a1 (int): The first term of the arithmetic sequence.\n    #     a2 (int): The second term of the arithmetic sequence.\n    #     n (int): The term number to calculate.\n    #\n    # Output:\n    #     Prints the value of the nth term in the arithmetic sequence.\n    #\n    # Examples:\n    # >>> calculate_nth_term 1 3 5\n    # 9", "canonical_solution": "    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}", "test": "test_calculate_nth_term() {\n    local result\n\n    result=$(calculate_nth_term 1 3 5)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 2 5 10)\n    [[ \"$result\" -eq 29 ]] || { echo \"Test 2 failed: Expected 20, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term -1 1 50)\n    [[ \"$result\" -eq 97 ]] || { echo \"Test 3 failed: Expected 97, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 100 -100 3)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 4 failed: Expected -300, got $result\"; exit 1; }\n\n}\n\ntest_calculate_nth_term", "entry_point": "calculate_nth_term", "signature": "calculate_nth_term() {", "docstring": " Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n The difference between any two consecutive terms is constant.\n Args:\n a1 (int): The first term of the arithmetic sequence.\n a2 (int): The second term of the arithmetic sequence.\n n (int): The term number to calculate.\n\n Output:\n Prints the value of the nth term in the arithmetic sequence.\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9", "instruction": "Write a Shell function `calculate_nth_term() {` to solve the following problem: Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n The difference between any two consecutive terms is constant.\n Args:\n a1 (int): The first term of the arithmetic sequence.\n a2 (int): The second term of the arithmetic sequence.\n n (int): The term number to calculate.\n\n Output:\n Prints the value of the nth term in the arithmetic sequence.\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9", "level": "easy"}
{"task_id": "Shell/47", "prompt": "multiply_numbers() {\n    # Calculates the product of two positive integers A and B.\n    # Given two positive integers, this function computes their product.\n    # It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n    # Args:\n    #     A (int): The first positive integer.\n    #     B (int): The second positive integer.\n    #\n    # Output:\n    #     Prints the product of A and B.\n    #\n    # Examples:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088", "canonical_solution": "    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}", "test": "test_multiply_numbers() {\n    local result\n\n    result=$(multiply_numbers 5 10)\n    [[ \"$result\" -eq 50 ]] || { echo \"Test 1 failed: Expected 50, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 123 456)\n    [[ \"$result\" -eq 56088 ]] || { echo \"Test 2 failed: Expected 56088, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 1 50000)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 3 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 250 200)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 4 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 500 100)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 5 failed: Expected 50000, got $result\"; exit 1; }\n}\n\ntest_multiply_numbers", "entry_point": "multiply_numbers", "signature": "multiply_numbers() {", "docstring": " Calculates the product of two positive integers A and B.\n Given two positive integers, this function computes their product.\n It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n Args:\n A (int): The first positive integer.\n B (int): The second positive integer.\n\n Output:\n Prints the product of A and B.\n\n Examples:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088", "instruction": "Write a Shell function `multiply_numbers() {` to solve the following problem: Calculates the product of two positive integers A and B.\n Given two positive integers, this function computes their product.\n It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n Args:\n A (int): The first positive integer.\n B (int): The second positive integer.\n\n Output:\n Prints the product of A and B.\n\n Examples:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088", "level": "easy"}
{"task_id": "Shell/48", "prompt": "calculate_power_of_two() {\n    # Calculates 2 to the power of n.\n    # Given a non-negative integer n, this function computes 2^n.\n    # It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n    # Args:\n    #     n (int): The exponent to raise 2 to. Must be a non-negative integer.\n    #\n    # Output:\n    #     Prints the value of 2 raised to the power of n.\n    #\n    # Examples:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024", "canonical_solution": "    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}", "test": "test_calculate_power_of_two() {\n    local result\n\n    result=$(calculate_power_of_two 5)\n    [[ \"$result\" -eq 32 ]] || { echo \"Test 1 failed: Expected 32, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 10)\n    [[ \"$result\" -eq 1024 ]] || { echo \"Test 2 failed: Expected 1024, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 0)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 15)\n    [[ \"$result\" -eq 32768 ]] || { echo \"Test 4 failed: Expected 32768, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 20)\n    [[ \"$result\" -eq 1048576 ]] || { echo \"Test 5 failed: Expected 1048576, got $result\"; exit 1; }\n}\n\ntest_calculate_power_of_two", "entry_point": "calculate_power_of_two", "signature": "calculate_power_of_two() {", "docstring": " Calculates 2 to the power of n.\n Given a non-negative integer n, this function computes 2^n.\n It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n Args:\n n (int): The exponent to raise 2 to. Must be a non-negative integer.\n\n Output:\n Prints the value of 2 raised to the power of n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024", "instruction": "Write a Shell function `calculate_power_of_two() {` to solve the following problem: Calculates 2 to the power of n.\n Given a non-negative integer n, this function computes 2^n.\n It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n Args:\n n (int): The exponent to raise 2 to. Must be a non-negative integer.\n\n Output:\n Prints the value of 2 raised to the power of n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024", "level": "easy"}
{"task_id": "Shell/49", "prompt": "check_sign() {\n    # Check the sign of a given integer.\n    # If the integer is greater than zero, return \"positive\".\n    # If the integer is zero, return \"zero\".\n    # If the integer is less than zero, return \"negative\".\n    #\n    # Example:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative", "canonical_solution": "    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}", "test": "\ntest_check_sign() {\n    [[ $(check_sign 95) == \"positive\" ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(check_sign 0) == \"zero\" ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(check_sign -95) == \"negative\" ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(check_sign 1000000000) == \"positive\" ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(check_sign -1000000000) == \"negative\" ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(check_sign 1) == \"positive\" ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(check_sign -1) == \"negative\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_check_sign", "entry_point": "check_sign", "signature": "check_sign() {", "docstring": " Check the sign of a given integer.\n If the integer is greater than zero, return \"positive\".\n If the integer is zero, return \"zero\".\n If the integer is less than zero, return \"negative\".\n\n Example:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative", "instruction": "Write a Shell function `check_sign() {` to solve the following problem: Check the sign of a given integer.\n If the integer is greater than zero, return \"positive\".\n If the integer is zero, return \"zero\".\n If the integer is less than zero, return \"negative\".\n\n Example:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative", "level": "easy"}
{"task_id": "Shell/50", "prompt": "absolute_value() {\n    # Calculate the absolute value of a given integer.\n    # If the integer is positive, return the number as is.\n    # If the integer is negative, return the number multiplied by -1.\n    #\n    # Example:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0", "canonical_solution": "    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}", "test": "test_absolute_value() {\n    [[ $(absolute_value 95) -eq 95 ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(absolute_value -95) -eq 95 ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(absolute_value 0) -eq 0 ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(absolute_value 10000) -eq 10000 ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(absolute_value -10000) -eq 10000 ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(absolute_value 1) -eq 1 ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(absolute_value -1) -eq 1 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_absolute_value", "entry_point": "absolute_value", "signature": "absolute_value() {", "docstring": " Calculate the absolute value of a given integer.\n If the integer is positive, return the number as is.\n If the integer is negative, return the number multiplied by -1.\n\n Example:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0", "instruction": "Write a Shell function `absolute_value() {` to solve the following problem: Calculate the absolute value of a given integer.\n If the integer is positive, return the number as is.\n If the integer is negative, return the number multiplied by -1.\n\n Example:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0", "level": "easy"}
