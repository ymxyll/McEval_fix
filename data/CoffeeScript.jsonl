{"task_id": "CoffeeScript/1", "prompt": "assert = require 'assert'\nhasCloseElements = (numbers, threshold) ->\n  \"\"\"\n  Check if in given list of numbers, any two numbers are closer to each other than\n  given threshold.\n  >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n  False\n  >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  True\n  \"\"\"", "canonical_solution": "  for elem, idx in numbers\n    for elem2, idx2 in numbers\n      if idx isnt idx2\n        distance = Math.abs(elem - elem2)\n        return true if distance < threshold\n  false", "test": "# Test cases\ncheck = (hasCloseElements) ->\n  assert hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) is true\n  assert hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) is false\n  assert hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) is true\n  assert hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) is false\n  assert hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) is true\n  assert hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) is true\n  assert hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) is false\n\ncheck hasCloseElements", "entry_point": "hasCloseElements", "signature": "hasCloseElements = (numbers, threshold) ->", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\n  given threshold.\n  >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n  False\n  >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  True", "instruction": "Write a Coffeescript function `hasCloseElements = (numbers, threshold) ->` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\n  given threshold.\n  >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n  False\n  >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  True", "level": "easy"}
{"task_id": "CoffeeScript/2", "prompt": "class ListNode\n  constructor: (@val = null, @next = null) ->\n\n# Given the head of a singly linked list, reverse the list and return the reversed list.\n# @param head The head node of the linked list.\n# @return The head node of the reversed linked list.\n#\n# Example 1:\n# Input: head = [1,2,3,4,5]\n# Output: [5,4,3,2,1]\n#\n# Example 2:\n# Input: head = [1,2]\n# Output: [2,1]\n#\n# Example 3:\n# Input: head = []\n# Output: []\n#\n# Definition for singly-linked list:\n# class ListNode\n#     constructor: (@val = null, @next = null) ->\nreverseList = (head) ->", "canonical_solution": "  prev = null\n  curr = head\n\n  while curr\n    nextNode = curr.next\n    curr.next = prev\n    prev = curr\n    curr = nextNode\n\n  return prev\n", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n\nmain = ->\n  # Test case 1\n  head1 = new ListNode(1)\n  head1.next = new ListNode(2)\n  head1.next.next = new ListNode(3)\n  head1.next.next.next = new ListNode(4)\n  head1.next.next.next.next = new ListNode(5)\n\n  reversedHead1 = reverseList(head1)\n  assertEqual reversedHead1.val, 5\n  assertEqual reversedHead1.next.val, 4\n  assertEqual reversedHead1.next.next.val, 3\n  assertEqual reversedHead1.next.next.next.val, 2\n  assertEqual reversedHead1.next.next.next.next.val, 1\n\n  # Test case 2\n  head2 = new ListNode(1)\n  head2.next = new ListNode(2)\n\n  reversedHead2 = reverseList(head2)\n  assertEqual reversedHead2.val, 2\n  assertEqual reversedHead2.next.val, 1\n\n  # Test case 3\n  head3 = null\n\n  reversedHead3 = reverseList(head3)\n  assertEqual reversedHead3, null\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "reverseList", "signature": "reverseList = (head) ->", "docstring": "# Given the head of a singly linked list, reverse the list and return the reversed list.\n# @param head The head node of the linked list.\n# @return The head node of the reversed linked list.\n#\n# Example 1:\n# Input: head = [1,2,3,4,5]\n# Output: [5,4,3,2,1]\n#\n# Example 2:\n# Input: head = [1,2]\n# Output: [2,1]\n#\n# Example 3:\n# Input: head = []\n# Output: []\n#\n# Definition for singly-linked list:\n# class ListNode\n#     constructor: (@val = null, @next = null) ->", "instruction": "Write a Coffeescript function `reverseList = (head) ->` to solve the following problem:\n# Given the head of a singly linked list, reverse the list and return the reversed list.\n# @param head The head node of the linked list.\n# @return The head node of the reversed linked list.\n#\n# Example 1:\n# Input: head = [1,2,3,4,5]\n# Output: [5,4,3,2,1]\n#\n# Example 2:\n# Input: head = [1,2]\n# Output: [2,1]\n#\n# Example 3:\n# Input: head = []\n# Output: []\n#\n# Definition for singly-linked list:\n# class ListNode\n#     constructor: (@val = null, @next = null) ->", "level": "easy"}
{"task_id": "CoffeeScript/3", "prompt": "# Given a string s, convert all uppercase letters to lowercase letters and return the new string.\n# @param s A string.\n# @return The new converted string.\n#\n# Example 1:\n# Input: s = \"Hello\"\n# Output: \"hello\"\n#\n# Example 2:\n# Input: s = \"here\"\n# Output: \"here\"\n#\n# Example 3:\n# Input: s = \"LOVELY\"\n# Output: \"lovely\"\ntoLowerCase = (s) ->", "canonical_solution": "  s.toLowerCase()", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  # Test Case 1\n  s = \"Hello\"\n  expected = \"hello\"\n  assertEqual(toLowerCase(s), expected, \"Test Case 1 Failed\")\n\n  # Test Case 2\n  s = \"here\"\n  expected = \"here\"\n  assertEqual(toLowerCase(s), expected, \"Test Case 2 Failed\")\n\n  # Test Case 3\n  s = \"LOVELY\"\n  expected = \"lovely\"\n  assertEqual(toLowerCase(s), expected, \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "toLowerCase", "signature": "toLowerCase = (s) ->", "docstring": "# Given a string s, convert all uppercase letters to lowercase letters and return the new string.\n# @param s A string.\n# @return The new converted string.\n#\n# Example 1:\n# Input: s = \"Hello\"\n# Output: \"hello\"\n#\n# Example 2:\n# Input: s = \"here\"\n# Output: \"here\"\n#\n# Example 3:\n# Input: s = \"LOVELY\"\n# Output: \"lovely\"", "instruction": "Write a Coffeescript function `toLowerCase = (s) ->` to solve the following problem:\n# Given a string s, convert all uppercase letters to lowercase letters and return the new string.\n# @param s A string.\n# @return The new converted string.\n#\n# Example 1:\n# Input: s = \"Hello\"\n# Output: \"hello\"\n#\n# Example 2:\n# Input: s = \"here\"\n# Output: \"here\"\n#\n# Example 3:\n# Input: s = \"LOVELY\"\n# Output: \"lovely\"", "level": "easy"}
{"task_id": "CoffeeScript/4", "prompt": "# Given a signed 32-bit integer x, return the reverse of x.\n# If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\n# Assume the environment does not allow storing 64-bit integers (signed or unsigned).\n\n# @param x A signed 32-bit integer.\n# @return The reverse of x if it is within the 32-bit integer range, or 0 if it is outside the range.\n#\n# Example 1:\n# Input: x = 123\n# Output: 321\n#\n# Example 2:\n# Input: x = -123\n# Output: -321\n#\n# Example 3:\n# Input: x = 120\n# Output: 21\n#\n# Example 4:\n# Input: x = 0\n# Output: 0\nreverseInteger = (x) ->", "canonical_solution": "  if x >= 0\n    result = parseInt(x.toString().split(\"\").reverse().join(\"\"))\n  else\n    result = -parseInt((-x).toString().split(\"\").reverse().join(\"\"))\n\n  if result < -Math.pow(2, 31) or result > Math.pow(2, 31) - 1\n    return 0\n\n  return result", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n\nmain = ->\n  # Test cases\n  assertEqual(reverseInteger(123), 321, \"Test Case 1 Failed\")\n  assertEqual(reverseInteger(-123), -321, \"Test Case 2 Failed\")\n  assertEqual(reverseInteger(120), 21, \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "reverseInteger", "signature": "reverseInteger = (x) ->", "docstring": "# Given a signed 32-bit integer x, return the reverse of x.\n# If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\n# Assume the environment does not allow storing 64-bit integers (signed or unsigned).\n\n# @param x A signed 32-bit integer.\n# @return The reverse of x if it is within the 32-bit integer range, or 0 if it is outside the range.\n#\n# Example 1:\n# Input: x = 123\n# Output: 321\n#\n# Example 2:\n# Input: x = -123\n# Output: -321\n#\n# Example 3:\n# Input: x = 120\n# Output: 21\n#\n# Example 4:\n# Input: x = 0\n# Output: 0", "instruction": "Write a Coffeescript function `reverseInteger = (x) ->` to solve the following problem:\n# Given a signed 32-bit integer x, return the reverse of x.\n# If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\n# Assume the environment does not allow storing 64-bit integers (signed or unsigned).\n\n# @param x A signed 32-bit integer.\n# @return The reverse of x if it is within the 32-bit integer range, or 0 if it is outside the range.\n#\n# Example 1:\n# Input: x = 123\n# Output: 321\n#\n# Example 2:\n# Input: x = -123\n# Output: -321\n#\n# Example 3:\n# Input: x = 120\n# Output: 21\n#\n# Example 4:\n# Input: x = 0\n# Output: 0", "level": "middle"}
{"task_id": "CoffeeScript/5", "prompt": "# Given a non-negative integer, you can swap at most one digit. Return the maximum value you can get.\n# @param num A non-negative integer.\n# @return The maximum value after at most one digit swap.\n#\n# Example 1:\n# Input: num = 2736\n# Output: 7236\n# Explanation: Swap the digit 2 and the digit 7.\n#\n# Example 2:\n# Input: num = 9973\n# Output: 9973\n# Explanation: No swap is needed.\n#\n# Note:\n# The given number is in the range [0, 10^8].\nmaximumSwap = (num) ->", "canonical_solution": "  digits = num.toString().split('')\n  lastOccurrences = new Array(10).fill(-1)\n\n  # Find the last occurrence of each digit\n  for i in [0...digits.length]\n    lastOccurrences[parseInt(digits[i])] = i\n\n  # Find the first digit that can be swapped\n  for i in [0...digits.length]\n    for j in [9..parseInt(digits[i])+1] by -1\n      if lastOccurrences[j] > i\n        # Swap the digits\n        [digits[i], digits[lastOccurrences[j]]] = [digits[lastOccurrences[j]], digits[i]]\n        return parseInt(digits.join(''))\n\n  return num", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n\n# Testing\nmain = ->\n  assertEqual(maximumSwap(2736), 7236, 'Test Case 1 Failed')\n  assertEqual(maximumSwap(9973), 9973, 'Test Case 2 Failed')\n  assertEqual(maximumSwap(1234), 4231, 'Test Case 3 Failed')\n\n  console.log('All tests passed')\n\nmain()", "entry_point": "maximumSwap", "signature": "maximumSwap = (num) ->", "docstring": "# Given a non-negative integer, you can swap at most one digit. Return the maximum value you can get.\n# @param num A non-negative integer.\n# @return The maximum value after at most one digit swap.\n#\n# Example 1:\n# Input: num = 2736\n# Output: 7236\n# Explanation: Swap the digit 2 and the digit 7.\n#\n# Example 2:\n# Input: num = 9973\n# Output: 9973\n# Explanation: No swap is needed.\n#\n# Note:\n# The given number is in the range [0, 10^8].", "instruction": "Write a Coffeescript function `maximumSwap = (num) ->` to solve the following problem:\n# Given a non-negative integer, you can swap at most one digit. Return the maximum value you can get.\n# @param num A non-negative integer.\n# @return The maximum value after at most one digit swap.\n#\n# Example 1:\n# Input: num = 2736\n# Output: 7236\n# Explanation: Swap the digit 2 and the digit 7.\n#\n# Example 2:\n# Input: num = 9973\n# Output: 9973\n# Explanation: No swap is needed.\n#\n# Note:\n# The given number is in the range [0, 10^8].", "level": "hard"}
{"task_id": "CoffeeScript/6", "prompt": "# Given an integer n, return the nth Fibonacci number.\n# The Fibonacci sequence is defined as follows:\n# F0 = 0, F1 = 1, F2 = 1, and for n >= 2, Fn = Fn-1 + Fn-2.\n# @param n An integer representing the sequence number.\n# @return The nth Fibonacci number.\n#\n# Example 1:\n# Input: n = 4\n# Output: 3\n#\n# Example 2:\n# Input: n = 25\n# Output: 75025\n#\n# Example 3:\n# Input: n = 10\n# Output: 55\nfibonacci = (n) ->", "canonical_solution": "  return 0 if n is 0\n  return 1 if n is 1 or n is 2\n  fibPrev = 1\n  fibCurrent = 1\n  for i in [3..n]\n    temp = fibCurrent\n    fibCurrent = fibPrev + fibCurrent\n    fibPrev = temp\n  return fibCurrent", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n\n# Test cases\nmain = ->\n  assertEqual fibonacci(4), 3, \"Test Case 1 Failed\"\n  assertEqual fibonacci(25), 75025, \"Test Case 2 Failed\"\n  assertEqual fibonacci(10), 55, \"Test Case 3 Failed\"\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "fibonacci", "signature": "fibonacci = (n) ->", "docstring": "# Given an integer n, return the nth Fibonacci number.\n# The Fibonacci sequence is defined as follows:\n# F0 = 0, F1 = 1, F2 = 1, and for n >= 2, Fn = Fn-1 + Fn-2.\n# @param n An integer representing the sequence number.\n# @return The nth Fibonacci number.\n#\n# Example 1:\n# Input: n = 4\n# Output: 3\n#\n# Example 2:\n# Input: n = 25\n# Output: 75025\n#\n# Example 3:\n# Input: n = 10\n# Output: 55", "instruction": "Write a Coffeescript function `fibonacci = (n) ->` to solve the following problem:\n# Given an integer n, return the nth Fibonacci number.\n# The Fibonacci sequence is defined as follows:\n# F0 = 0, F1 = 1, F2 = 1, and for n >= 2, Fn = Fn-1 + Fn-2.\n# @param n An integer representing the sequence number.\n# @return The nth Fibonacci number.\n#\n# Example 1:\n# Input: n = 4\n# Output: 3\n#\n# Example 2:\n# Input: n = 25\n# Output: 75025\n#\n# Example 3:\n# Input: n = 10\n# Output: 55", "level": "easy"}
{"task_id": "CoffeeScript/7", "prompt": "# Given two strings s and t, where t is formed by randomly shuffling the characters in s and adding one extra letter at a random position.\n# Find the letter that was added in t.\n# @param s The original string.\n# @param t The shuffled string with one extra letter.\n# @return The letter that was added in t.\n#\n# Example 1:\n# Input: s = \"abcd\", t = \"abcde\"\n# Output: \"e\"\n#\n# Example 2:\n# Input: s = \"\", t = \"y\"\n# Output: \"y\"\n#\n# Constraints:\n# 0 <= s.length <= 1000\n# t.length == s.length + 1\n# s and t contain only lowercase letters.\nfindAddedLetter = (s, t) ->", "canonical_solution": "  sMap = new Map()\n  \n  for i in [0...s.length]\n    char = s[i]\n    sMap.set(char, (sMap.get(char) or 0) + 1)\n  \n  for i in [0...t.length]\n    char = t[i]\n    if not sMap.has(char) or sMap.get(char) is 0\n      return char\n    sMap.set(char, sMap.get(char) - 1)\n  \n  throw new Error(\"No added letter found.\")", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Testing\nmain = ->\n  # Test Case 1\n  s = \"abcd\"\n  t = \"abcde\"\n  addedLetter = findAddedLetter(s, t)\n  assertEqual(addedLetter, \"e\", \"Test Case 1 Failed\")\n\n  # Test Case 2\n  s = \"\"\n  t = \"y\"\n  addedLetter = findAddedLetter(s, t)\n  assertEqual(addedLetter, \"y\", \"Test Case 2 Failed\")\n\n  # Test Case 3\n  s = \"hello\"\n  t = \"hlello\"\n  addedLetter = findAddedLetter(s, t)\n  assertEqual(addedLetter, \"l\", \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "findAddedLetter", "signature": "findAddedLetter = (s, t) ->", "docstring": "# Given two strings s and t, where t is formed by randomly shuffling the characters in s and adding one extra letter at a random position.\n# Find the letter that was added in t.\n# @param s The original string.\n# @param t The shuffled string with one extra letter.\n# @return The letter that was added in t.\n#\n# Example 1:\n# Input: s = \"abcd\", t = \"abcde\"\n# Output: \"e\"\n#\n# Example 2:\n# Input: s = \"\", t = \"y\"\n# Output: \"y\"\n#\n# Constraints:\n# 0 <= s.length <= 1000\n# t.length == s.length + 1\n# s and t contain only lowercase letters.", "instruction": "Write a Coffeescript function `findAddedLetter = (s, t) ->` to solve the following problem:\n# Given two strings s and t, where t is formed by randomly shuffling the characters in s and adding one extra letter at a random position.\n# Find the letter that was added in t.\n# @param s The original string.\n# @param t The shuffled string with one extra letter.\n# @return The letter that was added in t.\n#\n# Example 1:\n# Input: s = \"abcd\", t = \"abcde\"\n# Output: \"e\"\n#\n# Example 2:\n# Input: s = \"\", t = \"y\"\n# Output: \"y\"\n#\n# Constraints:\n# 0 <= s.length <= 1000\n# t.length == s.length + 1\n# s and t contain only lowercase letters.", "level": "hard"}
{"task_id": "CoffeeScript/8", "prompt": "# Given a number N, find the smallest prime palindrome greater than or equal to N.\n# @param N An integer representing the input number.\n# @return The smallest prime palindrome greater than or equal to N.\n#\n# Example 1:\n# Input: N = 6\n# Output: 7\n#\n# Example 2:\n# Input: N = 8\n# Output: 11\n#\n# Example 3:\n# Input: N = 13\n# Output: 101\n#\n# Constraints:\n# 1 <= N <= 10^8\n# The answer is guaranteed to exist and be less than 2 * 10^8.\nsmallestPrimePalindrome = (N) ->", "canonical_solution": "  while true\n    return N if isPalindrome(N) and isPrime(N)\n    N++\n\nisPalindrome = (num) ->\n  str = num.toString()\n  len = str.length\n  for i in [0..Math.floor(len / 2)]\n    return false unless str[i] is str[len - 1 - i]\n  true\n\nisPrime = (num) ->\n  return false if num < 2\n  for i in [2..Math.floor(Math.sqrt(num))]\n    return false if num % i is 0\n  true\n", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test Cases\nmain = ->\n  assertEqual(smallestPrimePalindrome(7), 7)\n  assertEqual(smallestPrimePalindrome(9), 11)\n  assertEqual(smallestPrimePalindrome(15), 101)\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "smallestPrimePalindrome", "signature": "smallestPrimePalindrome = (N) ->", "docstring": "# Given a number N, find the smallest prime palindrome greater than or equal to N.\n# @param N An integer representing the input number.\n# @return The smallest prime palindrome greater than or equal to N.\n#\n# Example 1:\n# Input: N = 6\n# Output: 7\n#\n# Example 2:\n# Input: N = 8\n# Output: 11\n#\n# Example 3:\n# Input: N = 13\n# Output: 101\n#\n# Constraints:\n# 1 <= N <= 10^8\n# The answer is guaranteed to exist and be less than 2 * 10^8.", "instruction": "Write a Coffeescript function `smallestPrimePalindrome = (N) ->` to solve the following problem:\n# Given a number N, find the smallest prime palindrome greater than or equal to N.\n# @param N An integer representing the input number.\n# @return The smallest prime palindrome greater than or equal to N.\n#\n# Example 1:\n# Input: N = 6\n# Output: 7\n#\n# Example 2:\n# Input: N = 8\n# Output: 11\n#\n# Example 3:\n# Input: N = 13\n# Output: 101\n#\n# Constraints:\n# 1 <= N <= 10^8\n# The answer is guaranteed to exist and be less than 2 * 10^8.", "level": "middle"}
{"task_id": "CoffeeScript/9", "prompt": "class TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given the root of a binary tree, return the zigzag level order traversal of its nodes' values.\n# The zigzag level order traversal is a traversal of the nodes' values in a zigzag pattern (i.e., from left to right, then right to left for the next level and alternate between).\n#\n# @param root The root of the binary tree.\n# @return The zigzag level order traversal of the nodes' values.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: [[3],[20,9],[15,7]]\n#\n# Example 2:\n# Input: root = [1]\n# Output: [[1]]\n#\n# Example 3:\n# Input: root = []\n# Output: []\n#\n# Constraints:\n# - The number of nodes in the tree is in the range [0, 2000].\n# - -100 <= Node.val <= 100\nzigzagLevelOrder = (root) ->", "canonical_solution": "  return [] unless root\n\n  result = []\n  queue = [root]\n  level = 0\n\n  while queue.length > 0\n    levelSize = queue.length\n    currentLevel = []\n\n    for i in [0...levelSize]\n      node = queue.shift()\n      currentLevel.push(node.val)\n\n      if node.left\n        queue.push(node.left)\n      if node.right\n        queue.push(node.right)\n\n    currentLevel.reverse() if level % 2 is 1\n\n    result.push(currentLevel)\n    level++\n\n  result\n", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n\n# Test Cases\nmain = ->\n  root1 = new TreeNode(3)\n  root1.left = new TreeNode(9)\n  root1.right = new TreeNode(20)\n  root1.right.left = new TreeNode(15)\n  root1.right.right = new TreeNode(7)\n\n  result1 = zigzagLevelOrder(root1)\n  assertEqual result1.length, 3, \"Test Case 1\"\n  assertEqual result1[0].toString(), [3].toString(), \"Test Case 1\"\n  assertEqual result1[1].toString(), [20, 9].toString(), \"Test Case 1\"\n  assertEqual result1[2].toString(), [15, 7].toString(), \"Test Case 1\"\n\n  root2 = new TreeNode(1)\n  result2 = zigzagLevelOrder(root2)\n  assertEqual result2.length, 1, \"Test Case 2\"\n  assertEqual result2[0].toString(), [1].toString(), \"Test Case 2\"\n\n  root3 = null\n  result3 = zigzagLevelOrder(root3)\n  assertEqual result3.length, 0, \"Test Case 3\"\n\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "zigzagLevelOrder", "signature": "zigzagLevelOrder", "docstring": "class TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given the root of a binary tree, return the zigzag level order traversal of its nodes' values.\n# The zigzag level order traversal is a traversal of the nodes' values in a zigzag pattern (i.e., from left to right, then right to left for the next level and alternate between).\n#\n# @param root The root of the binary tree.\n# @return The zigzag level order traversal of the nodes' values.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: [[3],[20,9],[15,7]]\n#\n# Example 2:\n# Input: root = [1]\n# Output: [[1]]\n#\n# Example 3:\n# Input: root = []\n# Output: []\n#\n# Constraints:\n# - The number of nodes in the tree is in the range [0, 2000].\n# - -100 <= Node.val <= 100", "instruction": "Write a Coffeescript function `zigzagLevelOrder` to solve the following problem:\nclass TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given the root of a binary tree, return the zigzag level order traversal of its nodes' values.\n# The zigzag level order traversal is a traversal of the nodes' values in a zigzag pattern (i.e., from left to right, then right to left for the next level and alternate between).\n#\n# @param root The root of the binary tree.\n# @return The zigzag level order traversal of the nodes' values.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: [[3],[20,9],[15,7]]\n#\n# Example 2:\n# Input: root = [1]\n# Output: [[1]]\n#\n# Example 3:\n# Input: root = []\n# Output: []\n#\n# Constraints:\n# - The number of nodes in the tree is in the range [0, 2000].\n# - -100 <= Node.val <= 100", "level": "middle"}
{"task_id": "CoffeeScript/10", "prompt": "# Given two integer arrays nums1 and nums2, return the length of the longest common subarray between them.\n# @param nums1 An array of integers.\n# @param nums2 An array of integers.\n# @return The length of the longest common subarray.\n#\n# Example 1:\n# Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n# Output: 3\n#\n# Example 2:\n# Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n# Output: 5\n#\n# Constraints:\n# - 1 <= nums1.length, nums2.length <= 1000\n# - 0 <= nums1[i], nums2[i] <= 100\n\nfindLength = (nums1, nums2) ->", "canonical_solution": "  m = nums1.length\n  n = nums2.length\n  dp = Array(m + 1).fill(0).map(() -> Array(n + 1).fill(0))\n  maxLength = 0\n\n  for i in [1..m]\n    for j in [1..n]\n      if nums1[i - 1] is nums2[j - 1]\n        dp[i][j] = dp[i - 1][j - 1] + 1\n        maxLength = Math.max(maxLength, dp[i][j])\n\n  maxLength", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test Cases\nmain = ->\n  nums1 = [1, 2, 3, 4, 5]\n  nums2 = [5, 4, 3, 2, 1]\n  assertEqual(findLength(nums1, nums2), 1, \"Test Case 1 Failed\")\n\n  nums3 = [2, 4, 6, 8]\n  nums4 = [1, 3, 5, 7]\n  assertEqual(findLength(nums3, nums4), 0, \"Test Case 2 Failed\")\n\n  nums5 = [1, 2, 3]\n  nums6 = [4, 5, 6]\n  assertEqual(findLength(nums5, nums6), 0, \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "findLength", "signature": "findLength = (nums1, nums2) ->", "docstring": "# Given two integer arrays nums1 and nums2, return the length of the longest common subarray between them.\n# @param nums1 An array of integers.\n# @param nums2 An array of integers.\n# @return The length of the longest common subarray.\n#\n# Example 1:\n# Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n# Output: 3\n#\n# Example 2:\n# Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n# Output: 5\n#\n# Constraints:\n# - 1 <= nums1.length, nums2.length <= 1000\n# - 0 <= nums1[i], nums2[i] <= 100", "instruction": "Write a Coffeescript function `findLength = (nums1, nums2) ->` to solve the following problem:\n# Given two integer arrays nums1 and nums2, return the length of the longest common subarray between them.\n# @param nums1 An array of integers.\n# @param nums2 An array of integers.\n# @return The length of the longest common subarray.\n#\n# Example 1:\n# Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n# Output: 3\n#\n# Example 2:\n# Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n# Output: 5\n#\n# Constraints:\n# - 1 <= nums1.length, nums2.length <= 1000\n# - 0 <= nums1[i], nums2[i] <= 100", "level": "middle"}
{"task_id": "CoffeeScript/11", "prompt": "# Given two words word1 and word2, return the minimum number of steps required to make word1 and word2 identical.\n# Each step can consist of deleting any character from either string.\n#\n# @param word1 The first word.\n# @param word2 The second word.\n# @return The minimum number of steps required.\n#\n# Example 1:\n# Input: word1 = \"sea\", word2 = \"eat\"\n# Output: 2\n# Explanation: The first step is to transform \"sea\" into \"ea\", then the second step is to transform \"eat\" into \"ea\".\n#\n# Example 2:\n# Input: word1 = \"leetcode\", word2 = \"etco\"\n# Output: 4\n#\n# Constraints:\n# 1 <= word1.length, word2.length <= 500\n# word1 and word2 only contain lowercase English letters.\nminSteps = (word1, word2) ->", "canonical_solution": "  m = word1.length\n  n = word2.length\n  \n  dp = new Array(m + 1)\n  for i in [0..m]\n    dp[i] = new Array(n + 1).fill(0)\n  \n  for i in [1..m]\n    for j in [1..n]\n      if word1[i - 1] is word2[j - 1]\n        dp[i][j] = dp[i - 1][j - 1] + 1\n      else\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n  \n  return m + n - 2 * dp[m][n]", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Testing\nmain = ->\n  assertEqual(minSteps(\"abc\", \"def\"), 6, \"Test Case 1 Failed\")\n  assertEqual(minSteps(\"hello\", \"world\"), 8, \"Test Case 2 Failed\")\n  assertEqual(minSteps(\"algorithm\", \"logarithm\"), 4, \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "minSteps", "signature": "minSteps = (word1, word2) ->", "docstring": "# Given two words word1 and word2, return the minimum number of steps required to make word1 and word2 identical.\n# Each step can consist of deleting any character from either string.\n#\n# @param word1 The first word.\n# @param word2 The second word.\n# @return The minimum number of steps required.\n#\n# Example 1:\n# Input: word1 = \"sea\", word2 = \"eat\"\n# Output: 2\n# Explanation: The first step is to transform \"sea\" into \"ea\", then the second step is to transform \"eat\" into \"ea\".\n#\n# Example 2:\n# Input: word1 = \"leetcode\", word2 = \"etco\"\n# Output: 4\n#\n# Constraints:\n# 1 <= word1.length, word2.length <= 500\n# word1 and word2 only contain lowercase English letters.", "instruction": "Write a Coffeescript function `minSteps = (word1, word2) ->` to solve the following problem:\n# Given two words word1 and word2, return the minimum number of steps required to make word1 and word2 identical.\n# Each step can consist of deleting any character from either string.\n#\n# @param word1 The first word.\n# @param word2 The second word.\n# @return The minimum number of steps required.\n#\n# Example 1:\n# Input: word1 = \"sea\", word2 = \"eat\"\n# Output: 2\n# Explanation: The first step is to transform \"sea\" into \"ea\", then the second step is to transform \"eat\" into \"ea\".\n#\n# Example 2:\n# Input: word1 = \"leetcode\", word2 = \"etco\"\n# Output: 4\n#\n# Constraints:\n# 1 <= word1.length, word2.length <= 500\n# word1 and word2 only contain lowercase English letters.", "level": "hard"}
{"task_id": "CoffeeScript/12", "prompt": "# Given two integers a and b, calculate the sum of the two integers without using the + or - operator.\n# @param a An integer.\n# @param b An integer.\n# @return The sum of the two integers.\n#\n# Example 1:\n# Input: a = 1, b = 2\n# Output: 3\n#\n# Example 2:\n# Input: a = 2, b = 3\n# Output: 5\ngetSum = (a, b) ->", "canonical_solution": "  while b isnt 0\n    carry = a & b\n    a ^= b\n    b = carry << 1\n  return a", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  # Test cases\n  assertEqual(getSum(2, 5), 7, \"Test Case 1 Failed\")\n  assertEqual(getSum(-1, 1), 0, \"Test Case 2 Failed\")\n  assertEqual(getSum(10, -5), 5, \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "getSum", "signature": "getSum = (a, b) ->", "docstring": "# Given two integers a and b, calculate the sum of the two integers without using the + or - operator.\n# @param a An integer.\n# @param b An integer.\n# @return The sum of the two integers.\n#\n# Example 1:\n# Input: a = 1, b = 2\n# Output: 3\n#\n# Example 2:\n# Input: a = 2, b = 3\n# Output: 5", "instruction": "Write a Coffeescript function `getSum = (a, b) ->` to solve the following problem:\n# Given two integers a and b, calculate the sum of the two integers without using the + or - operator.\n# @param a An integer.\n# @param b An integer.\n# @return The sum of the two integers.\n#\n# Example 1:\n# Input: a = 1, b = 2\n# Output: 3\n#\n# Example 2:\n# Input: a = 2, b = 3\n# Output: 5", "level": "easy"}
{"task_id": "CoffeeScript/13", "prompt": "# Given two integers num1 and num2, return the sum of the two numbers.\n# @param num1 An integer.\n# @param num2 An integer.\n# @return The sum of num1 and num2.\n#\n# Example 1:\n# Input: num1 = 12, num2 = 5\n# Output: 17\n#\n# Example 2:\n# Input: num1 = -10, num2 = 4\n# Output: -6\n#\nnumSum = (num1, num2) ->", "canonical_solution": "  num1 + num2", "test": "class AssertionError extends Error\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# \u6d4b\u8bd5\u7528\u4f8b\nmain = ->\n  try\n    assertEqual numSum(3, 4), 7, 'Test Case 1 Failed'\n    assertEqual numSum(-5, 10), 5, 'Test Case 2 Failed'\n    assertEqual numSum(0, 0), 0, 'Test Case 3 Failed'\n    console.log 'All tests passed'\n  catch error\n    console.error error\n\nmain()", "entry_point": "numSum", "signature": "numSum = (num1, num2) ->", "docstring": "# Given two integers num1 and num2, return the sum of the two numbers.\n# @param num1 An integer.\n# @param num2 An integer.\n# @return The sum of num1 and num2.\n#\n# Example 1:\n# Input: num1 = 12, num2 = 5\n# Output: 17\n#\n# Example 2:\n# Input: num1 = -10, num2 = 4\n# Output: -6\n#", "instruction": "Write a Coffeescript function `numSum = (num1, num2) ->` to solve the following problem:\n# Given two integers num1 and num2, return the sum of the two numbers.\n# @param num1 An integer.\n# @param num2 An integer.\n# @return The sum of num1 and num2.\n#\n# Example 1:\n# Input: num1 = 12, num2 = 5\n# Output: 17\n#\n# Example 2:\n# Input: num1 = -10, num2 = 4\n# Output: -6\n#", "level": "easy"}
{"task_id": "CoffeeScript/14", "prompt": "# Given a string s, find the index of the first non-repeating character and return it. If it does not exist, return -1.\n# @param s A string.\n# @return The index of the first non-repeating character, or -1 if it does not exist.\n#\n# Example 1:\n# Input: s = \"leetcode\"\n# Output: 0\n#\n# Example 2:\n# Input: s = \"loveleetcode\"\n# Output: 2\n#\n# Example 3:\n# Input: s = \"aabb\"\n# Output: -1\n#\n# Constraints:\n# 1 <= s.length <= 105\n# s only contains lowercase letters\nfirstUniqChar = (s) ->", "canonical_solution": "  charCount = {}\n\n  for i in [0...s.length]\n    char = s[i]\n    charCount[char] = (charCount[char] or 0) + 1\n\n  for i in [0...s.length]\n    char = s[i]\n    return i if charCount[char] is 1\n\n  return -1", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test cases\nmain = ->\n  assertEqual(firstUniqChar(\"hello\"), 0, \"Test case 1 failed\")\n  assertEqual(firstUniqChar(\"goodbye\"), 0, \"Test case 2 failed\")\n  assertEqual(firstUniqChar(\"abcabc\"), -1, \"Test case 3 failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "firstUniqChar", "signature": "firstUniqChar = (s) ->", "docstring": "# Given a string s, find the index of the first non-repeating character and return it. If it does not exist, return -1.\n# @param s A string.\n# @return The index of the first non-repeating character, or -1 if it does not exist.\n#\n# Example 1:\n# Input: s = \"leetcode\"\n# Output: 0\n#\n# Example 2:\n# Input: s = \"loveleetcode\"\n# Output: 2\n#\n# Example 3:\n# Input: s = \"aabb\"\n# Output: -1\n#\n# Constraints:\n# 1 <= s.length <= 105\n# s only contains lowercase letters", "instruction": "Write a Coffeescript function `firstUniqChar = (s) ->` to solve the following problem:\n# Given a string s, find the index of the first non-repeating character and return it. If it does not exist, return -1.\n# @param s A string.\n# @return The index of the first non-repeating character, or -1 if it does not exist.\n#\n# Example 1:\n# Input: s = \"leetcode\"\n# Output: 0\n#\n# Example 2:\n# Input: s = \"loveleetcode\"\n# Output: 2\n#\n# Example 3:\n# Input: s = \"aabb\"\n# Output: -1\n#\n# Constraints:\n# 1 <= s.length <= 105\n# s only contains lowercase letters", "level": "easy"}
{"task_id": "CoffeeScript/15", "prompt": "# Given a grid of non-negative integers grid, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n# Each time, you can move either down or right by one step.\n# @param grid A 2D array of non-negative integers.\n# @return The minimum sum of a path from the top-left corner to the bottom-right corner.\n#\n# Example 1:\n# Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n# Output: 7\n# Explanation: The minimum sum path is 1->3->1->1->1.\n#\n# Example 2:\n# Input: grid = [[1,2,3],[4,5,6]]\n# Output: 12\n#\n# @param grid The grid of non-negative integers.\n# @return The minimum sum of a path from the top-left corner to the bottom-right corner.\nminPathSum = (grid) ->", "canonical_solution": "  m = grid.length\n  n = grid[0].length\n  dp = (Array(m)).fill().map(() -> (Array(n)).fill(0))\n\n  dp[0][0] = grid[0][0]\n\n  for i in [1...m]\n    dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n  for j in [1...n]\n    dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n  for i in [1...m]\n    for j in [1...n]\n      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n  dp[m - 1][n - 1]", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  # Test case 1\n  grid1 = [[1, 4, 7], [2, 5, 1], [8, 3, 6]]\n  assertEqual(minPathSum(grid1), 15, 'Test case 1 failed')\n\n  # Test case 2\n  grid2 = [[3, 2, 1], [4, 5, 1], [1, 2, 3]]\n  assertEqual(minPathSum(grid2), 10, 'Test case 2 failed')\n\n  # Test case 3\n  grid3 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n  assertEqual(minPathSum(grid3), 30, 'Test case 3 failed')\n\n  console.log('All tests passed')\n\nmain()", "entry_point": "minPathSum", "signature": "minPathSum = (grid) ->", "docstring": "# Given a grid of non-negative integers grid, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n# Each time, you can move either down or right by one step.\n# @param grid A 2D array of non-negative integers.\n# @return The minimum sum of a path from the top-left corner to the bottom-right corner.\n#\n# Example 1:\n# Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n# Output: 7\n# Explanation: The minimum sum path is 1->3->1->1->1.\n#\n# Example 2:\n# Input: grid = [[1,2,3],[4,5,6]]\n# Output: 12\n#\n# @param grid The grid of non-negative integers.\n# @return The minimum sum of a path from the top-left corner to the bottom-right corner.", "instruction": "Write a Coffeescript function `minPathSum = (grid) ->` to solve the following problem:\n# Given a grid of non-negative integers grid, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n# Each time, you can move either down or right by one step.\n# @param grid A 2D array of non-negative integers.\n# @return The minimum sum of a path from the top-left corner to the bottom-right corner.\n#\n# Example 1:\n# Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n# Output: 7\n# Explanation: The minimum sum path is 1->3->1->1->1.\n#\n# Example 2:\n# Input: grid = [[1,2,3],[4,5,6]]\n# Output: 12\n#\n# @param grid The grid of non-negative integers.\n# @return The minimum sum of a path from the top-left corner to the bottom-right corner.", "level": "hard"}
{"task_id": "CoffeeScript/16", "prompt": "# Given an array of positive integers A,\n# calculate the sum of the digits in the smallest element S.\n# If the sum is odd, return 0; if it is even, return 1.\n#\n# @param A An array of positive integers.\n# @return 0 if the sum of digits is odd, 1 if it is even.\n#\n# Example 1:\n# Input: [34,23,1,24,75,33,54,8]\n# Output: 0\n#\n# Example 2:\n# Input: [99,77,33,66,55]\n# Output: 1\nsmallestDigitSum = (A) ->", "canonical_solution": "  smallest = Infinity\n  for num in A\n    smallest = Math.min(smallest, num)\n  \n  sum = 0\n  while smallest > 0\n    sum += smallest % 10\n    smallest = Math.floor(smallest / 10)\n  \n  if sum % 2 is 0\n    return 1\n  else\n    return 0", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test cases\nmain = ->\n  assertEqual(smallestDigitSum([12, 34, 56, 78]), 0, \"Test case 1\")\n  assertEqual(smallestDigitSum([9, 8, 7, 6, 5]), 0, \"Test case 2\")\n  assertEqual(smallestDigitSum([123, 456, 789]), 1, \"Test case 3\")\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "smallestDigitSum", "signature": "smallestDigitSum = (A) ->", "docstring": "# Given an array of positive integers A,\n# calculate the sum of the digits in the smallest element S.\n# If the sum is odd, return 0; if it is even, return 1.\n#\n# @param A An array of positive integers.\n# @return 0 if the sum of digits is odd, 1 if it is even.\n#\n# Example 1:\n# Input: [34,23,1,24,75,33,54,8]\n# Output: 0\n#\n# Example 2:\n# Input: [99,77,33,66,55]\n# Output: 1", "instruction": "Write a Coffeescript function `smallestDigitSum = (A) ->` to solve the following problem:\n# Given an array of positive integers A,\n# calculate the sum of the digits in the smallest element S.\n# If the sum is odd, return 0; if it is even, return 1.\n#\n# @param A An array of positive integers.\n# @return 0 if the sum of digits is odd, 1 if it is even.\n#\n# Example 1:\n# Input: [34,23,1,24,75,33,54,8]\n# Output: 0\n#\n# Example 2:\n# Input: [99,77,33,66,55]\n# Output: 1", "level": "middle"}
{"task_id": "CoffeeScript/17", "prompt": "# Given two strings, s and goal. Return true if s can be transformed into goal after several rotations.\n# A rotation operation on s moves the leftmost character of s to the rightmost position.\n# For example, if s = 'abcde', after one rotation, it becomes 'bcdea'.\n\n# @param s The original string.\n# @param goal The target string.\n# @return True if s can be transformed into goal after several rotations, False otherwise.\n\n# Example 1:\n# Input: s = \"abcde\", goal = \"cdeab\"\n# Output: true\n\n# Example 2:\n# Input: s = \"abcde\", goal = \"abced\"\n# Output: false\n\n# Constraints:\n# 1 <= len(s), len(goal) <= 100\n# s and goal consist of lowercase English letters.\nisTransformable = (s, goal) ->", "canonical_solution": "  return false if s.length isnt goal.length\n\n  rotations = s.length\n  for i in [0...rotations]\n    return true if s is goal\n    s = s.slice(1) + s[0]\n\n  return false\n", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test cases\nmain = ->\n  # Test case 1\n  s = \"abcdef\"\n  goal = \"defabc\"\n  assertEqual(isTransformable(s, goal), true, \"Test case 1 failed\")\n\n  # Test case 2\n  s = \"abcde\"\n  goal = \"edcba\"\n  assertEqual(isTransformable(s, goal), false, \"Test case 2 failed\")\n\n  # Test case 3\n  s = \"xyz\"\n  goal = \"zxy\"\n  assertEqual(isTransformable(s, goal), true, \"Test case 3 failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "isTransformable", "signature": "isTransformable = (s, goal) ->", "docstring": "# Given two strings, s and goal. Return true if s can be transformed into goal after several rotations.\n# A rotation operation on s moves the leftmost character of s to the rightmost position.\n# For example, if s = 'abcde', after one rotation, it becomes 'bcdea'.\n\n# @param s The original string.\n# @param goal The target string.\n# @return True if s can be transformed into goal after several rotations, False otherwise.\n\n# Example 1:\n# Input: s = \"abcde\", goal = \"cdeab\"\n# Output: true\n\n# Example 2:\n# Input: s = \"abcde\", goal = \"abced\"\n# Output: false\n\n# Constraints:\n# 1 <= len(s), len(goal) <= 100\n# s and goal consist of lowercase English letters.", "instruction": "Write a Coffeescript function `isTransformable = (s, goal) ->` to solve the following problem:\n# Given two strings, s and goal. Return true if s can be transformed into goal after several rotations.\n# A rotation operation on s moves the leftmost character of s to the rightmost position.\n# For example, if s = 'abcde', after one rotation, it becomes 'bcdea'.\n\n# @param s The original string.\n# @param goal The target string.\n# @return True if s can be transformed into goal after several rotations, False otherwise.\n\n# Example 1:\n# Input: s = \"abcde\", goal = \"cdeab\"\n# Output: true\n\n# Example 2:\n# Input: s = \"abcde\", goal = \"abced\"\n# Output: false\n\n# Constraints:\n# 1 <= len(s), len(goal) <= 100\n# s and goal consist of lowercase English letters.", "level": "easy"}
{"task_id": "CoffeeScript/18", "prompt": "# Given a non-empty integer array nums, every element appears twice except for one. Find that single one.\n# You must implement an algorithm with linear runtime complexity and use only constant extra space.\n#\n# @param nums A non-empty integer array.\n# @return The single number that appears only once.\n#\n# Example 1:\n# Input: nums = [2,2,1]\n# Output: 1\n#\n# Example 2:\n# Input: nums = [4,1,2,1,2]\n# Output: 4\n#\n# Example 3:\n# Input: nums = [1]\n# Output: 1\n\nsingleNumber = (nums) ->", "canonical_solution": "  result = 0\n  for num in nums\n    result ^= num\n  result", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test Cases\nmain = ->\n  # Generate Test Cases\n  nums1 = [3, 3, 7, 7, 9]\n  expected1 = 9\n\n  nums2 = [5, 2, 5, 9, 2]\n  expected2 = 9\n\n  nums3 = [1, 4, 1, 4, 6]\n  expected3 = 6\n\n  # Run Test Cases\n  assertEqual(singleNumber(nums1), expected1, \"Test Case 1 Failed\")\n  assertEqual(singleNumber(nums2), expected2, \"Test Case 2 Failed\")\n  assertEqual(singleNumber(nums3), expected3, \"Test Case 3 Failed\")\n\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "singleNumber", "signature": "singleNumber = (nums) ->", "docstring": "# Given a non-empty integer array nums, every element appears twice except for one. Find that single one.\n# You must implement an algorithm with linear runtime complexity and use only constant extra space.\n#\n# @param nums A non-empty integer array.\n# @return The single number that appears only once.\n#\n# Example 1:\n# Input: nums = [2,2,1]\n# Output: 1\n#\n# Example 2:\n# Input: nums = [4,1,2,1,2]\n# Output: 4\n#\n# Example 3:\n# Input: nums = [1]\n# Output: 1", "instruction": "Write a Coffeescript function `singleNumber = (nums) ->` to solve the following problem:\n# Given a non-empty integer array nums, every element appears twice except for one. Find that single one.\n# You must implement an algorithm with linear runtime complexity and use only constant extra space.\n#\n# @param nums A non-empty integer array.\n# @return The single number that appears only once.\n#\n# Example 1:\n# Input: nums = [2,2,1]\n# Output: 1\n#\n# Example 2:\n# Input: nums = [4,1,2,1,2]\n# Output: 4\n#\n# Example 3:\n# Input: nums = [1]\n# Output: 1", "level": "easy"}
{"task_id": "CoffeeScript/19", "prompt": "# Given a set of letter tiles, each represented by a letter in `tiles`, return the number of possible non-empty letter sequences that can be printed.\n# @param tiles A string representing the set of letter tiles.\n# @return The number of possible letter sequences.\n#\n# Example 1:\n# Input: tiles = \"AAB\"\n# Output: 8\n#\n# Example 2:\n# Input: tiles = \"AAABBC\"\n# Output: 188\n#\n# Example 3:\n# Input: tiles = \"V\"\n# Output: 1\nnumTilePossibilities = (tiles) ->", "canonical_solution": "\n  count = 0\n  visited = (false for _ in tiles)\n  tilesArr = tiles.split('')  # Corrected line\n\n  backtrack = ->\n    for i in [0...tilesArr.length]\n      continue if visited[i]\n      continue if i > 0 and tilesArr[i] == tilesArr[i - 1] and not visited[i - 1]\n      visited[i] = true\n      count++\n      backtrack()\n      visited[i] = false\n\n  tilesArr.sort()\n  backtrack()\n\n  return count", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Testing\nmain = ->\n  # Test case 1\n  tiles = \"ABC\"\n  expected = 15\n  assertEqual(numTilePossibilities(tiles), expected, \"Test case 1 failed\")\n\n  # Test case 2\n  tiles = \"ABCD\"\n  expected = 64\n  assertEqual(numTilePossibilities(tiles), expected, \"Test case 2 failed\")\n\n  # Test case 3\n  tiles = \"XYZ\"\n  expected = 15\n  assertEqual(numTilePossibilities(tiles), expected, \"Test case 3 failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "numTilePossibilities", "signature": "numTilePossibilities = (tiles) ->", "docstring": "# Given a set of letter tiles, each represented by a letter in `tiles`, return the number of possible non-empty letter sequences that can be printed.\n# @param tiles A string representing the set of letter tiles.\n# @return The number of possible letter sequences.\n#\n# Example 1:\n# Input: tiles = \"AAB\"\n# Output: 8\n#\n# Example 2:\n# Input: tiles = \"AAABBC\"\n# Output: 188\n#\n# Example 3:\n# Input: tiles = \"V\"\n# Output: 1", "instruction": "Write a Coffeescript function `numTilePossibilities = (tiles) ->` to solve the following problem:\n# Given a set of letter tiles, each represented by a letter in `tiles`, return the number of possible non-empty letter sequences that can be printed.\n# @param tiles A string representing the set of letter tiles.\n# @return The number of possible letter sequences.\n#\n# Example 1:\n# Input: tiles = \"AAB\"\n# Output: 8\n#\n# Example 2:\n# Input: tiles = \"AAABBC\"\n# Output: 188\n#\n# Example 3:\n# Input: tiles = \"V\"\n# Output: 1", "level": "hard"}
{"task_id": "CoffeeScript/20", "prompt": "# Given an integer array A, find and return the maximum integer that appears only once in the array.\n# If there is no integer that appears only once, return -1.\n#\n# @param A An array of integers.\n# @return The maximum integer that appears only once, or -1 if none exists.\n#\n# Example 1:\n# Input: [5,7,3,9,4,9,8,3,1]\n# Output: 8\n#\n# Example 2:\n# Input: [9,9,8,8]\n# Output: -1\n#\n# Note:\n# - The length of the array A is 1 to 2000.\n# - The elements of A are integers between 0 and 1000.\nfindMaxUniqueInteger = (A) ->", "canonical_solution": "  count = {}\n  maxUnique = -1\n\n  for num in A\n    count[num] ?= 0\n    count[num]++\n\n  for num, value of count\n    if count.hasOwnProperty(num) and value is 1\n      maxUnique = Math.max(maxUnique, num)\n\n  maxUnique", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n\n# Testing the algorithm\nmain = ->\n  # Test case 1\n  arr1 = [5, 7, 3, 9, 4, 9, 8, 3, 1]\n  assertEqual(findMaxUniqueInteger(arr1), 8, \"Test case 1 failed\")\n\n  # Test case 2\n  arr2 = [9, 9, 8, 8]\n  assertEqual(findMaxUniqueInteger(arr2), -1, \"Test case 2 failed\")\n\n  # Test case 3\n  arr3 = [2, 2, 3, 3, 4, 4, 5, 5]\n  assertEqual(findMaxUniqueInteger(arr3), -1, \"Test case 3 failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "findMaxUniqueInteger", "signature": "findMaxUniqueInteger = (A) ->", "docstring": "# Given an integer array A, find and return the maximum integer that appears only once in the array.\n# If there is no integer that appears only once, return -1.\n#\n# @param A An array of integers.\n# @return The maximum integer that appears only once, or -1 if none exists.\n#\n# Example 1:\n# Input: [5,7,3,9,4,9,8,3,1]\n# Output: 8\n#\n# Example 2:\n# Input: [9,9,8,8]\n# Output: -1\n#\n# Note:\n# - The length of the array A is 1 to 2000.\n# - The elements of A are integers between 0 and 1000.", "instruction": "Write a Coffeescript function `findMaxUniqueInteger = (A) ->` to solve the following problem:\n# Given an integer array A, find and return the maximum integer that appears only once in the array.\n# If there is no integer that appears only once, return -1.\n#\n# @param A An array of integers.\n# @return The maximum integer that appears only once, or -1 if none exists.\n#\n# Example 1:\n# Input: [5,7,3,9,4,9,8,3,1]\n# Output: 8\n#\n# Example 2:\n# Input: [9,9,8,8]\n# Output: -1\n#\n# Note:\n# - The length of the array A is 1 to 2000.\n# - The elements of A are integers between 0 and 1000.", "level": "middle"}
{"task_id": "CoffeeScript/21", "prompt": "# Given the root of a binary tree, return the level order traversal of its nodes from bottom to top.\n# @param root The root node of the binary tree.\n# @return The level order traversal of the binary tree from bottom to top.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: [[15,7],[9,20],[3]]\n#\n# Example 2:\n# Input: root = [1]\n# Output: [[1]]\n#\n# Example 3:\n# Input: root = []\n# Output: []\nlevelOrderBottom = (root) ->", "canonical_solution": "  return [] unless root\n\n  queue = [root]\n  result = []\n\n  while queue.length > 0\n    levelSize = queue.length\n    currentLevel = []\n\n    for i in [0...levelSize]\n      node = queue.shift()\n      currentLevel.push(node.val)\n\n      queue.push(node.left) if node.left\n      queue.push(node.right) if node.right\n\n    result.unshift(currentLevel)\n\n  return result", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test Cases\nmain = ->\n  root1 =\n    val: 3\n    left:\n      val: 9\n      left: null\n      right: null\n    right:\n      val: 20\n      left:\n        val: 15\n        left: null\n        right: null\n      right:\n        val: 7\n        left: null\n        right: null\n\n  result1 = levelOrderBottom(root1)\n  assertEqual(result1.length, 3)\n  assertEqual(result1[0].length, 2)\n  assertEqual(result1[0][0], 15)\n  assertEqual(result1[0][1], 7)\n  assertEqual(result1[1].length, 2)\n  assertEqual(result1[1][0], 9)\n  assertEqual(result1[1][1], 20)\n  assertEqual(result1[2].length, 1)\n  assertEqual(result1[2][0], 3)\n\n  root2 =\n    val: 1\n    left: null\n    right: null\n\n  result2 = levelOrderBottom(root2)\n  assertEqual(result2.length, 1)\n  assertEqual(result2[0].length, 1)\n  assertEqual(result2[0][0], 1)\n\n  root3 = null\n  result3 = levelOrderBottom(root3)\n  assertEqual(result3.length, 0)\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "levelOrderBottom", "signature": "levelOrderBottom = (root) ->", "docstring": "# Given the root of a binary tree, return the level order traversal of its nodes from bottom to top.\n# @param root The root node of the binary tree.\n# @return The level order traversal of the binary tree from bottom to top.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: [[15,7],[9,20],[3]]\n#\n# Example 2:\n# Input: root = [1]\n# Output: [[1]]\n#\n# Example 3:\n# Input: root = []\n# Output: []", "instruction": "Write a Coffeescript function `levelOrderBottom = (root) ->` to solve the following problem:\n# Given the root of a binary tree, return the level order traversal of its nodes from bottom to top.\n# @param root The root node of the binary tree.\n# @return The level order traversal of the binary tree from bottom to top.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: [[15,7],[9,20],[3]]\n#\n# Example 2:\n# Input: root = [1]\n# Output: [[1]]\n#\n# Example 3:\n# Input: root = []\n# Output: []", "level": "middle"}
{"task_id": "CoffeeScript/22", "prompt": "class TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given a binary search tree root and a target sum k, return true if there exist two elements in the binary search tree such that their sum is equal to the given target sum.\n# @param root The root node of the binary search tree.\n# @param k The target sum.\n# @return true if there exist two elements in the binary search tree such that their sum is equal to the given target sum, false otherwise.\n#\n# Example 1:\n# Input: root = [5,3,6,2,4,null,7], k = 9\n# Output: true\n#\n# Example 2:\n# Input: root = [5,3,6,2,4,null,7], k = 28\n# Output: false\n#\n# Constraints:\n# - The number of nodes in the binary search tree is in the range [1, 104].\n# - Node.val is within the range [-104, 104].\n# - The input root is a valid binary search tree.\n# - The input k is within the range [-105, 105].\nfindTarget = (root, k) ->", "canonical_solution": "  set = new Set()\n\n  dfs = (node) ->\n    return false unless node?\n\n    return true if set.has(k - node.val)\n\n    set.add(node.val)\n\n    dfs(node.left) || dfs(node.right)\n\n  dfs(root)", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  # Test case 1\n  root1 = new TreeNode(5)\n  root1.left = new TreeNode(3)\n  root1.right = new TreeNode(6)\n  root1.left.left = new TreeNode(2)\n  root1.left.right = new TreeNode(4)\n  root1.right.right = new TreeNode(7)\n\n  assertEqual(findTarget(root1, 9), true, \"Test case 1 failed\")\n\n  # Test case 2\n  root2 = new TreeNode(5)\n  root2.left = new TreeNode(3)\n  root2.right = new TreeNode(6)\n  root2.left.left = new TreeNode(2)\n  root2.left.right = new TreeNode(4)\n  root2.right.right = new TreeNode(7)\n\n  assertEqual(findTarget(root2, 28), false, \"Test case 2 failed\")\n\n  # Test case 3\n  root3 = new TreeNode(1)\n  root3.left = new TreeNode(2)\n  root3.right = new TreeNode(3)\n  root3.left.left = new TreeNode(4)\n  root3.left.right = new TreeNode(5)\n  root3.right.left = new TreeNode(6)\n  root3.right.right = new TreeNode(7)\n\n  assertEqual(findTarget(root3, 8), true, \"Test case 3 failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "findTarget", "signature": "findTarget = (root, k) ->", "docstring": "class TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given a binary search tree root and a target sum k, return true if there exist two elements in the binary search tree such that their sum is equal to the given target sum.\n# @param root The root node of the binary search tree.\n# @param k The target sum.\n# @return true if there exist two elements in the binary search tree such that their sum is equal to the given target sum, false otherwise.\n#\n# Example 1:\n# Input: root = [5,3,6,2,4,null,7], k = 9\n# Output: true\n#\n# Example 2:\n# Input: root = [5,3,6,2,4,null,7], k = 28\n# Output: false\n#\n# Constraints:\n# - The number of nodes in the binary search tree is in the range [1, 104].\n# - Node.val is within the range [-104, 104].\n# - The input root is a valid binary search tree.\n# - The input k is within the range [-105, 105].", "instruction": "Write a Coffeescript function `findTarget = (root, k) ->` to solve the following problem:\nclass TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given a binary search tree root and a target sum k, return true if there exist two elements in the binary search tree such that their sum is equal to the given target sum.\n# @param root The root node of the binary search tree.\n# @param k The target sum.\n# @return true if there exist two elements in the binary search tree such that their sum is equal to the given target sum, false otherwise.\n#\n# Example 1:\n# Input: root = [5,3,6,2,4,null,7], k = 9\n# Output: true\n#\n# Example 2:\n# Input: root = [5,3,6,2,4,null,7], k = 28\n# Output: false\n#\n# Constraints:\n# - The number of nodes in the binary search tree is in the range [1, 104].\n# - Node.val is within the range [-104, 104].\n# - The input root is a valid binary search tree.\n# - The input k is within the range [-105, 105].", "level": "easy"}
{"task_id": "CoffeeScript/23", "prompt": "# Given an integer n, return the largest number less than or equal to n that is monotonically increasing.\n# @param n An integer.\n# @return The largest monotonically increasing number less than or equal to n.\n#\n# Example 1:\n# Input: n = 10\n# Output: 9\n#\n# Example 2:\n# Input: n = 1234\n# Output: 1234\n#\n# Example 3:\n# Input: n = 332\n# Output: 299\nmaxMonotonicNumber = (n) ->", "canonical_solution": "  num = n\n  digits = String(num).split('')\n\n  for i in [digits.length - 1..1] by -1\n    if digits[i] < digits[i - 1]\n      digits[i - 1]--\n      digits[j] = '9' for j in [i...digits.length]\n\n  Number(digits.join(''))", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test cases\nmain = ->\n  assertEqual(maxMonotonicNumber(15), 15, 'Test Case 1 Failed')\n  assertEqual(maxMonotonicNumber(87654321), 79999999, 'Test Case 2 Failed')\n  assertEqual(maxMonotonicNumber(987654), 899999, 'Test Case 3 Failed')\n\n  console.log('All tests passed')\n\nmain()", "entry_point": "maxMonotonicNumber", "signature": "maxMonotonicNumber = (n) ->", "docstring": "# Given an integer n, return the largest number less than or equal to n that is monotonically increasing.\n# @param n An integer.\n# @return The largest monotonically increasing number less than or equal to n.\n#\n# Example 1:\n# Input: n = 10\n# Output: 9\n#\n# Example 2:\n# Input: n = 1234\n# Output: 1234\n#\n# Example 3:\n# Input: n = 332\n# Output: 299", "instruction": "Write a Coffeescript function `maxMonotonicNumber = (n) ->` to solve the following problem:\n# Given an integer n, return the largest number less than or equal to n that is monotonically increasing.\n# @param n An integer.\n# @return The largest monotonically increasing number less than or equal to n.\n#\n# Example 1:\n# Input: n = 10\n# Output: 9\n#\n# Example 2:\n# Input: n = 1234\n# Output: 1234\n#\n# Example 3:\n# Input: n = 332\n# Output: 299", "level": "middle"}
{"task_id": "CoffeeScript/24", "prompt": "# Given a string s and an integer k, find the length of the longest substring that contains at most k distinct characters.\n# @param s A string.\n# @param k The maximum number of distinct characters allowed in the substring.\n# @return The length of the longest substring.\n#\n# Example 1:\n# Input: s = \"eceba\", k = 2\n# Output: 3\n# Explanation: The longest substring with at most 2 distinct characters is \"ece\" with a length of 3.\n#\n# Example 2:\n# Input: s = \"aa\", k = 1\n# Output: 2\n# Explanation: The longest substring with at most 1 distinct character is \"aa\" with a length of 2.\nlongestSubstringLength = (s, k) ->", "canonical_solution": "  maxLength = 0\n  start = 0\n  charCount = new Map()\n\n  for end in [0...s.length]\n    char = s[end]\n    charCount.set(char, (charCount.get(char) or 0) + 1)\n\n    while charCount.size > k\n      startChar = s[start]\n      charCount.set(startChar, charCount.get(startChar) - 1)\n      if charCount.get(startChar) is 0\n        charCount.delete(startChar)\n      start++\n\n    maxLength = Math.max(maxLength, end - start + 1)\n\n  maxLength", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test Cases\ntry\n  assertEqual longestSubstringLength(\"abcabcbb\", 2), 4, \"Test Case 1 Failed\"\n  assertEqual longestSubstringLength(\"abaccc\", 2), 4, \"Test Case 2 Failed\"\n  assertEqual longestSubstringLength(\"aabbcc\", 3), 6, \"Test Case 3 Failed\"\n\n  console.log \"All tests passed\"\ncatch error\n  console.error error", "entry_point": "longestSubstringLength", "signature": "longestSubstringLength = (s, k) ->", "docstring": "# Given a string s and an integer k, find the length of the longest substring that contains at most k distinct characters.\n# @param s A string.\n# @param k The maximum number of distinct characters allowed in the substring.\n# @return The length of the longest substring.\n#\n# Example 1:\n# Input: s = \"eceba\", k = 2\n# Output: 3\n# Explanation: The longest substring with at most 2 distinct characters is \"ece\" with a length of 3.\n#\n# Example 2:\n# Input: s = \"aa\", k = 1\n# Output: 2\n# Explanation: The longest substring with at most 1 distinct character is \"aa\" with a length of 2.", "instruction": "Write a Coffeescript function `longestSubstringLength = (s, k) ->` to solve the following problem:\n# Given a string s and an integer k, find the length of the longest substring that contains at most k distinct characters.\n# @param s A string.\n# @param k The maximum number of distinct characters allowed in the substring.\n# @return The length of the longest substring.\n#\n# Example 1:\n# Input: s = \"eceba\", k = 2\n# Output: 3\n# Explanation: The longest substring with at most 2 distinct characters is \"ece\" with a length of 3.\n#\n# Example 2:\n# Input: s = \"aa\", k = 1\n# Output: 2\n# Explanation: The longest substring with at most 1 distinct character is \"aa\" with a length of 2.", "level": "hard"}
{"task_id": "CoffeeScript/25", "prompt": "# Given an integer num, return three consecutive integers that add up to num. If num cannot be represented as the sum of three consecutive integers, return an empty array.\n# @param num An integer.\n# @return Three consecutive integers that add up to num.\n#\n# Example 1:\n# Input: num = 33\n# Output: [10,11,12]\n# Explanation: 33 can be represented as 10 + 11 + 12 = 33. So, return [10, 11, 12] which are three consecutive integers.\n#\n# Example 2:\n# Input: num = 4\n# Output: []\n# Explanation: There is no way to represent 4 as the sum of three consecutive integers. So, return an empty array.\nconsecutiveSum = (num) ->", "canonical_solution": "  for i in [1...num]\n    sum = i + (i + 1) + (i + 2)\n    return [i, i + 1, i + 2] if sum is num\n  []", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  result = consecutiveSum(33)\n  assertEqual result.length, 3, \"Test Case 1 failed\"\n  assertEqual result[0], 10, \"Test Case 1 failed\"\n  assertEqual result[1], 11, \"Test Case 1 failed\"\n  assertEqual result[2], 12, \"Test Case 1 failed\"\n\n  result = consecutiveSum(4)\n  assertEqual result.length, 0, \"Test Case 2 failed\"\n\n  result = consecutiveSum(21)\n  assertEqual result.length, 3, \"Test Case 3 failed\"\n  assertEqual result[0], 6, \"Test Case 3 failed\"\n  assertEqual result[1], 7, \"Test Case 3 failed\"\n  assertEqual result[2], 8, \"Test Case 3 failed\"\n\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "consecutiveSum", "signature": "consecutiveSum = (num) ->", "docstring": "# Given an integer num, return three consecutive integers that add up to num. If num cannot be represented as the sum of three consecutive integers, return an empty array.\n# @param num An integer.\n# @return Three consecutive integers that add up to num.\n#\n# Example 1:\n# Input: num = 33\n# Output: [10,11,12]\n# Explanation: 33 can be represented as 10 + 11 + 12 = 33. So, return [10, 11, 12] which are three consecutive integers.\n#\n# Example 2:\n# Input: num = 4\n# Output: []\n# Explanation: There is no way to represent 4 as the sum of three consecutive integers. So, return an empty array.", "instruction": "Write a Coffeescript function `consecutiveSum = (num) ->` to solve the following problem:\n# Given an integer num, return three consecutive integers that add up to num. If num cannot be represented as the sum of three consecutive integers, return an empty array.\n# @param num An integer.\n# @return Three consecutive integers that add up to num.\n#\n# Example 1:\n# Input: num = 33\n# Output: [10,11,12]\n# Explanation: 33 can be represented as 10 + 11 + 12 = 33. So, return [10, 11, 12] which are three consecutive integers.\n#\n# Example 2:\n# Input: num = 4\n# Output: []\n# Explanation: There is no way to represent 4 as the sum of three consecutive integers. So, return an empty array.", "level": "easy"}
{"task_id": "CoffeeScript/26", "prompt": "# Given an array of integers nums, return the number of longest increasing subsequences.\n# The subsequence must be strictly increasing.\n#\n# @param nums An array of integers.\n# @return The number of longest increasing subsequences.\n#\n# Example 1:\n# Input: [1,3,5,4,7]\n# Output: 2\n# Explanation: There are two longest increasing subsequences: [1, 3, 4, 7] and [1, 3, 5, 7].\n#\n# Example 2:\n# Input: [2,2,2,2,2]\n# Output: 5\n# Explanation: The length of the longest increasing subsequence is 1, and there are 5 subsequences with length 1, so the output is 5.\n#\n# Constraints:\n# 1 <= nums.length <= 2000\n# -10^6 <= nums[i] <= 10^6\ncountLongestIncreasingSubsequences = (nums) ->", "canonical_solution": "  n = nums.length\n  lengths = Array(n).fill(1)\n  counts = Array(n).fill(1)\n  maxLen = 1\n  result = 0\n\n  for i in [1...n]\n    for j in [0...i]\n      if nums[i] > nums[j]\n        if lengths[j] + 1 > lengths[i]\n          lengths[i] = lengths[j] + 1\n          counts[i] = counts[j]\n        else if lengths[j] + 1 is lengths[i]\n          counts[i] += counts[j]\n\n    maxLen = Math.max(maxLen, lengths[i])\n\n  for i in [0...n]\n    if lengths[i] is maxLen\n      result += counts[i]\n\n  return result", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n\n# Test cases\nmain = ->\n  nums1 = [1, 3, 5, 4, 7]\n  assertEqual countLongestIncreasingSubsequences(nums1), 2, \"Test case 1 failed\"\n\n  nums2 = [2, 2, 2, 2, 2]\n  assertEqual countLongestIncreasingSubsequences(nums2), 5, \"Test case 2 failed\"\n\n  nums3 = [3, 1, 2, 4, 6, 5, 8]\n  assertEqual countLongestIncreasingSubsequences(nums3), 2, \"Test case 3 failed\"\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "countLongestIncreasingSubsequences", "signature": "countLongestIncreasingSubsequences = (nums) ->", "docstring": "# Given an array of integers nums, return the number of longest increasing subsequences.\n# The subsequence must be strictly increasing.\n#\n# @param nums An array of integers.\n# @return The number of longest increasing subsequences.\n#\n# Example 1:\n# Input: [1,3,5,4,7]\n# Output: 2\n# Explanation: There are two longest increasing subsequences: [1, 3, 4, 7] and [1, 3, 5, 7].\n#\n# Example 2:\n# Input: [2,2,2,2,2]\n# Output: 5\n# Explanation: The length of the longest increasing subsequence is 1, and there are 5 subsequences with length 1, so the output is 5.\n#\n# Constraints:\n# 1 <= nums.length <= 2000\n# -10^6 <= nums[i] <= 10^6", "instruction": "Write a Coffeescript function `countLongestIncreasingSubsequences = (nums) ->` to solve the following problem:\n# Given an array of integers nums, return the number of longest increasing subsequences.\n# The subsequence must be strictly increasing.\n#\n# @param nums An array of integers.\n# @return The number of longest increasing subsequences.\n#\n# Example 1:\n# Input: [1,3,5,4,7]\n# Output: 2\n# Explanation: There are two longest increasing subsequences: [1, 3, 4, 7] and [1, 3, 5, 7].\n#\n# Example 2:\n# Input: [2,2,2,2,2]\n# Output: 5\n# Explanation: The length of the longest increasing subsequence is 1, and there are 5 subsequences with length 1, so the output is 5.\n#\n# Constraints:\n# 1 <= nums.length <= 2000\n# -10^6 <= nums[i] <= 10^6", "level": "hard"}
{"task_id": "CoffeeScript/27", "prompt": "# Determine if a sentence is a pangram.\n# @param sentence A string consisting of lowercase letters.\n# @return True if the sentence is a pangram, False otherwise.\n#\n# Example 1:\n# Input: sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n# Output: true\n#\n# Example 2:\n# Input: sentence = \"leetcode\"\n# Output: false\n#\nisPangram = (sentence) ->", "canonical_solution": "  lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz'\n  for char in sentence\n    return false unless lowercaseLetters.includes(char)\n  true", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test cases\nmain = ->\n  assertEqual isPangram(\"thequickbrownfoxjumpsoverthelazydog\"), true, \"Test case 1 failed\"\n  assertEqual isPangram(\"leetcode\"), true, \"Test case 2 failed\"\n  assertEqual isPangram(\"abcdefghijklmnopqrstuvwxyz123\"), false, \"Test case 3 failed\"\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "isPangram", "signature": "isPangram = (sentence) ->", "docstring": "# Determine if a sentence is a pangram.\n# @param sentence A string consisting of lowercase letters.\n# @return True if the sentence is a pangram, False otherwise.\n#\n# Example 1:\n# Input: sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n# Output: true\n#\n# Example 2:\n# Input: sentence = \"leetcode\"\n# Output: false\n#", "instruction": "Write a Coffeescript function `isPangram = (sentence) ->` to solve the following problem:\n# Determine if a sentence is a pangram.\n# @param sentence A string consisting of lowercase letters.\n# @return True if the sentence is a pangram, False otherwise.\n#\n# Example 1:\n# Input: sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n# Output: true\n#\n# Example 2:\n# Input: sentence = \"leetcode\"\n# Output: false\n#", "level": "easy"}
{"task_id": "CoffeeScript/28", "prompt": "# Given a list of time points in a 24-hour format (hour:minute \"HH:MM\"), find the minimum time difference between any two time points and represent it in minutes.\n# @param timePoints A list of time points.\n# @return The minimum time difference between any two time points in minutes.\n#\n# Example 1:\n# Input: timePoints = [\"23:59\",\"00:00\"]\n# Output: 1\n#\n# Example 2:\n# Input: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n# Output: 0\n#\n# Constraints:\n# - 2 <= timePoints.length <= 20000\n# - timePoints[i] has the format \"HH:MM\"\nminTimeDifference = (timePoints) ->", "canonical_solution": "  minutes = timePoints.map((time) ->\n    [hour, minute] = time.split(':')\n    parseInt(hour) * 60 + parseInt(minute)\n  )\n\n  minutes.sort((a, b) -> a - b)\n\n  minDiff = Infinity\n  for i in [1...minutes.length]\n    diff = minutes[i] - minutes[i - 1]\n    minDiff = Math.min(minDiff, diff)\n\n  minDiff", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Testing\nmain = ->\n  # Test Case 1\n  timePoints1 = [\"12:00\", \"13:30\", \"15:45\", \"16:00\"]\n  assertEqual(minTimeDifference(timePoints1), 15, \"Test Case 1 Failed\")\n\n  # Test Case 2\n  timePoints2 = [\"00:00\", \"06:00\", \"12:00\", \"18:00\"]\n  assertEqual(minTimeDifference(timePoints2), 360, \"Test Case 2 Failed\")\n\n  # Test Case 3\n  timePoints3 = [\"01:30\", \"02:00\", \"03:45\", \"04:15\"]\n  assertEqual(minTimeDifference(timePoints3), 30, \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "minTimeDifference", "signature": "minTimeDifference = (timePoints) ->", "docstring": "# Given a list of time points in a 24-hour format (hour:minute \"HH:MM\"), find the minimum time difference between any two time points and represent it in minutes.\n# @param timePoints A list of time points.\n# @return The minimum time difference between any two time points in minutes.\n#\n# Example 1:\n# Input: timePoints = [\"23:59\",\"00:00\"]\n# Output: 1\n#\n# Example 2:\n# Input: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n# Output: 0\n#\n# Constraints:\n# - 2 <= timePoints.length <= 20000\n# - timePoints[i] has the format \"HH:MM\"", "instruction": "Write a Coffeescript function `minTimeDifference = (timePoints) ->` to solve the following problem:\n# Given a list of time points in a 24-hour format (hour:minute \"HH:MM\"), find the minimum time difference between any two time points and represent it in minutes.\n# @param timePoints A list of time points.\n# @return The minimum time difference between any two time points in minutes.\n#\n# Example 1:\n# Input: timePoints = [\"23:59\",\"00:00\"]\n# Output: 1\n#\n# Example 2:\n# Input: timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n# Output: 0\n#\n# Constraints:\n# - 2 <= timePoints.length <= 20000\n# - timePoints[i] has the format \"HH:MM\"", "level": "middle"}
{"task_id": "CoffeeScript/29", "prompt": "# Determine whether a given number is an ugly number.\n# An ugly number is a positive integer that is divisible by either 2, 3, or 5.\n# @param n The number to be checked.\n# @return True if the number is an ugly number, false otherwise.\n#\n# Example 1:\n# Input: n = 6\n# Output: true\n#\n# Example 2:\n# Input: n = 1\n# Output: true\n#\n# Example 3:\n# Input: n = 14\n# Output: false\nisUgly = (n) ->", "canonical_solution": "  return false if n <= 0\n\n  while n % 2 is 0\n    n /= 2\n\n  while n % 3 is 0\n    n /= 3\n\n  while n % 5 is 0\n    n /= 5\n\n  return n is 1", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test Cases\nmain = ->\n  assertEqual(isUgly(10), true, \"Test Case 1 Failed\")\n  assertEqual(isUgly(14), false, \"Test Case 2 Failed\")\n  assertEqual(isUgly(30), true, \"Test Case 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "isUgly", "signature": "isUgly = (n) ->", "docstring": "# Determine whether a given number is an ugly number.\n# An ugly number is a positive integer that is divisible by either 2, 3, or 5.\n# @param n The number to be checked.\n# @return True if the number is an ugly number, false otherwise.\n#\n# Example 1:\n# Input: n = 6\n# Output: true\n#\n# Example 2:\n# Input: n = 1\n# Output: true\n#\n# Example 3:\n# Input: n = 14\n# Output: false", "instruction": "Write a Coffeescript function `isUgly = (n) ->` to solve the following problem:\n# Determine whether a given number is an ugly number.\n# An ugly number is a positive integer that is divisible by either 2, 3, or 5.\n# @param n The number to be checked.\n# @return True if the number is an ugly number, false otherwise.\n#\n# Example 1:\n# Input: n = 6\n# Output: true\n#\n# Example 2:\n# Input: n = 1\n# Output: true\n#\n# Example 3:\n# Input: n = 14\n# Output: false", "level": "easy"}
{"task_id": "CoffeeScript/30", "prompt": "class TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given a binary tree, determine if it is height-balanced.\n# A height-balanced binary tree is defined as a binary tree in which the\n# depth of the two subtrees of every node never differ by more than 1.\n#\n# @param root The root node of the binary tree.\n# @return True if the binary tree is height-balanced, False otherwise.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: true\n#\n# Example 2:\n# Input: root = [1,2,2,3,3,null,null,4,4]\n# Output: false\n#\n# Example 3:\n# Input: root = []\n# Output: true\nisBalanced = (root) ->", "canonical_solution": "  return true unless root\n\n  getHeight = (node) ->\n    return 0 unless node\n\n    leftHeight = getHeight(node.left)\n    rightHeight = getHeight(node.right)\n\n    return -1 if leftHeight is -1 or rightHeight is -1 or Math.abs(leftHeight - rightHeight) > 1\n\n    Math.max(leftHeight, rightHeight) + 1\n\n  return getHeight(root) isnt -1", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test Cases\nmain = ->\n  root1 = new TreeNode(3)\n  root1.left = new TreeNode(9)\n  root1.right = new TreeNode(20)\n  root1.right.left = new TreeNode(15)\n  root1.right.right = new TreeNode(7)\n  assertEqual isBalanced(root1), true, 'Test Case 1'\n\n  root2 = new TreeNode(1)\n  root2.left = new TreeNode(2)\n  root2.right = new TreeNode(2)\n  root2.left.left = new TreeNode(3)\n  root2.left.right = new TreeNode(3)\n  root2.left.left.left = new TreeNode(4)\n  root2.left.left.right = new TreeNode(4)\n  assertEqual isBalanced(root2), false, 'Test Case 2'\n\n  root3 = null\n  assertEqual isBalanced(root3), true, 'Test Case 3'\n\n  console.log 'All tests passed'\n\nmain()", "entry_point": "isBalanced", "signature": "isBalanced = (root) ->", "docstring": "class TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given a binary tree, determine if it is height-balanced.\n# A height-balanced binary tree is defined as a binary tree in which the\n# depth of the two subtrees of every node never differ by more than 1.\n#\n# @param root The root node of the binary tree.\n# @return True if the binary tree is height-balanced, False otherwise.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: true\n#\n# Example 2:\n# Input: root = [1,2,2,3,3,null,null,4,4]\n# Output: false\n#\n# Example 3:\n# Input: root = []\n# Output: true", "instruction": "Write a Coffeescript function `isBalanced = (root) ->` to solve the following problem:\nclass TreeNode\n  constructor: (val) ->\n    @val = val\n    @left = null\n    @right = null\n\n# Given a binary tree, determine if it is height-balanced.\n# A height-balanced binary tree is defined as a binary tree in which the\n# depth of the two subtrees of every node never differ by more than 1.\n#\n# @param root The root node of the binary tree.\n# @return True if the binary tree is height-balanced, False otherwise.\n#\n# Example 1:\n# Input: root = [3,9,20,null,null,15,7]\n# Output: true\n#\n# Example 2:\n# Input: root = [1,2,2,3,3,null,null,4,4]\n# Output: false\n#\n# Example 3:\n# Input: root = []\n# Output: true", "level": "hard"}
{"task_id": "CoffeeScript/31", "prompt": "# Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n# @param n The number of passengers.\n# @return The probability that the last passenger will sit in their own seat.\n#\n# Example 1:\n# Input: n = 6\n# Output: 0.5\n#\n# Example 2:\n# Input: n = 10\n# Output: 0.5\n#\n\ncalculateProbability = (n) ->", "canonical_solution": "  if n is 1 then return 1\n  else return 0.5", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless JSON.stringify(actual) is JSON.stringify(expected) \n# Test cases\nmain = ->\n    assertEqual(calculateProbability(6), 0.5, \"Expected the probability for 6 passengers to be 0.5\")\n    assertEqual(calculateProbability(10), 0.5, \"Expected the probability for 10 passengers to be 0.5\")\n    assertEqual(calculateProbability(20), 0.5, \"Expected the probability for 20 passengers to be 0.5\")\n    \n    console.log(\"All tests passed\")\n    \nmain()", "entry_point": "calculateProbability", "signature": "calculateProbability = (n) ->", "docstring": "Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n@param n The number of passengers.\n@return The probability that the last passenger will sit in their own seat.\n\nExample 1:\nInput: n = 6\nOutput: 0.5\n\nExample 2:\nInput: n = 10\nOutput: 0.5", "instruction": "Write a Coffeescript function `calculateProbability = (n) ->` to solve the following problem:\nGiven the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n@param n The number of passengers.\n@return The probability that the last passenger will sit in their own seat.\n\nExample 1:\nInput: n = 6\nOutput: 0.5\n\nExample 2:\nInput: n = 10\nOutput: 0.5", "level": "easy"}
{"task_id": "CoffeeScript/32", "prompt": "# Given an array of integers nums and an integer k, return the kth largest element in the array.\n# Note: You need to find the kth largest element after sorting the array, not the kth distinct element.\n# You must design and implement an algorithm with O(n) time complexity to solve this problem.\n#\n# @param nums An array of integers.\n# @param k The value of k.\n# @return The kth largest element in the array.\n#\n# Example 1:\n# Input: nums = [3,2,1,5,6,4], k = 2\n# Output: 5\n#\n# Example 2:\n# Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\n# Output: 4\n#\n# Constraints:\n# 1 <= k <= nums.length <= 105\n# -104 <= nums[i] <= 104\nfindKthLargest = (nums, k) ->", "canonical_solution": "  nums.sort (a, b) -> b - a\n  nums[k - 1]", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless JSON.stringify(actual) is JSON.stringify(expected) \nmain = ->\n  # First Test Case\n  assertEqual findKthLargest([7, 10, 4, 3, 20, 15], 3), 10\n  # Second Test Case\n  assertEqual findKthLargest([1, 2, 3, 4, 5, 6], 4), 3\n  # Third Test Case\n  assertEqual findKthLargest([100, 36, 1, 3, 2, 25, 9], 2), 36\n  console.log 'All tests passed'\n\nmain()", "entry_point": "findKthLargest", "signature": "findKthLargest = (nums, k) ->", "docstring": "Given an array of integers nums and an integer k, return the kth largest element in the array.\nNote: You need to find the kth largest element after sorting the array, not the kth distinct element.\nYou must design and implement an algorithm with O(n) time complexity to solve this problem.\n\n@param nums An array of integers.\n@param k The value of k.\n@return The kth largest element in the array.\n\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n\nExample 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104", "instruction": "Write a Coffeescript function `findKthLargest = (nums, k) ->` to solve the following problem:\nGiven an array of integers nums and an integer k, return the kth largest element in the array.\nNote: You need to find the kth largest element after sorting the array, not the kth distinct element.\nYou must design and implement an algorithm with O(n) time complexity to solve this problem.\n\n@param nums An array of integers.\n@param k The value of k.\n@return The kth largest element in the array.\n\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n\nExample 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n\nConstraints:\n1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104", "level": "easy"}
{"task_id": "CoffeeScript/33", "prompt": "# Reverse the given string in-place.\n# @param s An array of characters representing the string.\n# @return The reversed string.\n#\n# Example 1:\n# Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n# Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n#\n# Example 2:\n# Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n# Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\nreverseString = (s) ->", "canonical_solution": "  left = 0\n  right = s.length - 1\n  while left < right\n    [s[left], s[right]] = [s[right], s[left]]\n    left++\n    right--\n  s", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless JSON.stringify(actual) is JSON.stringify(expected) \nmain = ->\n  # Test 1\n  testString1 = [\"C\",\"o\",\"f\",\"f\",\"e\",\"e\"]\n  expected1 = [\"e\",\"e\",\"f\",\"f\",\"o\",\"C\"]\n  assertEqual(reverseString(testString1), expected1, \"Test 1 Failed\")\n\n  # Test 2\n  testString2 = [\"J\",\"a\",\"v\",\"a\",\"S\",\"c\",\"r\",\"i\",\"p\",\"t\"]\n  expected2 = [\"t\",\"p\",\"i\",\"r\",\"c\",\"S\",\"a\",\"v\",\"a\",\"J\"]\n  assertEqual(reverseString(testString2), expected2, \"Test 2 Failed\")\n\n  # Test 3\n  testString3 = [\"P\",\"y\",\"t\",\"h\",\"o\",\"n\"]\n  expected3 = [\"n\",\"o\",\"h\",\"t\",\"y\",\"P\"]\n  assertEqual(reverseString(testString3), expected3, \"Test 3 Failed\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "reverseString", "signature": "reverseString = (s) ->", "docstring": "Reverse the given string in-place.\n@param s An array of characters representing the string.\n@return The reversed string.\n\nExample 1:\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nExample 2:\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "instruction": "Write a Coffeescript function `reverseString = (s) ->` to solve the following problem:\nReverse the given string in-place.\n@param s An array of characters representing the string.\n@return The reversed string.\n\nExample 1:\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nExample 2:\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "level": "easy"}
{"task_id": "CoffeeScript/34", "prompt": "# Given an integer n, determine whether it is an Armstrong number.\n# An Armstrong number is a number that is equal to the sum of its digits raised to the power of the number of digits.\n# @param n An integer.\n# @return True if n is an Armstrong number, False otherwise.\n#\n# Example 1:\n# Input: n = 153\n# Output: true\n# Explanation: 153 is a 3-digit number and 153 = 1^3 + 5^3 + 3^3.\n#\n# Example 2:\n# Input: n = 123\n# Output: false\n# Explanation: 123 is a 3-digit number but 123 != 1^3 + 2^3 + 3^3 = 36.\nisArmstrongNumber = (n) ->", "canonical_solution": "  sum = 0\n  digits = n.toString().split('')\n  length = digits.length\n  for digit in digits\n    sum += parseInt(digit, 10) ** length\n  return sum is n", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message || \"Expected #{actual} to equal #{expected}\") unless actual is expected\nmain = ->\n  assertEqual isArmstrongNumber(371), true, \"Test case 1 failed\"\n  assertEqual isArmstrongNumber(9474), true, \"Test case 2 failed\"\n  assertEqual isArmstrongNumber(9475), false, \"Test case 3 failed\"\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "isArmstrongNumber", "signature": "isArmstrongNumber = (n) ->", "docstring": "Given an integer n, determine whether it is an Armstrong number.\nAn Armstrong number is a number that is equal to the sum of its digits raised to the power of the number of digits.\n@param n An integer.\n@return True if n is an Armstrong number, False otherwise.\n\nExample 1:\nInput: n = 153\nOutput: true\nExplanation: 153 is a 3-digit number and 153 = 1^3 + 5^3 + 3^3.\n\nExample 2:\nInput: n = 123\nOutput: false\nExplanation: 123 is a 3-digit number but 123 != 1^3 + 2^3 + 3^3 = 36.", "instruction": "Write a Coffeescript function `isArmstrongNumber = (n) ->` to solve the following problem:\nGiven an integer n, determine whether it is an Armstrong number.\nAn Armstrong number is a number that is equal to the sum of its digits raised to the power of the number of digits.\n@param n An integer.\n@return True if n is an Armstrong number, False otherwise.\n\nExample 1:\nInput: n = 153\nOutput: true\nExplanation: 153 is a 3-digit number and 153 = 1^3 + 5^3 + 3^3.\n\nExample 2:\nInput: n = 123\nOutput: false\nExplanation: 123 is a 3-digit number but 123 != 1^3 + 2^3 + 3^3 = 36.", "level": "easy"}
{"task_id": "CoffeeScript/35", "prompt": "# Given an integer, convert it to a hexadecimal string.\n# For negative integers, use two's complement method.\n# @param num The integer to be converted.\n# @return The hexadecimal string representation of the integer.\n#\n# Example 1:\n# Input: num = 26\n# Output: \"1a\"\n#\n# Example 2:\n# Input: num = -1\n# Output: \"ffffffff\"\ntoHex = (num) ->", "canonical_solution": "  return \"0\" if num is 0\n  hex = ''\n  while num isnt 0\n    hex = '0123456789abcdef'[(num & 15)] + hex\n    num >>>= 4 # Logical right shift by 4, works for negative numbers too\n  hex", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  assertEqual toHex(305419896), '12345678', 'Test Case 1 Failed'\n  assertEqual toHex(-42), 'ffffffd6', 'Test Case 2 Failed'\n  assertEqual toHex(1234), '4d2', 'Test Case 3 Failed'\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "toHex", "signature": "toHex = (num) ->", "docstring": "Given an integer, convert it to a hexadecimal string.\nFor negative integers, use two's complement method.\n@param num The integer to be converted.\n@return The hexadecimal string representation of the integer.\n\nExample 1:\nInput: num = 26\nOutput: \"1a\"\n\nExample 2:\nInput: num = -1\nOutput: \"ffffffff\"", "instruction": "Write a Coffeescript function `toHex = (num) ->` to solve the following problem:\nGiven an integer, convert it to a hexadecimal string.\nFor negative integers, use two's complement method.\n@param num The integer to be converted.\n@return The hexadecimal string representation of the integer.\n\nExample 1:\nInput: num = 26\nOutput: \"1a\"\n\nExample 2:\nInput: num = -1\nOutput: \"ffffffff\"", "level": "easy"}
{"task_id": "CoffeeScript/36", "prompt": "# Given a string s, check if it can be divided into three non-empty palindrome substrings.\n# @param s A string.\n# @return True if s can be divided into three non-empty palindrome substrings, False otherwise.\n#\n# Example 1:\n# Input: s = \"abcbdd\"\n# Output: true\n#\n# Example 2:\n# Input: s = \"bcbddxy\"\n# Output: false\n#\n# Example 3:\n# Input: s = \"abcba\"\n# Output: false\n#\n# Example 4:\n# Input: s = \"aaa\"\n# Output: true\n#\n# Example 5:\n# Input: s = \"abcde\"\n# Output: false\nisDivisibleIntoThreePalindromes = (s) ->", "canonical_solution": "  for i in [1...s.length - 1]\n    for j in [i + 1...s.length]\n      if isPalindrome(s[0...i]) and isPalindrome(s[i...j]) and isPalindrome(s[j...])\n        return true\n  false\n  \n# helper function to test if a string is a palindrome\nisPalindrome = (str) -> str == str.split('').reverse().join('')", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  assertEqual(isDivisibleIntoThreePalindromes(\"aaabbbccc\"), true, \"Test 1 Failed\")\n  assertEqual(isDivisibleIntoThreePalindromes(\"madamracecar\"), false, \"Test 2 Failed\")\n  assertEqual(isDivisibleIntoThreePalindromes(\"abacaba\"), true, \"Test 3 Failed\")\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "isDivisibleIntoThreePalindromes", "signature": "isDivisibleIntoThreePalindromes = (s) ->", "docstring": "Given a string s, check if it can be divided into three non-empty palindrome substrings.\n@param s A string.\n@return True if s can be divided into three non-empty palindrome substrings, False otherwise.\n\nExample 1:\nInput: s = \"abcbdd\"\nOutput: true\n\nExample 2:\nInput: s = \"bcbddxy\"\nOutput: false\n\nExample 3:\nInput: s = \"abcba\"\nOutput: false\n\nExample 4:\nInput: s = \"aaa\"\nOutput: true\n\nExample 5:\nInput: s = \"abcde\"\nOutput: false", "instruction": "Write a Coffeescript function `isDivisibleIntoThreePalindromes = (s) ->` to solve the following problem:\nGiven a string s, check if it can be divided into three non-empty palindrome substrings.\n@param s A string.\n@return True if s can be divided into three non-empty palindrome substrings, False otherwise.\n\nExample 1:\nInput: s = \"abcbdd\"\nOutput: true\n\nExample 2:\nInput: s = \"bcbddxy\"\nOutput: false\n\nExample 3:\nInput: s = \"abcba\"\nOutput: false\n\nExample 4:\nInput: s = \"aaa\"\nOutput: true\n\nExample 5:\nInput: s = \"abcde\"\nOutput: false", "level": "hard"}
{"task_id": "CoffeeScript/37", "prompt": "# Given an integer num, determine whether it is a perfect number.\n# A perfect number is a positive integer that is equal to the sum of its proper positive divisors.\n# @param num An integer.\n# @return True if num is a perfect number, False otherwise.\n#\n# Example 1:\n# Input: num = 28\n# Output: true\n# Explanation: 28 = 1 + 2 + 4 + 7 + 14\n# 1, 2, 4, 7, and 14 are all the proper positive divisors of 28.\n#\n# Example 2:\n# Input: num = 7\n# Output: false\n#\n# Constraints:\n# 1 <= num <= 10^8\nisPerfectNumber = (num) ->", "canonical_solution": "  return false if num <= 1\n  sum = 1\n  for i in [2..Math.sqrt(num)]\n    if num % i == 0\n      sum += i\n      sum += (num / i) unless i * i == num\n  sum == num", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  # Test cases\n  assertEqual isPerfectNumber(6), true, \"6 should be a perfect number\"\n  assertEqual isPerfectNumber(496), true, \"496 should be a perfect number\"\n  assertEqual isPerfectNumber(8128), true, \"8128 should be a perfect number\"\n  console.log \"All tests passed\"\n  \nmain()", "entry_point": "isPerfectNumber", "signature": "isPerfectNumber = (num) ->", "docstring": "Given an integer num, determine whether it is a perfect number.\nA perfect number is a positive integer that is equal to the sum of its proper positive divisors.\n@param num An integer.\n@return True if num is a perfect number, False otherwise.\n\nExample 1:\nInput: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all the proper positive divisors of 28.\n\nExample 2:\nInput: num = 7\nOutput: false\n\nConstraints:\n1 <= num <= 10^8", "instruction": "Write a Coffeescript function `isPerfectNumber = (num) ->` to solve the following problem:\nGiven an integer num, determine whether it is a perfect number.\nA perfect number is a positive integer that is equal to the sum of its proper positive divisors.\n@param num An integer.\n@return True if num is a perfect number, False otherwise.\n\nExample 1:\nInput: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all the proper positive divisors of 28.\n\nExample 2:\nInput: num = 7\nOutput: false\n\nConstraints:\n1 <= num <= 10^8", "level": "easy"}
{"task_id": "CoffeeScript/38", "prompt": "# Given a valid IPv4 address, return its defanged version.\n# @param address A string representing the IPv4 address.\n# @return The defanged version of the IPv4 address.\n#\n# Example 1:\n# Input: address = \"1.1.1.1\"\n# Output: \"1[.]1[.]1[.]1\"\n#\n# Example 2:\n# Input: address = \"255.100.50.0\"\n# Output: \"255[.]100[.]50[.]0\"\ndefangIPaddr = (address) ->", "canonical_solution": "  # Replace every period '.' with '[.]'\n  address.replace /\\./g, '[.]'", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Tests\nmain = ->\n  assertEqual defangIPaddr(\"192.168.0.1\"), \"192[.]168[.]0[.]1\", \"Test case 1 failed\"\n  assertEqual defangIPaddr(\"172.16.254.1\"), \"172[.]16[.]254[.]1\", \"Test case 2 failed\"\n  assertEqual defangIPaddr(\"10.0.0.1\"), \"10[.]0[.]0[.]1\", \"Test case 3 failed\"\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "defangIPaddr", "signature": "defangIPaddr = (address) ->", "docstring": "Given a valid IPv4 address, return its defanged version.\n@param address A string representing the IPv4 address.\n@return The defanged version of the IPv4 address.\n\nExample 1:\nInput: address = \"1.1.1.1\"\nOutput: \"1[.]1[.]1[.]1\"\n\nExample 2:\nInput: address = \"255.100.50.0\"\nOutput: \"255[.]100[.]50[.]0\"", "instruction": "Write a Coffeescript function `defangIPaddr = (address) ->` to solve the following problem:\nGiven a valid IPv4 address, return its defanged version.\n@param address A string representing the IPv4 address.\n@return The defanged version of the IPv4 address.\n\nExample 1:\nInput: address = \"1.1.1.1\"\nOutput: \"1[.]1[.]1[.]1\"\n\nExample 2:\nInput: address = \"255.100.50.0\"\nOutput: \"255[.]100[.]50[.]0\"", "level": "easy"}
{"task_id": "CoffeeScript/39", "prompt": "# Given a non-empty string s, check if it can be constructed by repeating a substring.\n# @param s A non-empty string.\n# @return True if s can be constructed by repeating a substring, False otherwise.\n#\n# Example 1:\n# Input: s = \"abab\"\n# Output: true\n#\n# Example 2:\n# Input: s = \"aba\"\n# Output: false\n#\n# Example 3:\n# Input: s = \"abcabcabcabc\"\n# Output: true\nisRepeatedSubstring = (s) ->", "canonical_solution": "  return (s + s).indexOf(s, 1) < s.length", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  # Test cases\n  assertEqual(isRepeatedSubstring(\"abcdabcd\"), true, \"Failed on test case 1\")\n  assertEqual(isRepeatedSubstring(\"xyz\"), false, \"Failed on test case 2\")\n  assertEqual(isRepeatedSubstring(\"pppppppp\"), true, \"Failed on test case 3\")\n\n  console.log(\"All tests passed\")\n\nmain()", "entry_point": "isRepeatedSubstring", "signature": "isRepeatedSubstring = (s) ->", "docstring": "Given a non-empty string s, check if it can be constructed by repeating a substring.\n@param s A non-empty string.\n@return True if s can be constructed by repeating a substring, False otherwise.\n\nExample 1:\nInput: s = \"abab\"\nOutput: true\n\nExample 2:\nInput: s = \"aba\"\nOutput: false\n\nExample 3:\nInput: s = \"abcabcabcabc\"\nOutput: true", "instruction": "Write a Coffeescript function `isRepeatedSubstring = (s) ->` to solve the following problem:\nGiven a non-empty string s, check if it can be constructed by repeating a substring.\n@param s A non-empty string.\n@return True if s can be constructed by repeating a substring, False otherwise.\n\nExample 1:\nInput: s = \"abab\"\nOutput: true\n\nExample 2:\nInput: s = \"aba\"\nOutput: false\n\nExample 3:\nInput: s = \"abcabcabcabc\"\nOutput: true", "level": "easy"}
{"task_id": "CoffeeScript/40", "prompt": "# Given two non-negative integers low and high, return the count of odd numbers between low and high (inclusive).\n# @param low A non-negative integer representing the lower bound.\n# @param high A non-negative integer representing the upper bound.\n# @return The count of odd numbers between low and high.\n#\n# Example 1:\n# Input: low = 3, high = 7\n# Output: 3\n# Explanation: The odd numbers between 3 and 7 are [3, 5, 7].\n#\n# Example 2:\n# Input: low = 8, high = 10\n# Output: 1\n# Explanation: The odd number between 8 and 10 is [9].\ncountOddNumbers = (low, high) ->", "canonical_solution": "  count = 0\n  for num in [low..high]\n    count++ if num % 2 isnt 0\n  count", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  assertEqual countOddNumbers(1, 5), 3, \"Test Case 1 Failed\"\n  assertEqual countOddNumbers(10, 20), 5, \"Test Case 2 Failed\"\n  assertEqual countOddNumbers(15, 15), 1, \"Test Case 3 Failed\"\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "countOddNumbers", "signature": "countOddNumbers = (low, high) ->", "docstring": "Given two non-negative integers low and high, return the count of odd numbers between low and high (inclusive).\n@param low A non-negative integer representing the lower bound.\n@param high A non-negative integer representing the upper bound.\n@return The count of odd numbers between low and high.\n\nExample 1:\nInput: low = 3, high = 7\nOutput: 3\nExplanation: The odd numbers between 3 and 7 are [3, 5, 7].\n\nExample 2:\nInput: low = 8, high = 10\nOutput: 1\nExplanation: The odd number between 8 and 10 is [9].", "instruction": "Write a Coffeescript function `countOddNumbers = (low, high) ->` to solve the following problem:\nGiven two non-negative integers low and high, return the count of odd numbers between low and high (inclusive).\n@param low A non-negative integer representing the lower bound.\n@param high A non-negative integer representing the upper bound.\n@return The count of odd numbers between low and high.\n\nExample 1:\nInput: low = 3, high = 7\nOutput: 3\nExplanation: The odd numbers between 3 and 7 are [3, 5, 7].\n\nExample 2:\nInput: low = 8, high = 10\nOutput: 1\nExplanation: The odd number between 8 and 10 is [9].", "level": "easy"}
{"task_id": "CoffeeScript/41", "prompt": "# Given two integers left and right, representing the range [left, right], return the bitwise AND of all the numbers in this range (including the endpoints).\n# @param left An integer representing the left endpoint of the range.\n# @param right An integer representing the right endpoint of the range.\n# @return The bitwise AND of all the numbers in the range.\n#\n# Example 1:\n# Input: left = 5, right = 7\n# Output: 4\n#\n# Example 2:\n# Input: left = 0, right = 0\n# Output: 0\n#\n# Example 3:\n# Input: left = 1, right = 2147483647\n# Output: 0\nbitwiseANDRange = (left, right) ->", "canonical_solution": "  while left < right\n    right = right & (right - 1)\n  return right", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\nmain = ->\n  assertEqual(bitwiseANDRange(10, 15), 8, \"Test case 1 failed\")\n  assertEqual(bitwiseANDRange(12, 17), 0, \"Test case 2 failed\")\n  assertEqual(bitwiseANDRange(19, 24), 16, \"Test case 3 failed\")\n  \n  console.log \"All tests passed\"\n\nmain()", "entry_point": "bitwiseANDRange", "signature": "bitwiseANDRange = (left, right) ->", "docstring": "Given two integers left and right, representing the range [left, right], return the bitwise AND of all the numbers in this range (including the endpoints).\n@param left An integer representing the left endpoint of the range.\n@param right An integer representing the right endpoint of the range.\n@return The bitwise AND of all the numbers in the range.\n\nExample 1:\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\nInput: left = 1, right = 2147483647\nOutput: 0", "instruction": "Write a Coffeescript function `bitwiseANDRange = (left, right) ->` to solve the following problem:\nGiven two integers left and right, representing the range [left, right], return the bitwise AND of all the numbers in this range (including the endpoints).\n@param left An integer representing the left endpoint of the range.\n@param right An integer representing the right endpoint of the range.\n@return The bitwise AND of all the numbers in the range.\n\nExample 1:\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\nInput: left = 1, right = 2147483647\nOutput: 0", "level": "easy"}
{"task_id": "CoffeeScript/42", "prompt": "# Given an integer n, return the number of unique binary search trees that can be formed using n nodes.\n# The nodes are labeled from 1 to n.\n# @param n An integer representing the number of nodes.\n# @return The number of unique binary search trees.\n#\n# Example 1:\n# Input: n = 3\n# Output: 5\n#\n# Example 2:\n# Input: n = 1\n# Output: 1\nnumTrees = (n) ->", "canonical_solution": "  binomialCoefficient(2 * n, n) / (n + 1)\n  \n# Helper function to calculate factorial\nfactorial = (n) ->\n  result = 1\n  result *= i for i in [n..1]\n  result\n\n# Helper function to calculate binomial coefficient\nbinomialCoefficient = (n, k) ->\n  factorial(n) / (factorial(k) * factorial(n - k))\n", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Testing the numTrees function with 3 different test cases\nmain = ->\n  assertEqual(numTrees(3), 5, \"Test case 1 failed\")\n  assertEqual(numTrees(1), 1, \"Test case 2 failed\")\n  assertEqual(numTrees(4), 14, \"Test case 3 failed\")\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "numTrees", "signature": "numTrees = (n) ->", "docstring": "Given an integer n, return the number of unique binary search trees that can be formed using n nodes.\nThe nodes are labeled from 1 to n.\n@param n An integer representing the number of nodes.\n@return The number of unique binary search trees.\n\nExample 1:\nInput: n = 3\nOutput: 5\n\nExample 2:\nInput: n = 1\nOutput: 1", "instruction": "Write a Coffeescript function `numTrees = (n) ->` to solve the following problem:\nGiven an integer n, return the number of unique binary search trees that can be formed using n nodes.\nThe nodes are labeled from 1 to n.\n@param n An integer representing the number of nodes.\n@return The number of unique binary search trees.\n\nExample 1:\nInput: n = 3\nOutput: 5\n\nExample 2:\nInput: n = 1\nOutput: 1", "level": "middle"}
{"task_id": "CoffeeScript/43", "prompt": "# Given a non-negative integer c, determine if there are two integers a and b such that a^2 + b^2 = c.\n# @param c A non-negative integer.\n# @return A boolean value indicating whether there are two integers a and b such that a^2 + b^2 = c.\n#\n# Example 1:\n# Input: c = 5\n# Output: true\n#\n# Example 2:\n# Input: c = 3\n# Output: false\n#\n# Constraints:\n# 0 <= c <= 231 - 1\nisSumOfSquares = (c) ->", "canonical_solution": "  return false if c < 0\n  i = 0\n  while i * i <= c\n    b = Math.sqrt(c - i * i)\n    return true if b == Math.floor(b)\n    i++\n  return false", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test cases\nmain = ->\n  assertEqual(isSumOfSquares(10), true, \"10 is a sum of two squares\")\n  assertEqual(isSumOfSquares(11), false, \"8 is not a sum of two squares\")\n  assertEqual(isSumOfSquares(50), true, \"50 is a sum of two squares\")\n  console.log \"All tests passed\"\n\n# Run the test cases\nmain()  ", "entry_point": "isSumOfSquares", "signature": "isSumOfSquares = (c) ->", "docstring": "Given a non-negative integer c, determine if there are two integers a and b such that a^2 + b^2 = c.\n@param c A non-negative integer.\n@return A boolean value indicating whether there are two integers a and b such that a^2 + b^2 = c.\n\nExample 1:\nInput: c = 5\nOutput: true\n\nExample 2:\nInput: c = 3\nOutput: false\n\nConstraints:\n0 <= c <= 231 - 1", "instruction": "Write a Coffeescript function `isSumOfSquares = (c) ->` to solve the following problem:\nGiven a non-negative integer c, determine if there are two integers a and b such that a^2 + b^2 = c.\n@param c A non-negative integer.\n@return A boolean value indicating whether there are two integers a and b such that a^2 + b^2 = c.\n\nExample 1:\nInput: c = 5\nOutput: true\n\nExample 2:\nInput: c = 3\nOutput: false\n\nConstraints:\n0 <= c <= 231 - 1", "level": "easy"}
{"task_id": "CoffeeScript/44", "prompt": "# Given a non-decreasing sorted integer array, find the integer that appears more than 25% of the total number of elements in the array.\n# @param arr A non-decreasing sorted integer array.\n# @return The integer that appears more than 25% of the total number of elements in the array.\n#\n# Example:\n# Input: arr = [1,2,2,6,6,6,6,7,10]\n# Output: 6\n#\nfindSpecialInteger = (arr) ->", "canonical_solution": "  threshold = arr.length / 4\n  count = 1\n  for i in [1...arr.length]\n    if arr[i] == arr[i - 1]\n      count++\n      if count > threshold\n        return arr[i]\n    else\n      count = 1\n  return arr[0]", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual == expected\nmain = ->\n  # Test Case 1\n  testArr1 = [1,1,2,2,3,3,3,3]\n  assertEqual(findSpecialInteger(testArr1), 3)\n\n  # Test Case 2\n  testArr2 = [1]\n  assertEqual(findSpecialInteger(testArr2), 1)\n\n  # Test Case 3\n  testArr3 = [10,10,10,20,30,30,30,30,40,50,50,60,70,80,90]\n  assertEqual(findSpecialInteger(testArr3), 30)\n\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "findSpecialInteger", "signature": "findSpecialInteger = (arr) ->", "docstring": "Given a non-decreasing sorted integer array, find the integer that appears more than 25% of the total number of elements in the array.\n@param arr A non-decreasing sorted integer array.\n@return The integer that appears more than 25% of the total number of elements in the array.\n\nExample:\nInput: arr = [1,2,2,6,6,6,6,7,10]\nOutput: 6", "instruction": "Write a Coffeescript function `findSpecialInteger = (arr) ->` to solve the following problem:\nGiven a non-decreasing sorted integer array, find the integer that appears more than 25% of the total number of elements in the array.\n@param arr A non-decreasing sorted integer array.\n@return The integer that appears more than 25% of the total number of elements in the array.\n\nExample:\nInput: arr = [1,2,2,6,6,6,6,7,10]\nOutput: 6", "level": "easy"}
{"task_id": "CoffeeScript/45", "prompt": "# Given an array of integers nums, return the minimum number of operations required to make all elements in the array equal.\n# In one operation, you can either increment or decrement one element in the array.\n# @param nums An array of integers.\n# @return The minimum number of operations required.\n#\n# Example 1:\n# Input: nums = [1,2,3]\n# Output: 2\n#\n# Example 2:\n# Input: nums = [1,10,2,9]\n# Output: 16\n#\n# Example 3:\n# Input: nums = [5,5,5,5]\n# Output: 0\nminOperations = (nums) ->", "canonical_solution": "  nums.sort (a, b) -> a - b\n  mid = nums[Math.floor(nums.length / 2)]\n  nums.reduce ((acc, num) -> acc + Math.abs(num - mid)), 0", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless actual is expected\n# Test cases\nmain = ->\n  assertEqual(minOperations([3,1,10]), 9, \"Example case 1 failed\")\n  assertEqual(minOperations([8,8,8,8,9]), 1, \"Example case 2 failed\")\n  assertEqual(minOperations([0,0,3,4]), 7, \"Example case 3 failed\")\n  console.log(\"All tests passed\")\n\n# Run the test cases    \nmain()", "entry_point": "minOperations", "signature": "minOperations = (nums) ->", "docstring": "Given an array of integers nums, return the minimum number of operations required to make all elements in the array equal.\nIn one operation, you can either increment or decrement one element in the array.\n@param nums An array of integers.\n@return The minimum number of operations required.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\n\nExample 2:\nInput: nums = [1,10,2,9]\nOutput: 16\n\nExample 3:\nInput: nums = [5,5,5,5]\nOutput: 0", "instruction": "Write a Coffeescript function `minOperations = (nums) ->` to solve the following problem:\nGiven an array of integers nums, return the minimum number of operations required to make all elements in the array equal.\nIn one operation, you can either increment or decrement one element in the array.\n@param nums An array of integers.\n@return The minimum number of operations required.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\n\nExample 2:\nInput: nums = [1,10,2,9]\nOutput: 16\n\nExample 3:\nInput: nums = [5,5,5,5]\nOutput: 0", "level": "easy"}
{"task_id": "CoffeeScript/46", "prompt": "#  Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n#  @param nums An integer array where every element appears three times except for one.\n#  @return The element that appears only once.\n\n#  Example:\n#  singleNumber(new int[]{2,2,3,2})\n#  Output: 3\n\n#  Example:\n#  singleNumber(new int[]{0,1,0,1,0,1,99})\n#  Output: 99\nsingleNumber = (nums) ->", "canonical_solution": "  frequencyMap = {}\n  for num in nums\n    frequencyMap[num] = (frequencyMap[num] || 0) + 1\n\n  for num, count of frequencyMap\n    return parseInt(num, 10) if count is 1\n\n  # If function reaches this point, input does not meet the problem statement\n  throw new Error(\"No element appears only once.\")", "test": "# Define the custom AssertionError class\nclass AssertionError extends Error\n\n# Define the assert equal function\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless JSON.stringify(actual) is JSON.stringify(expected)\n# Testing the function using assert\nmain = ->\n  assertEqual singleNumber([6, 1, 6, 6]), 1, \"Test case 1 failed\"\n  assertEqual singleNumber([22, 22, 22, 11, 11, 11, 55]), 55, \"Test case 2 failed\"\n  assertEqual singleNumber([-1, 3, -1, 3, -1, 3, 99]), 99, \"Test case 3 failed\"\n  console.log \"All tests passed\"\n\n# Run the tests\nmain()", "entry_point": "singleNumber", "signature": "singleNumber = (nums) ->", "docstring": "Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99", "instruction": "Write a Coffeescript function `singleNumber = (nums) ->` to solve the following problem:\nGiven an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99", "level": "hard"}
{"task_id": "CoffeeScript/47", "prompt": "###\n Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n\n @param n An integer representing the upper limit.\n @return The number of times the digit 1 appears.\n\n Example:\n countDigitOne(13)\n Output: 6\n\n Example:\n countDigitOne(0)\n Output: 0\n###\ncountDigitOne = (n) ->", "canonical_solution": "  count = 0\n  k = 1\n  while k <= n\n    divider = k * 10\n    count += Math.floor(n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k)\n    k *= 10\n  count", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless JSON.stringify(actual) is JSON.stringify(expected) \n\n# Test cases\nassertEqual countDigitOne(20), 12, \"Test case 1 failed\"\nassertEqual countDigitOne(55), 16, \"Test case 2 failed\"\nassertEqual countDigitOne(99), 20, \"Test case 3 failed\"\nconsole.log 'All tests passed'", "entry_point": "countDigitOne", "signature": "countDigitOne = (n) ->", "docstring": "Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n\n @param n An integer representing the upper limit.\n @return The number of times the digit 1 appears.\n\n Example:\n countDigitOne(13)\n Output: 6\n\n Example:\n countDigitOne(0)\n Output: 0", "instruction": "Write a Coffeescript function `countDigitOne = (n) ->` to solve the following problem:\nCalculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n\n @param n An integer representing the upper limit.\n @return The number of times the digit 1 appears.\n\n Example:\n countDigitOne(13)\n Output: 6\n\n Example:\n countDigitOne(0)\n Output: 0", "level": "easy"}
{"task_id": "CoffeeScript/48", "prompt": "# Given an integer n, determine if it is a power of two.\n# If it is, return true; otherwise, return false.\n# A number n is a power of two if there exists an integer x such that n == 2^x.\n\n# @param n The integer to be checked.\n# @return True if n is a power of two, false otherwise.\n#\n# Example:\n# isPowerOfTwo(1)\n# Output: true\n#\n# Example:\n# isPowerOfTwo(16)\n# Output: true\n#\n# Example:\n# isPowerOfTwo(3)\n# Output: false\n#\n# Example:\n# isPowerOfTwo(4)\n# Output: true\n#\n# Example:\n# isPowerOfTwo(5)\n# Output: false\n\nisPowerOfTwo = (n) ->", "canonical_solution": "  return false if n <= 0\n  n /= 2 while n % 2 == 0\n  n == 1", "test": "# AssertionError class\nclass AssertionError extends Error\n\n# Assert function\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless JSON.stringify(actual) is JSON.stringify(expected) \n# Test cases using assert function\nmain = ->\n  assertEqual isPowerOfTwo(1024), true, \"1024 is 2^10\"\n  assertEqual isPowerOfTwo(65536), true, \"65536 is 2^16\"\n  assertEqual isPowerOfTwo(14), false, \"14 is not a power of two\"\n\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "isPowerOfTwo", "signature": "isPowerOfTwo = (n) ->", "docstring": "Given an integer n, determine if it is a power of two.\nIf it is, return true; otherwise, return false.\nA number n is a power of two if there exists an integer x such that n == 2^x.\n\n@param n The integer to be checked.\n@return True if n is a power of two, false otherwise.\n\nExample:\nisPowerOfTwo(1)\nOutput: true\n\nExample:\nisPowerOfTwo(16)\nOutput: true\n\nExample:\nisPowerOfTwo(3)\nOutput: false\n\nExample:\nisPowerOfTwo(4)\nOutput: true\n\nExample:\nisPowerOfTwo(5)\nOutput: false", "instruction": "Write a Coffeescript function `isPowerOfTwo = (n) ->` to solve the following problem:\nGiven an integer n, determine if it is a power of two.\nIf it is, return true; otherwise, return false.\nA number n is a power of two if there exists an integer x such that n == 2^x.\n\n@param n The integer to be checked.\n@return True if n is a power of two, false otherwise.\n\nExample:\nisPowerOfTwo(1)\nOutput: true\n\nExample:\nisPowerOfTwo(16)\nOutput: true\n\nExample:\nisPowerOfTwo(3)\nOutput: false\n\nExample:\nisPowerOfTwo(4)\nOutput: true\n\nExample:\nisPowerOfTwo(5)\nOutput: false", "level": "easy"}
{"task_id": "CoffeeScript/49", "prompt": "# Given a non-negative integer num, repeatedly add all its digits until\n# the result is a single digit. Return the result.\n#\n# @param num The non-negative integer to perform the operation on.\n# @return The single digit result after repeatedly adding all digits.\n#\n# Example:\n# addDigits(38)\n# Output: 2\n\naddDigits = (num) ->", "canonical_solution": "  num = sumOfDigits(num) while num >= 10\n  num\n\nsumOfDigits = (num) ->\n  sum = 0\n  while num > 0\n    sum += num % 10 # adds the last digit to the sum\n    num = Math.floor(num / 10) # removes the last digit\n  sum", "test": "class AssertionError extends Error\n\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) if JSON.stringify(actual) isnt JSON.stringify(expected)\n\n# Test cases using assert function\nmain = ->\n  assertEqual(addDigits(123), 6, \"Test case 1 failed\")\n  assertEqual(addDigits(59), 5, \"Test case 2 failed\")\n  assertEqual(addDigits(0), 0, \"Test case 3 failed\")\n  console.log(\"All tests passed\")\n\n\nmain()", "entry_point": "addDigits", "signature": "addDigits = (num) ->", "docstring": "Given a non-negative integer num, repeatedly add all its digits until\nthe result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2", "instruction": "Write a Coffeescript function `addDigits = (num) ->` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until\nthe result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2", "level": "easy"}
{"task_id": "CoffeeScript/50", "prompt": "# Given an integer n, return the minimum number of perfect square numbers that sum up to n.\nminPerfectSquareSum = (n) ->", "canonical_solution": "  dp = [0..n]\n  for i in [1..n]\n    dp[i] = Infinity\n    for j in [1..Math.sqrt(i)]\n      j = Math.floor(j)\n      dp[i] = Math.min(dp[i], dp[i - j*j] + 1) if j*j <= i\n  dp[n]", "test": "# Custom AssertionError class for testing\nclass AssertionError extends Error\n\n# Custom assert function for testing equality of actual and expected values\nassertEqual = (actual, expected, message = null) ->\n  throw new AssertionError(message) unless JSON.stringify(actual) is JSON.stringify(expected) \n\n\n# Test cases using assert function\nmain = ->\n  assertEqual minPerfectSquareSum(26), 2, \"Test case 1 failed\"\n  assertEqual minPerfectSquareSum(17), 2, \"Test case 2 failed\"\n  assertEqual minPerfectSquareSum(99), 3, \"Test case 3 failed\"\n  console.log \"All tests passed\"\n\nmain()", "entry_point": "minPerfectSquareSum", "signature": "minPerfectSquareSum = (n) ->", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.", "instruction": "Write a Coffeescript function `minPerfectSquareSum = (n) ->` to solve the following problem:\nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.", "level": "easy"}
