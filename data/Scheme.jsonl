{"task_id": "Scheme/1", "prompt": "#lang racket \n(require rackunit)\n(define (abs x)\n(if (< x 0) (- x) x))\n\n(define (has-close-elements numbers threshold)\n#|\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n|#", "canonical_solution": "(define (distance-close? x rest threshold)\n(if (null? rest)\n#f\n(if (< (abs (- x (car rest))) threshold)\n#t\n(distance-close? x (cdr rest) threshold))))\n(define (iter elements)\n(if (null? elements)\n#f\n(if (distance-close? (car elements) (cdr elements) threshold)\n#t\n(iter (cdr elements)))))\n(iter numbers))", "test": ";; Test cases\n(define (check has-close-elements)\n(check-equal? (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)\n(check-not-equal? (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #t)\n(check-equal? (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) #t)\n(check-not-equal? (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) #t)\n(check-equal? (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)\n(check-equal? (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) #t)\n(check-not-equal? (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) #t))\n\n(check has-close-elements)", "entry_point": "has-close-elements", "signature": "(define (has-close-elements", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Write a Scheme function `(define (has-close-elements` to solve the following problem:\n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "level": "easy"}
{"task_id": "Scheme/2", "prompt": "#lang racket\n(require rackunit)\n\n(define (remove-duplicates nums)\n#|\nRemoves duplicate elements from a non-strictly increasing list 'nums' and returns\nthe new length of the list. Elements' relative order is maintained.\nExamples:\n>>> remove-duplicates([1, 2, 2, 3])\n3\n>>> remove-duplicates([1, 1, 1, 1])\n1\n>>> remove-duplicates([1, 2, 3, 3, 4])\n4\n|#", "canonical_solution": "(define (iter elements unique)\n(if (null? elements)\nunique\n(let ((current (car elements)))\n(if (member current unique)\n(iter (cdr elements) unique)\n(iter (cdr elements) (append unique (list current)))))))\n(length (iter nums '())))", "test": "(define (check remove-duplicates)\n(check-equal? (remove-duplicates '(1 2 2 3)) 3)\n(check-equal? (remove-duplicates '(1 1 1 1)) 1)\n(check-equal? (remove-duplicates '(1 2 3 3 4)) 4)\n(check-equal? (remove-duplicates '(4 4 4 4 4 4 4)) 1)\n(check-equal? (remove-duplicates '(1 2 2 2 3 3 3 4 4 5 5 5 6)) 6)\n(check-not-equal? (remove-duplicates '(1 2 3 4 5)) 4))\n\n(check remove-duplicates)", "entry_point": "remove-duplicates", "signature": "(define (remove-duplicates", "docstring": "\nRemoves duplicate elements from a non-strictly increasing list 'nums' and returns\nthe new length of the list. Elements' relative order is maintained.\nExamples:\n>>> remove-duplicates([1, 2, 2, 3])\n3\n>>> remove-duplicates([1, 1, 1, 1])\n1\n>>> remove-duplicates([1, 2, 3, 3, 4])\n4\n", "instruction": "Write a Scheme function `(define (remove-duplicates` to solve the following problem:\n\nRemoves duplicate elements from a non-strictly increasing list 'nums' and returns\nthe new length of the list. Elements' relative order is maintained.\nExamples:\n>>> remove-duplicates([1, 2, 2, 3])\n3\n>>> remove-duplicates([1, 1, 1, 1])\n1\n>>> remove-duplicates([1, 2, 3, 3, 4])\n4\n", "level": "easy"}
{"task_id": "Scheme/3", "prompt": "#lang racket\n(require rackunit)\n\n(define (roman-to-int roman)\n#|\nConverts a Roman numeral to an integer.\nExamples:\n>>> roman-to-int(\"III\")\n3\n>>> roman-to-int(\"IV\")\n4\n>>> roman-to-int(\"IX\")\n9\n>>> roman-to-int(\"LVIII\")\n58\n>>> roman-to-int(\"MCMXCIV\")\n1994\n|#", "canonical_solution": "(define roman-values\n(hash \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000))\n(define (iter chars sum)\n(if (null? chars)\nsum\n(let ((current (hash-ref roman-values (string (car chars)) 0)))\n(if (and (pair? (cdr chars))\n(let ((next (hash-ref roman-values (string (cadr chars)) 0)))\n(> next current)))\n(iter (cddr chars) (+ sum (- (hash-ref roman-values (string (cadr chars)) 0) current)))\n(iter (cdr chars) (+ sum current))))))\n(iter (string->list roman) 0))\n", "test": ";; Test cases\n(define (check roman-to-int)\n(check-equal? (roman-to-int \"III\") 3)\n(check-equal? (roman-to-int \"IV\") 4)\n(check-equal? (roman-to-int \"IX\") 9)\n(check-equal? (roman-to-int \"LVIII\") 58)\n(check-equal? (roman-to-int \"MCMXCIV\") 1994)\n(check-equal? (roman-to-int \"MCDXLIV\") 1444)\n)\n\n(check roman-to-int)", "entry_point": "roman-to-int", "signature": "(define (roman-to-int", "docstring": "\nConverts a Roman numeral to an integer.\nExamples:\n>>> roman-to-int(\"III\")\n3\n>>> roman-to-int(\"IV\")\n4\n>>> roman-to-int(\"IX\")\n9\n>>> roman-to-int(\"LVIII\")\n58\n>>> roman-to-int(\"MCMXCIV\")\n1994\n", "instruction": "Write a Scheme function `(define (roman-to-int` to solve the following problem:\n\nConverts a Roman numeral to an integer.\nExamples:\n>>> roman-to-int(\"III\")\n3\n>>> roman-to-int(\"IV\")\n4\n>>> roman-to-int(\"IX\")\n9\n>>> roman-to-int(\"LVIII\")\n58\n>>> roman-to-int(\"MCMXCIV\")\n1994\n", "level": "hard"}
{"task_id": "Scheme/4", "prompt": "#lang racket\n(require rackunit)\n\n(define (longest-common-prefix strs)\n#|\nFinds the longest common prefix among a list of strings.\nReturns an empty string if there is no common prefix.\nExamples:\n>>> longest-common-prefix([\"flower\", \"flow\", \"flight\"])\n\"fl\"\n>>> longest-common-prefix([\"dog\", \"racecar\", \"car\"])\n\"\"\n>>> longest-common-prefix([\"interspecies\", \"interstellar\", \"interstate\"])\n\"inters\"\n|#", "canonical_solution": "(define (common-prefix a b)\n(let loop ((prefix \"\")\n(chars-a (string->list a))\n(chars-b (string->list b)))\n(if (and (not (null? chars-a)) (not (null? chars-b)) (eq? (car chars-a) (car chars-b)))\n(loop (string-append prefix (string (car chars-a))) (cdr chars-a) (cdr chars-b))\nprefix)))\n(if (null? strs)\n\"\"\n(foldl common-prefix (car strs) (cdr strs))))", "test": "(define (check longest-common-prefix)\n(check-equal? (longest-common-prefix '(\"flower\" \"flow\" \"flight\")) \"fl\")\n(check-equal? (longest-common-prefix '(\"dog\" \"racecar\" \"car\")) \"\")\n(check-equal? (longest-common-prefix '(\"interspecies\" \"interstellar\" \"interstate\")) \"inters\")\n(check-equal? (longest-common-prefix '(\"hello\")) \"hello\")\n(check-equal? (longest-common-prefix '()) \"\")\n(check-equal? (longest-common-prefix '(\"prefix\" \"precalculate\" \"precarious\" \"presume\")) \"pre\"))\n\n(check longest-common-prefix)", "entry_point": "longest-common-prefix", "signature": "(define (longest-common-prefix", "docstring": "\nFinds the longest common prefix among a list of strings.\nReturns an empty string if there is no common prefix.\nExamples:\n>>> longest-common-prefix([\"flower\", \"flow\", \"flight\"])\n\"fl\"\n>>> longest-common-prefix([\"dog\", \"racecar\", \"car\"])\n\"\"\n>>> longest-common-prefix([\"interspecies\", \"interstellar\", \"interstate\"])\n\"inters\"\n", "instruction": "Write a Scheme function `(define (longest-common-prefix` to solve the following problem:\n\nFinds the longest common prefix among a list of strings.\nReturns an empty string if there is no common prefix.\nExamples:\n>>> longest-common-prefix([\"flower\", \"flow\", \"flight\"])\n\"fl\"\n>>> longest-common-prefix([\"dog\", \"racecar\", \"car\"])\n\"\"\n>>> longest-common-prefix([\"interspecies\", \"interstellar\", \"interstate\"])\n\"inters\"\n", "level": "middle"}
{"task_id": "Scheme/5", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-substring haystack needle)\n#|\nFinds the first occurrence of the substring 'needle' in the string 'haystack'.\nReturns the index of the first match, or -1 if 'needle' is not a part of 'haystack'.\nExamples:\n>>> find-substring(\"hello\" \"ll\")\n2\n>>> find-substring(\"aaaaa\" \"bba\")\n-1\n>>> find-substring(\"abc\" \"c\")\n2\n|#", "canonical_solution": "(define (substring-at? haystack needle start)\n(and (<= (+ start (string-length needle)) (string-length haystack))\n(string=? (substring haystack start (+ start (string-length needle))) needle)))\n(define (iter haystack needle index)\n(if (> index (- (string-length haystack) (string-length needle)))\n-1\n(if (substring-at? haystack needle index)\nindex\n(iter haystack needle (+ index 1)))))\n(if (> (string-length needle) (string-length haystack))\n-1\n(iter haystack needle 0)))", "test": "(define (check find-substring)\n(check-equal? (find-substring \"hello\" \"ll\") 2)\n(check-equal? (find-substring \"aaaaa\" \"bba\") -1)\n(check-equal? (find-substring \"abc\" \"c\") 2)\n(check-equal? (find-substring \"haystack\" \"stack\") 3)\n(check-equal? (find-substring \"needle\" \"needle\") 0)\n(check-equal? (find-substring \"short\" \"longneedle\") -1))\n\n(check find-substring)", "entry_point": "find-substring", "signature": "(define (find-substring", "docstring": "\nFinds the first occurrence of the substring 'needle' in the string 'haystack'.\nReturns the index of the first match, or -1 if 'needle' is not a part of 'haystack'.\nExamples:\n>>> find-substring(\"hello\" \"ll\")\n2\n>>> find-substring(\"aaaaa\" \"bba\")\n-1\n>>> find-substring(\"abc\" \"c\")\n2\n", "instruction": "Write a Scheme function `(define (find-substring` to solve the following problem:\n\nFinds the first occurrence of the substring 'needle' in the string 'haystack'.\nReturns the index of the first match, or -1 if 'needle' is not a part of 'haystack'.\nExamples:\n>>> find-substring(\"hello\" \"ll\")\n2\n>>> find-substring(\"aaaaa\" \"bba\")\n-1\n>>> find-substring(\"abc\" \"c\")\n2\n", "level": "hard"}
{"task_id": "Scheme/6", "prompt": "#lang racket\n(require rackunit)\n\n(define (length-of-last-word s)\n#|\nReturns the length of the last word in a string 's'. \nA word is defined as a maximum substring consisting only of letters and not containing any space characters.\nExamples:\n>>> length-of-last-word(\"Hello World\")\n5\n>>> length-of-last-word(\" fly me to the moon \")\n4\n>>> length-of-last-word(\"luffy is still joyboy\")\n6\n|#", "canonical_solution": "(define (reverse lst)\n(foldl (lambda (item acc) (cons item acc)) '() lst))\n(define (split-into-words str)\n(let loop ((chars (string->list str)) (word '()) (words '()))\n(cond\n((null? chars) (if (null? word) words (cons (reverse word) words)))\n((char=? (car chars) #\\space) (if (null? word)\n(loop (cdr chars) word words)\n(loop (cdr chars) '() (cons (reverse word) words))))\n(else (loop (cdr chars) (cons (car chars) word) words)))))\n(let ((words (split-into-words s)))\n(if (null? words)\n0\n(length (car words)))))", "test": "(define (check length-of-last-word)\n(check-equal? (length-of-last-word \"Hello World\") 5)\n(check-equal? (length-of-last-word \" fly me to the moon \") 4)\n(check-equal? (length-of-last-word \"luffy is still joyboy\") 6)\n(check-equal? (length-of-last-word \"single\") 6)\n(check-equal? (length-of-last-word \" \") 0)\n(check-equal? (length-of-last-word \"\") 0))\n\n(check length-of-last-word)", "entry_point": "length-of-last-word", "signature": "(define (length-of-last-word", "docstring": "\nReturns the length of the last word in a string 's'. \nA word is defined as a maximum substring consisting only of letters and not containing any space characters.\nExamples:\n>>> length-of-last-word(\"Hello World\")\n5\n>>> length-of-last-word(\" fly me to the moon \")\n4\n>>> length-of-last-word(\"luffy is still joyboy\")\n6\n", "instruction": "Write a Scheme function `(define (length-of-last-word` to solve the following problem:\n\nReturns the length of the last word in a string 's'. \nA word is defined as a maximum substring consisting only of letters and not containing any space characters.\nExamples:\n>>> length-of-last-word(\"Hello World\")\n5\n>>> length-of-last-word(\" fly me to the moon \")\n4\n>>> length-of-last-word(\"luffy is still joyboy\")\n6\n", "level": "hard"}
{"task_id": "Scheme/7", "prompt": "#lang racket\n(require rackunit)\n\n(define (add-binary a b)\n#|\nAdds two binary strings a and b, returning the sum as a binary string.\nExamples:\n>>> add-binary(\"11\" \"1\")\n\"100\"\n>>> add-binary(\"1010\" \"1011\")\n\"10101\"\n>>> add-binary(\"0\" \"0\")\n\"0\"\n|#", "canonical_solution": "(define (binary-to-integer binary-string)\n(foldl (lambda (char sum) (+ (* sum 2) (if (char=? char #\\1) 1 0)))\n0 (string->list binary-string)))\n(define (integer-to-binary integer)\n(if (= integer 0)\n\"0\"\n(let loop ((n integer) (acc \"\"))\n(if (= n 0)\nacc\n(loop (quotient n 2) (string-append (if (odd? n) \"1\" \"0\") acc))))))\n(integer-to-binary (+ (binary-to-integer a) (binary-to-integer b))))", "test": "(define (check add-binary)\n(check-equal? (add-binary \"11\" \"1\") \"100\")\n(check-equal? (add-binary \"1010\" \"1011\") \"10101\")\n(check-equal? (add-binary \"0\" \"0\") \"0\")\n(check-equal? (add-binary \"111\" \"111\") \"1110\")\n(check-equal? (add-binary \"1\" \"111\") \"1000\")\n(check-equal? (add-binary \"1001\" \"1101\") \"10110\"))\n\n(check add-binary)", "entry_point": "add-binary", "signature": "(define (add-binary", "docstring": "\nAdds two binary strings a and b, returning the sum as a binary string.\nExamples:\n>>> add-binary(\"11\" \"1\")\n\"100\"\n>>> add-binary(\"1010\" \"1011\")\n\"10101\"\n>>> add-binary(\"0\" \"0\")\n\"0\"\n", "instruction": "Write a Scheme function `(define (add-binary` to solve the following problem:\n\nAdds two binary strings a and b, returning the sum as a binary string.\nExamples:\n>>> add-binary(\"11\" \"1\")\n\"100\"\n>>> add-binary(\"1010\" \"1011\")\n\"10101\"\n>>> add-binary(\"0\" \"0\")\n\"0\"\n", "level": "middle"}
{"task_id": "Scheme/8", "prompt": "#lang racket\n(require rackunit)\n\n(define (is-palindrome s)\n#|\nChecks if a string 's' is a palindrome after converting all uppercase characters to lowercase\nand removing all non-alphanumeric characters. Returns true if it is a palindrome, false otherwise.\nExamples:\n>>> is-palindrome(\"A man, a plan, a canal: Panama\")\n#t\n>>> is-palindrome(\"race a car\")\n#f\n>>> is-palindrome(\" \")\n#t\n|#", "canonical_solution": "(define (alphanumeric? char)\n(or (char-numeric? char) (char-alphabetic? char)))\n(define (process-string str)\n(list->string (filter alphanumeric? (map char-downcase (string->list str)))))\n(define (reverse-string str)\n(list->string (reverse (string->list str))))\n(define processed-str (process-string s))\n(string=? processed-str (reverse-string processed-str)))", "test": "(define (check is-palindrome)\n(check-equal? (is-palindrome \"A man, a plan, a canal: Panama\") #t)\n(check-equal? (is-palindrome \"race a car\") #f)\n(check-equal? (is-palindrome \" \") #t)\n(check-equal? (is-palindrome \"No lemon, no melon\") #t)\n(check-equal? (is-palindrome \"Red rum, sir, is murder\") #t)\n(check-equal? (is-palindrome \"Was it a car or a cat I saw\") #t)\n(check-equal? (is-palindrome \"Madam, in Eden, I'm Adam\") #t)\n(check-not-equal? (is-palindrome \"Example\") #t))\n\n(check is-palindrome)", "entry_point": "is-palindrome", "signature": "(define (is-palindrome", "docstring": "\nChecks if a string 's' is a palindrome after converting all uppercase characters to lowercase\nand removing all non-alphanumeric characters. Returns true if it is a palindrome, false otherwise.\nExamples:\n>>> is-palindrome(\"A man, a plan, a canal: Panama\")\n#t\n>>> is-palindrome(\"race a car\")\n#f\n>>> is-palindrome(\" \")\n#t\n", "instruction": "Write a Scheme function `(define (is-palindrome` to solve the following problem:\n\nChecks if a string 's' is a palindrome after converting all uppercase characters to lowercase\nand removing all non-alphanumeric characters. Returns true if it is a palindrome, false otherwise.\nExamples:\n>>> is-palindrome(\"A man, a plan, a canal: Panama\")\n#t\n>>> is-palindrome(\"race a car\")\n#f\n>>> is-palindrome(\" \")\n#t\n", "level": "middle"}
{"task_id": "Scheme/9", "prompt": "#lang racket\n(require rackunit)\n\n(define (number-to-column columnNumber)\n#|\nConverts an integer to its corresponding Excel column name.\nExamples:\n>>> number-to-column(1)\n\"A\"\n>>> number-to-column(28)\n\"AB\"\n>>> number-to-column(701)\n\"ZY\"\n|#", "canonical_solution": "(define (iter n acc)\n(if (= n 0)\nacc\n(let ((mod (modulo (- n 1) 26)))\n(iter (quotient (- n (add1 mod)) 26)\n(string-append (string (integer->char (+ mod 65))) acc)))))\n(iter columnNumber \"\"))", "test": "(define (check number-to-column)\n(check-equal? (number-to-column 1) \"A\")\n(check-equal? (number-to-column 28) \"AB\")\n(check-equal? (number-to-column 701) \"ZY\")\n(check-equal? (number-to-column 52) \"AZ\")\n(check-equal? (number-to-column 705) \"AAC\")\n(check-equal? (number-to-column 26) \"Z\")\n(check-equal? (number-to-column 27) \"AA\"))\n\n(check number-to-column)", "entry_point": "number-to-column", "signature": "(define (number-to-column", "docstring": "\nConverts an integer to its corresponding Excel column name.\nExamples:\n>>> number-to-column(1)\n\"A\"\n>>> number-to-column(28)\n\"AB\"\n>>> number-to-column(701)\n\"ZY\"\n", "instruction": "Write a Scheme function `(define (number-to-column` to solve the following problem:\n\nConverts an integer to its corresponding Excel column name.\nExamples:\n>>> number-to-column(1)\n\"A\"\n>>> number-to-column(28)\n\"AB\"\n>>> number-to-column(701)\n\"ZY\"\n", "level": "easy"}
{"task_id": "Scheme/10", "prompt": "#lang racket\n(require rackunit)\n\n(define (reverse-string s)\n#|\nReverses the input string s.\nExamples:\n>>> reverse-string(\"hello\")\n\"olleh\"\n>>> reverse-string(\"world\")\n\"dlrow\"\n>>> reverse-string(\"\")\n\"\"\n|#", "canonical_solution": "(list->string (reverse (string->list s))))", "test": "(define (check reverse-string)\n(check-equal? (reverse-string \"hello\") \"olleh\")\n(check-equal? (reverse-string \"world\") \"dlrow\")\n(check-equal? (reverse-string \"\") \"\")\n(check-equal? (reverse-string \"a\") \"a\")\n(check-equal? (reverse-string \"racecar\") \"racecar\")\n(check-equal? (reverse-string \"Scheme\") \"emehcS\"))\n\n(check reverse-string)", "entry_point": "reverse-string", "signature": "(define (reverse-string", "docstring": "\nReverses the input string s.\nExamples:\n>>> reverse-string(\"hello\")\n\"olleh\"\n>>> reverse-string(\"world\")\n\"dlrow\"\n>>> reverse-string(\"\")\n\"\"\n", "instruction": "Write a Scheme function `(define (reverse-string` to solve the following problem:\n\nReverses the input string s.\nExamples:\n>>> reverse-string(\"hello\")\n\"olleh\"\n>>> reverse-string(\"world\")\n\"dlrow\"\n>>> reverse-string(\"\")\n\"\"\n", "level": "easy"}
{"task_id": "Scheme/11", "prompt": "#lang racket\n(require rackunit)\n\n(define (add-one digits)\n#|\nAdds one to the non-negative integer represented by the array of its digits.\nThe highest digit is at the start of the array.\n>>> add-one '(1 2 3)\n'(1 2 4)\n>>> add-one '(4 3 2 1)\n'(4 3 2 2)\n>>> add-one '(9 9 9)\n'(1 0 0 0)\n|#", "canonical_solution": "(define (reverse lst)\n(if (null? lst)\n'()\n(append (reverse (cdr lst)) (list (car lst)))))\n(define (add-one-iter rev-digits carry)\n(if (null? rev-digits)\n(if (= carry 1) '(1) '())\n(let ((sum (+ (car rev-digits) carry)))\n(if (= sum 10)\n(cons 0 (add-one-iter (cdr rev-digits) 1))\n(cons sum (add-one-iter (cdr rev-digits) 0))))))\n(reverse (add-one-iter (reverse digits) 1)))", "test": "(define (check add-one)\n(check-equal? (add-one '(1 2 3)) '(1 2 4))\n(check-equal? (add-one '(4 3 2 1)) '(4 3 2 2))\n(check-equal? (add-one '(9 9 9)) '(1 0 0 0))\n(check-equal? (add-one '(0)) '(1))\n(check-equal? (add-one '(2 9 9)) '(3 0 0))\n(check-equal? (add-one '(1 0 0 0)) '(1 0 0 1)))\n\n(check add-one)", "entry_point": "add-one", "signature": "(define (add-one", "docstring": "\nAdds one to the non-negative integer represented by the array of its digits.\nThe highest digit is at the start of the array.\n>>> add-one '(1 2 3)\n'(1 2 4)\n>>> add-one '(4 3 2 1)\n'(4 3 2 2)\n>>> add-one '(9 9 9)\n'(1 0 0 0)\n", "instruction": "Write a Scheme function `(define (add-one` to solve the following problem:\n\nAdds one to the non-negative integer represented by the array of its digits.\nThe highest digit is at the start of the array.\n>>> add-one '(1 2 3)\n'(1 2 4)\n>>> add-one '(4 3 2 1)\n'(4 3 2 2)\n>>> add-one '(9 9 9)\n'(1 0 0 0)\n", "level": "middle"}
{"task_id": "Scheme/12", "prompt": "#lang racket\n(require rackunit)\n\n(define (merge-arrays nums1 nums2)\n#|\nMerges two non-decreasing integer arrays into one, maintaining non-decreasing order.\n>>> merge-arrays '(1 2 4) '(1 3 4)\n'(1 1 2 3 4 4)\n>>> merge-arrays '(1 3 5 7) '(2 4 6 8)\n'(1 2 3 4 5 6 7 8)\n>>> merge-arrays '(1 1 1) '(2 2 2)\n'(1 1 1 2 2 2)\n|#", "canonical_solution": "(define (iter n1 n2 merged)\n(cond\n((null? n1) (append merged n2))\n((null? n2) (append merged n1))\n((<= (car n1) (car n2))\n(iter (cdr n1) n2 (append merged (list (car n1)))))\n(else\n(iter n1 (cdr n2) (append merged (list (car n2)))))))\n(iter nums1 nums2 '()))", "test": "(define (check merge-arrays)\n(check-equal? (merge-arrays '(1 2 4) '(1 3 4)) '(1 1 2 3 4 4))\n(check-equal? (merge-arrays '(1 3 5 7) '(2 4 6 8)) '(1 2 3 4 5 6 7 8))\n(check-equal? (merge-arrays '(1 1 1) '(2 2 2)) '(1 1 1 2 2 2))\n(check-equal? (merge-arrays '() '(1 2 3)) '(1 2 3))\n(check-equal? (merge-arrays '(4 5 6) '()) '(4 5 6))\n(check-equal? (merge-arrays '() '()) '()))\n\n(check merge-arrays)", "entry_point": "merge-arrays", "signature": "(define (merge-arrays", "docstring": "\nMerges two non-decreasing integer arrays into one, maintaining non-decreasing order.\n>>> merge-arrays '(1 2 4) '(1 3 4)\n'(1 1 2 3 4 4)\n>>> merge-arrays '(1 3 5 7) '(2 4 6 8)\n'(1 2 3 4 5 6 7 8)\n>>> merge-arrays '(1 1 1) '(2 2 2)\n'(1 1 1 2 2 2)\n", "instruction": "Write a Scheme function `(define (merge-arrays` to solve the following problem:\n\nMerges two non-decreasing integer arrays into one, maintaining non-decreasing order.\n>>> merge-arrays '(1 2 4) '(1 3 4)\n'(1 1 2 3 4 4)\n>>> merge-arrays '(1 3 5 7) '(2 4 6 8)\n'(1 2 3 4 5 6 7 8)\n>>> merge-arrays '(1 1 1) '(2 2 2)\n'(1 1 1 2 2 2)\n", "level": "easy"}
{"task_id": "Scheme/13", "prompt": "#lang racket\n(require rackunit)\n\n(define (max-profit prices)\n#|\nCalculate the maximum profit from buying and selling a stock on different days.\n>>> max-profit '(7 1 5 3 6 4)\n5\n>>> max-profit '(7 6 4 3 1)\n0\n>>> max-profit '(1 2 3 4 5)\n4\n|#", "canonical_solution": "(define (iter prices min-price max-profit)\n(if (null? prices)\nmax-profit\n(let ((current-price (car prices)))\n(if (< current-price min-price)\n(iter (cdr prices) current-price max-profit)\n(iter (cdr prices)\nmin-price\n(max max-profit (- current-price min-price)))))))\n(if (null? prices)\n0\n(iter (cdr prices) (car prices) 0)))", "test": "(define (check max-profit)\n(check-equal? (max-profit '(7 1 5 3 6 4)) 5)\n(check-equal? (max-profit '(7 6 4 3 1)) 0)\n(check-equal? (max-profit '(1 2 3 4 5)) 4)\n(check-equal? (max-profit '(1 1 1 1)) 0)\n(check-equal? (max-profit '(2 4 1 5)) 4)\n(check-equal? (max-profit '()) 0))\n\n(check max-profit)", "entry_point": "max-profit", "signature": "(define (max-profit", "docstring": "\nCalculate the maximum profit from buying and selling a stock on different days.\n>>> max-profit '(7 1 5 3 6 4)\n5\n>>> max-profit '(7 6 4 3 1)\n0\n>>> max-profit '(1 2 3 4 5)\n4\n", "instruction": "Write a Scheme function `(define (max-profit` to solve the following problem:\n\nCalculate the maximum profit from buying and selling a stock on different days.\n>>> max-profit '(7 1 5 3 6 4)\n5\n>>> max-profit '(7 6 4 3 1)\n0\n>>> max-profit '(1 2 3 4 5)\n4\n", "level": "middle"}
{"task_id": "Scheme/14", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-unique-element nums)\n#|\nFinds the element that appears only once in an array where all other elements appear twice.\n>>> find-unique-element '(2 2 1)\n1\n>>> find-unique-element '(4 1 2 1 2)\n4\n>>> find-unique-element '(1)\n1\n|#", "canonical_solution": "(define (xor-list lst)\n(if (null? lst)\n0\n(bitwise-xor (car lst) (xor-list (cdr lst)))))\n(xor-list nums))", "test": "(define (check find-unique-element)\n(check-equal? (find-unique-element '(2 2 1)) 1)\n(check-equal? (find-unique-element '(4 1 2 1 2)) 4)\n(check-equal? (find-unique-element '(1)) 1)\n(check-equal? (find-unique-element '(3 3 7 2 2)) 7)\n(check-equal? (find-unique-element '(0 1 0)) 1))\n\n(check find-unique-element)", "entry_point": "find-unique-element", "signature": "(define (find-unique-element", "docstring": "\nFinds the element that appears only once in an array where all other elements appear twice.\n>>> find-unique-element '(2 2 1)\n1\n>>> find-unique-element '(4 1 2 1 2)\n4\n>>> find-unique-element '(1)\n1\n", "instruction": "Write a Scheme function `(define (find-unique-element` to solve the following problem:\n\nFinds the element that appears only once in an array where all other elements appear twice.\n>>> find-unique-element '(2 2 1)\n1\n>>> find-unique-element '(4 1 2 1 2)\n4\n>>> find-unique-element '(1)\n1\n", "level": "easy"}
{"task_id": "Scheme/15", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-majority-element nums)\n#|\nFinds the majority element in the array, which appears more than floor(n/2) times.\n>>> find-majority-element '(3 2 3)\n3\n>>> find-majority-element '(2 2 1 1 1 2 2)\n2\n>>> find-majority-element '(1)\n1\n|#", "canonical_solution": "(define (find-candidate lst)\n(define (iter elements candidate count)\n(if (null? elements)\ncandidate\n(let ((current (car elements)))\n(if (= count 0)\n(iter (cdr elements) current 1)\n(if (= current candidate)\n(iter (cdr elements) candidate (+ count 1))\n(iter (cdr elements) candidate (- count 1)))))))\n(iter lst 0 0))\n(define candidate (find-candidate nums))\ncandidate)", "test": "(define (check find-majority-element)\n(check-equal? (find-majority-element '(3 2 3)) 3)\n(check-equal? (find-majority-element '(2 2 1 1 1 2 2)) 2)\n(check-equal? (find-majority-element '(1)) 1)\n(check-equal? (find-majority-element '(1 1 2 2 2 1 1)) 1)\n(check-equal? (find-majority-element '(4 4 2 4)) 4))\n\n(check find-majority-element)", "entry_point": "find-majority-element", "signature": "(define (find-majority-element", "docstring": "\nFinds the majority element in the array, which appears more than floor(n/2) times.\n>>> find-majority-element '(3 2 3)\n3\n>>> find-majority-element '(2 2 1 1 1 2 2)\n2\n>>> find-majority-element '(1)\n1\n", "instruction": "Write a Scheme function `(define (find-majority-element` to solve the following problem:\n\nFinds the majority element in the array, which appears more than floor(n/2) times.\n>>> find-majority-element '(3 2 3)\n3\n>>> find-majority-element '(2 2 1 1 1 2 2)\n2\n>>> find-majority-element '(1)\n1\n", "level": "middle"}
{"task_id": "Scheme/16", "prompt": "#lang racket\n(require rackunit)\n\n(define (contains-duplicate nums)\n#|\nChecks if any value in the array appears at least twice.\nReturns true if any value appears at least twice, false otherwise.\n>>> contains-duplicate '(1 2 3 1)\n#t\n>>> contains-duplicate '(1 2 3 4)\n#f\n>>> contains-duplicate '(1 1 1 3 3 4 3 2 4 2)\n#t\n|#", "canonical_solution": "(define (iter rest seen)\n(if (null? rest)\n#f\n(if (member (car rest) seen)\n#t\n(iter (cdr rest) (cons (car rest) seen)))))\n(iter nums '()))", "test": "(define (check contains-duplicate)\n(check-equal? (contains-duplicate '(1 2 3 1)) #t)\n(check-equal? (contains-duplicate '(1 2 3 4)) #f)\n(check-equal? (contains-duplicate '(1 1 1 3 3 4 3 2 4 2)) #t)\n(check-equal? (contains-duplicate '(1)) #f)\n(check-equal? (contains-duplicate '(1 2 2)) #t)\n(check-equal? (contains-duplicate '()) #f))\n\n(check contains-duplicate)", "entry_point": "contains-duplicate", "signature": "(define (contains-duplicate", "docstring": "\nChecks if any value in the array appears at least twice.\nReturns true if any value appears at least twice, false otherwise.\n>>> contains-duplicate '(1 2 3 1)\n#t\n>>> contains-duplicate '(1 2 3 4)\n#f\n>>> contains-duplicate '(1 1 1 3 3 4 3 2 4 2)\n#t\n", "instruction": "Write a Scheme function `(define (contains-duplicate` to solve the following problem:\n\nChecks if any value in the array appears at least twice.\nReturns true if any value appears at least twice, false otherwise.\n>>> contains-duplicate '(1 2 3 1)\n#t\n>>> contains-duplicate '(1 2 3 4)\n#f\n>>> contains-duplicate '(1 1 1 3 3 4 3 2 4 2)\n#t\n", "level": "easy"}
{"task_id": "Scheme/17", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-missing-number nums)\n#|\nFinds the missing number in an array containing n distinct numbers in the range [0, n].\n>>> find-missing-number '(3 0 1)\n2\n>>> find-missing-number '(0 1)\n2\n>>> find-missing-number '(9 6 4 2 3 5 7 0 1)\n8\n|#", "canonical_solution": "(define (xor-list lst)\n(if (null? lst)\n0\n(bitwise-xor (car lst) (xor-list (cdr lst)))))\n(define n (length nums))\n(bitwise-xor (xor-list nums) (xor-list (iota (add1 n)))))\n(define (iota n)\n(define (iota-helper count acc)\n(if (= count n)\nacc\n(iota-helper (add1 count) (cons count acc))))\n(reverse (iota-helper 0 '())))", "test": "(define (check find-missing-number)\n(check-equal? (find-missing-number '(3 0 1)) 2)\n(check-equal? (find-missing-number '(0 1)) 2)\n(check-equal? (find-missing-number '(9 6 4 2 3 5 7 0 1)) 8)\n(check-equal? (find-missing-number '(0)) 1)\n(check-equal? (find-missing-number '(1 2 3 4 5 6 7 8 9)) 0))\n\n(check find-missing-number)", "entry_point": "find-missing-number", "signature": "(define (find-missing-number", "docstring": "\nFinds the missing number in an array containing n distinct numbers in the range [0, n].\n>>> find-missing-number '(3 0 1)\n2\n>>> find-missing-number '(0 1)\n2\n>>> find-missing-number '(9 6 4 2 3 5 7 0 1)\n8\n", "instruction": "Write a Scheme function `(define (find-missing-number` to solve the following problem:\n\nFinds the missing number in an array containing n distinct numbers in the range [0, n].\n>>> find-missing-number '(3 0 1)\n2\n>>> find-missing-number '(0 1)\n2\n>>> find-missing-number '(9 6 4 2 3 5 7 0 1)\n8\n", "level": "middle"}
{"task_id": "Scheme/18", "prompt": "#lang racket\n(require rackunit)\n\n(define (move-zeros-to-end nums)\n#|\nMoves all zeros in the array to the end while maintaining the order of non-zero elements.\n>>> move-zeros-to-end '(0 1 0 3 12)\n'(1 3 12 0 0)\n>>> move-zeros-to-end '(0 0 1)\n'(1 0 0)\n>>> move-zeros-to-end '(1 0 2 0 3)\n'(1 2 3 0 0)\n|#", "canonical_solution": "(define (remove-zeros lst)\n(filter (lambda (x) (not (= x 0))) lst))\n(define (count-zeros lst)\n(length (filter zero? lst)))\n(append (remove-zeros nums) (make-list (count-zeros nums) 0)))", "test": "(define (check move-zeros-to-end)\n(check-equal? (move-zeros-to-end '(0 1 0 3 12)) '(1 3 12 0 0))\n(check-equal? (move-zeros-to-end '(0 0 1)) '(1 0 0))\n(check-equal? (move-zeros-to-end '(1 0 2 0 3)) '(1 2 3 0 0))\n(check-equal? (move-zeros-to-end '(0 0 0)) '(0 0 0))\n(check-equal? (move-zeros-to-end '(1 2 3)) '(1 2 3))\n(check-equal? (move-zeros-to-end '()) '()))\n\n(check move-zeros-to-end)", "entry_point": "move-zeros-to-end", "signature": "(define (move-zeros-to-end", "docstring": "\nMoves all zeros in the array to the end while maintaining the order of non-zero elements.\n>>> move-zeros-to-end '(0 1 0 3 12)\n'(1 3 12 0 0)\n>>> move-zeros-to-end '(0 0 1)\n'(1 0 0)\n>>> move-zeros-to-end '(1 0 2 0 3)\n'(1 2 3 0 0)\n", "instruction": "Write a Scheme function `(define (move-zeros-to-end` to solve the following problem:\n\nMoves all zeros in the array to the end while maintaining the order of non-zero elements.\n>>> move-zeros-to-end '(0 1 0 3 12)\n'(1 3 12 0 0)\n>>> move-zeros-to-end '(0 0 1)\n'(1 0 0)\n>>> move-zeros-to-end '(1 0 2 0 3)\n'(1 2 3 0 0)\n", "level": "easy"}
{"task_id": "Scheme/19", "prompt": "#lang racket\n(require rackunit)\n\n(define (array-intersection nums1 nums2)\n#|\nFinds the intersection of two arrays, returning unique elements in ascending order.\n>>> array-intersection '(1 2 2 1) '(2 2)\n'(2)\n>>> array-intersection '(4 9 5) '(9 4 9 8 4)\n'(4 9)\n>>> array-intersection '(1 2 3) '(4 5 6)\n'()\n|#", "canonical_solution": "(define (unique lst)\n(foldr (lambda (x acc) (if (member x acc) acc (cons x acc))) '() lst))\n(define (sort-list lst)\n(sort lst <))\n(sort-list (unique (filter (lambda (x) (member x nums2)) nums1))))", "test": "(define (check array-intersection)\n(check-equal? (array-intersection '(1 2 2 1) '(2 2)) '(2))\n(check-equal? (array-intersection '(4 9 5) '(9 4 9 8 4)) '(4 9))\n(check-equal? (array-intersection '(1 2 3) '(4 5 6)) '())\n(check-equal? (array-intersection '(1 3 5 7) '(2 4 6 8)) '())\n(check-equal? (array-intersection '(1 1 1 1) '(1)) '(1))\n(check-equal? (array-intersection '() '(1 2 3)) '()))\n\n(check array-intersection)", "entry_point": "array-intersection", "signature": "(define (array-intersection", "docstring": "\nFinds the intersection of two arrays, returning unique elements in ascending order.\n>>> array-intersection '(1 2 2 1) '(2 2)\n'(2)\n>>> array-intersection '(4 9 5) '(9 4 9 8 4)\n'(4 9)\n>>> array-intersection '(1 2 3) '(4 5 6)\n'()\n", "instruction": "Write a Scheme function `(define (array-intersection` to solve the following problem:\n\nFinds the intersection of two arrays, returning unique elements in ascending order.\n>>> array-intersection '(1 2 2 1) '(2 2)\n'(2)\n>>> array-intersection '(4 9 5) '(9 4 9 8 4)\n'(4 9)\n>>> array-intersection '(1 2 3) '(4 5 6)\n'()\n", "level": "easy"}
{"task_id": "Scheme/20", "prompt": "#lang racket\n(require rackunit)\n(define (unique-and-sort random-numbers)\n#|\nThis function takes a list of random numbers and performs two operations:\n1. Removes duplicate numbers, keeping only unique values.\n2. Sorts the remaining unique numbers in ascending order.\n\nThe function returns a list containing the sorted unique numbers.\n\nExamples:\n>>> unique-and-sort '(4 1 2 3 2 1)\n'(1 2 3 4)\n>>> unique-and-sort '(5 3 5 7 8 9)\n'(3 5 7 8 9)\n>>> unique-and-sort '(10 20 10 20 30)\n'(10 20 30)\n|#", "canonical_solution": "(define (unique lst)\n(cond\n[(null? lst) '()]\n[(member (car lst) (cdr lst)) (unique (cdr lst))]\n[else (cons (car lst) (unique (cdr lst)))]))\n\n(define (insert-sort lst)\n(define (insert x sorted)\n(cond\n[(null? sorted) (list x)]\n[(<= x (car sorted)) (cons x sorted)]\n[else (cons (car sorted) (insert x (cdr sorted)))]))\n(foldr insert '() lst))\n\n(insert-sort (unique random-numbers))\n)", "test": "(define (check unique-and-sort)\n(check-equal? (unique-and-sort '(4 1 2 3 2 1)) '(1 2 3 4))\n(check-equal? (unique-and-sort '(5 3 5 7 8 9)) '(3 5 7 8 9))\n(check-equal? (unique-and-sort '(10 20 10 20 30)) '(10 20 30))\n(check-equal? (unique-and-sort '(100 200 300 200 100)) '(100 200 300))\n(check-equal? (unique-and-sort '(55 42 42 55 60)) '(42 55 60))\n(check-equal? (unique-and-sort '(9 8 7 6 5 4 3 2 1 0)) '(0 1 2 3 4 5 6 7 8 9)))\n\n(check unique-and-sort)", "entry_point": "unique-and-sort", "signature": "(define (unique-and-sort", "docstring": "\nThis function takes a list of random numbers and performs two operations:\n1. Removes duplicate numbers, keeping only unique values.\n2. Sorts the remaining unique numbers in ascending order.\n\nThe function returns a list containing the sorted unique numbers.\n\nExamples:\n>>> unique-and-sort '(4 1 2 3 2 1)\n'(1 2 3 4)\n>>> unique-and-sort '(5 3 5 7 8 9)\n'(3 5 7 8 9)\n>>> unique-and-sort '(10 20 10 20 30)\n'(10 20 30)\n", "instruction": "Write a Scheme function `(define (unique-and-sort` to solve the following problem:\n\nThis function takes a list of random numbers and performs two operations:\n1. Removes duplicate numbers, keeping only unique values.\n2. Sorts the remaining unique numbers in ascending order.\n\nThe function returns a list containing the sorted unique numbers.\n\nExamples:\n>>> unique-and-sort '(4 1 2 3 2 1)\n'(1 2 3 4)\n>>> unique-and-sort '(5 3 5 7 8 9)\n'(3 5 7 8 9)\n>>> unique-and-sort '(10 20 10 20 30)\n'(10 20 30)\n", "level": "middle"}
{"task_id": "Scheme/21", "prompt": "#lang racket\n(require rackunit)\n(require srfi/1)\n(define (minimum-nuts-to-defeat-zombies zombie-info)\n#|\nThis function calculates the minimum number of nuts required to defeat all zombies in a game scenario.\nThe game field is a 6x60 grid, with zombies appearing at the rightmost column (column 60) and moving left each second.\nA nut can be placed at the leftmost column (column 1) of any row, instantly defeating all zombies in that row.\n\n'zombie-info' is a list of pairs, each pair containing a row number and the time of appearance for a zombie.\nThe function returns the minimum number of nuts needed to defeat all zombies.\n\nExamples:\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (3 3)))\n3\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (1 2) (1 3)))\n1\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (1 61)))\n2\n|#", "canonical_solution": "(let loop ((remaining-zombies zombie-info)\n(current-time 1)\n(nuts-used 0)\n(rows-cleared '()))\n(cond\n[(empty? remaining-zombies) nuts-used]\n[(> current-time 60) nuts-used]\n[else\n(let* ((current-zombies (filter (lambda (zombie) (= (cadr zombie) current-time)) remaining-zombies))\n(new-rows (remove-duplicates (map car current-zombies)))\n(uncleared-rows (filter (lambda (row) (not (member row rows-cleared))) new-rows))\n(new-nuts (length uncleared-rows))\n(updated-rows-cleared (append rows-cleared uncleared-rows))\n(zombies-remaining (filter (lambda (zombie) (> (cadr zombie) current-time)) remaining-zombies)))\n(loop zombies-remaining (+ current-time 1) (+ nuts-used new-nuts) updated-rows-cleared))])))", "test": "(define (test-minimum-nuts-to-defeat-zombies)\n(check-equal? (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (3 3))) 3)\n(check-equal? (minimum-nuts-to-defeat-zombies '((1 1) (1 2) (1 3))) 1)\n(check-equal? (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (1 61))) 2)\n(check-equal? (minimum-nuts-to-defeat-zombies '((1 1) (1 61) (2 1) (2 60) (3 2) (4 2) (5 3))) 5)\n(check-equal? (minimum-nuts-to-defeat-zombies '((1 10) (2 20) (3 30) (4 40) (5 50) (6 60))) 6))\n\n(test-minimum-nuts-to-defeat-zombies)", "entry_point": "minimum-nuts-to-defeat-zombies", "signature": "(define (minimum-nuts-to-defeat-zombies", "docstring": "\nThis function calculates the minimum number of nuts required to defeat all zombies in a game scenario.\nThe game field is a 6x60 grid, with zombies appearing at the rightmost column (column 60) and moving left each second.\nA nut can be placed at the leftmost column (column 1) of any row, instantly defeating all zombies in that row.\n\n'zombie-info' is a list of pairs, each pair containing a row number and the time of appearance for a zombie.\nThe function returns the minimum number of nuts needed to defeat all zombies.\n\nExamples:\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (3 3)))\n3\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (1 2) (1 3)))\n1\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (1 61)))\n2\n", "instruction": "Write a Scheme function `(define (minimum-nuts-to-defeat-zombies` to solve the following problem:\n\nThis function calculates the minimum number of nuts required to defeat all zombies in a game scenario.\nThe game field is a 6x60 grid, with zombies appearing at the rightmost column (column 60) and moving left each second.\nA nut can be placed at the leftmost column (column 1) of any row, instantly defeating all zombies in that row.\n\n'zombie-info' is a list of pairs, each pair containing a row number and the time of appearance for a zombie.\nThe function returns the minimum number of nuts needed to defeat all zombies.\n\nExamples:\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (3 3)))\n3\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (1 2) (1 3)))\n1\n>>> (minimum-nuts-to-defeat-zombies '((1 1) (2 2) (1 61)))\n2\n", "level": "hard"}
{"task_id": "Scheme/22", "prompt": "#lang racket\n(require rackunit)\n\n(define (max-untouched-nodes n)\n#|\nDetermines the maximum number of nodes that can remain untouched by aliens on Mars, \nwhere the aliens attack the graph nodes in order of their degrees, starting from degree 0 and moving upwards.\n\nThe Martian graph is an undirected graph without self-loops or multiple edges between the same nodes.\nThe degree of a node is dynamically updated after each attack.\n\n'n' is the number of nodes in the graph. The function returns the maximum number of nodes that can remain unattacked.\n\nExample:\n(max-untouched-nodes 4) ; A graph with 4 nodes could be designed so that 1 node remains untouched.\n(max-untouched-nodes 5) ; A graph with 5 nodes could be designed so that 2 nodes remain untouched.\n(max-untouched-nodes 6) ; A graph with 6 nodes could be designed so that 2 nodes remain untouched.\n|#", "canonical_solution": "(if (< n 3)\nn\n(if (even? n)\n2\n1)))", "test": "(define (check max-untouched-nodes)\n(check-equal? (max-untouched-nodes 2) 2)\n(check-equal? (max-untouched-nodes 3) 1)\n(check-equal? (max-untouched-nodes 4) 2)\n(check-equal? (max-untouched-nodes 5) 1)\n(check-equal? (max-untouched-nodes 6) 2)\n(check-equal? (max-untouched-nodes 7) 1)\n(check-equal? (max-untouched-nodes 8) 2)\n(check-equal? (max-untouched-nodes 9) 1))\n\n(check max-untouched-nodes)", "entry_point": "max-untouched-nodes", "signature": "(define (max-untouched-nodes", "docstring": "\nDetermines the maximum number of nodes that can remain untouched by aliens on Mars, \nwhere the aliens attack the graph nodes in order of their degrees, starting from degree 0 and moving upwards.\n\nThe Martian graph is an undirected graph without self-loops or multiple edges between the same nodes.\nThe degree of a node is dynamically updated after each attack.\n\n'n' is the number of nodes in the graph. The function returns the maximum number of nodes that can remain unattacked.\n\nExample:\n(max-untouched-nodes 4) ; A graph with 4 nodes could be designed so that 1 node remains untouched.\n(max-untouched-nodes 5) ; A graph with 5 nodes could be designed so that 2 nodes remain untouched.\n(max-untouched-nodes 6) ; A graph with 6 nodes could be designed so that 2 nodes remain untouched.\n", "instruction": "Write a Scheme function `(define (max-untouched-nodes` to solve the following problem:\n\nDetermines the maximum number of nodes that can remain untouched by aliens on Mars, \nwhere the aliens attack the graph nodes in order of their degrees, starting from degree 0 and moving upwards.\n\nThe Martian graph is an undirected graph without self-loops or multiple edges between the same nodes.\nThe degree of a node is dynamically updated after each attack.\n\n'n' is the number of nodes in the graph. The function returns the maximum number of nodes that can remain unattacked.\n\nExample:\n(max-untouched-nodes 4) ; A graph with 4 nodes could be designed so that 1 node remains untouched.\n(max-untouched-nodes 5) ; A graph with 5 nodes could be designed so that 2 nodes remain untouched.\n(max-untouched-nodes 6) ; A graph with 6 nodes could be designed so that 2 nodes remain untouched.\n", "level": "easy"}
{"task_id": "Scheme/23", "prompt": "#lang racket\n(require rackunit)\n\n(define memo (make-hash))\n\n(define (w a b c)\n#|\nComputes the value of the function w(a, b, c) based on the following rules:\n- If any of a, b, or c are <= 0, return 1.\n- If any of a, b, or c are > 20, return w(20, 20, 20).\n- If a < b and b < c, return w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c).\n- Otherwise, return w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1).\nThis function uses memoization to optimize recursive calls.\nExamples:\n>>> w(0, 0, 0)\n1\n>>> w(21, 21, 21)\n1048576\n>>> w(10, 10, 10)\n1024\n|#", "canonical_solution": "(cond\n((or (<= a 0) (<= b 0) (<= c 0)) 1)\n((or (> a 20) (> b 20) (> c 20)) (w 20 20 20))\n((hash-ref memo (list a b c) #f) => identity)\n(else\n(let ((result\n(cond\n((and (< a b) (< b c))\n(+ (w a b (- c 1))\n(w a (- b 1) (- c 1))\n(- (w a (- b 1) c))))\n(else\n(+ (w (- a 1) b c)\n(w (- a 1) (- b 1) c)\n(w (- a 1) b (- c 1))\n(- (w (- a 1) (- b 1) (- c 1))))))))\n(hash-set! memo (list a b c) result)\nresult))))", "test": "(define (test-w)\n(check-equal? (w 0 0 0) 1)\n(check-equal? (w 21 21 21) 1048576)\n(check-equal? (w 10 10 10) 1024)\n(check-equal? (w 5 5 5) 32)\n(check-equal? (w 15 15 15) 32768)\n(check-equal? (w 20 20 20) 1048576))\n\n(test-w)", "entry_point": "w", "signature": "(define (w", "docstring": "\nComputes the value of the function w(a, b, c) based on the following rules:\n- If any of a, b, or c are <= 0, return 1.\n- If any of a, b, or c are > 20, return w(20, 20, 20).\n- If a < b and b < c, return w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c).\n- Otherwise, return w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1).\nThis function uses memoization to optimize recursive calls.\nExamples:\n>>> w(0, 0, 0)\n1\n>>> w(21, 21, 21)\n1048576\n>>> w(10, 10, 10)\n1024\n", "instruction": "Write a Scheme function `(define (w` to solve the following problem:\n\nComputes the value of the function w(a, b, c) based on the following rules:\n- If any of a, b, or c are <= 0, return 1.\n- If any of a, b, or c are > 20, return w(20, 20, 20).\n- If a < b and b < c, return w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c).\n- Otherwise, return w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1).\nThis function uses memoization to optimize recursive calls.\nExamples:\n>>> w(0, 0, 0)\n1\n>>> w(21, 21, 21)\n1048576\n>>> w(10, 10, 10)\n1024\n", "level": "hard"}
{"task_id": "Scheme/24", "prompt": "#lang racket\n(require rackunit)\n\n(define (extract-digits str)\n#|\nExtracts all digits from the given string 'str' and returns them as a new string.\nIf no digits are found, returns an empty string.\nExamples:\n>>> extract-digits(\"hello123\")\n\"123\"\n>>> extract-digits(\"abc\")\n\"\"\n>>> extract-digits(\"2024code\")\n\"2024\"\n|#", "canonical_solution": "(define (is-digit? char)\n(and (char-numeric? char) (char<=? #\\0 char) (char<=? char #\\9)))\n\n(define (iter str index result)\n(if (= index (string-length str))\n(list->string (reverse result))\n(iter str \n(+ index 1) \n(if (is-digit? (string-ref str index))\n(cons (string-ref str index) result)\nresult))))\n\n(iter str 0 '()))", "test": "(define (check extract-digits)\n(check-equal? (extract-digits \"hello123\") \"123\")\n(check-equal? (extract-digits \"abc\") \"\")\n(check-equal? (extract-digits \"2024code\") \"2024\")\n(check-equal? (extract-digits \"123abc456\") \"123456\")\n(check-equal? (extract-digits \"no digits here!\") \"\")\n(check-equal? (extract-digits \"0\") \"0\"))\n\n(check extract-digits)", "entry_point": "extract-digits", "signature": "(define (extract-digits", "docstring": "\nExtracts all digits from the given string 'str' and returns them as a new string.\nIf no digits are found, returns an empty string.\nExamples:\n>>> extract-digits(\"hello123\")\n\"123\"\n>>> extract-digits(\"abc\")\n\"\"\n>>> extract-digits(\"2024code\")\n\"2024\"\n", "instruction": "Write a Scheme function `(define (extract-digits` to solve the following problem:\n\nExtracts all digits from the given string 'str' and returns them as a new string.\nIf no digits are found, returns an empty string.\nExamples:\n>>> extract-digits(\"hello123\")\n\"123\"\n>>> extract-digits(\"abc\")\n\"\"\n>>> extract-digits(\"2024code\")\n\"2024\"\n", "level": "middle"}
{"task_id": "Scheme/25", "prompt": "#lang racket\n(require rackunit)\n(define (max-apples-collected apple-data chair-height tao-max-reach init-energy)\n#|\nCalculates the maximum number of apples Tao Tao can collect without his energy going below zero.\n- apple-data: a list of pairs, each containing the apple's height and the energy required to pick it.\n- chair-height: the height of the chair Tao Tao can stand on.\n- tao-max-reach: the maximum height Tao Tao can reach with his arm extended.\n- init-energy: Tao Tao's initial energy level.\nReturns the maximum number of apples Tao Tao can pick.\nExamples:\n>>> max-apples-collected '((100 4) (150 3) (120 5)) 20 130 10\n2\n|#", "canonical_solution": "(define (apple-within-reach? apple-height chair-height tao-max-reach)\n(<= apple-height (+ chair-height tao-max-reach)))\n\n(define (sort-apples-by-energy apple-data)\n(sort apple-data (lambda (x y) (< (cadr x) (cadr y)))))\n\n(define (collect-apples sorted-apples chair-height tao-max-reach energy)\n(if (null? sorted-apples)\n0\n(let ((first-apple (car sorted-apples)))\n(if (and (apple-within-reach? (car first-apple) chair-height tao-max-reach)\n(>= energy (cadr first-apple)))\n(+ 1 (collect-apples (cdr sorted-apples) chair-height tao-max-reach (- energy (cadr first-apple))))\n(collect-apples (cdr sorted-apples) chair-height tao-max-reach energy)))))\n(collect-apples (sort-apples-by-energy apple-data) chair-height tao-max-reach init-energy))", "test": "(define (test max-apples-collected)\n(check-equal? (max-apples-collected '((100 4) (150 3) (120 5)) 20 130 10) 2)\n(check-equal? (max-apples-collected '((110 7) (90 3) (200 6)) 15 125 8) 1)\n(check-equal? (max-apples-collected '((180 2) (130 1) (170 4)) 25 140 15) 1)\n(check-equal? (max-apples-collected '((160 3) (140 5) (110 2)) 30 135 12) 3)\n(check-equal? (max-apples-collected '((120 1) (130 2) (140 3)) 15 120 5) 2))\n\n(test max-apples-collected)", "entry_point": "max-apples-collected", "signature": "(define (max-apples-collected", "docstring": "\nCalculates the maximum number of apples Tao Tao can collect without his energy going below zero.\n- apple-data: a list of pairs, each containing the apple's height and the energy required to pick it.\n- chair-height: the height of the chair Tao Tao can stand on.\n- tao-max-reach: the maximum height Tao Tao can reach with his arm extended.\n- init-energy: Tao Tao's initial energy level.\nReturns the maximum number of apples Tao Tao can pick.\nExamples:\n>>> max-apples-collected '((100 4) (150 3) (120 5)) 20 130 10\n2\n", "instruction": "Write a Scheme function `(define (max-apples-collected` to solve the following problem:\n\nCalculates the maximum number of apples Tao Tao can collect without his energy going below zero.\n- apple-data: a list of pairs, each containing the apple's height and the energy required to pick it.\n- chair-height: the height of the chair Tao Tao can stand on.\n- tao-max-reach: the maximum height Tao Tao can reach with his arm extended.\n- init-energy: Tao Tao's initial energy level.\nReturns the maximum number of apples Tao Tao can pick.\nExamples:\n>>> max-apples-collected '((100 4) (150 3) (120 5)) 20 130 10\n2\n", "level": "hard"}
{"task_id": "Scheme/26", "prompt": "#lang racket\n(require racket/math)\n(require rackunit)\n\n(define (calculate-quotient a b)\n#|\nComputes the integer part of the quotient of two numbers, 'a' and 'b'.\nThe function takes two integers 'a' (the dividend) and 'b' (the divisor) as inputs.\nIt returns the integer part of the quotient of 'a' divided by 'b'.\nNote: 'a' can be very large (up to 10^5000), while 'b' ranges from 1 to 10^9.\n\nExamples:\n>>> compute-quotient 10 2\n5\n>>> compute-quotient 20 3\n6\n>>> compute-quotient 1000000000 1\n1000000000\n|#", "canonical_solution": "(if (or (< a 0) (<= b 0))\n(error \"Invalid input: 'a' must be non-negative and 'b' must be positive.\")\n(quotient a b))\n)", "test": "(define (check-calculate-quotient)\n(check-equal? (calculate-quotient 15 3) 5)\n(check-equal? (calculate-quotient 20 4) 5)\n(check-equal? (calculate-quotient 5 2) 2)\n(check-equal? (calculate-quotient 7 3) 2)\n(check-equal? (calculate-quotient 100 10) 10)\n(check-equal? (calculate-quotient 0 5) 0))\n\n(check-calculate-quotient)", "entry_point": "calculate-quotient", "signature": "(define (calculate-quotient", "docstring": "\nComputes the integer part of the quotient of two numbers, 'a' and 'b'.\nThe function takes two integers 'a' (the dividend) and 'b' (the divisor) as inputs.\nIt returns the integer part of the quotient of 'a' divided by 'b'.\nNote: 'a' can be very large (up to 10^5000), while 'b' ranges from 1 to 10^9.\n\nExamples:\n>>> compute-quotient 10 2\n5\n>>> compute-quotient 20 3\n6\n>>> compute-quotient 1000000000 1\n1000000000\n", "instruction": "Write a Scheme function `(define (calculate-quotient` to solve the following problem:\n\nComputes the integer part of the quotient of two numbers, 'a' and 'b'.\nThe function takes two integers 'a' (the dividend) and 'b' (the divisor) as inputs.\nIt returns the integer part of the quotient of 'a' divided by 'b'.\nNote: 'a' can be very large (up to 10^5000), while 'b' ranges from 1 to 10^9.\n\nExamples:\n>>> compute-quotient 10 2\n5\n>>> compute-quotient 20 3\n6\n>>> compute-quotient 1000000000 1\n1000000000\n", "level": "easy"}
{"task_id": "Scheme/27", "prompt": "#lang racket\n(require rackunit)\n\n(define (determine-winner n triangles)\n#|\nDetermines the winner of a geometric game played on a convex polygon with n vertices.\nThe game is played by cutting along the diagonals of the polygon to remove triangles.\nThe first triangle is black, and the rest are white. The player who removes the black triangle wins.\nThe function takes the number of vertices 'n' and a list of triples, each representing a triangle's vertices.\nThe function returns \"JMcat Win\" if the first player has a winning strategy, otherwise \"PZ Win\".\n\nExamples:\n>>> determine-winner 5 '((0 1 2) (2 3 4) (4 1 0))\n\"PZ Win\"\n>>> determine-winner 4 '((0 1 2) (2 3 0))\n\"JMcat Win\"\n|#", "canonical_solution": "(define (is-jmcat-win? n)\n(even? (- n 2)))\n\n(if (is-jmcat-win? n) \"JMcat Win\" \"PZ Win\"))", "test": "(define (check determine-winner)\n(check-equal? (determine-winner 5 '((0 1 2) (2 3 4) (4 1 0))) \"PZ Win\")\n(check-equal? (determine-winner 4 '((0 1 2) (2 3 0))) \"JMcat Win\")\n(check-equal? (determine-winner 6 '((0 1 2) (2 3 4) (4 5 0) (0 3 2))) \"JMcat Win\")\n(check-equal? (determine-winner 7 '((0 1 2) (2 3 4) (4 5 6) (6 0 4))) \"PZ Win\"))\n\n(check determine-winner)\n", "entry_point": "determine-winner", "signature": "(define (determine-winner", "docstring": "\nDetermines the winner of a geometric game played on a convex polygon with n vertices.\nThe game is played by cutting along the diagonals of the polygon to remove triangles.\nThe first triangle is black, and the rest are white. The player who removes the black triangle wins.\nThe function takes the number of vertices 'n' and a list of triples, each representing a triangle's vertices.\nThe function returns \"JMcat Win\" if the first player has a winning strategy, otherwise \"PZ Win\".\n\nExamples:\n>>> determine-winner 5 '((0 1 2) (2 3 4) (4 1 0))\n\"PZ Win\"\n>>> determine-winner 4 '((0 1 2) (2 3 0))\n\"JMcat Win\"\n", "instruction": "Write a Scheme function `(define (determine-winner` to solve the following problem:\n\nDetermines the winner of a geometric game played on a convex polygon with n vertices.\nThe game is played by cutting along the diagonals of the polygon to remove triangles.\nThe first triangle is black, and the rest are white. The player who removes the black triangle wins.\nThe function takes the number of vertices 'n' and a list of triples, each representing a triangle's vertices.\nThe function returns \"JMcat Win\" if the first player has a winning strategy, otherwise \"PZ Win\".\n\nExamples:\n>>> determine-winner 5 '((0 1 2) (2 3 4) (4 1 0))\n\"PZ Win\"\n>>> determine-winner 4 '((0 1 2) (2 3 0))\n\"JMcat Win\"\n", "level": "easy"}
{"task_id": "Scheme/28", "prompt": "#lang racket\n(require rackunit)\n(define (max-calorie-value max-volume max-weight food-items)\n#|\nCalculates the maximum total calories that can be carried within the given volume and weight constraints.\nEach food item is represented as a list of three values: volume, weight, and calorie content. \nThe function selects a combination of these items to maximize the total calorie content without exceeding the volume and weight limits.\nEach food item can only be used once.\nExamples:\n>>> max-calorie-value 300 300 '((100 50 200) (200 100 300) (150 150 400))\n600\n|#", "canonical_solution": "(define (knapsack max-v max-w items n)\n(if (or (= n 0) (= max-v 0) (= max-w 0))\n0\n(let* ((item (list-ref items (- n 1)))\n(vol (list-ref item 0))\n(wt (list-ref item 1))\n(cal (list-ref item 2)))\n(if (or (> vol max-v) (> wt max-w))\n(knapsack max-v max-w items (- n 1))\n(max (knapsack max-v max-w items (- n 1))\n(+ cal (knapsack (- max-v vol) (- max-w wt) items (- n 1))))))))\n(knapsack max-volume max-weight food-items (length food-items)))", "test": "(define (test-max-calorie-value)\n(check-equal? (max-calorie-value 300 300 '((100 50 200) (200 100 300) (150 150 400))) 600)\n(check-equal? (max-calorie-value 250 200 '((80 30 100) (60 70 150) (110 100 200))) 450)\n(check-equal? (max-calorie-value 400 450 '((100 300 350) (150 100 400) (200 50 500))) 900)\n(check-equal? (max-calorie-value 500 500 '((120 80 250) (130 90 300) (250 330 450))) 1000)\n(check-equal? (max-calorie-value 200 150 '((50 30 100) (70 80 150) (80 40 200))) 450))\n\n(test-max-calorie-value)", "entry_point": "max-calorie-value", "signature": "(define (max-calorie-value", "docstring": "\nCalculates the maximum total calories that can be carried within the given volume and weight constraints.\nEach food item is represented as a list of three values: volume, weight, and calorie content. \nThe function selects a combination of these items to maximize the total calorie content without exceeding the volume and weight limits.\nEach food item can only be used once.\nExamples:\n>>> max-calorie-value 300 300 '((100 50 200) (200 100 300) (150 150 400))\n600\n", "instruction": "Write a Scheme function `(define (max-calorie-value` to solve the following problem:\n\nCalculates the maximum total calories that can be carried within the given volume and weight constraints.\nEach food item is represented as a list of three values: volume, weight, and calorie content. \nThe function selects a combination of these items to maximize the total calorie content without exceeding the volume and weight limits.\nEach food item can only be used once.\nExamples:\n>>> max-calorie-value 300 300 '((100 50 200) (200 100 300) (150 150 400))\n600\n", "level": "hard"}
{"task_id": "Scheme/29", "prompt": "#lang racket\n(require rackunit)\n(define (count-dictionary-lookups M N words)\n#|\nCounts the number of times a translation software needs to look up words in an external dictionary.\n\nThe software has a memory of size M, which can store translations of M different words.\nGiven an array of word indices (words) of length N, representing the order of words in a text,\nthe function returns how many times the software needs to look up a word in the external dictionary.\n\nExamples:\n>>> count-dictionary-lookups 2 5 '(1 2 3 2 1)\n4\n>>> count-dictionary-lookups 3 6 '(4 4 4 5 6 7)\n4\n>>> count-dictionary-lookups 1 4 '(8 8 8 8)\n1\n|#", "canonical_solution": "(define (update-memory memory word)\n(if (member word memory)\nmemory\n(if (< (length memory) M)\n(append memory (list word))\n(append (cdr memory) (list word)))))\n\n(define (count-lookups words memory)\n(if (null? words)\n0\n(+ (if (member (car words) memory) 0 1)\n(count-lookups (cdr words) (update-memory memory (car words))))))\n\n(count-lookups words '()))", "test": "(define (test-count-dictionary-lookups)\n(check-equal? (count-dictionary-lookups 2 5 '(1 2 3 2 1)) 4)\n(check-equal? (count-dictionary-lookups 3 6 '(4 4 4 5 6 7)) 4)\n(check-equal? (count-dictionary-lookups 1 4 '(8 8 8 8)) 1)\n(check-equal? (count-dictionary-lookups 2 3 '(9 9 10)) 2)\n(check-equal? (count-dictionary-lookups 4 8 '(1 2 3 4 5 1 2 3)) 8))\n\n(test-count-dictionary-lookups)", "entry_point": "count-dictionary-lookups", "signature": "(define (count-dictionary-lookups", "docstring": "\nCounts the number of times a translation software needs to look up words in an external dictionary.\n\nThe software has a memory of size M, which can store translations of M different words.\nGiven an array of word indices (words) of length N, representing the order of words in a text,\nthe function returns how many times the software needs to look up a word in the external dictionary.\n\nExamples:\n>>> count-dictionary-lookups 2 5 '(1 2 3 2 1)\n4\n>>> count-dictionary-lookups 3 6 '(4 4 4 5 6 7)\n4\n>>> count-dictionary-lookups 1 4 '(8 8 8 8)\n1\n", "instruction": "Write a Scheme function `(define (count-dictionary-lookups` to solve the following problem:\n\nCounts the number of times a translation software needs to look up words in an external dictionary.\n\nThe software has a memory of size M, which can store translations of M different words.\nGiven an array of word indices (words) of length N, representing the order of words in a text,\nthe function returns how many times the software needs to look up a word in the external dictionary.\n\nExamples:\n>>> count-dictionary-lookups 2 5 '(1 2 3 2 1)\n4\n>>> count-dictionary-lookups 3 6 '(4 4 4 5 6 7)\n4\n>>> count-dictionary-lookups 1 4 '(8 8 8 8)\n1\n", "level": "middle"}
{"task_id": "Scheme/30", "prompt": "#lang racket\n(require rackunit)\n(define (sum-of-arithmetic-sequence first second n)\n\n#|\nThis function calculates the sum of the first n terms of an arithmetic sequence given the first two terms.\nAn arithmetic sequence is a sequence of numbers where the difference of any two successive members is a constant.\nThe function takes three arguments: the first two terms of the sequence and the number of terms.\nIt returns the sum of the first n terms of the sequence.\n\nExamples:\n\n(sum-of-arithmetic-sequence 1 2 3)\n6\n(sum-of-arithmetic-sequence -5 -10 5)\n-75\n|#", "canonical_solution": "(define (arithmetic-sum n first difference)\n(/ (* n (+ (* 2 first) (* (dec n) difference))) 2))\n(arithmetic-sum n first (- second first)))\n(define (dec x) (- x 1))", "test": "(define (check sum-of-arithmetic-sequence)\n(check-equal? (sum-of-arithmetic-sequence 1 2 3) 6)\n(check-equal? (sum-of-arithmetic-sequence -5 -10 5) -75)\n(check-equal? (sum-of-arithmetic-sequence 3 5 2) 8)\n(check-equal? (sum-of-arithmetic-sequence 0 0 10) 0)\n(check-equal? (sum-of-arithmetic-sequence 1 1 10) 10))\n\n(check sum-of-arithmetic-sequence)", "entry_point": "sum-of-arithmetic-sequence", "signature": "(define (sum-of-arithmetic-sequence", "docstring": "\nThis function calculates the sum of the first n terms of an arithmetic sequence given the first two terms.\nAn arithmetic sequence is a sequence of numbers where the difference of any two successive members is a constant.\nThe function takes three arguments: the first two terms of the sequence and the number of terms.\nIt returns the sum of the first n terms of the sequence.\n\nExamples:\n\n(sum-of-arithmetic-sequence 1 2 3)\n6\n(sum-of-arithmetic-sequence -5 -10 5)\n-75\n", "instruction": "Write a Scheme function `(define (sum-of-arithmetic-sequence` to solve the following problem:\n\nThis function calculates the sum of the first n terms of an arithmetic sequence given the first two terms.\nAn arithmetic sequence is a sequence of numbers where the difference of any two successive members is a constant.\nThe function takes three arguments: the first two terms of the sequence and the number of terms.\nIt returns the sum of the first n terms of the sequence.\n\nExamples:\n\n(sum-of-arithmetic-sequence 1 2 3)\n6\n(sum-of-arithmetic-sequence -5 -10 5)\n-75\n", "level": "easy"}
{"task_id": "Scheme/31", "prompt": "#lang racket\n(require rackunit)\n\n(define (simulate-mock-exams n m k availability-list)\n#|\nThis function simulates the organization of mock exams for 'n' students over 'k' days,\nwith 'm' mock exams in total. Each student has their own schedule of available days.\nThe input 'availability-list' is a list of lists, where each sublist represents a student's \navailable days in ascending order.\nThe function returns a list of 'k' integers, where each integer represents the number of mock exams\nthe coach needs to prepare for each day.\n\nExamples:\n(simulate-mock-exams 1 2 3 '((1 3)))\n1 0 1\n\n|#", "canonical_solution": "(let ([exam-days (make-vector k 0)])\n(for ([student availability-list])\n(for ([day student])\n(vector-set! exam-days (- day 1) (+ 1 (vector-ref exam-days (- day 1))))))\n(vector->list exam-days)))", "test": "(define (test-simulate-mock-exams)\n(check-equal? (simulate-mock-exams 1 2 3 '((1 3))) '(1 0 1))\n(check-equal? (simulate-mock-exams 2 2 4 '((1 4) (2 3))) '(1 1 1 1))\n(check-equal? (simulate-mock-exams 3 3 5 '((1 2 5) (2 3 4) (3 4 5))) '(1 2 2 2 2)))\n\n(test-simulate-mock-exams)", "entry_point": "simulate-mock-exams", "signature": "(define (simulate-mock-exams", "docstring": "\nThis function simulates the organization of mock exams for 'n' students over 'k' days,\nwith 'm' mock exams in total. Each student has their own schedule of available days.\nThe input 'availability-list' is a list of lists, where each sublist represents a student's \navailable days in ascending order.\nThe function returns a list of 'k' integers, where each integer represents the number of mock exams\nthe coach needs to prepare for each day.\n\nExamples:\n(simulate-mock-exams 1 2 3 '((1 3)))\n1 0 1\n\n", "instruction": "Write a Scheme function `(define (simulate-mock-exams` to solve the following problem:\n\nThis function simulates the organization of mock exams for 'n' students over 'k' days,\nwith 'm' mock exams in total. Each student has their own schedule of available days.\nThe input 'availability-list' is a list of lists, where each sublist represents a student's \navailable days in ascending order.\nThe function returns a list of 'k' integers, where each integer represents the number of mock exams\nthe coach needs to prepare for each day.\n\nExamples:\n(simulate-mock-exams 1 2 3 '((1 3)))\n1 0 1\n\n", "level": "easy"}
{"task_id": "Scheme/32", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-test-answers exam-data student-answers)\n#|\nThis function helps a student, Xiao D, to find the correct answers in a mock exam. \nThe exam consists of multiple-choice questions with four options each.\n'exam-data' is a list of pairs, each pair containing a question and its correct answer.\n'student-answers' is a list of lists, where each list represents a question in the mock exam,\nconsisting of the question followed by four options.\nThe function returns a list of characters ('A', 'B', 'C', or 'D'), representing the correct option for each question.\nExamples:\n>>> (find-test-answers '((\"q1\" \"ans1\") (\"q2\" \"ans2\")) '((\"q1\" \"ans3\" \"ans1\" \"ans4\" \"ans5\") (\"q2\" \"ans2\" \"ans6\" \"ans7\" \"ans8\")))\n'(\"B\" \"A\")\n>>> (find-test-answers '((\"q1\" \"ans1\")) '((\"q1\" \"ans2\" \"ans3\" \"ans1\" \"ans4\")))\n'(\"C\")\n|#", "canonical_solution": "(define (find-answer question options)\n(let loop ((opts options) (index 0))\n(if (null? opts)\n\"N\"\n(if (string=? (car opts) question)\n(string (integer->char (+ index 65))) ; Convert index to corresponding letter and then to string\n(loop (cdr opts) (+ index 1))))))\n\n(define (process-student-answers exam-data student-answers)\n(map (lambda (student-answer)\n(let ((question (car student-answer))\n(options (cdr student-answer)))\n(find-answer (cadr (assoc question exam-data)) options)))\nstudent-answers))\n\n(process-student-answers exam-data student-answers))", "test": "(define (check-find-test-answers)\n(check-equal? \n(find-test-answers '((\"math\" \"C\") (\"physics\" \"A\"))\n'((\"math\" \"B\" \"C\" \"D\" \"A\")\n(\"physics\" \"A\" \"B\" \"C\" \"D\")))\n'(\"B\" \"A\"))\n\n(check-equal?\n(find-test-answers '((\"history\" \"D\"))\n'((\"history\" \"A\" \"B\" \"C\" \"D\")))\n'(\"D\"))\n\n(check-equal?\n(find-test-answers '((\"geography\" \"A\") (\"biology\" \"B\"))\n'((\"geography\" \"A\" \"B\" \"C\" \"D\")\n(\"biology\" \"C\" \"D\" \"A\" \"B\")))\n'(\"A\" \"D\")))\n\n(check-find-test-answers)", "entry_point": "find-test-answers", "signature": "(define (find-test-answers", "docstring": "\nThis function helps a student, Xiao D, to find the correct answers in a mock exam. \nThe exam consists of multiple-choice questions with four options each.\n'exam-data' is a list of pairs, each pair containing a question and its correct answer.\n'student-answers' is a list of lists, where each list represents a question in the mock exam,\nconsisting of the question followed by four options.\nThe function returns a list of characters ('A', 'B', 'C', or 'D'), representing the correct option for each question.\nExamples:\n>>> (find-test-answers '((\"q1\" \"ans1\") (\"q2\" \"ans2\")) '((\"q1\" \"ans3\" \"ans1\" \"ans4\" \"ans5\") (\"q2\" \"ans2\" \"ans6\" \"ans7\" \"ans8\")))\n'(\"B\" \"A\")\n>>> (find-test-answers '((\"q1\" \"ans1\")) '((\"q1\" \"ans2\" \"ans3\" \"ans1\" \"ans4\")))\n'(\"C\")\n", "instruction": "Write a Scheme function `(define (find-test-answers` to solve the following problem:\n\nThis function helps a student, Xiao D, to find the correct answers in a mock exam. \nThe exam consists of multiple-choice questions with four options each.\n'exam-data' is a list of pairs, each pair containing a question and its correct answer.\n'student-answers' is a list of lists, where each list represents a question in the mock exam,\nconsisting of the question followed by four options.\nThe function returns a list of characters ('A', 'B', 'C', or 'D'), representing the correct option for each question.\nExamples:\n>>> (find-test-answers '((\"q1\" \"ans1\") (\"q2\" \"ans2\")) '((\"q1\" \"ans3\" \"ans1\" \"ans4\" \"ans5\") (\"q2\" \"ans2\" \"ans6\" \"ans7\" \"ans8\")))\n'(\"B\" \"A\")\n>>> (find-test-answers '((\"q1\" \"ans1\")) '((\"q1\" \"ans2\" \"ans3\" \"ans1\" \"ans4\")))\n'(\"C\")\n", "level": "hard"}
{"task_id": "Scheme/33", "prompt": "#lang racket\n(require rackunit)\n(define (count-ones binary-string)\n#|\nCounts the number of '1's in a given binary string.\nThe function takes a string 'binary-string' consisting of only '0's and '1's and returns the count of '1's in it.\nThe length of the string is assumed to be 8 characters.\nExamples:\n>>> count-ones(\"01010101\")\n4\n>>> count-ones(\"00000000\")\n0\n>>> count-ones(\"11110000\")\n4\n|#", "canonical_solution": "(define (count-ones-helper str idx count)\n(if (= idx (string-length str))\ncount\n(count-ones-helper str (+ idx 1) (if (char=? (string-ref str idx) #\\1) (+ count 1) count))))\n(count-ones-helper binary-string 0 0))", "test": "(define (check count-ones)\n(check-equal? (count-ones \"01010101\") 4)\n(check-equal? (count-ones \"00000000\") 0)\n(check-equal? (count-ones \"11110000\") 4)\n(check-equal? (count-ones \"00101011\") 4)\n(check-equal? (count-ones \"10000001\") 2)\n(check-equal? (count-ones \"01111110\") 6))\n\n(check count-ones)", "entry_point": "count-ones", "signature": "(define (count-ones", "docstring": "\nCounts the number of '1's in a given binary string.\nThe function takes a string 'binary-string' consisting of only '0's and '1's and returns the count of '1's in it.\nThe length of the string is assumed to be 8 characters.\nExamples:\n>>> count-ones(\"01010101\")\n4\n>>> count-ones(\"00000000\")\n0\n>>> count-ones(\"11110000\")\n4\n", "instruction": "Write a Scheme function `(define (count-ones` to solve the following problem:\n\nCounts the number of '1's in a given binary string.\nThe function takes a string 'binary-string' consisting of only '0's and '1's and returns the count of '1's in it.\nThe length of the string is assumed to be 8 characters.\nExamples:\n>>> count-ones(\"01010101\")\n4\n>>> count-ones(\"00000000\")\n0\n>>> count-ones(\"11110000\")\n4\n", "level": "easy"}
{"task_id": "Scheme/34", "prompt": "#lang racket\n(require rackunit)\n\n(define (compare-areas a b c)\n#|\nCompares the areas of a square and a rectangle.\nThe square has a side length 'a', and the rectangle has lengths 'b' and 'c'.\nReturns \"Alice\" if the square's area is larger, \"Bob\" if the rectangle's area is larger, or \"Equal\" if the areas are the same.\nExamples:\n>>> compare-areas 5 3 3\n\"Alice\"\n>>> compare-areas 4 2 4\n\"Equal\"\n|#", "canonical_solution": "(let ((square-area (* a a))\n(rectangle-area (* b c)))\n(cond\n((> square-area rectangle-area) \"Alice\")\n((< square-area rectangle-area) \"Bob\")\n(else \"Equal\"))))", "test": "(define (test-compare-areas)\n(check-equal? (compare-areas 3 2 4) \"Alice\")\n(check-equal? (compare-areas 5 3 3) \"Alice\")\n(check-equal? (compare-areas 4 2 4) \"Alice\")\n(check-equal? (compare-areas 6 2 5) \"Alice\")\n(check-equal? (compare-areas 2 3 4) \"Bob\")\n(check-equal? (compare-areas 4 4 4) \"Equal\"))\n\n(test-compare-areas)", "entry_point": "compare-areas", "signature": "(define (compare-areas", "docstring": "\nCompares the areas of a square and a rectangle.\nThe square has a side length 'a', and the rectangle has lengths 'b' and 'c'.\nReturns \"Alice\" if the square's area is larger, \"Bob\" if the rectangle's area is larger, or \"Equal\" if the areas are the same.\nExamples:\n>>> compare-areas 5 3 3\n\"Alice\"\n>>> compare-areas 4 2 4\n\"Equal\"\n", "instruction": "Write a Scheme function `(define (compare-areas` to solve the following problem:\n\nCompares the areas of a square and a rectangle.\nThe square has a side length 'a', and the rectangle has lengths 'b' and 'c'.\nReturns \"Alice\" if the square's area is larger, \"Bob\" if the rectangle's area is larger, or \"Equal\" if the areas are the same.\nExamples:\n>>> compare-areas 5 3 3\n\"Alice\"\n>>> compare-areas 4 2 4\n\"Equal\"\n", "level": "easy"}
{"task_id": "Scheme/35", "prompt": "#lang racket\n(require rackunit)\n\n(define (convert-to-uppercase letter)\n#|\nConverts a given lowercase letter to its corresponding uppercase letter.\nAssumes that the input 'letter' is a single lowercase letter.\n\nExamples:\n>>> convert-to-uppercase \"a\"\n\"A\"\n>>> convert-to-uppercase \"m\"\n\"M\"\n>>> convert-to-uppercase \"z\"\n\"Z\"\n|#", "canonical_solution": "(string (char-upcase (string-ref letter 0))))", "test": "(define (check convert-to-uppercase)\n(check-equal? (convert-to-uppercase \"a\") \"A\")\n(check-equal? (convert-to-uppercase \"m\") \"M\")\n(check-equal? (convert-to-uppercase \"z\") \"Z\")\n(check-equal? (convert-to-uppercase \"g\") \"G\")\n(check-equal? (convert-to-uppercase \"x\") \"X\"))\n\n(check convert-to-uppercase)", "entry_point": "convert-to-uppercase", "signature": "(define (convert-to-uppercase", "docstring": "\nConverts a given lowercase letter to its corresponding uppercase letter.\nAssumes that the input 'letter' is a single lowercase letter.\n\nExamples:\n>>> convert-to-uppercase \"a\"\n\"A\"\n>>> convert-to-uppercase \"m\"\n\"M\"\n>>> convert-to-uppercase \"z\"\n\"Z\"\n", "instruction": "Write a Scheme function `(define (convert-to-uppercase` to solve the following problem:\n\nConverts a given lowercase letter to its corresponding uppercase letter.\nAssumes that the input 'letter' is a single lowercase letter.\n\nExamples:\n>>> convert-to-uppercase \"a\"\n\"A\"\n>>> convert-to-uppercase \"m\"\n\"M\"\n>>> convert-to-uppercase \"z\"\n\"Z\"\n", "level": "easy"}
{"task_id": "Scheme/36", "prompt": "#lang racket\n(require rackunit)\n(define (remaining-apples m t s)\n#|\nCalculates the number of whole apples remaining after a certain time has passed.\n\n'm' is the total number of apples, with a constraint of 1 <= m <= 100.\n't' is the time in minutes it takes to eat one apple, with a constraint of 0 <= t <= 100.\n's' is the total time in minutes that has passed, with a constraint of 1 <= s <= 10000.\n\nThe function returns the number of whole apples remaining. If the time taken to eat all apples is less than or equal to the passed time, it returns 0. \n\nExamples:\n>>> remaining-apples 5 5 15\n2\n|#", "canonical_solution": "(if (= t 0)\nm\n(max 0 (- m (ceiling (/ s t)))))\n\n)", "test": "(define (check remaining-apples)\n(check-equal? (remaining-apples 5 5 15) 2) ; 5 apples, 5 mins each, 15 mins passed, 2 remaining\n(check-equal? (remaining-apples 3 10 5) 2) ; 3 apples, 10 mins each, 5 mins passed, 2 remaining\n(check-equal? (remaining-apples 8 0 50) 8) ; 8 apples, 0 mins each, 50 mins passed, 8 remaining\n(check-equal? (remaining-apples 10 1 5) 5) ; 10 apples, 1 min each, 5 mins passed, 5 remaining\n(check-equal? (remaining-apples 4 10 50) 0) ; 4 apples, 10 mins each, 50 mins passed, 0 remaining\n(check-equal? (remaining-apples 7 3 20) 0)) ; 7 apples, 3 mins each, 20 mins passed, 0 remaining\n\n(check remaining-apples)", "entry_point": "remaining-apples", "signature": "(define (remaining-apples", "docstring": "\nCalculates the number of whole apples remaining after a certain time has passed.\n\n'm' is the total number of apples, with a constraint of 1 <= m <= 100.\n't' is the time in minutes it takes to eat one apple, with a constraint of 0 <= t <= 100.\n's' is the total time in minutes that has passed, with a constraint of 1 <= s <= 10000.\n\nThe function returns the number of whole apples remaining. If the time taken to eat all apples is less than or equal to the passed time, it returns 0. \n\nExamples:\n>>> remaining-apples 5 5 15\n2\n", "instruction": "Write a Scheme function `(define (remaining-apples` to solve the following problem:\n\nCalculates the number of whole apples remaining after a certain time has passed.\n\n'm' is the total number of apples, with a constraint of 1 <= m <= 100.\n't' is the time in minutes it takes to eat one apple, with a constraint of 0 <= t <= 100.\n's' is the total time in minutes that has passed, with a constraint of 1 <= s <= 10000.\n\nThe function returns the number of whole apples remaining. If the time taken to eat all apples is less than or equal to the passed time, it returns 0. \n\nExamples:\n>>> remaining-apples 5 5 15\n2\n", "level": "easy"}
{"task_id": "Scheme/37", "prompt": "#lang racket\n(require rackunit)\n(define (check-integer-preferences x)\n#|\nDetermines the preferences of four individuals (A, B, C, D) for a given integer 'x'.\nEach individual has different criteria for liking an integer:\n- A likes integers that are both even and in the range 5 to 12 (inclusive).\n- B likes integers that are either even or in the range 5 to 12 (inclusive).\n- C likes integers that satisfy exactly one of the above two properties.\n- D likes integers that satisfy neither property.\nThe function returns a list of four elements, each either 0 or 1, representing whether each individual likes the integer 'x'.\nExamples:\n>>> check-integer-preferences 10\n'(1 1 0 0)\n>>> check-integer-preferences 3\n'(0 1 1 0)\n>>> check-integer-preferences 13\n'(0 0 0 1)\n|#", "canonical_solution": "(define (even? n) (= (remainder n 2) 0))\n(define (in-range? n) (and (> n 4) (<= n 12)))\n\n(define (likes-a? n) (and (even? n) (in-range? n)))\n(define (likes-uim? n) (or (even? n) (in-range? n)))\n(define (likes-yuki? n) (xor (even? n) (in-range? n)))\n(define (likes-mei? n) (not (or (even? n) (in-range? n))))\n\n(list (if (likes-a? x) 1 0)\n(if (likes-uim? x) 1 0)\n(if (likes-yuki? x) 1 0)\n(if (likes-mei? x) 1 0))\n)", "test": "(define (test-check-integer-preferences)\n(check-equal? (check-integer-preferences 10) '(1 1 0 0))\n(check-equal? (check-integer-preferences 3) '(0 0 0 1))\n(check-equal? (check-integer-preferences 13) '(0 0 0 1))\n(check-equal? (check-integer-preferences 8) '(1 1 0 0))\n(check-equal? (check-integer-preferences 5) '(0 1 1 0))\n(check-equal? (check-integer-preferences 2) '(0 1 1 0)))\n\n(test-check-integer-preferences)", "entry_point": "check-integer-preferences", "signature": "(define (check-integer-preferences", "docstring": "\nDetermines the preferences of four individuals (A, B, C, D) for a given integer 'x'.\nEach individual has different criteria for liking an integer:\n- A likes integers that are both even and in the range 5 to 12 (inclusive).\n- B likes integers that are either even or in the range 5 to 12 (inclusive).\n- C likes integers that satisfy exactly one of the above two properties.\n- D likes integers that satisfy neither property.\nThe function returns a list of four elements, each either 0 or 1, representing whether each individual likes the integer 'x'.\nExamples:\n>>> check-integer-preferences 10\n'(1 1 0 0)\n>>> check-integer-preferences 3\n'(0 1 1 0)\n>>> check-integer-preferences 13\n'(0 0 0 1)\n", "instruction": "Write a Scheme function `(define (check-integer-preferences` to solve the following problem:\n\nDetermines the preferences of four individuals (A, B, C, D) for a given integer 'x'.\nEach individual has different criteria for liking an integer:\n- A likes integers that are both even and in the range 5 to 12 (inclusive).\n- B likes integers that are either even or in the range 5 to 12 (inclusive).\n- C likes integers that satisfy exactly one of the above two properties.\n- D likes integers that satisfy neither property.\nThe function returns a list of four elements, each either 0 or 1, representing whether each individual likes the integer 'x'.\nExamples:\n>>> check-integer-preferences 10\n'(1 1 0 0)\n>>> check-integer-preferences 3\n'(0 1 1 0)\n>>> check-integer-preferences 13\n'(0 0 0 1)\n", "level": "hard"}
{"task_id": "Scheme/38", "prompt": "#lang racket\n(require rackunit)\n(define (is-leap-year year)\n#|\nDetermines whether a given year is a leap year.\nA leap year is divisible by 4, but not by 100, unless it is also divisible by 400.\nReturns 1 if the year is a leap year, otherwise returns 0.\nExamples:\n>>> is-leap-year(2024)\n1\n>>> is-leap-year(2100)\n0\n>>> is-leap-year(2004)\n1\n|#", "canonical_solution": "(if (or (zero? (modulo year 400))\n(and (zero? (modulo year 4)) (not (zero? (modulo year 100)))))\n1\n0))", "test": "(define (check is-leap-year)\n(check-equal? (is-leap-year 2024) 1)\n(check-equal? (is-leap-year 2100) 0)\n(check-equal? (is-leap-year 2004) 1)\n(check-equal? (is-leap-year 1901) 0)\n(check-equal? (is-leap-year 2400) 1)\n(check-equal? (is-leap-year 1999) 0))\n\n(check is-leap-year)", "entry_point": "is-leap-year", "signature": "(define (is-leap-year", "docstring": "\nDetermines whether a given year is a leap year.\nA leap year is divisible by 4, but not by 100, unless it is also divisible by 400.\nReturns 1 if the year is a leap year, otherwise returns 0.\nExamples:\n>>> is-leap-year(2024)\n1\n>>> is-leap-year(2100)\n0\n>>> is-leap-year(2004)\n1\n", "instruction": "Write a Scheme function `(define (is-leap-year` to solve the following problem:\n\nDetermines whether a given year is a leap year.\nA leap year is divisible by 4, but not by 100, unless it is also divisible by 400.\nReturns 1 if the year is a leap year, otherwise returns 0.\nExamples:\n>>> is-leap-year(2024)\n1\n>>> is-leap-year(2100)\n0\n>>> is-leap-year(2004)\n1\n", "level": "easy"}
{"task_id": "Scheme/39", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-minimum-n k)\n  #|\n  Computes the minimum value of n for which the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\n  The function takes a single integer argument k and returns the smallest integer n such that S_n > k.\n\n  Examples:\n  >>> find-minimum-n(3)\n  11\n  >>> find-minimum-n(4)\n  31\n  >>> find-minimum-n(2)\n  4\n  |#", "canonical_solution": "  (let loop ((n 1) (sum 0))\n    (if (> sum k)\n        (- n 1)\n        (loop (+ n 1) (+ sum (/ 1 n))))))", "test": "(define (check find-minimum-n)\n  (check-equal? (find-minimum-n 3) 11)\n  (check-equal? (find-minimum-n 4) 31)\n  (check-equal? (find-minimum-n 2) 4)\n  (check-equal? (find-minimum-n 5) 83)\n  (check-equal? (find-minimum-n 1) 2)\n  (check-not-equal? (find-minimum-n 3) 10))\n\n(check find-minimum-n)", "entry_point": "find-minimum-n", "signature": "(define (find-minimum-n k)", "docstring": "Computes the minimum value of n for which the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\nThe function takes a single integer argument k and returns the smallest integer n such that S_n > k.\n\nExamples:\n>>> find-minimum-n(3)\n11\n>>> find-minimum-n(4)\n31\n>>> find-minimum-n(2)\n4", "instruction": "Write a Scheme function `(define (find-minimum-n k)` to solve the following problem:Computes the minimum value of n for which the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n exceeds a given integer k.\nThe function takes a single integer argument k and returns the smallest integer n such that S_n > k.\n\nExamples:\n>>> find-minimum-n(3)\n11\n>>> find-minimum-n(4)\n31\n>>> find-minimum-n(2)\n4", "level": "easy"}
{"task_id": "Scheme/40", "prompt": "#lang racket\n(require rackunit)\n\n(define (max-pens a b)\n  #|\n  Determines the maximum number of pens that can be purchased with a given amount of money. A pen costs 1 yuan and 9 jiao (1.9 yuan), and the available money is specified in yuan (a) and jiao (b).\n  This function takes two arguments: a (yuan) and b (jiao), and returns the maximum number of pens that can be bought.\n\n  Examples:\n  >>> max-pens(20 5)\n  10.0\n  >>> max-pens(3 8)\n  2.0\n  >>> max-pens(0 9)\n  0.0\n  |#", "canonical_solution": "  (let* ((total-money (+ a (* b 0.1))) ; Convert all money to yuan\n         (pen-price 1.9)              ; Price of one pen\n         (max-pens (floor (/ total-money pen-price)))) ; Calculate max pens\n    max-pens))", "test": "(define (check max-pens)\n  (check-equal? (max-pens 20 5) 10.0)\n  (check-equal? (max-pens 3 8) 2.0)\n  (check-equal? (max-pens 0 9) 0.0)\n  (check-equal? (max-pens 11 0) 5.0)\n  (check-equal? (max-pens 50 5) 26.0)\n  (check-not-equal? (max-pens 10 3) 4.0))\n\n(check max-pens)", "entry_point": "max-pens", "signature": "(define (max-pens a b)", "docstring": "Determines the maximum number of pens that can be purchased with a given amount of money. A pen costs 1 yuan and 9 jiao (1.9 yuan), and the available money is specified in yuan (a) and jiao (b).\nThis function takes two arguments: a (yuan) and b (jiao), and returns the maximum number of pens that can be bought.\n\nExamples:\n>>> max-pens(20 5)\n10.0\n>>> max-pens(3 8)\n2.0\n>>> max-pens(0 9)\n0.0", "instruction": "Write a Scheme function `(define (max-pens a b)` to solve the following problem:Determines the maximum number of pens that can be purchased with a given amount of money. A pen costs 1 yuan and 9 jiao (1.9 yuan), and the available money is specified in yuan (a) and jiao (b).\nThis function takes two arguments: a (yuan) and b (jiao), and returns the maximum number of pens that can be bought.\n\nExamples:\n>>> max-pens(20 5)\n10.0\n>>> max-pens(3 8)\n2.0\n>>> max-pens(0 9)\n0.0", "level": "easy"}
{"task_id": "Scheme/41", "prompt": "#lang racket\n(require rackunit)\n\n(define (calculate-expression a b c)\n  #|\n  Calculates the value of the expression (a+b) * c given three integers a, b, and c.\n  This function takes three arguments a, b, and c, and returns the computed value of (a+b)*c.\n  Examples:\n  >>> calculate-expression(1, 2, 3)\n  9\n  >>> calculate-expression(-1, -2, 2)\n  -6\n  >>> calculate-expression(0, 0, 5)\n  0\n  |#", "canonical_solution": "  (* (+ a b) c))", "test": "(define (check calculate-expression)\n  (check-equal? (calculate-expression 1 2 3) 9)\n  (check-equal? (calculate-expression -1 -2 2) -6)\n  (check-equal? (calculate-expression 0 0 5) 0)\n  (check-equal? (calculate-expression 5 5 -2) -20)\n  (check-equal? (calculate-expression 3 2 4) 20)\n  (check-not-equal? (calculate-expression 1 1 1) 3))\n\n(check calculate-expression)", "entry_point": "calculate-expression", "signature": "(define (calculate-expression a b c)", "docstring": "Calculates the value of the expression (a+b) * c given three integers a, b, and c.\nThis function takes three arguments a, b, and c, and returns the computed value of (a+b)*c.\nExamples:\n>>> calculate-expression(1, 2, 3)\n9\n>>> calculate-expression(-1, -2, 2)\n-6\n>>> calculate-expression(0, 0, 5)\n0", "instruction": "Write a Scheme function `(define (calculate-expression a b c)` to solve the following problem:Calculates the value of the expression (a+b) * c given three integers a, b, and c.\nThis function takes three arguments a, b, and c, and returns the computed value of (a+b)*c.\nExamples:\n>>> calculate-expression(1, 2, 3)\n9\n>>> calculate-expression(-1, -2, 2)\n-6\n>>> calculate-expression(0, 0, 5)\n0", "level": "easy"}
{"task_id": "Scheme/42", "prompt": "#lang racket\n(require rackunit)\n\n(define (char-to-ascii char)\n  #|\n  Converts a single visible character (excluding space) to its ASCII code and returns the code as an integer.\n  The function takes a single character as input and outputs the ASCII code of that character.\n  Examples:\n  >>> char-to-ascii('A')\n  65\n  >>> char-to-ascii('z')\n  122\n  >>> char-to-ascii('0')\n  48\n  |#", "canonical_solution": "  (char->integer char))", "test": "(define (check char-to-ascii)\n  (check-equal? (char-to-ascii #\\A) 65)\n  (check-equal? (char-to-ascii #\\z) 122)\n  (check-equal? (char-to-ascii #\\0) 48)\n  (check-equal? (char-to-ascii #\\=) 61)\n  (check-equal? (char-to-ascii #\\!) 33)\n  (check-not-equal? (char-to-ascii #\\A) 66))\n\n(check char-to-ascii)", "entry_point": "char-to-ascii", "signature": "(define (char-to-ascii char)", "docstring": "Converts a single visible character (excluding space) to its ASCII code and returns the code as an integer.\nThe function takes a single character as input and outputs the ASCII code of that character.\nExamples:\n>>> char-to-ascii('A')\n65\n>>> char-to-ascii('z')\n122\n>>> char-to-ascii('0')\n48", "instruction": "Write a Scheme function `(define (char-to-ascii char)` to solve the following problem:Converts a single visible character (excluding space) to its ASCII code and returns the code as an integer.\nThe function takes a single character as input and outputs the ASCII code of that character.\nExamples:\n>>> char-to-ascii('A')\n65\n>>> char-to-ascii('z')\n122\n>>> char-to-ascii('0')\n48", "level": "easy"}
{"task_id": "Scheme/43", "prompt": "#lang racket\n(require rackunit)\n\n(define (ascii-to-char code)\n  #|\n  Converts an ASCII code to its corresponding character. The function takes an integer 'code'\n  representing the ASCII code and returns the character associated with that code.\n  Only ASCII codes that represent visible characters (greater than 0 and less than 128) are considered valid inputs.\n  Examples:\n  >>> ascii-to-char(65)\n  'A'\n  >>> ascii-to-char(122)\n  'z'\n  >>> ascii-to-char(48)\n  '0'\n  |#", "canonical_solution": "  (integer->char code))", "test": "(define (check ascii-to-char)\n  (check-equal? (ascii-to-char 65) #\\A)\n  (check-equal? (ascii-to-char 122) #\\z)\n  (check-equal? (ascii-to-char 48) #\\0)\n  (check-equal? (ascii-to-char 33) #\\!)\n  (check-equal? (ascii-to-char 57) #\\9)\n  (check-not-equal? (ascii-to-char 65) #\\B))\n\n(check ascii-to-char)", "entry_point": "ascii-to-char", "signature": "(define (ascii-to-char code)", "docstring": "Converts an ASCII code to its corresponding character. The function takes an integer 'code'\nrepresenting the ASCII code and returns the character associated with that code.\nOnly ASCII codes that represent visible characters (greater than 0 and less than 128) are considered valid inputs.\nExamples:\n>>> ascii-to-char(65)\n'A'\n>>> ascii-to-char(122)\n'z'\n>>> ascii-to-char(48)\n'0'", "instruction": "Write a Scheme function `(define (ascii-to-char code)` to solve the following problem:Converts an ASCII code to its corresponding character. The function takes an integer 'code'\nrepresenting the ASCII code and returns the character associated with that code.\nOnly ASCII codes that represent visible characters (greater than 0 and less than 128) are considered valid inputs.\nExamples:\n>>> ascii-to-char(65)\n'A'\n>>> ascii-to-char(122)\n'z'\n>>> ascii-to-char(48)\n'0'", "level": "easy"}
{"task_id": "Scheme/44", "prompt": "#lang racket\n(require rackunit)\n\n(define (int-bool-int-conversion num)\n  #|\n  Converts an integer to a boolean value and then back to an integer. In Scheme, non-zero integers are treated as true (represented by #t),\n  and only 0 is treated as false (#f). Therefore, any non-zero input will result in 1 (true), and 0 will remain 0 (false).\n  The function takes an integer 'num' and returns 1 if 'num' is non-zero, otherwise it returns 0.\n  Examples:\n  >>> int-bool-int-conversion(5)\n  1\n  >>> int-bool-int-conversion(0)\n  0\n  >>> int-bool-int-conversion(-3)\n  1\n  |#", "canonical_solution": "  (if (= num 0) 0 1))", "test": "(define (check int-bool-int-conversion)\n  (check-equal? (int-bool-int-conversion 5) 1)\n  (check-equal? (int-bool-int-conversion 0) 0)\n  (check-equal? (int-bool-int-conversion -3) 1)\n  (check-equal? (int-bool-int-conversion 100) 1)\n  (check-equal? (int-bool-int-conversion -1) 1)\n  (check-not-equal? (int-bool-int-conversion 1) 0))\n\n(check int-bool-int-conversion)", "entry_point": "int-bool-int-conversion", "signature": "(define (int-bool-int-conversion num)", "docstring": "Converts an integer to a boolean value and then back to an integer. In Scheme, non-zero integers are treated as true (represented by #t),\nand only 0 is treated as false (#f). Therefore, any non-zero input will result in 1 (true), and 0 will remain 0 (false).\nThe function takes an integer 'num' and returns 1 if 'num' is non-zero, otherwise it returns 0.\nExamples:\n>>> int-bool-int-conversion(5)\n1\n>>> int-bool-int-conversion(0)\n0\n>>> int-bool-int-conversion(-3)\n1", "instruction": "Write a Scheme function `(define (int-bool-int-conversion num)` to solve the following problem:Converts an integer to a boolean value and then back to an integer. In Scheme, non-zero integers are treated as true (represented by #t),\nand only 0 is treated as false (#f). Therefore, any non-zero input will result in 1 (true), and 0 will remain 0 (false).\nThe function takes an integer 'num' and returns 1 if 'num' is non-zero, otherwise it returns 0.\nExamples:\n>>> int-bool-int-conversion(5)\n1\n>>> int-bool-int-conversion(0)\n0\n>>> int-bool-int-conversion(-3)\n1", "level": "easy"}
{"task_id": "Scheme/45", "prompt": "#lang racket\n(require rackunit)\n\n(define (reverse-three-digit num)\n  #|\n  Reverses a three-digit number and returns the reversed number. This function takes a three-digit integer 'num' as input\n  and returns a new integer that represents the digits of 'num' in reverse order. Leading zeros are preserved in the output.\n  Examples:\n  >>> reverse-three-digit(123)\n  321\n  >>> reverse-three-digit(400)\n  4\n  |#", "canonical_solution": "  (string->number (list->string (reverse (string->list (number->string num))))))", "test": "(define (check reverse-three-digit)\n  (check-equal? (reverse-three-digit 123) 321)\n  (check-equal? (reverse-three-digit 400) 4) ; Note: Scheme automatically removes leading zeros in numbers.\n  (check-equal? (reverse-three-digit 50) 5)  ; Adjusted example to fit Scheme's representation of numbers.\n  (check-equal? (reverse-three-digit 678) 876)\n  (check-equal? (reverse-three-digit 905) 509)\n  (check-not-equal? (reverse-three-digit 123) 123))\n\n(check reverse-three-digit)", "entry_point": "reverse-three-digit", "signature": "(define (reverse-three-digit num)", "docstring": "Reverses a three-digit number and returns the reversed number. This function takes a three-digit integer 'num' as input\nand returns a new integer that represents the digits of 'num' in reverse order. Leading zeros are preserved in the output.\nExamples:\n>>> reverse-three-digit(123)\n321\n>>> reverse-three-digit(400)\n4", "instruction": "Write a Scheme function `(define (reverse-three-digit num)` to solve the following problem:Reverses a three-digit number and returns the reversed number. This function takes a three-digit integer 'num' as input\nand returns a new integer that represents the digits of 'num' in reverse order. Leading zeros are preserved in the output.\nExamples:\n>>> reverse-three-digit(123)\n321\n>>> reverse-three-digit(400)\n4", "level": "easy"}
{"task_id": "Scheme/46", "prompt": "#lang racket\n(require rackunit)\n\n(define (arithmetic-sequence-nth-term a1 a2 n)\n  #|\n  Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2, and the term position n.\n  The difference between any two consecutive terms is constant. The function returns the value of the nth term.\n  Examples:\n  >>> arithmetic-sequence-nth-term(1, 3, 4)\n  7\n  >>> arithmetic-sequence-nth-term(5, 7, 10)\n  23\n  >>> arithmetic-sequence-nth-term(-2, 4, 6)\n  22\n  |#", "canonical_solution": "  (+ a1 (* (- a2 a1) (- n 1))))", "test": "(define (check arithmetic-sequence-nth-term)\n  (check-equal? (arithmetic-sequence-nth-term 1 3 4) 7)\n  (check-equal? (arithmetic-sequence-nth-term 5 7 10) 23)\n  (check-equal? (arithmetic-sequence-nth-term -2 4 6) 28)\n  (check-equal? (arithmetic-sequence-nth-term 0 2 50) 98)\n  (check-equal? (arithmetic-sequence-nth-term 100 -100 11) -1900)\n  (check-not-equal? (arithmetic-sequence-nth-term 1 1 1) 2))\n\n(check arithmetic-sequence-nth-term)", "entry_point": "arithmetic-sequence-nth-term", "signature": "(define (arithmetic-sequence-nth-term a1 a2 n)", "docstring": "Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2, and the term position n.\nThe difference between any two consecutive terms is constant. The function returns the value of the nth term.\nExamples:\n>>> arithmetic-sequence-nth-term(1, 3, 4)\n7\n>>> arithmetic-sequence-nth-term(5, 7, 10)\n23\n>>> arithmetic-sequence-nth-term(-2, 4, 6)\n22", "instruction": "Write a Scheme function `(define (arithmetic-sequence-nth-term a1 a2 n)` to solve the following problem:Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2, and the term position n.\nThe difference between any two consecutive terms is constant. The function returns the value of the nth term.\nExamples:\n>>> arithmetic-sequence-nth-term(1, 3, 4)\n7\n>>> arithmetic-sequence-nth-term(5, 7, 10)\n23\n>>> arithmetic-sequence-nth-term(-2, 4, 6)\n22", "level": "easy"}
{"task_id": "Scheme/47", "prompt": "#lang racket\n(require rackunit)\n\n(define (multiply a b)  \n  #|\n  Calculates the product of two positive integers A and B. This function takes two integers 'a' and 'b' as input\n  and returns their product. The range of input values is from 1 to 50000, so the function ensures that the output\n  is within the bounds of integer values that Scheme can handle.\n  Examples:\n  >>> multiply(5, 6)\n  30\n  >>> multiply(10, 10)\n  100\n  >>> multiply(500, 100)\n  50000\n  |#", "canonical_solution": "  (* a b))", "test": "(define (check multiply)\n  (check-equal? (multiply 5 6) 30)\n  (check-equal? (multiply 10 10) 100)\n  (check-equal? (multiply 500 100) 50000)\n  (check-equal? (multiply 1 50000) 50000)\n  (check-equal? (multiply 123 456) 56088)\n  (check-not-equal? (multiply 2 2) 5))\n\n(check multiply)", "entry_point": "multiply", "signature": "(define (multiply a b)  ", "docstring": "Calculates the product of two positive integers A and B. This function takes two integers 'a' and 'b' as input\nand returns their product. The range of input values is from 1 to 50000, so the function ensures that the output\nis within the bounds of integer values that Scheme can handle.\nExamples:\n>>> multiply(5, 6)\n30\n>>> multiply(10, 10)\n100\n>>> multiply(500, 100)\n50000", "instruction": "Write a Scheme function `(define (multiply a b)  ` to solve the following problem:Calculates the product of two positive integers A and B. This function takes two integers 'a' and 'b' as input\nand returns their product. The range of input values is from 1 to 50000, so the function ensures that the output\nis within the bounds of integer values that Scheme can handle.\nExamples:\n>>> multiply(5, 6)\n30\n>>> multiply(10, 10)\n100\n>>> multiply(500, 100)\n50000", "level": "easy"}
{"task_id": "Scheme/48", "prompt": "#lang racket\n(require rackunit)\n\n(define (sign-of-n n)\n  #|\n  Determines if an integer N is positive, zero, or negative and returns a string indicating the sign.\n  This function takes a single integer 'n' as input and returns 'positive' if N > 0, 'zero' if N = 0,\n  and 'negative' if N < 0. The range of N is from -10^9 to 10^9.\n  Examples:\n  >>> sign-of-n(10)\n  \"positive\"\n  >>> sign-of-n(0)\n  \"zero\"\n  >>> sign-of-n(-5)\n  \"negative\"\n  |#", "canonical_solution": "  (cond\n    [(> n 0) \"positive\"]\n    [(< n 0) \"negative\"]\n    [else \"zero\"]))", "test": "(define (check sign-of-n)\n  (check-equal? (sign-of-n 10) \"positive\")\n  (check-equal? (sign-of-n 0) \"zero\")\n  (check-equal? (sign-of-n -5) \"negative\")\n  (check-equal? (sign-of-n 1000000000) \"positive\")\n  (check-equal? (sign-of-n -1000000000) \"negative\")\n  (check-not-equal? (sign-of-n 1) \"negative\"))\n\n(check sign-of-n)", "entry_point": "sign-of-n", "signature": "(define (sign-of-n n)", "docstring": "Determines if an integer N is positive, zero, or negative and returns a string indicating the sign.\nThis function takes a single integer 'n' as input and returns 'positive' if N > 0, 'zero' if N = 0,\nand 'negative' if N < 0. The range of N is from -10^9 to 10^9.\nExamples:\n>>> sign-of-n(10)\n\"positive\"\n>>> sign-of-n(0)\n\"zero\"\n>>> sign-of-n(-5)\n\"negative\"", "instruction": "Write a Scheme function `(define (sign-of-n n)` to solve the following problem:Determines if an integer N is positive, zero, or negative and returns a string indicating the sign.\nThis function takes a single integer 'n' as input and returns 'positive' if N > 0, 'zero' if N = 0,\nand 'negative' if N < 0. The range of N is from -10^9 to 10^9.\nExamples:\n>>> sign-of-n(10)\n\"positive\"\n>>> sign-of-n(0)\n\"zero\"\n>>> sign-of-n(-5)\n\"negative\"", "level": "easy"}
{"task_id": "Scheme/49", "prompt": "#lang racket\n(require rackunit)\n\n(define (power-of-two n)\n  #|\n  Calculates the value of 2 raised to the power of a non-negative integer n. This function takes an integer 'n'\n  as input and returns the value of 2^n. The range of 'n' is from 0 to 30, inclusive, to ensure the output\n  is within a manageable integer range.\n  Examples:\n  >>> power-of-two(0)\n  1\n  >>> power-of-two(4)\n  16\n  >>> power-of-two(10)\n  1024\n  |#", "canonical_solution": "  (expt 2 n))", "test": "(define (check power-of-two)\n  (check-equal? (power-of-two 0) 1)\n  (check-equal? (power-of-two 4) 16)\n  (check-equal? (power-of-two 10) 1024)\n  (check-equal? (power-of-two 5) 32)\n  (check-equal? (power-of-two 15) 32768)\n  (check-not-equal? (power-of-two 6) 32))\n\n(check power-of-two)", "entry_point": "power-of-two", "signature": "(define (power-of-two n)", "docstring": "Calculates the value of 2 raised to the power of a non-negative integer n. This function takes an integer 'n'\nas input and returns the value of 2^n. The range of 'n' is from 0 to 30, inclusive, to ensure the output\nis within a manageable integer range.\nExamples:\n>>> power-of-two(0)\n1\n>>> power-of-two(4)\n16\n>>> power-of-two(10)\n1024", "instruction": "Write a Scheme function `(define (power-of-two n)` to solve the following problem:Calculates the value of 2 raised to the power of a non-negative integer n. This function takes an integer 'n'\nas input and returns the value of 2^n. The range of 'n' is from 0 to 30, inclusive, to ensure the output\nis within a manageable integer range.\nExamples:\n>>> power-of-two(0)\n1\n>>> power-of-two(4)\n16\n>>> power-of-two(10)\n1024", "level": "easy"}
{"task_id": "Scheme/50", "prompt": "#lang racket\n(require rackunit)\n\n(define (absolute-value n)\n  #|\n  Outputs the absolute value of an integer n. The function takes a single integer 'n' as input\n  and returns its absolute value. The absolute value of 'n' is guaranteed not to exceed 10000.\n  Examples:\n  >>> absolute-value(-10)\n  10\n  >>> absolute-value(5)\n  5\n  >>> absolute-value(0)\n  0\n  |#", "canonical_solution": "  (abs n))", "test": "(define (check absolute-value)\n  (check-equal? (absolute-value -10) 10)\n  (check-equal? (absolute-value 5) 5)\n  (check-equal? (absolute-value 0) 0)\n  (check-equal? (absolute-value -10000) 10000)\n  (check-equal? (absolute-value 9999) 9999)\n  (check-not-equal? (absolute-value -1) -1))\n\n(check absolute-value)", "entry_point": "absolute-value", "signature": "(define (absolute-value n)", "docstring": "Outputs the absolute value of an integer n. The function takes a single integer 'n' as input\nand returns its absolute value. The absolute value of 'n' is guaranteed not to exceed 10000.\nExamples:\n>>> absolute-value(-10)\n10\n>>> absolute-value(5)\n5\n>>> absolute-value(0)\n0", "instruction": "Write a Scheme function `(define (absolute-value n)` to solve the following problem:Outputs the absolute value of an integer n. The function takes a single integer 'n' as input\nand returns its absolute value. The absolute value of 'n' is guaranteed not to exceed 10000.\nExamples:\n>>> absolute-value(-10)\n10\n>>> absolute-value(5)\n5\n>>> absolute-value(0)\n0", "level": "easy"}
