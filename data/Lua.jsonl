{"task_id": "Lua/1", "prompt": "\n-- Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()", "canonical_solution": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\nend", "test": "function testHelloMMCodeEval()\n    assert(hello_mmcodeeval() == \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\")\nend", "entry_point": "hello_mmcodeeval", "signature": "function hello_mmcodeeval()", "docstring": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"", "instruction": "Write a Lua function `function hello_mmcodeeval()` to solve the following problem:\nReturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"", "level": "easy"}
{"task_id": "Lua/2", "prompt": "\n--[[\nCalculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- number: If the provided sides form a triangle, returns the calculated area \n          with 2 decimal places. Otherwise, returns -1 to indicate invalid input.\n\nExamples:\n    print(calculate_triangle_area(3, 5, 4)) -- Should print 6\n    print(calculate_triangle_area(1, 1, 4)) -- Should print -1 for not a triangle\n--]]\nfunction calculate_triangle_area(a, b, c)", "canonical_solution": "-- Check if sides can form a triangle\n    if a + b > c and a + c > b and b + c > a then\n        -- Heron's formula\n        local s = (a + b + c) / 2.0\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    else\n        -- Not a triangle\n        return -1\n    end\nend", "test": "function testCalculateTriangleArea()\n    -- Triangle with sides 3, 5, 4 should return area close to 6\n    local area = calculate_triangle_area(3, 5, 4)\n    assert(math.abs(area - 6) < 1e-6)\n\n    -- Not a triangle with sides 1, 1, 4\n    area = calculate_triangle_area(1, 1, 4)\n    assert(area == -1)\n\n    -- Triangle with sides 7, 24, 25 should return area close to 84\n    area = calculate_triangle_area(7, 24, 25)\n    assert(math.abs(area - 84) < 1e-6)\n\n    -- Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculate_triangle_area(10.5, 6.2, 7.3)\n    -- Assuming the test is for an area close to an expected value due to precision\n    assert(math.abs(area - 22.15) < 1e-2)\n\n    -- print(\"All tests passed successfully.\")\nend\n\ntestCalculateTriangleArea()", "entry_point": "calculate_triangle_area", "signature": "function calculate_triangle_area(a, b, c)", "docstring": "Calculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- number: If the provided sides form a triangle, returns the calculated area with 2 decimal places. Otherwise, returns -1 to indicate invalid input.\n\nExamples:\n    print(calculate_triangle_area(3, 5, 4)) -- Should print 6\n    print(calculate_triangle_area(1, 1, 4)) -- Should print -1 for not a triangle\n", "instruction": "Write a Lua function `function calculate_triangle_area(a, b, c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- number: If the provided sides form a triangle, returns the calculated area with 2 decimal places. Otherwise, returns -1 to indicate invalid input.\n\nExamples:\n    print(calculate_triangle_area(3, 5, 4)) -- Should print 6\n    print(calculate_triangle_area(1, 1, 4)) -- Should print -1 for not a triangle\n", "level": "easy"}
{"task_id": "Lua/3", "prompt": "\n--[[\nCalculate the value of the function for a given input.\n    Parameters:\n      - x (integer): Input value for the function.\n    Returns:\n      - number or string: If x is not in the defined domain, the returned value is \"Not define\".\n      Otherwise, the function returns the calculated value rounded to 5 decimal places.\n\n    Function Definitions:\n      - For 0 <= x < 10: y = cos(x + 3.0)\n      - For 10 <= x < 20: y = (cos(x + 7.5))^2\n      - For 20 <= x < 30: y = (cos(x + 4.0))^4\n      Example Usage:\n        print(calculate_function_value(5))  -- Expected Output: y represented as a string rounded to 5 decimal places\n        print(calculate_function_value(40)) -- Expected Output: \"Not define\"\n]]--\nfunction calculate_function_value(x)", "canonical_solution": "local output\n    if 0 <= x and x < 10 then\n        output = string.format(\"%.5f\", math.cos(x + 3.0))\n    elseif 10 <= x and x < 20 then\n        output = string.format(\"%.5f\", math.pow(math.cos(x + 7.5), 2.0))\n    elseif 20 <= x and x < 30 then\n        output = string.format(\"%.5f\", math.pow(math.cos(x + 4.0), 4.0))\n    else\n        return \"Not define\"\n    end\n    return output\nend", "test": "function test_calculate_function_value()\n    assert(calculate_function_value(40) == \"Not define\")\n    assert(calculate_function_value(5) == \"-0.14550\")\n    assert(calculate_function_value(15) == \"0.76266\")\n    assert(calculate_function_value(25) == \"0.31314\")\n    assert(calculate_function_value(-1) == \"Not define\")\nend\n\ntest_calculate_function_value()", "entry_point": "calculate_function_value", "signature": "function calculate_function_value(x)", "docstring": "Calculate the value of the function for a given input.\n    Parameters:\n      - x (integer): Input value for the function.\n    Returns:\n      - number or string: If x is not in the defined domain, the returned value is \"Not define\".\n      Otherwise, the function returns the calculated value rounded to 5 decimal places.\n\n    Function Definitions:\n      - For 0 <= x < 10: y = cos(x + 3.0)\n      - For 10 <= x < 20: y = (cos(x + 7.5))^2\n      - For 20 <= x < 30: y = (cos(x + 4.0))^4\n      Example Usage:\n        print(calculate_function_value(5))  -- Expected Output: y represented as a string rounded to 5 decimal places\n        print(calculate_function_value(40)) -- Expected Output: \"Not define\"", "instruction": "Write a Lua function `function calculate_function_value(x)` to solve the following problem:\nCalculate the value of the function for a given input.\n    Parameters:\n      - x (integer): Input value for the function.\n    Returns:\n      - number or string: If x is not in the defined domain, the returned value is \"Not define\".\n      Otherwise, the function returns the calculated value rounded to 5 decimal places.\n\n    Function Definitions:\n      - For 0 <= x < 10: y = cos(x + 3.0)\n      - For 10 <= x < 20: y = (cos(x + 7.5))^2\n      - For 20 <= x < 30: y = (cos(x + 4.0))^4\n      Example Usage:\n        print(calculate_function_value(5))  -- Expected Output: y represented as a string rounded to 5 decimal places\n        print(calculate_function_value(40)) -- Expected Output: \"Not define\"", "level": "middle"}
{"task_id": "Lua/4", "prompt": "\n--[[\nFind the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nA table with the maximum and minimum values, with \"max\" as the key for the maximum value and \"min\" as the key for the minimum value.\n\nExample call:\nlocal result = find_max_min(1,2,3)\nassert(result.max == 3 and result.min == 1)\n]]--\nfunction find_max_min(a, b, c)", "canonical_solution": "local max, min\n    if a > b then\n        if a > c then\n            max = a\n            min = (b < c) and b or c\n        else\n            max = c\n            min = b\n        end\n    else\n        if b > c then\n            max = b\n            min = (a < c) and a or c\n        else\n            max = c\n            min = a\n        end\n    end\n    return {max = max, min = min}\nend", "test": "function testFindMaxMin()\n    local result\n\n    result = find_max_min(1, 2, 3)\n    assert(result.max == 3 and result.min == 1)\n\n    -- Additional tests\n    result = find_max_min(5, 3, 4)\n    assert(result.max == 5 and result.min == 3)\n\n    result = find_max_min(10, -2, 7)\n    assert(result.max == 10 and result.min == -2)\n\n    result = find_max_min(-1, -3, -2)\n    assert(result.max == -1 and result.min == -3)\nend\n\ntestFindMaxMin()", "entry_point": "find_max_min", "signature": "function find_max_min(a, b, c)", "docstring": "Find the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nA table with the maximum and minimum values, with \"max\" as the key for the maximum value and \"min\" as the key for the minimum value.\n\nExample call:\nlocal result = find_max_min(1,2,3)\nassert(result.max == 3 and result.min == 1)", "instruction": "Write a Lua function `function find_max_min(a, b, c)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nA table with the maximum and minimum values, with \"max\" as the key for the maximum value and \"min\" as the key for the minimum value.\n\nExample call:\nlocal result = find_max_min(1,2,3)\nassert(result.max == 3 and result.min == 1)", "level": "middle"}
{"task_id": "Lua/5", "prompt": "\n--[[\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\nUsage examples:\nprint(calculate_distance(0, 0, 3, 4)) -- Output: 5\n]]--\nfunction calculate_distance(xa, ya, xb, yb)", "canonical_solution": "return math.sqrt((xa - xb) ^ 2 + (ya - yb) ^ 2)\nend", "test": "function testCalculateDistance()\n    assert(math.abs(calculate_distance(0, 0, 3, 4) - 5) < 1e-6)\n    assert(math.abs(calculate_distance(0, 0, 0, 0) - 0) < 1e-6)\n    assert(math.abs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < 1e-6)\n    assert(math.abs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6)\n    -- print(\"All test cases passed!\")\nend\n\ntestCalculateDistance()", "entry_point": "calculate_distance", "signature": "function calculate_distance(xa, ya, xb, yb)", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\nUsage examples:\nprint(calculate_distance(0, 0, 3, 4)) -- Output: 5\n", "instruction": "Write a Lua function `function calculate_distance(xa, ya, xb, yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\nUsage examples:\nprint(calculate_distance(0, 0, 3, 4)) -- Output: 5\n", "level": "easy"}
{"task_id": "Lua/6", "prompt": "\n--[[\n    Find the factorial of N and take the modulo 10007 of the result.\n\u200b    \n    Parameters:\n    - N: An integer representing the input value (N <= 10000).\n    \n    Returns:\n    - The result after taking the modulo 10007 of the output.\n\n    Examples:\n    assert(process_request(1) == 1)\n    assert(process_request(5) == 10)\n]]\nfunction process_request(n)", "canonical_solution": "if n == 0 then\n        return 1\n    end\n    local a = {1, 1}\n    for i = 2, 10000 do\n        a[i] = (a[i - 1] * i) % 10007\n    end\n    return a[n]\nend", "test": "local function test_process_request()\n    assert(process_request(0) == 1) -- Added test for boundary condition\n    assert(process_request(1) == 1)\n    assert(process_request(2) == 2)\n    assert(process_request(3) == 6)\n    assert(process_request(4) == 24)\n    assert(process_request(10) == 6266) -- 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991) -- Added a test for upper boundary condition\nend\n\ntest_process_request()\n-- No equivalent in Lua for printf statement to indicate test status, as assert will automatically throw an error when a test fails.", "entry_point": "process_request", "signature": "function process_request(n)", "docstring": "Find the factorial of N and take the modulo 10007 of the result.\n\n    Parameters:\n    - N: An integer representing the input value (N <= 10000).\n\n    Returns:\n    - The result after taking the modulo 10007 of the output.\n\n    Examples:\n    assert(process_request(1) == 1)\n    assert(process_request(5) == 120)", "instruction": "Write a Lua function `function process_request(n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n\n    Parameters:\n    - N: An integer representing the input value (N <= 10000).\n\n    Returns:\n    - The result after taking the modulo 10007 of the output.\n\n    Examples:\n    assert(process_request(1) == 1)\n    assert(process_request(5) == 120)", "level": "easy"}
{"task_id": "Lua/7", "prompt": "\n--[[\nCalculates the area of a triangle given its base and height.\n\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\n\nReturns:\n- number: The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\nlocal area = calculate_triangle_area(1, 2)\nprint(area)  -- Output: 1.0\n\nlocal area = calculate_triangle_area(3, 4)\nprint(area)  -- Output: 6.0\n--]]\nfunction calculate_triangle_area(base, height)", "canonical_solution": "return base * height / 2.0  -- The area of a triangle formula\nend", "test": "local function test_calculate_triangle_area()\n    assert(math.abs(calculate_triangle_area(1, 2) - 1.0) < 1e-6)\n    assert(math.abs(calculate_triangle_area(3, 4) - 6.0) < 1e-6)\n    assert(math.abs(calculate_triangle_area(5, 8) - 20.0) < 1e-6)\n    assert(math.abs(calculate_triangle_area(7, 3) - 10.5) < 1e-6)\n    assert(math.abs(calculate_triangle_area(10, 10) - 50.0) < 1e-6)\n\n    -- print(\"All tests passed.\")\nend\n\ntest_calculate_triangle_area()", "entry_point": "calculate_triangle_area", "signature": "function calculate_triangle_area(base, height)", "docstring": "Calculates the area of a triangle given its base and height.\n\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\n\nReturns:\n- number: The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\nlocal area = calculate_triangle_area(1, 2)\nprint(area)  -- Output: 1.0\n\nlocal area = calculate_triangle_area(3, 4)\nprint(area)  -- Output: 6.0\n", "instruction": "Write a Lua function `function calculate_triangle_area(base, height)` to solve the following problem:\nCalculates the area of a triangle given its base and height.\n\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\n\nReturns:\n- number: The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\nlocal area = calculate_triangle_area(1, 2)\nprint(area)  -- Output: 1.0\n\nlocal area = calculate_triangle_area(3, 4)\nprint(area)  -- Output: 6.0\n", "level": "easy"}
{"task_id": "Lua/8", "prompt": "\n--[[\nCalculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\nReturns:\nint: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n     to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n]]--\nfunction hamming_distance(x, y)", "canonical_solution": "local distance = 0\n    local xor_result = x ~ y  -- XOR x and y to get a number where set bits are the differences\n    while xor_result ~= 0 do\n        if xor_result & 1 == 1 then\n            distance = distance + 1\n        end\n        xor_result = xor_result >> 1\n    end\n    return distance\nend", "test": "assert(hamming_distance(1, 2) == 2) -- 01 and 10 have 2 different bits\nassert(hamming_distance(4, 7) == 2) -- 100 and 111 have 2 different bits\nassert(hamming_distance(25, 30) == 3) -- Additional test: 11001 and 11110 have 3 different bits\nassert(hamming_distance(0, 0) == 0) -- Additional test: Same numbers have 0 different bits\nassert(hamming_distance(0xFFFFFFF, 0x0000000) == 28) -- Additional test: Max unsigned int and 0 have 32 different bits", "entry_point": "hamming_distance", "signature": "function hamming_distance(x, y)", "docstring": "Calculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\nReturns:\nint: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\nto transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n", "instruction": "Write a Lua function `function hamming_distance(x, y)` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\nReturns:\nint: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\nto transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n", "level": "easy"}
{"task_id": "Lua/9", "prompt": "\n--[[\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to analyze.\n- ... (int): A sequence of integers.\n\nReturns:\nint: The count of odd numbers in the provided sequence.\n\nExamples:\n    count_odd_numbers(5, 1, 4, 3, 2, 5) -- returns 3\n    count_odd_numbers(4, 2, 2, 0, 0) -- returns 0\n    count_odd_numbers(6, 7, 7, 8, 1, 9, 10) -- returns 4\n]]--\nfunction count_odd_numbers(count, ...)", "canonical_solution": "local args = {...}\n    local ans = 0\n    for i = 1, count do\n        local num = args[i]\n        if num % 2 ~= 0 then\n            ans = ans + 1\n        end\n    end\n    return ans\nend", "test": "function testCountOddNumbers()\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3)\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0)\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4) -- Additional Test Sample\n\n    -- print(\"All tests passed!\")\nend\n\ntestCountOddNumbers()", "entry_point": "count_odd_numbers", "signature": "function count_odd_numbers(count, ...)", "docstring": "Count the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to analyze.\n- ... (int): A sequence of integers.\n\nReturns:\nint: The count of odd numbers in the provided sequence.\n\nExamples:\n    count_odd_numbers(5, 1, 4, 3, 2, 5) -- returns 3\n    count_odd_numbers(4, 2, 2, 0, 0) -- returns 0\n    count_odd_numbers(6, 7, 7, 8, 1, 9, 10) -- returns 4\n", "instruction": "Write a Lua function `function count_odd_numbers(count, ...)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to analyze.\n- ... (int): A sequence of integers.\n\nReturns:\nint: The count of odd numbers in the provided sequence.\n\nExamples:\n    count_odd_numbers(5, 1, 4, 3, 2, 5) -- returns 3\n    count_odd_numbers(4, 2, 2, 0, 0) -- returns 0\n    count_odd_numbers(6, 7, 7, 8, 1, 9, 10) -- returns 4\n", "level": "easy"}
{"task_id": "Lua/10", "prompt": "-- No imports needed for Lua\n--[[\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum({1,4,3,2,5}, 5)\n    6\n]]--\nfunction calculate_even_sum(numbers, size)", "canonical_solution": "local ans = 0\n    for i = 1, size do\n        if (numbers[i] % 2) == 0 then -- Only sum the even numbers\n            ans = ans + numbers[i]\n        end\n    end\n    return ans\nend", "test": "do\n    local sample1 = {1, 4, 3, 2, 5}\n    local sample2 = {2, 2, 0, 0}\n    local sample3 = {7, 11, 19} -- Additional test with no even numbers\n    local sample4 = {12, 14, 16, 18, 20} -- Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1, 5) == 6)\n    assert(calculate_even_sum(sample2, 4) == 4)\n    assert(calculate_even_sum(sample3, 3) == 0) -- Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4, 5) == 12 + 14 + 16 + 18 + 20)\n\n    -- print(\"All tests passed successfully.\")\nend", "entry_point": "calculate_even_sum", "signature": "function calculate_even_sum(numbers, size)", "docstring": "Calculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum({1,4,3,2,5}, 5)\n    6", "instruction": "Write a Lua function `function calculate_even_sum(numbers, size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum({1,4,3,2,5}, 5)\n    6", "level": "easy"}
{"task_id": "Lua/11", "prompt": "\n--[[\nDetermine if two closed intervals intersect.\n    Arguments:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    boolean: true if the intervals intersect, false otherwise.\n]]\nfunction are_intervals_intersecting(a, b, c, d)", "canonical_solution": "if (c <= a and b <= d) or\n       (a <= c and c <= b and b <= d) or\n       (a <= c and d <= b) or\n       (c <= a and a <= d and d <= b) then\n        return true  -- Yes\n    else\n        return false  -- No\n    end\nend", "test": "function test_are_intervals_intersecting()\n    assert(are_intervals_intersecting(1, 1, 1, 2) == true)\n    assert(are_intervals_intersecting(3, 5, 2, 6) == true)\n    assert(are_intervals_intersecting(3, 5, 4, 7) == true)\n    assert(are_intervals_intersecting(3, 5, 6, 7) == false)\n    -- Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == true)\n    assert(are_intervals_intersecting(1, 3, 2, 4) == true)\n    assert(are_intervals_intersecting(1, 3, 4, 6) == false)\n    assert(are_intervals_intersecting(10, 20, 20, 30) == true)\n    assert(are_intervals_intersecting(10, 20, 21, 30) == false)\n    \n    -- print(\"All tests passed.\")\nend\n\ntest_are_intervals_intersecting()", "entry_point": "are_intervals_intersecting", "signature": "function are_intervals_intersecting(a, b, c, d)", "docstring": "Determine if two closed intervals intersect.\n    Arguments:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    boolean: true if the intervals intersect, false otherwise.\n", "instruction": "Write a Lua function `function are_intervals_intersecting(a, b, c, d)` to solve the following problem:\nDetermine if two closed intervals intersect.\n    Arguments:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    boolean: true if the intervals intersect, false otherwise.\n", "level": "easy"}
{"task_id": "Lua/12", "prompt": "\n--[[\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two.\nFind the value that occurs exactly once.\nExamples:\n    extraNumber(0, 0, 1) returns 1\n    extraNumber(4, 3, 4) returns 3\n]]--\nfunction extraNumber(a, b, c)", "canonical_solution": "if a == b then\n        return c\n    elseif a == c then\n        return b\n    else\n        return a\n    end\nend", "test": "function testExtraNumber()\n    assert(extraNumber(2, 7, 2) == 7)\n    assert(extraNumber(3, 2, 2) == 3)\n    assert(extraNumber(5, 5, 1) == 1)\n    assert(extraNumber(500000000, 3, 500000000) == 3)\n    assert(extraNumber(500000000, 500000000, 3) == 3)\nend\n\ntestExtraNumber()", "entry_point": "extraNumber", "signature": "function extraNumber(a, b, c)", "docstring": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two.\nFind the value that occurs exactly once.\nExamples:\n    extraNumber(0, 0, 1) returns 1\n    extraNumber(4, 3, 4) returns 3\n", "instruction": "Write a Lua function `function extraNumber(a, b, c)` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two.\nFind the value that occurs exactly once.\nExamples:\n    extraNumber(0, 0, 1) returns 1\n    extraNumber(4, 3, 4) returns 3\n", "level": "easy"}
{"task_id": "Lua/13", "prompt": "\n--[[\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n    - subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    Example usage:\n    print(calculate_total_score(100,100,100,100,100)) -- Output: 500\n--]]\nfunction calculate_total_score(score1, score2, score3, score4, score5)", "canonical_solution": "return score1 + score2 + score3 + score4 + score5\nend", "test": "function testCalculateTotalScore()\n    assert(calculate_total_score(100,100,100,100,100) == 500)\n    assert(calculate_total_score(0,0,0,0,0) == 0)\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150)\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236)\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25)\nend\n\ntestCalculateTotalScore()", "entry_point": "calculate_total_score", "signature": "function calculate_total_score(score1, score2, score3, score4, score5)", "docstring": "Calculate the total score for a student based on the scores in different subjects.\n    Parameters:\n    - subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    Example usage:\n    print(calculate_total_score(100,100,100,100,100)) -- Output: 500\n", "instruction": "Write a Lua function `function calculate_total_score(score1, score2, score3, score4, score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n    - subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    Example usage:\n    print(calculate_total_score(100,100,100,100,100)) -- Output: 500\n", "level": "easy"}
{"task_id": "Lua/14", "prompt": "\n--[[\nDecode a series of numbers to reveal the pattern and understand the actual values\neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers.\n\nReturns:\nThe result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n]]--\nfunction decode_numbers(data_str)", "canonical_solution": "local a = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n    local ans = 0\n    for i = 1, #data_str do\n        local num = tonumber(data_str:sub(i,i))\n        ans = ans + a[num + 1]\n    end\n    return ans\nend", "test": "function testDecodeNumbers()\n    assert(decode_numbers(\"0000\") == 4)\n    assert(decode_numbers(\"8888\") == 8)\n    assert(decode_numbers(\"1234\") == 1)\n    assert(decode_numbers(\"5678\") == 3)\n    assert(decode_numbers(\"9012\") == 2)\n    assert(decode_numbers(\"1357\") == 0)\n    assert(decode_numbers(\"2468\") == 4)\n    -- Additional test samples\n    assert(decode_numbers(\"9999\") == 4)\n    assert(decode_numbers(\"1111\") == 0)\n    assert(decode_numbers(\"2222\") == 0)\n    assert(decode_numbers(\"3333\") == 0)\n    assert(decode_numbers(\"4444\") == 4)\n    assert(decode_numbers(\"5555\") == 0)\n    assert(decode_numbers(\"6666\") == 4)\n    assert(decode_numbers(\"7777\") == 0)\n    assert(decode_numbers(\"0001\") == 3)\n    assert(decode_numbers(\"2301\") == 1)\nend\n\ntestDecodeNumbers()", "entry_point": "decode_numbers", "signature": "function decode_numbers(data_str)", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values\neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers.\n\nReturns:\nThe result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);", "instruction": "Write a Lua function `function decode_numbers(data_str)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values\neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers.\n\nReturns:\nThe result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);", "level": "easy"}
{"task_id": "Lua/15", "prompt": "\n--[[\nCounts the number of different coloring methods for 'n' squares with 'm' colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (int): The number of squares.\n- m (int): The number of colors.\n\nReturns:\nint: The count of different coloring methods satisfying the specified conditions.\nResult is modulo 1000003.\n\nExamples:\nextraNumber(1, 1) => 1\n\n--]]\nfunction count_coloring_methods(n, m)", "canonical_solution": "local f = {} -- Array to store results\n    if n == 1 then return m end\n    if n == 2 then return (m * (m - 1)) % 1000003 end\n    \n    -- Initialize the first three elements\n    f[1] = m\n    f[2] = (m * (m - 1)) % 1000003\n    f[3] = (f[2] * (m - 2)) % 1000003\n    \n    for i = 4, n do\n        f[i] = ((f[i - 1] * (m - 2)) % 1000003 + (f[i - 2] * (m - 1)) % 1000003) % 1000003\n    end\n    \n    return f[n]\nend", "test": "function testCountColoringMethods()\n    assert(count_coloring_methods(1, 1) == 1)\n    assert(count_coloring_methods(2, 2) == 2)\n    assert(count_coloring_methods(3, 3) == 6)\n    assert(count_coloring_methods(4, 2) == 2)\n    -- The following test is an example, as the expected result is not provided\n    assert(count_coloring_methods(1000, 10) == 566585)\n    \n    -- Additional test cases\n    assert(count_coloring_methods(2, 3) == 6)\n    assert(count_coloring_methods(1000, 1000) == 67911)\n    assert(count_coloring_methods(999, 66) == 501817)\n    assert(count_coloring_methods(5, 3) == 30) -- Example of an expected output\n\n    -- print(\"All tests passed!\")\nend\n\ntestCountColoringMethods()", "entry_point": "count_coloring_methods", "signature": "function count_coloring_methods(n, m)", "docstring": "Counts the number of different coloring methods for 'n' squares with 'm' colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (int): The number of squares.\n- m (int): The number of colors.\n\nReturns:\nint: The count of different coloring methods satisfying the specified conditions.\nResult is modulo 1000003.\n\nExamples:\nextraNumber(1, 1) => 1\n", "instruction": "Write a Lua function `function count_coloring_methods(n, m)` to solve the following problem:\nCounts the number of different coloring methods for 'n' squares with 'm' colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (int): The number of squares.\n- m (int): The number of colors.\n\nReturns:\nint: The count of different coloring methods satisfying the specified conditions.\nResult is modulo 1000003.\n\nExamples:\nextraNumber(1, 1) => 1\n", "level": "middle"}
{"task_id": "Lua/16", "prompt": "\n--[[\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin toss sequences.\n\nReturns:\nunsigned long long: The count of valid sequences.\n\nExamples:\nextraNumber(1) -- returns 2\nextraNumber(2) -- returns 3\n]]\nfunction count_valid_coin_toss_sequences(n)", "canonical_solution": "local a = {}\n    \n    -- Set the base case for 1 toss\n    a[1] = {1, 1}\n    \n    -- Compute the number of sequences for each number of tosses\n    for i = 2, n do\n        a[i] = {}\n        a[i][1] = a[i - 1][2] + a[i - 1][1]\n        a[i][2] = a[i - 1][1]\n    end\n    \n    -- The total for 'n' is the sum of the sequences ending in tails and the sequences ending in heads\n    return a[n][1] + a[n][2]\nend", "test": "function testCountValidCoinTossSequences()\n    assert(count_valid_coin_toss_sequences(1) == 2)\n    assert(count_valid_coin_toss_sequences(2) == 3)\n    assert(count_valid_coin_toss_sequences(3) == 5)\n    assert(count_valid_coin_toss_sequences(4) == 8) -- Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13) -- Additional test\n    -- Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296) -- Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141)\n    assert(count_valid_coin_toss_sequences(38) == 102334155)\n    -- print(\"All tests passed!\")\nend\n\ntestCountValidCoinTossSequences()", "entry_point": "count_valid_coin_toss_sequences", "signature": "function count_valid_coin_toss_sequences(n)", "docstring": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin toss sequences.\n\nReturns:\nunsigned long long: The count of valid sequences.\n\nExamples:\nextraNumber(1) -- returns 2\nextraNumber(2) -- returns 3\n", "instruction": "Write a Lua function `function count_valid_coin_toss_sequences(n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin toss sequences.\n\nReturns:\nunsigned long long: The count of valid sequences.\n\nExamples:\nextraNumber(1) -- returns 2\nextraNumber(2) -- returns 3\n", "level": "middle"}
{"task_id": "Lua/17", "prompt": "\n--[[\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\nParameters:\n- n: A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\n- The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7)    -- returns 3\n]]--\nfunction find_longest_consecutive_ones_length(n)", "canonical_solution": "local max = 0\n    local ans = 0\n    while n ~= 0 do\n        if n & 1 == 1 then\n            ans = ans + 1\n        else\n            if ans > max then\n                max = ans\n            end\n            ans = 0\n        end\n        n = math.floor(n / 2)\n    end\n    if ans > max then\n        max = ans\n    end\n    return max\nend", "test": "function testFindLongestConsecutiveOnesLength()\n    assert(find_longest_consecutive_ones_length(7) == 3)\n    assert(find_longest_consecutive_ones_length(13) == 2)\n    assert(find_longest_consecutive_ones_length(12345) == 3)\n    -- assert(find_longest_consecutive_ones_length(0xb111101111) == 4)\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32)\n    assert(find_longest_consecutive_ones_length(0) == 0)\n\n    -- Uncomment the following line to print a success message\n    -- print(\"All tests passed!\")\nend\n\ntestFindLongestConsecutiveOnesLength()", "entry_point": "find_longest_consecutive_ones_length", "signature": "function find_longest_consecutive_ones_length(n)", "docstring": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\nParameters:\n- n: A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\n- The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7)    -- returns 3\n", "instruction": "Write a Lua function `function find_longest_consecutive_ones_length(n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\nParameters:\n- n: A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\n- The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7)    -- returns 3\n", "level": "easy"}
{"task_id": "Lua/18", "prompt": "\n--[[\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> create_id(\"fish\",\"cat\")\n    \"ftiasch\"\n]]\nfunction create_id(word1, word2)", "canonical_solution": "local length1 = #word1\n    local length2 = #word2\n    local total_length = length1 + length2\n    local id = {}\n\n    local j, k = 1, length2\n\n    for i = 1, total_length do\n        if i % 2 == 0 then\n            id[i] = string.sub(word2, k, k) -- Take character from word2 in reverse\n            k = k - 1\n        else\n            id[i] = string.sub(word1, j, j) -- Take character from word1\n            j = j + 1\n        end\n    end\n\n    return table.concat(id) -- Concatenate table into string and return\nend", "test": "function test_create_id()\n    assert(create_id(\"fish\", \"cat\") == \"ftiasch\")\n    assert(create_id(\"icpc\", \"acm\") == \"imccpac\")\n    assert(create_id(\"oo\", \"w\") == \"owo\")\n    assert(create_id(\"hello\", \"world\") == \"hdellrloow\")\n    assert(create_id(\"abc\", \"def\") == \"afbecd\")\n    assert(create_id(\"buaanb\", \"nbbuaa\") == \"bauaauabnbbn\")\n    assert(create_id(\"xtuisgood\", \"ilovextu\") == \"xuttuxiesvgooloid\")\nend\n\ntest_create_id()", "entry_point": "create_id", "signature": "function create_id(word1, word2)", "docstring": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(\"fish\",\"cat\")\n    \"ftiasch\"\n", "instruction": "Write a Lua function `function create_id(word1, word2)` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(\"fish\",\"cat\")\n    \"ftiasch\"\n", "level": "hard"}
{"task_id": "Lua/19", "prompt": "\n--[[\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n--]]\nfunction count_permutations_of_binary_string(n, m)", "canonical_solution": "local factorial = 1.0\n    local i\n\n    -- Calculate n factorial (n!)\n    for i = 2, n do\n        factorial = factorial * i\n    end\n\n    local numerator = factorial -- n!\n\n    -- Calculate (n+m)/2 factorial\n    factorial = 1.0\n    for i = 2, (n + m) // 2 do\n        factorial = factorial * i\n    end\n\n    local denominator1 = factorial -- ((n+m)/2)!\n\n    -- Calculate (n-m)/2 factorial\n    factorial = 1.0\n    for i = 2, (n - m) // 2 do\n        factorial = factorial * i\n    end\n\n    local denominator2 = factorial -- ((n-m)/2)!\n\n    if ((n + m) % 2) ~= 0 then\n        return 0\n    elseif n == m then\n        return 1\n    else\n        -- Calculating the number of permutations using the factorial values\n        return math.floor(numerator / denominator1 / denominator2 + 0.5)\n    end\nend", "test": "do\n    assert(count_permutations_of_binary_string(2, 0) == 2)\n    assert(count_permutations_of_binary_string(2, 1) == 0)\n    assert(count_permutations_of_binary_string(3, 0) == 0)\n    assert(count_permutations_of_binary_string(3, 1) == 3)\n    assert(count_permutations_of_binary_string(3, 2) == 0)\n    assert(count_permutations_of_binary_string(30, 2) == 145422675)\n    assert(count_permutations_of_binary_string(4, 2) == 4)\n    assert(count_permutations_of_binary_string(5, 5) == 1)\n    assert(count_permutations_of_binary_string(33, 17) == 13884156)\n    assert(count_permutations_of_binary_string(1000, 1000) == 1)\n    -- Add more test cases if necessary\nend", "entry_point": "count_permutations_of_binary_string", "signature": "function count_permutations_of_binary_string(n, m)", "docstring": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.", "instruction": "Write a Lua function `function count_permutations_of_binary_string(n, m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.", "level": "hard"}
{"task_id": "Lua/20", "prompt": "\n--[[\n    Answer a series of questions by providing choices A, B, C, or D for each question.\n    Question 1:\n    Constants like 1e6 belong to which data type?\n        A. unsigned int\n        B. int\n        C. float\n        D. double\n    Question 2:\n    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n        A. int\n        B. long long\n        C. double\n        D. None of the above\n    Question 3:\n    Which statement about left values in expressions is incorrect?\n        A. Variable name expressions are left values.\n        B. Increment operation requires the operand to be a left value.\n        C. Pointer dereference expressions are left values.\n        D. Prefix increment operation expressions are left values.\n    Question 4:\n    Which statement about functions is incorrect?\n        A. Formal parameters of a function are local variables.\n        B. Local variables are allocated space in the stack.\n        C. The function type is the same as the return value type.\n        D. A function can call itself from within its body.\n    Question 5:\n    Which statement about pointers is incorrect?\n        A. Subtracting two pointers equals the difference in their address values.\n        B. Pointer dereference involves resolving based on the pointer's type.\n        C. int *p[4], p is an array of int pointers.\n        D. Function names can be assigned to function pointers.\n    >>> answer_questions()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n]]--\nfunction answer_questions()", "canonical_solution": "return \"DDDBA\"\nend", "test": "function testAnswerQuestions()\n    local expected_answers = \"DDDBA\"\n    assert(answer_questions() == expected_answers)\nend\n\ntestAnswerQuestions()", "entry_point": "answer_questions", "signature": "function answer_questions()", "docstring": "Answer a series of questions by providing choices A, B, C, or D for each question.\n    Question 1:\n    Constants like 1e6 belong to which data type?\n        A. unsigned int\n        B. int\n        C. float\n        D. double\n    Question 2:\n    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n        A. int\n        B. long long\n        C. double\n        D. None of the above\n    Question 3:\n    Which statement about left values in expressions is incorrect?\n        A. Variable name expressions are left values.\n        B. Increment operation requires the operand to be a left value.\n        C. Pointer dereference expressions are left values.\n        D. Prefix increment operation expressions are left values.\n    Question 4:\n    Which statement about functions is incorrect?\n        A. Formal parameters of a function are local variables.\n        B. Local variables are allocated space in the stack.\n        C. The function type is the same as the return value type.\n        D. A function can call itself from within its body.\n    Question 5:\n    Which statement about pointers is incorrect?\n        A. Subtracting two pointers equals the difference in their address values.\n        B. Pointer dereference involves resolving based on the pointer's type.\n        C. int *p[4], p is an array of int pointers.\n        D. Function names can be assigned to function pointers.\n    >>> answer_questions()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "instruction": "Write a Lua function `function answer_questions()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\n    Question 1:\n    Constants like 1e6 belong to which data type?\n        A. unsigned int\n        B. int\n        C. float\n        D. double\n    Question 2:\n    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n        A. int\n        B. long long\n        C. double\n        D. None of the above\n    Question 3:\n    Which statement about left values in expressions is incorrect?\n        A. Variable name expressions are left values.\n        B. Increment operation requires the operand to be a left value.\n        C. Pointer dereference expressions are left values.\n        D. Prefix increment operation expressions are left values.\n    Question 4:\n    Which statement about functions is incorrect?\n        A. Formal parameters of a function are local variables.\n        B. Local variables are allocated space in the stack.\n        C. The function type is the same as the return value type.\n        D. A function can call itself from within its body.\n    Question 5:\n    Which statement about pointers is incorrect?\n        A. Subtracting two pointers equals the difference in their address values.\n        B. Pointer dereference involves resolving based on the pointer's type.\n        C. int *p[4], p is an array of int pointers.\n        D. Function names can be assigned to function pointers.\n    >>> answer_questions()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "level": "easy"}
{"task_id": "Lua/21", "prompt": "\n--[[\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, {9})\n    true\n    >>> Is_Square(2, {14, 2})\n    true\n    >>> Is_Square(2, {7, 7})\n    false\n]]--\nfunction Is_Square(length, squares)", "canonical_solution": "local sum = 0\n    for i = 1, length do\n        sum = sum + squares[i]\n    end\n    local root = math.floor(math.sqrt(sum))\n    return root * root == sum\nend", "test": "local function testIsSquare()\n    assert(Is_Square(1, {9}) == true)\n    assert(Is_Square(2, {14, 2}) == true)\n    assert(Is_Square(2, {7, 7}) == false)\n    assert(Is_Square(7, {1, 2, 3, 4, 5, 6, 7}) == false)\n    assert(Is_Square(6, {1, 3, 5, 7, 9, 11}) == true)\n    assert(Is_Square(4, {2, 2, 2, 2}) == false)\n\n    -- Additional test cases\n    assert(Is_Square(3, {4, 5, 6}) == false)\n    assert(Is_Square(4, {16, 9, 4, 1}) == false)\n    assert(Is_Square(5, {1, 1, 1, 1, 1}) == false)\n    assert(Is_Square(2, {25, 25}) == false)\n    assert(Is_Square(3, {10, 10, 5}) == true)\n\n    -- print(\"All tests passed!\")\nend\n\ntestIsSquare()", "entry_point": "Is_Square", "signature": "function Is_Square(length, squares)", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, {9})\n    true\n    >>> Is_Square(2, {14, 2})\n    true\n    >>> Is_Square(2, {7, 7})\n    false", "instruction": "Write a Lua function `function Is_Square(length, squares)` to solve the following problem:\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, {9})\n    true\n    >>> Is_Square(2, {14, 2})\n    true\n    >>> Is_Square(2, {7, 7})\n    false", "level": "easy"}
{"task_id": "Lua/22", "prompt": "\n--[[\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b).\nIf there are multiple groups, output the group with the smallest a.\nIf valid values for a and b do not exist, the function will return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\nOptional[int]: A possible value of a.\n\nUsage:\n    print(find_integers(7, 11))  -- Output: -1\n]]--\nfunction find_integers(c, d)", "canonical_solution": "for i = 0, math.floor(c / 2) do\n        if i * (c - i) == d then\n            return i\n        end\n    end\n    return -1 -- Return -1 if no valid pairs (a, b) are found.\nend", "test": "function testFindIntegers()\n    assert(find_integers(5, 6) == 2)\n    assert(find_integers(6, 9) == 3)\n    assert(find_integers(7, 12) == 3)\n    assert(find_integers(7, 11) == -1)\n    assert(find_integers(9, 8) == 1)\n    assert(find_integers(10, 25) == 5)\n    assert(find_integers(10000, 8765) == -1)\n    \n    -- print(\"All tests passed successfully.\")\nend\n\ntestFindIntegers()", "entry_point": "find_integers", "signature": "function find_integers(c, d)", "docstring": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b).\nIf there are multiple groups, output the group with the smallest a.\nIf valid values for a and b do not exist, the function will return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\nOptional[int]: A possible value of a.\n\nUsage:\n    print(find_integers(7, 11))  -- Output: -1", "instruction": "Write a Lua function `function find_integers(c, d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b).\nIf there are multiple groups, output the group with the smallest a.\nIf valid values for a and b do not exist, the function will return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\nOptional[int]: A possible value of a.\n\nUsage:\n    print(find_integers(7, 11))  -- Output: -1", "level": "easy"}
{"task_id": "Lua/23", "prompt": "\n--[[\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges: A table containing integer values representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles({1, 1, 1, 1})\n4\n]]\nfunction count_acute_triangles(edges)", "canonical_solution": "table.sort(edges)\n\n    local sum = 0\n    local edges_count = #edges\n    for i=1, edges_count - 2 do\n        for j=i + 1, edges_count - 1 do\n            for k=j + 1, edges_count do\n                local x = edges[i]\n                local y = edges[j]\n                local z = edges[k]\n                if x + y > z and (x * x + y * y) > (z * z) then\n                    sum = sum + 1\n                end\n            end\n        end\n    end\n    return sum\nend", "test": "function testCountAcuteTriangles()\n    assert(count_acute_triangles({1, 1, 1, 1}) == 4)\n    assert(count_acute_triangles({1, 2, 3}) == 0)\n    -- Additional tests to ensure correctness\n    assert(count_acute_triangles({3, 4, 5, 7, 10}) == 0)\n    assert(count_acute_triangles({6, 8, 10, 5, 5, 5}) == 4)\nend\n\ntestCountAcuteTriangles()", "entry_point": "count_acute_triangles", "signature": "function count_acute_triangles(edges)", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges: A table containing integer values representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles({1, 1, 1, 1})\n4", "instruction": "Write a Lua function `function count_acute_triangles(edges)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges: A table containing integer values representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles({1, 1, 1, 1})\n4", "level": "middle"}
{"task_id": "Lua/24", "prompt": "\n--[[\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\n\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExample usage:\nlocal result = process_integer_and_char(234,'H')\nprint(result) -- Output: 234,H\n]]\nfunction process_integer_and_char(integer_value, char_value)", "canonical_solution": "-- Format the string with the integer and character separated by a comma.\n    local result = string.format(\"%d,%s\", integer_value, char_value)\n    return result\nend", "test": "function testProcessIntegerAndChar()\n    assert(process_integer_and_char(234, 'H') == \"234,H\")\n    assert(process_integer_and_char(123, 'A') == \"123,A\")\n    assert(process_integer_and_char(0, 'Z') == \"0,Z\")\n\n    -- Additional tests can be added here with different input values.\nend\n\n-- Run the tests to verify that the function works as intended.\ntestProcessIntegerAndChar()", "entry_point": "process_integer_and_char", "signature": "function process_integer_and_char(integer_value, char_value)", "docstring": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\n\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExample usage:\nlocal result = process_integer_and_char(234,'H')\nprint(result) -- Output: 234,H\n", "instruction": "Write a Lua function `function process_integer_and_char(integer_value, char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\n\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExample usage:\nlocal result = process_integer_and_char(234,'H')\nprint(result) -- Output: 234,H\n", "level": "easy"}
{"task_id": "Lua/25", "prompt": "\n--[[\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExamples:\nshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n-- Expected: \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n]]--\nfunction shift_characters(text)", "canonical_solution": "local shifted_text = {}\n  for i = 1, #text do\n    local char = text:sub(i, i)\n    local byte = string.byte(char)\n    -- Only shift uppercase letters\n    if byte >= 65 and byte <= 90 then\n      if byte <= 69 then -- 'A' to 'E'\n        byte = byte + 21\n      else -- 'F' to 'Z'\n        byte = byte - 5\n      end\n    end\n    table.insert(shifted_text, string.char(byte))\n  end\n  return table.concat(shifted_text)\nend", "test": "function testShiftCharacters()\n  local test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\"\n  local test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\"\n  local test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\"\n  assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\")\n  assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\")\n  assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\")\nend\n\ntestShiftCharacters()", "entry_point": "shift_characters", "signature": "function shift_characters(text)", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExamples:\nshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n-- Expected: \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "instruction": "Write a Lua function `function shift_characters(text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExamples:\nshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n-- Expected: \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "level": "middle"}
{"task_id": "Lua/26", "prompt": "\n--[[\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n    \nReturns:\n- int: The class to which the integer x belongs.\n\nExample usage:\nclassify_integer(\"24\") --> 6\n]]\nfunction classify_integer(x)", "canonical_solution": "local n = 0\n    for i = 1, #x do\n        n = n + tonumber(x:sub(i, i)) -- Convert the character to a number and add it to n\n    end\n    while n > 9 do\n        local t = n\n        local a = 0\n        while t > 0 do\n            a = a + t % 10 -- Sum the digits of t\n            t = math.floor(t / 10) -- Remove the last digit from t\n        end\n        n = a\n    end\n    return n\nend", "test": "function testClassifyInteger()\n    assert(classify_integer(\"24\") == 6)\n    assert(classify_integer(\"39\") == 3)\n    assert(classify_integer(\"123456789\") == 9)\n    assert(classify_integer(\"123456789012345678901234567890\") == 9)\n    assert(classify_integer(\"12345\") == 6)\n    assert(classify_integer(\"999999999\") == 9)\n    -- print(\"All tests passed!\")\nend\n\ntestClassifyInteger()", "entry_point": "classify_integer", "signature": "function classify_integer(x)", "docstring": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n    \nReturns:\n- int: The class to which the integer x belongs.\n\nExample usage:\nclassify_integer(\"24\") --> 6\n", "instruction": "Write a Lua function `function classify_integer(x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n    \nReturns:\n- int: The class to which the integer x belongs.\n\nExample usage:\nclassify_integer(\"24\") --> 6\n", "level": "middle"}
{"task_id": "Lua/27", "prompt": "\n--[[\n    Transforms the case of a given letter.\n    Parameters:\n    - letter (string): The input letter to be transformed.\n    Returns:\n    - string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n    and if the input is uppercase, it returns the lowercase version.\n\n    Example usage:\n    print(transform_letter_case('b')) -- Outputs: B\n    print(transform_letter_case('Z')) -- Outputs: z\n--]]\nfunction transform_letter_case(letter)", "canonical_solution": "if letter:match(\"%u\") then\n        return letter:lower()\n    elseif letter:match(\"%l\") then\n        return letter:upper()\n    else\n        -- Non-alphabetic characters are returned unchanged\n        return letter\n    end\nend", "test": "function test_transform_letter_case()\n    assert(transform_letter_case('b') == 'B')\n    assert(transform_letter_case('B') == 'b')\n\n    -- Additional test cases\n    assert(transform_letter_case('z') == 'Z')\n    assert(transform_letter_case('Z') == 'z')\n    assert(transform_letter_case('m') == 'M')\n    assert(transform_letter_case('M') == 'm')\n    assert(transform_letter_case('1') == '1') -- Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!') -- Non-alphabetic, should be unchanged\n\n    -- print(\"All tests passed successfully.\")\nend\n\ntest_transform_letter_case()", "entry_point": "transform_letter_case", "signature": "function transform_letter_case(letter)", "docstring": "Transforms the case of a given letter.\n    Parameters:\n    - letter (string): The input letter to be transformed.\n    Returns:\n    - string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n    and if the input is uppercase, it returns the lowercase version.\n\n    Example usage:\n    print(transform_letter_case('b')) -- Outputs: B\n    print(transform_letter_case('Z')) -- Outputs: z\n", "instruction": "Write a Lua function `function transform_letter_case(letter)` to solve the following problem:\nTransforms the case of a given letter.\n    Parameters:\n    - letter (string): The input letter to be transformed.\n    Returns:\n    - string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n    and if the input is uppercase, it returns the lowercase version.\n\n    Example usage:\n    print(transform_letter_case('b')) -- Outputs: B\n    print(transform_letter_case('Z')) -- Outputs: z\n", "level": "easy"}
{"task_id": "Lua/28", "prompt": "\n--[[\nDisplay the ASCII information for a given character.\n    \nParameters:\n- character: The input character for which ASCII information is to be displayed.\n    \nReturns:\n- The corresponding ASCII code\n\nExample:\ndisplay_ascii_info('A') -- Returns 65\n]]--\nfunction display_ascii_info(character)", "canonical_solution": "return string.byte(character)\nend", "test": "function testDisplayAsciiInfo()\n    assert(display_ascii_info('A') == 65)\n    assert(display_ascii_info('B') == 66) -- Additional test case\n    assert(display_ascii_info('0') == 48) -- Additional test case\n    assert(display_ascii_info(' ') == 32) -- Additional test case\n    -- print(\"All tests passed.\")\nend\n\ntestDisplayAsciiInfo()", "entry_point": "display_ascii_info", "signature": "function display_ascii_info(character)", "docstring": "Display the ASCII information for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code\n\nExample:\ndisplay_ascii_info('A') -- Returns 65\n", "instruction": "Write a Lua function `function display_ascii_info(character)` to solve the following problem:\nDisplay the ASCII information for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code\n\nExample:\ndisplay_ascii_info('A') -- Returns 65\n", "level": "easy"}
{"task_id": "Lua/29", "prompt": "-- No imports required for Lua\n--[[\nEvaluate the grade for an input integer.\n\nParameters:\n- score (integer): The integer score to be evaluated.\n\nReturns:\n\u200b\u200b    char: The grade corresponding to the input score.\n\u200b\u200b         If the score is between 90 and 100 (inclusive), returns 'A'.\n\u200b\u200b         Otherwise, returns 'B'.\n\nExample usage:\n    print(evaluate_integer_grade(90)) -- Output: A\n--]]\nfunction evaluate_integer_grade(score)", "canonical_solution": "if 90 <= score and score <= 100 then\n        return 'A'\n    else\n        return 'B'\n    end\nend", "test": "function test_evaluate_integer_grade()\n    assert(evaluate_integer_grade(90) == 'A') -- Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B') -- Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A') -- Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A') -- Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B') -- Additional test for a score greater than 100\n\n    -- Print \"All tests passed\" if all assertions hold true (optional)\n    -- print(\"All tests passed\")\nend\n\ntest_evaluate_integer_grade()", "entry_point": "evaluate_integer_grade", "signature": "function evaluate_integer_grade(score)", "docstring": "Evaluate the grade for an input integer.\n\nParameters:\n- score (integer): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\nExample usage:\n    print(evaluate_integer_grade(90)) -- Output: A\n", "instruction": "Write a Lua function `function evaluate_integer_grade(score)` to solve the following problem:\nEvaluate the grade for an input integer.\n\nParameters:\n- score (integer): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\nExample usage:\n    print(evaluate_integer_grade(90)) -- Output: A\n", "level": "easy"}
{"task_id": "Lua/30", "prompt": "\n--[[\nChecks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (string): The three-character string to be checked.\n\nReturns:\n    string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    Examples:\n    check_two_equal_digits(\"112\") --> \"Yes\"\n    check_two_equal_digits(\"123\") --> \"No\"\n]]--\nfunction check_two_equal_digits(s)", "canonical_solution": "if (s:sub(1, 1) == s:sub(2, 2) and s:sub(1, 1) ~= s:sub(3, 3)) or\n       (s:sub(1, 1) == s:sub(3, 3) and s:sub(1, 1) ~= s:sub(2, 2)) or\n       (s:sub(2, 2) == s:sub(3, 3) and s:sub(1, 1) ~= s:sub(2, 2)) then\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend", "test": "function test_check_two_equal_digits()\n    assert(check_two_equal_digits(\"112\") == \"Yes\")\n    assert(check_two_equal_digits(\"123\") == \"No\")\n    assert(check_two_equal_digits(\"232\") == \"Yes\")\n    assert(check_two_equal_digits(\"444\") == \"No\") -- All three characters are equal, not two.\n    assert(check_two_equal_digits(\"121\") == \"Yes\")\n\n    -- Additional test cases to cover more scenarios\n    assert(check_two_equal_digits(\"787\") == \"Yes\")\n    assert(check_two_equal_digits(\"999\") == \"No\") -- All three characters are equal\n    assert(check_two_equal_digits(\"890\") == \"No\")\n    assert(check_two_equal_digits(\"556\") == \"Yes\")\n    assert(check_two_equal_digits(\"353\") == \"Yes\")\n    \n    -- print(\"All tests passed successfully.\")\nend\n\ntest_check_two_equal_digits()", "entry_point": "check_two_equal_digits", "signature": "function check_two_equal_digits(s)", "docstring": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (string): The three-character string to be checked.\n\nReturns:\n    string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    Examples:\n    check_two_equal_digits(\"112\") --> \"Yes\"\n    check_two_equal_digits(\"123\") --> \"No\"", "instruction": "Write a Lua function `function check_two_equal_digits(s)` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (string): The three-character string to be checked.\n\nReturns:\n    string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    Examples:\n    check_two_equal_digits(\"112\") --> \"Yes\"\n    check_two_equal_digits(\"123\") --> \"No\"", "level": "easy"}
{"task_id": "Lua/31", "prompt": "\n--[[\nGiven a string consisting of lowercase English letters, in each round you\ncan change one of the characters to another character. The question is: what\nis the minimum number of rounds needed to make the string composed of the \nsame character?\n\nExamples:\n    -- minRoundsToSameChar(\"aab\") should return 1\n--]]\nfunction minRoundsToSameChar(s)", "canonical_solution": "local charCount = {}\n    for char in s:gmatch(\".\") do\n        charCount[char] = (charCount[char] or 0) + 1\n    end\n\n    local maxCount = 0\n    for _, count in pairs(charCount) do\n        if count > 0 then\n            maxCount = maxCount + 1\n        end\n    end\n\n    return maxCount - 1\nend", "test": "function testMinRoundsToSameChar()\n    assert(minRoundsToSameChar(\"aab\") == 1)\n    assert(minRoundsToSameChar(\"abc\") == 2)\n    assert(minRoundsToSameChar(\"aaa\") == 0)\n    assert(minRoundsToSameChar(\"abab\") == 1)\n    assert(minRoundsToSameChar(\"zzzzz\") == 0)\nend\n\ntestMinRoundsToSameChar()", "entry_point": "minRoundsToSameChar", "signature": "function minRoundsToSameChar(s)", "docstring": "Given a string consisting of lowercase English letters, in each round you\ncan change one of the characters to another character. The question is: what\nis the minimum number of rounds needed to make the string composed of the same character?\n\nExamples:\n    minRoundsToSameChar(\"aab\") should return 1", "instruction": "Write a Lua function `function minRoundsToSameChar(s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round you\ncan change one of the characters to another character. The question is: what\nis the minimum number of rounds needed to make the string composed of the same character?\n\nExamples:\n    minRoundsToSameChar(\"aab\") should return 1", "level": "easy"}
{"task_id": "Lua/32", "prompt": "\n--[[\nGiven a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Y_n when the n-th event occurs, under the condition\nthat the countdown for event i+1 can only commence in the year immediately following\nthe occurrence of event i.\n\n    >>> apocalypseYear(6, {3, 2, 4, 5, 9, 18})\n    36\n]]--\nfunction apocalypseYear(n, signs)", "canonical_solution": "local year = 0\n    for i = 1, n do\n        local period = signs[i]\n        local nextOccurrence = math.floor(year / period + 1) * period\n        year = nextOccurrence\n    end\n    return year\nend", "test": "function testApocalypseYear()\n    assert(apocalypseYear(6, {3, 2, 4, 5, 9, 18}) == 36)\n    assert(apocalypseYear(5, {1, 2, 3, 4, 5}) == 5)\n    assert(apocalypseYear(5, {1, 1, 1, 1, 1}) == 5)\n    assert(apocalypseYear(6, {50, 30, 711, 200, 503, 1006}) == 2012)\n    assert(apocalypseYear(2, {1, 2}) == 2)\n    assert(apocalypseYear(3, {3, 1, 2}) == 6)\n    assert(apocalypseYear(3, {2, 3, 4}) == 4)\n    assert(apocalypseYear(4, {1, 2, 3, 4}) == 4)\n    assert(apocalypseYear(4, {5, 7, 11, 13}) == 13)\n    assert(apocalypseYear(5, {2, 2, 2, 2, 2}) == 10)\n    assert(apocalypseYear(3, {6, 10, 15}) == 15)\n    assert(apocalypseYear(3, {4, 6, 14}) == 14)\n    assert(apocalypseYear(4, {50, 30, 711, 200}) == 800)\n    assert(apocalypseYear(6, {1, 1, 1, 1, 1, 1}) == 6)\n    assert(apocalypseYear(2, {1000000, 999999}) == 1999998)\nend\n\ntestApocalypseYear()", "entry_point": "apocalypseYear", "signature": "function apocalypseYear(n, signs)", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, {3, 2, 4, 5, 9, 18})\n    36\n", "instruction": "Write a Lua function `function apocalypseYear(n, signs)` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, {3, 2, 4, 5, 9, 18})\n    36\n", "level": "easy"}
{"task_id": "Lua/33", "prompt": "\n--[[\nThis problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y,\nif x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y\nrepeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is\nthe remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4. Given a prime number p, there\nwill be several queries. For each query, an integer n is given, and you need to compute the value of\nn! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or\nequal to n.\n\nExamples:\n    >>> newModuloFactorial(3, 7)\n    6\n]]--\nfunction newModuloFactorial(n, p)", "canonical_solution": "local pj = {1, 1}\n    for i = 2, p - 1 do\n        pj[i + 1] = (i * pj[i]) % p\n    end\n\n    local ans = 1\n    while n > 0 do\n        ans = ans * pj[n % p + 1] % p\n        ans = ((math.floor(n / p)) % 2) == 1 and (p - ans) or ans\n        n = math.floor(n / p)\n    end\n    return ans\nend", "test": "do\n    assert(newModuloFactorial(3, 7) == 6)\n    assert(newModuloFactorial(10, 3) == 1)\n    assert(newModuloFactorial(11, 7) == 4)\n    assert(newModuloFactorial(45, 7) == 1)\n    assert(newModuloFactorial(14, 7) == 2)\n    assert(newModuloFactorial(1919, 10007) == 3152)\n    assert(newModuloFactorial(810, 10007) == 3679)\n    assert(newModuloFactorial(3, 7) == 6)\n    assert(newModuloFactorial(10, 3) == 1)\n    assert(newModuloFactorial(1, 2) == 1)\n    assert(newModuloFactorial(5, 11) == 10)\n    assert(newModuloFactorial(6, 13) == 5)\n    assert(newModuloFactorial(8, 17) == 13)\n    assert(newModuloFactorial(15, 19) == 16)\n    assert(newModuloFactorial(21, 23) == 1)\n    assert(newModuloFactorial(30, 29) == 28)\n    assert(newModuloFactorial(100, 101) == 100)\nend", "entry_point": "newModuloFactorial", "signature": "function newModuloFactorial(n, p)", "docstring": "This problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y,\nif x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y\nrepeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is\nthe remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4. Given a prime number p, there\nwill be several queries. For each query, an integer n is given, and you need to compute the value of\nn! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or\nequal to n.\n\nExamples:\n    >>> newModuloFactorial(3, 7)\n    6\n", "instruction": "Write a Lua function `function newModuloFactorial(n, p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y,\nif x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y\nrepeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is\nthe remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4. Given a prime number p, there\nwill be several queries. For each query, an integer n is given, and you need to compute the value of\nn! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or\nequal to n.\n\nExamples:\n    >>> newModuloFactorial(3, 7)\n    6\n", "level": "easy"}
{"task_id": "Lua/34", "prompt": "\n--[[\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, {1, 2, 1})\n    1\n    >>> makeEqualAgain(5, {5, 5, 1, 5, 5})\n    1\n--]]\nfunction makeEqualAgain(n, b)", "canonical_solution": "local j = 0\n    local p = 1\n    q = 0\n    local c, d = 0, 0\n    local k = n\n    a = {}  -- \u5b9a\u4e49a\u6570\u7ec4\n\n    a[0] = b[1]  -- \u8bbe\u7f6ea[0]\u7b49\u4e8eb[1]\n\n    for i = 1, #b - 1 do  -- \u904d\u5386b\u6570\u7ec4\u7684\u5269\u4f59\u5143\u7d20\n        a[i] = b[i + 1]  -- \u8bbe\u7f6ea[i]\u7b49\u4e8eb[i+1]\n    end\n        \n    p = 1\n    while p < k do\n        if a[p] ~= a[p - 1] then\n            break\n        end\n        p = p + 1\n    end\n\n    q = k - 1\n    while q > p do\n        if a[q] ~= a[p - 1] then\n            break\n        end\n        q = q - 1\n    end\n\n    d = k - 2\n    while d >= 0 do\n        if a[d] ~= a[d + 1] then\n            break\n        end\n        d = d - 1\n    end\n\n    c = 0\n    while c < d do\n        if a[c] ~= a[c + 1] then\n            break\n        end\n        c = c + 1\n    end\n    if q - p + 1 < d - c + 1 then\n        return q - p + 1\n    else\n        return d - c + 1\n    end\nend", "test": "function testMakeEqualAgain()\n    assert(makeEqualAgain(6, {1,2,3,4,5,1}) == 4)\n    assert(makeEqualAgain(7, {1,1,1,1,1,1,1}) == 0)\n    assert(makeEqualAgain(8, {8,8,8,1,2,8,8,8}) == 2)\n    assert(makeEqualAgain(3, {1,2,3}) == 2)\n    assert(makeEqualAgain(7, {4,3,2,7,1,1,3}) == 6)\n    assert(makeEqualAgain(9, {9,9,2,9,2,5,5,5,3}) == 7)\n    assert(makeEqualAgain(3, {1, 2, 1}) == 1)\n    assert(makeEqualAgain(5, {5, 5, 1, 5, 5}) == 1)\n    assert(makeEqualAgain(4, {1, 1, 1, 1}) == 0)\n    assert(makeEqualAgain(6, {2, 2, 2, 3, 2, 2}) == 1)\n    assert(makeEqualAgain(1, {1}) == 0)\n    assert(makeEqualAgain(2, {1, 2}) == 1)\n    assert(makeEqualAgain(4, {1, 2, 2, 1}) == 2)\n    assert(makeEqualAgain(7, {4, 4, 4, 3, 3, 4, 4}) == 2)\n    assert(makeEqualAgain(6, {5, 4, 4, 4, 5, 5}) == 3)\n    assert(makeEqualAgain(7, {1, 2, 1, 2, 1, 2, 1}) == 5)\nend\n\ntestMakeEqualAgain()", "entry_point": "makeEqualAgain", "signature": "function makeEqualAgain(n, b)", "docstring": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, {1, 2, 1})\n    1\n    >>> makeEqualAgain(5, {5, 5, 1, 5, 5})\n    1\n", "instruction": "Write a Lua function `function makeEqualAgain(n, b)` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, {1, 2, 1})\n    1\n    >>> makeEqualAgain(5, {5, 5, 1, 5, 5})\n    1\n", "level": "hard"}
{"task_id": "Lua/35", "prompt": "\n--[[\nGiven a sequence of N piles of stones numbered from 1 to N,\nwith each pile containing a positive number of stones, determine \nthe winner of a game played by Charlie and Dan. Charlie goes first, \nand they take turns moving a positive number of stones from the \nleftmost non-empty pile to the adjacent right pile. The player who \ncan only move stones in the last pile loses. Assuming both players \nuse the best possible strategy, find out who will win the game.\n\n    >>> gameWinner(3, {1, 2, 2})\n    \"Dan\"\n--]]\nfunction gameWinner(n, piles)", "canonical_solution": "-- Only the first pile's stone count is needed to determine the winner.\n    local firstPileStones = piles[1]\n    if n == 2 then -- With only two piles, Charlie always wins.\n        return \"Charlie\"\n    end\n    if firstPileStones == 1 then -- If the first pile has only one stone, Dan wins.\n        return \"Dan\"\n    end\n    return \"Charlie\" -- In all other cases, Charlie wins.\nend", "test": "function testGameWinner()\n    assert(gameWinner(3, {1, 2, 2}) == \"Dan\")\n    assert(gameWinner(5, {5, 5, 5, 5, 5}) == \"Charlie\")\n    assert(gameWinner(3, {2, 1, 2}) == \"Charlie\")\n    assert(gameWinner(4, {3, 3, 3, 3}) == \"Charlie\")\n    assert(gameWinner(2, {1, 1}) == \"Charlie\")\n    assert(gameWinner(2, {2, 1}) == \"Charlie\")\n    assert(gameWinner(11, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}) == \"Dan\")\n    assert(gameWinner(10, {2, 2, 2, 2, 2, 2, 2, 2, 2, 1}) == \"Charlie\")\n    assert(gameWinner(10, {10, 10, 10, 10, 10, 10, 10, 10, 10, 10}) == \"Charlie\")\n    assert(gameWinner(10, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == \"Dan\")\nend\n\ntestGameWinner()", "entry_point": "gameWinner", "signature": "function gameWinner(n, piles)", "docstring": "Given a sequence of N piles of stones numbered from 1 to N,\nwith each pile containing a positive number of stones, determine \nthe winner of a game played by Charlie and Dan. Charlie goes first, \nand they take turns moving a positive number of stones from the \nleftmost non-empty pile to the adjacent right pile. The player who \ncan only move stones in the last pile loses. Assuming both players \nuse the best possible strategy, find out who will win the game.\n\n    >>> gameWinner(3, {1, 2, 2})\n    \"Dan\"", "instruction": "Write a Lua function `function gameWinner(n, piles)` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N,\nwith each pile containing a positive number of stones, determine \nthe winner of a game played by Charlie and Dan. Charlie goes first, \nand they take turns moving a positive number of stones from the \nleftmost non-empty pile to the adjacent right pile. The player who \ncan only move stones in the last pile loses. Assuming both players \nuse the best possible strategy, find out who will win the game.\n\n    >>> gameWinner(3, {1, 2, 2})\n    \"Dan\"", "level": "middle"}
{"task_id": "Lua/36", "prompt": "\n--[[ \nGiven n doors arranged in a circle, the player starts in front of door 1. \nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right \nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, {1, 1, 1})\n    3\n]]\nfunction minTotalCost(n, C)", "canonical_solution": "return C[n-1] * (n - 1) + C[n]\nend", "test": "function testMinTotalCost()\n\tassert(minTotalCost(5, {4, 3, 3, 3, 3}) == 15)\n\tassert(minTotalCost(3, {1, 1, 1}) == 3)\n\tassert(minTotalCost(4, {5, 4, 3, 2}) == 11)\n\tassert(minTotalCost(4, {100, 99, 98, 97}) == 391)\n\tassert(minTotalCost(6, {10, 9, 8, 7, 6, 5}) == 35)\n\tassert(minTotalCost(7, {2, 2, 2, 2, 2, 2, 2}) == 14)\n\tassert(minTotalCost(8, {9, 7, 7, 7, 7, 7, 7, 7}) == 56)\n\tassert(minTotalCost(9, {3, 2, 2, 2, 2, 2, 2, 2, 2}) == 18)\n\tassert(minTotalCost(10, {6, 5, 5, 5, 5, 5, 5, 5, 5, 5}) == 50)\n\tassert(minTotalCost(11, {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}) == 11)\nend\n\ntestMinTotalCost()", "entry_point": "minTotalCost", "signature": "function minTotalCost(n, C)", "docstring": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n. The task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, {1, 1, 1})\n    3\n", "instruction": "Write a Lua function `function minTotalCost(n, C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n. The task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, {1, 1, 1})\n    3\n", "level": "easy"}
{"task_id": "Lua/37", "prompt": "\n--[[\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of \nhandshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number.\nThe sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, {2, 1, 0})\n    0\n]]--\nfunction countHandshakes(n, order)", "canonical_solution": "local ans = 0\n    local tr = {}\n    for i = 1, n do -- Lua arrays are 1-indexed\n        tr[i] = 0\n    end\n    for i, x in ipairs(order) do\n        x = x + 1 -- Convert 0-indexed to 1-indexed\n        local j = x - 1\n        while j > 0 do\n            ans = ans + (tr[j] or 0)\n            j = j - (j & -j)\n        end\n        j = x\n        while j <= n do\n            tr[j] = (tr[j] or 0) + 1\n            j = j + (j & -j)\n        end\n    end\n    return ans\nend", "test": "function testCountHandshakes()\n    assert(countHandshakes(4, {2, 1, 3, 0}) == 2)\n    assert(countHandshakes(6, {0, 1, 2, 3, 4, 5}) == 15)\n    assert(countHandshakes(3, {1, 2, 0}) == 1)\n\n    assert(countHandshakes(4, {3, 2, 1, 0}) == 0)\n    assert(countHandshakes(4, {0, 1, 2, 3}) == 6)\n    assert(countHandshakes(6, {5, 4, 3, 2, 1, 0}) == 0)\n\n    assert(countHandshakes(4, {0, 2, 1, 3}) == 5)\n    assert(countHandshakes(5, {3, 1, 4, 2, 0}) == 3)\n    assert(countHandshakes(4, {1, 0, 3, 2}) == 4)\n\n    assert(countHandshakes(3, {2, 0, 1}) == 1)\n    assert(countHandshakes(5, {1, 3, 0, 2, 4}) == 7)\n    assert(countHandshakes(5, {4, 3, 2, 1, 0}) == 0)\nend\n\ntestCountHandshakes()", "entry_point": "countHandshakes", "signature": "function countHandshakes(n, order)", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, {2, 1, 0})\n    0\n", "instruction": "Write a Lua function `function countHandshakes(n, order)` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, {2, 1, 0})\n    0\n", "level": "middle"}
{"task_id": "Lua/38", "prompt": "\n--[[\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, {1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n]]--\nfunction maxModeSum(n, counts)", "canonical_solution": "local ans = 0\n    local mx = 0\n    local f = {}\n    for i = 0, n do\n        f[i] = 0\n    end\n\n    for i = n, 1, -1 do\n        while mx < counts[i] do\n            mx = mx + 1\n            f[mx] = f[mx - 1] + i\n        end\n        ans = ans + f[counts[i]]\n    end\n    return ans\nend", "test": "function testMaxModeSum()\n    assert(maxModeSum(3, {1, 3, 2}) == 17)\n    assert(maxModeSum(4, {4, 1, 2, 3}) == 37)\n    assert(maxModeSum(2, {1, 1}) == 4)\n    assert(maxModeSum(5, {1, 2, 3, 4, 5}) == 75)\n    assert(maxModeSum(1, {100000}) == 100000)\n    assert(maxModeSum(5, {5, 3, 2, 4, 1}) == 62)\n    assert(maxModeSum(3, {100000, 100000, 100000}) == 900000)\n    assert(maxModeSum(3, {2, 2, 5}) == 27)\n    assert(maxModeSum(4, {4, 4, 4, 4}) == 64)\n    assert(maxModeSum(6, {1, 2, 3, 4, 5, 6}) == 126)\n    assert(maxModeSum(3, {3, 1, 2}) == 16)\nend\n\ntestMaxModeSum()", "entry_point": "maxModeSum", "signature": "function maxModeSum(n, counts)", "docstring": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, {1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).", "instruction": "Write a Lua function `function maxModeSum(n, counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, {1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).", "level": "easy"}
{"task_id": "Lua/39", "prompt": "\n--[[\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n]]--\nfunction sumOfXorSubarrays(A)", "canonical_solution": "local n = #A\n    local q, w, ans = {}, {}, 0\n    for i = 0, 100010 do\n        q[i] = 0\n        w[i] = {0, 0}\n    end\n    \n    for i = 1, n do\n        q[i] = q[i - 1] ~ A[i]\n    end\n    \n    for i = 0, n do\n        for j = 20, 0, -1 do\n            local bitPosition = (q[i] >> j) & 1\n            w[j][bitPosition+1] = w[j][bitPosition+1] + 1\n        end\n    end\n    \n    for i = 0, 20 do\n        ans = ans + w[i][1] * w[i][2] * (1 << i)\n    end\n    return ans\nend", "test": "do\n    local function testSumOfXorSubarrays()\n        assert(sumOfXorSubarrays({1, 2, 3, 4, 5}) == 39)\n        assert(sumOfXorSubarrays({1, 1, 1}) == 4)\n        assert(sumOfXorSubarrays({2, 3, 1}) == 9)\n        assert(sumOfXorSubarrays({4, 5, 7, 9}) == 74)\n        assert(sumOfXorSubarrays({0, 0, 0, 0}) == 0)\n        assert(sumOfXorSubarrays({8, 8, 8, 8, 8}) == 72)\n        assert(sumOfXorSubarrays({3, 6, 9, 12, 15}) == 125)\n        assert(sumOfXorSubarrays({10, 20, 30, 40, 50}) == 390)\n        assert(sumOfXorSubarrays({16, 16, 16, 16, 16, 16}) == 192)\n        assert(sumOfXorSubarrays({1, 3, 5, 7, 9, 11, 13}) == 192)\n        assert(sumOfXorSubarrays({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) == 218)\n    end\n    testSumOfXorSubarrays()\nend", "entry_point": "sumOfXorSubarrays", "signature": "function sumOfXorSubarrays(A)", "docstring": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n", "instruction": "Write a Lua function `function sumOfXorSubarrays(A)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n", "level": "middle"}
{"task_id": "Lua/40", "prompt": "\n--[[\nGiven two positive integers n and k, find the number of positive integers x, \nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive \nintegers and b >= k. Different legal representations of the same number are \ncounted only once.\n\n    >>> countPowerNumbers(99, 1)\n    99\n]]--\nfunction countPowerNumbers(n, k)", "canonical_solution": "local count = 0\n    local x = 0\n    local mp = {}\n    for i = 0, n+1 do\n        mp[i] = false\n    end\n\n    i = 2\n    while i * i * i <= n do\n        local t = i * i\n        local m = 2\n        while t <= n / i do\n            t = t * i\n            m = m + 1\n            if m < k or mp[t] then\n                goto continue\n            end\n            if math.floor(math.sqrt(t)) == math.sqrt(t) then\n                x = x + 1\n            end\n            mp[t] = true\n            count = count + 1\n            ::continue::\n        end\n        i = i + 1\n    end\n    if k == 1 then\n        count = n\n    elseif k >= 3 then\n        count = count + 1\n    else\n        count = count + math.floor(math.sqrt(n)) - x\n    end\n    return count\nend", "test": "function testCountPowerNumbers()\n    assert(countPowerNumbers(99, 1) == 99)\n    assert(countPowerNumbers(99, 3) == 7)\n    assert(countPowerNumbers(99, 2) == 12)\n    assert(countPowerNumbers(10, 1) == 10)\n    assert(countPowerNumbers(10, 2) == 4)\n    assert(countPowerNumbers(500, 1) == 500)\n    assert(countPowerNumbers(500, 2) == 30)\n    assert(countPowerNumbers(500, 3) == 13)\n    assert(countPowerNumbers(1000, 1) == 1000)\n    assert(countPowerNumbers(1000, 2) == 41)\n    assert(countPowerNumbers(1000, 3) == 17)\n    assert(countPowerNumbers(1000, 93) == 1)\n    assert(countPowerNumbers(50, 2) == 10)\n    assert(countPowerNumbers(50, 3) == 5)\n    assert(countPowerNumbers(2, 3) == 1)\nend\n\ntestCountPowerNumbers()", "entry_point": "countPowerNumbers", "signature": "function countPowerNumbers(n, k)", "docstring": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\n\n    >>> countPowerNumbers(99, 1)\n    99\n", "instruction": "Write a Lua function `function countPowerNumbers(n, k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\n\n    >>> countPowerNumbers(99, 1)\n    99\n", "level": "hard"}
{"task_id": "Lua/41", "prompt": "\n--[[\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that\nthe longest balanced subsequence is of length 2 * k. The result should be calculated modulo\n1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n]]--\nfunction countBalancedSubsequences(n, m, k)", "canonical_solution": "local P = 1000000000 + 7\n    local C = {}\n    for i = 0, n + m + 2 do\n        C[i] = {}\n        C[i][0] = 1\n    end\n\n    -- Compute binomial coefficients only once.\n    for i = 1, n + m + 2 do\n        for j = 1, i do\n            if C[i-1][j] == nil then\n                C[i-1][j] = 0\n            end\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P\n        end\n    end\n    \n    -- Calculate the number of balanced subsequences.\n    if k > n or k > m then return 0 end\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P\nend", "test": "function testCountBalancedSubsequences()\n    assert(countBalancedSubsequences(2, 2, 2) == 2)\n    assert(countBalancedSubsequences(3, 2, 3) == 0)\n    assert(countBalancedSubsequences(3, 2, 1) == 4)\n    assert(countBalancedSubsequences(4, 3, 2) == 14)\n    assert(countBalancedSubsequences(5, 5, 2) == 35)\n    assert(countBalancedSubsequences(6, 1, 1) == 6)\n    assert(countBalancedSubsequences(1, 6, 1) == 6)\n    assert(countBalancedSubsequences(7, 2, 2) == 27)\n    assert(countBalancedSubsequences(8, 3, 3) == 110)\n    assert(countBalancedSubsequences(10, 10, 5) == 10659)\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648)\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531)\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485)\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024)\nend\n\ntestCountBalancedSubsequences()", "entry_point": "countBalancedSubsequences", "signature": "function countBalancedSubsequences(n, m, k)", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that\nthe longest balanced subsequence is of length 2 * k. The result should be calculated modulo\n1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "instruction": "Write a Lua function `function countBalancedSubsequences(n, m, k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that\nthe longest balanced subsequence is of length 2 * k. The result should be calculated modulo\n1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "level": "hard"}
{"task_id": "Lua/42", "prompt": "\n--[[\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m),\nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, \nand cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n--]]\nfunction expectedCuts(n, m, k)", "canonical_solution": "local MD = 1000000007\n    local N = 1000000\n    local vv = {}\n    local i, j\n    local ans = 1\n    \n    vv[1] = 1\n    for i = 2, N * 2 do\n        vv[i] = (vv[i - MD % i] * (MD // i + 1)) % MD\n    end\n    \n    if k > n * m then\n        return 0\n    end\n    \n    for i = (k + m - 1) // m, n - 1 do\n        ans = (ans + vv[i + (k + i - 1) // i - 1]) % MD\n    end\n    for j = (k + n - 1) // n, m - 1 do\n        ans = (ans + vv[(k + j - 1) // j + j - 1]) % MD\n    end\n    \n    return ans\nend", "test": "function testExpectedCuts()\n    assert(expectedCuts(2, 4, 10) == 0)\n    assert(expectedCuts(2, 4, 8) == 1)\n    assert(expectedCuts(2, 4, 2) == 833333342)\n    assert(expectedCuts(2, 4, 6) == 250000003)\n    assert(expectedCuts(3, 3, 4) == 666666673)\n    assert(expectedCuts(5, 5, 12) == 666666673)\n    assert(expectedCuts(6, 7, 20) == 722222229)\n    assert(expectedCuts(8, 8, 30) == 72727275)\n    assert(expectedCuts(10, 10, 50) == 714285721)\n    assert(expectedCuts(1, 10, 5) == 945634929)\n    assert(expectedCuts(10, 1, 5) == 945634929)\nend\n\ntestExpectedCuts()", "entry_point": "expectedCuts", "signature": "function expectedCuts(n, m, k)", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m),\nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, \nand cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n", "instruction": "Write a Lua function `function expectedCuts(n, m, k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m),\nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, \nand cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n", "level": "hard"}
{"task_id": "Lua/43", "prompt": "\n--[[\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements\nsuch that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\ndividing p into exactly k non-empty contiguous segments and sorting each segment (that is, choose k-1 \nbreakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide p into [1, x1], (x1, x2], ..., (x(k-1), n]).\nThe result should be modulo 998244353. \n\n    >>> countPermutations(2, 1, {1, 2})\n    2\n--]]\nfunction countPermutations(n, k, qq)", "canonical_solution": "local N = 505\n    local P = 998244353\n    local q = {}\n    local dp = {}\n    local jc = {}\n    local f = {}\n    local ans = 0\n\n    for i=0, N do\n        q[i] = 0\n        jc[i] = 0\n        f[i] = 0\n        dp[i] = {}\n        for j=0, N do\n            dp[i][j] = 0\n        end\n    end\n\n    for i=1, n do\n        q[i] = qq[i]\n    end\n    dp[0][0] = 1\n    f[0] = 1\n    jc[0] = 1\n\n    for i=1, n do\n        jc[i] = 1 * jc[i-1] * i % P\n    end\n\n    for i=1, n do\n        f[i] = jc[i]\n        for j=1, i-1 do\n            f[i] = (f[i] + P - 1 * f[j] * jc[i-j] % P) % P\n        end\n    end\n\n    for i=1, n do\n        for j=0, i-1 do\n            for k=1, n do\n                dp[i][k] = (dp[i][k] + dp[j][k-1] * 1 * f[i-j] % P) % P\n            end\n        end\n    end\n\n    local m = 0\n    for i=1, n do\n        if q[i] > q[i+1] then\n            m = i\n            break\n        end\n    end\n\n    if m == n then\n        for i=k, n do\n            ans = (ans + dp[n][i]) % P\n        end\n    else\n        for i=m+1, n do\n            if i ~= m+1 and (q[i-1] > q[i] or q[i] < q[m]) then\n                break\n            end\n            local c = k + i - n - 1\n            if c >= 0 then\n                ans = (ans + dp[m][c] * 1 * jc[i-m-1] % P) % P\n            end\n        end\n    end\n\n    return ans\nend", "test": "local function testCountPermutations()\n    local q1 = {1, 2}\n    assert(countPermutations(2, 1, q1) == 2)\n\n    local q2 = {3, 1, 2}\n    assert(countPermutations(3, 3, q2) == 1)\n\n    local q3 = {1, 2, 3, 6, 5, 4}\n    assert(countPermutations(6, 3, q3) == 13)\n\n    local q4 = {1, 2, 3, 4, 5, 6}\n    assert(countPermutations(6, 1, q4) == 720)\n\n    local q5 = {1, 2, 5, 3, 4, 5}\n    assert(countPermutations(6, 3, q5) == 0)\n\n    local q6 = {1, 2, 3, 4, 5, 6, 7, 8, 9}\n    assert(countPermutations(9, 9, q6) == 1)\n\n    local q7 = {1, 2, 3, 4, 5, 6, 7, 9, 8}\n    assert(countPermutations(9, 2, q7) == 29093)\nend\n\ntestCountPermutations()", "entry_point": "countPermutations", "signature": "function countPermutations(n, k, qq)", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\nsuch that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\ndividing p into exactly k non-empty contiguous segments and sorting each segment (that is, choose k-1 \nbreakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide p into [1, x1], (x1, x2], ..., (x(k-1), n]).\nThe result should be modulo 998244353. \n\n    >>> countPermutations(2, 1, {1, 2})\n    2\n", "instruction": "Write a Lua function `function countPermutations(n, k, qq)` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements\nsuch that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\ndividing p into exactly k non-empty contiguous segments and sorting each segment (that is, choose k-1 \nbreakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide p into [1, x1], (x1, x2], ..., (x(k-1), n]).\nThe result should be modulo 998244353. \n\n    >>> countPermutations(2, 1, {1, 2})\n    2\n", "level": "hard"}
{"task_id": "Lua/44", "prompt": "\n--[[\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> countTriplets({1, 5, 7})\n    1\n]]--\nfunction countTriplets(heights)", "canonical_solution": "local count = 0\n    local n = #heights\n    for i=1, n do\n        for j=i+1, n do\n            for k=j+1, n do\n                local minVal = math.min(heights[i], heights[j], heights[k])\n                local maxVal = math.max(heights[i], heights[j], heights[k])\n                \n                -- Euclidean algorithm to find GCD\n                local a = minVal\n                local b = maxVal\n                while b ~= 0 do\n                    local t = b\n                    b = a % b\n                    a = t\n                end\n                if a == 1 then\n                    count = count + 1\n                end\n            end\n        end\n    end\n    return count\nend", "test": "function testCountTriplets()\n    assert(countTriplets({1, 5, 7}) == 1)\n    assert(countTriplets({1, 6, 2, 3}) == 3)\n    assert(countTriplets({16, 4, 8, 2}) == 0)\n    assert(countTriplets({10, 1, 6, 7, 9, 8, 4, 3, 5, 2}) == 77)\n    assert(countTriplets({4, 5, 9, 11, 14}) == 7)\n    assert(countTriplets({15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}) == 104)\n    assert(countTriplets({3, 7, 11, 13}) == 4)\n    assert(countTriplets({5, 12, 13, 17, 19}) == 10)\n    assert(countTriplets({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 87)\n    assert(countTriplets({1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}) == 122)\nend\n\ntestCountTriplets()", "entry_point": "countTriplets", "signature": "function countTriplets(heights)", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets({1, 5, 7})\n    1\n", "instruction": "Write a Lua function `function countTriplets(heights)` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets({1, 5, 7})\n    1\n", "level": "hard"}
{"task_id": "Lua/45", "prompt": "\n--[[\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, {1, 2, 3, 2, 1})\n    2\n]]--\n", "canonical_solution": "function minOperations(n, pixels)\n    local pre = {}\n    local u = {}\n    local f = {}\n    for i = 1, n do\n        pre[i] = 0\n        u[i] = 0\n        f[i] = {}\n        for j = 1, n do\n            f[i][j] = i ~= j and 1000000000 or 0\n        end\n    end\n    for i = 1, n do\n        pre[i] = u[pixels[i]]\n        u[pixels[i]] = i\n    end\n    for len = 2, n do\n        for i = 1, n - len + 1 do\n            local j = i + len - 1\n            f[i][j] = f[i][j - 1] + 1\n            -- for l = pre[j], i, -1 do\n            l = pre[j]\n            while l >= i do\n                f[i][j] = math.min(f[i][j], f[i][l] + f[l + 1][j])\n                l = pre[l]\n            end\n        end\n    end\n    return f[1][n]\nend", "test": "local function testMinOperations()\n    assert(minOperations(5, {1, 2, 3, 2, 1}) == 2)\n    assert(minOperations(4, {1, 1, 2, 2}) == 1)\n    assert(minOperations(5, {1, 2, 1, 4, 2}) == 3)\n    assert(minOperations(5, {5, 5, 5, 5, 5}) == 0)\n    assert(minOperations(6, {1, 1, 1, 2, 2, 2}) == 1)\n    assert(minOperations(7, {1, 3, 3, 3, 2, 2, 2}) == 2)\n    assert(minOperations(8, {4, 4, 4, 4, 3, 3, 3, 3}) == 1)\n    assert(minOperations(9, {1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8)\n    assert(minOperations(10, {1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5)\n    assert(minOperations(3, {3, 3, 3}) == 0)\n    assert(minOperations(4, {2, 1, 1, 2}) == 1)\nend\n\ntestMinOperations()", "entry_point": "minOperations", "signature": "function minOperations(n, pixelArray)", "docstring": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, {1, 2, 3, 2, 1})\n    2\n", "instruction": "Write a Lua function `function minOperations(n, pixelArray)` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, {1, 2, 3, 2, 1})\n    2\n", "level": "hard"}
{"task_id": "Lua/46", "prompt": "\n--[[ \nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples \nof either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 -- (3 + 5 + 6 + 9 + 10)\n]]\nfunction sumOfMultiples(n)", "canonical_solution": "local sum = 0\n    for i = 1, n do\n        if i % 3 == 0 or i % 5 == 0 then\n            sum = sum + i\n        end\n    end\n    return sum\nend", "test": "function testSumOfMultiples()\n    assert(sumOfMultiples(10) == 33)\n    assert(sumOfMultiples(15) == 60)\n    assert(sumOfMultiples(20) == 98)\n    assert(sumOfMultiples(5) == 8)\n    assert(sumOfMultiples(3) == 3)\n    assert(sumOfMultiples(6) == 14)\n    assert(sumOfMultiples(9) == 23)\n    assert(sumOfMultiples(12) == 45)\n    assert(sumOfMultiples(17) == 60)\n    assert(sumOfMultiples(21) == 119)\n    assert(sumOfMultiples(25) == 168)\nend\n\ntestSumOfMultiples()", "entry_point": "sumOfMultiples", "signature": "function sumOfMultiples(n)", "docstring": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 -- (3 + 5 + 6 + 9 + 10)\n", "instruction": "Write a Lua function `function sumOfMultiples(n)` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 -- (3 + 5 + 6 + 9 + 10)\n", "level": "easy"}
{"task_id": "Lua/47", "prompt": "\n--[[\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other \nsequence of characters that reads the same forward and backward (ignoring spaces, \npunctuation, and capitalization).\n    >>> isPalindrome(\"racecar\") -- true\n]]--\nfunction isPalindrome(str)", "canonical_solution": "local start = 1\n    local endd = #str\n\n    while start < endd do\n        -- Skip non-alphanumeric characters and handle case insensitivity\n        while not str:sub(start, start):match(\"%w\") and start < endd do start = start + 1 end\n        while not str:sub(endd, endd):match(\"%w\") and start < endd do endd = endd - 1 end\n        if str:sub(start, start):lower() ~= str:sub(endd, endd):lower() then\n            return false\n        end\n        start = start + 1\n        endd = endd - 1\n    end\n    return true\nend", "test": "function testIsPalindrome()\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true)\n    assert(isPalindrome(\"No lemon, no melon\") == true)\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true)\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true)\n    assert(isPalindrome(\"Never odd or even\") == true)\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true)\n    assert(isPalindrome(\"hello\") == false)\n    assert(isPalindrome(\"GitHub\") == false)\n    assert(isPalindrome(\"programming\") == false)\nend\n\ntestIsPalindrome()", "entry_point": "isPalindrome", "signature": "function isPalindrome(str)", "docstring": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\") -- true\n", "instruction": "Write a Lua function `function isPalindrome(str)` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\") -- true\n", "level": "hard"}
{"task_id": "Lua/48", "prompt": "\n--[[\nGiven a non-negative integer num, repeatedly add all its digits until\nthe result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n]]--\nfunction addDigits(num)", "canonical_solution": "while num >= 10 do\n        local sum = 0\n        while num > 0 do\n            sum = sum + (num % 10)\n            num = math.floor(num / 10)\n        end\n        num = sum\n    end\n    return num\nend", "test": "function testAddDigits()\n    assert(addDigits(38) == 2)\n    assert(addDigits(0) == 0)\n    assert(addDigits(9) == 9)\n    assert(addDigits(123) == 6)\n    assert(addDigits(456) == 6)\n    assert(addDigits(9999) == 9)\n    assert(addDigits(100) == 1)\n    assert(addDigits(1010) == 2)\n    assert(addDigits(1234) == 1)\n    assert(addDigits(9876) == 3)\n    assert(addDigits(199) == 1)\nend\ntestAddDigits()", "entry_point": "addDigits", "signature": "function addDigits(num)", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "instruction": "Write a Lua function `function addDigits(num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "level": "easy"}
{"task_id": "Lua/49", "prompt": "\n--[[\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game assuming both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n]]--\nfunction canWinNim(n)", "canonical_solution": "return n % 4 ~= 0\nend", "test": "local function testCanWinNim()\n    assert(canWinNim(1) == true)\n    assert(canWinNim(2) == true)\n    assert(canWinNim(3) == true)\n    assert(canWinNim(4) == false)\n    assert(canWinNim(5) == true)\n    assert(canWinNim(6) == true)\n    assert(canWinNim(7) == true)\n    assert(canWinNim(8) == false)\n    assert(canWinNim(9) == true)\n    assert(canWinNim(10) == true)\n    assert(canWinNim(11) == true)\n    assert(canWinNim(12) == false)\n    assert(canWinNim(13) == true)\n    assert(canWinNim(14) == true)\n    assert(canWinNim(15) == true)\n    assert(canWinNim(16) == false)\n    assert(canWinNim(17) == true)\n    assert(canWinNim(18) == true)\n    assert(canWinNim(19) == true)\n    assert(canWinNim(20) == false)\nend\n\ntestCanWinNim()", "entry_point": "canWinNim", "signature": "function canWinNim(n)", "docstring": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game assuming both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true", "instruction": "Write a Lua function `function canWinNim(n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game assuming both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true", "level": "easy"}
{"task_id": "Lua/50", "prompt": "\n--[[\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n\nExamples:\n    evenSumOrOddProduct(2, 3) -- returns 6\n]]--\nfunction evenSumOrOddProduct(a, b)", "canonical_solution": "local sum = a + b\n    if sum % 2 == 0 then\n        return sum\n    else\n        return a * b\n    end\nend", "test": "function testEvenSumOrOddProduct()\n    assert(evenSumOrOddProduct(2, 3) == 6)\n    assert(evenSumOrOddProduct(5, 5) == 10)\n    assert(evenSumOrOddProduct(1, 1) == 2)\n    assert(evenSumOrOddProduct(0, 0) == 0)\n    assert(evenSumOrOddProduct(-1, -1) == -2)\n    assert(evenSumOrOddProduct(100, 200) == 300)\n    assert(evenSumOrOddProduct(3, 4) == 12)\n    assert(evenSumOrOddProduct(-5, 5) == 0)\n    assert(evenSumOrOddProduct(7, 8) == 56)\n    assert(evenSumOrOddProduct(9, 10) == 90)\n    assert(evenSumOrOddProduct(11, 14) == 154)\nend\n\ntestEvenSumOrOddProduct()", "entry_point": "evenSumOrOddProduct", "signature": "function evenSumOrOddProduct(a, b)", "docstring": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n\nExamples:\n    evenSumOrOddProduct(2, 3) -- returns 6\n", "instruction": "Write a Lua function `function evenSumOrOddProduct(a, b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n\nExamples:\n    evenSumOrOddProduct(2, 3) -- returns 6\n", "level": "easy"}
