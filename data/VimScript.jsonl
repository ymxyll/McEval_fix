{"task_id": "VimScript/1", "prompt": "\n\" return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction! Hello_mmcodeeval() abort", "canonical_solution": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nendfunction", "test": "if assert_equal(\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\", Hello_mmcodeeval()) | cq | endif\nexit(0)", "entry_point": "Hello_mmcodeeval", "signature": "function! Hello_mmcodeeval() abort", "docstring": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "instruction": "Write a VimScript function `function! Hello_mmcodeeval() abort` to solve the following problem:\nreturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "level": "easy"}
{"task_id": "VimScript/2", "prompt": "\n\" Calculate the area of a triangle given its three sides.\n\" Parameters:\n\" - a (float): Length of side 'a'.\n\" - b (float): Length of side 'b'.\n\" - c (float): Length of side 'c'.\n\" Returns:\n\" - str: If the provided sides form a triangle, return the calculated area with \n\"        2 decimal places. Otherwise, return \"-1\".\n\" Example:\n\" >>> CalculateTriangleArea(3,5,4)\n\"     6\nfunction! CalculateTriangleArea(a, b, c)", "canonical_solution": "if a:a + a:b > a:c && a:a + a:c > a:b && a:b + a:c > a:a\n        let s = (a:a + a:b + a:c) / 2.0\n        return sqrt(s * (s - a:a) * (s - a:b) * (s - a:c))\n    else\n        return -1\n    endif\nendfunction", "test": "function! TestCalculateTriangleArea()\n    \" Triangle with sides 3, 5, 4 should return area 6\n    if assert_equal(6.0, CalculateTriangleArea(3, 5, 4)) | cq | endif\n\n    \" Not a triangle with sides 1, 1, 4 should return \"-1\"\n    \" echo assert_equal(CalculateTriangleArea(1, 1, 4), -1)\n    if assert_equal(-1, CalculateTriangleArea(1, 1, 4)) | cq | endif\n\n    \" Triangle with sides 7, 24, 25 should return area 84\n    if assert_equal(84.0, CalculateTriangleArea(7, 24, 25)) | cq | endif\n\n    \" Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    \" For precision issues, we test if the calculated area is close enough to the expected value (Considering 2 decimal places)\n    \" Since vim does not have an explicit assert_almost_equal, we perform a manual approximate check.\n    let area = CalculateTriangleArea(10.5, 6.2, 7.3)\n    \" echo area\n    if abs(area - 22.15) >= 0.01\n        cq\n    endif\n\nendfunction\n\ncall TestCalculateTriangleArea()\nexit(0)", "entry_point": "CalculateTriangleArea", "signature": "function! CalculateTriangleArea(a, b, c)", "docstring": "Calculate the area of a triangle given its three sides.\nParameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\nReturns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return \"-1\".\nExample:\n>>> CalculateTriangleArea(3,5,4)\n    6", "instruction": "Write a VimScript function `function! CalculateTriangleArea(a, b, c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\nParameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\nReturns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return \"-1\".\nExample:\n>>> CalculateTriangleArea(3,5,4)\n    6", "level": "easy"}
{"task_id": "VimScript/3", "prompt": "\n\" Function to calculate the value of a mathematical function\n\" for a given input and round to 5 decimal places.\n\"\n\" Parameters:\n\" - x (int): Input value for the function.\n\"\n\" Returns:\n\" - string: If x is not in the defined domain, returns \"Not define\".\n\"            Otherwise, returns the calculated function value as a string.\n\"\n\" Function Definitions:\n\" - For 0 <= x < 10: y = cos(x + 3.0)\n\" - For 10 <= x < 20: y = (cos(x + 7.5))^2\n\" - For 20 <= x < 30: y = (cos(x + 4.0))^4\n\"\n\" Example:\n\"     >>> calculate_function_value(40)\n\"         Not define\n\"\nfunction! CalculateFunctionValue(x)", "canonical_solution": "if a:x >= 0 && a:x < 10\n        return printf('%.5f', cos(a:x + 3.0))\n    elseif a:x >= 10 && a:x < 20\n        return printf('%.5f', pow(cos(a:x + 7.5), 2.0))\n    elseif a:x >= 20 && a:x < 30\n        return printf('%.5f', pow(cos(a:x + 4.0), 4.0))\n    else\n        return \"Not define\"\n    endif\nendfunction", "test": "function! TestCalculateFunctionValue()\n    if assert_equal(CalculateFunctionValue(40), \"Not define\") | cq | endif\n    \" Additional test cases based on provided function definitions\n    if assert_equal(CalculateFunctionValue(40), \"Not define\") | cq | endif\n    if assert_equal(CalculateFunctionValue(5), \"-0.14550\") | cq | endif\n    if assert_equal(CalculateFunctionValue(15), \"0.76266\") | cq | endif\n    if assert_equal(CalculateFunctionValue(25), \"0.31314\") | cq | endif\n    if assert_equal(CalculateFunctionValue(-1), \"Not define\") | cq | endif\nendfunction\n\ncall TestCalculateFunctionValue()\nexit(0)", "entry_point": "CalculateFunctionValue", "signature": "function! CalculateFunctionValue(x)", "docstring": "Function to calculate the value of a mathematical function for a given input and round to 5 decimal places.\n\nParameters:\n- x (int): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not defined\". Otherwise, returns the calculated function value as a string.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\n    >>> calculate_function_value(40)\n        Not define", "instruction": "Write a VimScript function `function! CalculateFunctionValue(x)` to solve the following problem:\nFunction to calculate the value of a mathematical function for a given input and round to 5 decimal places.\n\nParameters:\n- x (int): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not defined\". Otherwise, returns the calculated function value as a string.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\n    >>> calculate_function_value(40)\n        Not define", "level": "easy"}
{"task_id": "VimScript/4", "prompt": "\n\" Find the maximum and minimum of three distinct integers.\n\" Parameters:\n\" a (int): The first integer.\n\" b (int): The second integer.\n\" c (int): The third integer.\n\"\n\" Returns:\n\" Tuple[int, int]: This tuple concept is represented by returning a List in vimscript.\n\"\n\" >>> Example call:\n\" let [max, min] = FindMaxMin(1, 2, 3)\n\" assert_equal([3, 1], [max, min])\nfunction! FindMaxMin(a, b, c)", "canonical_solution": "let max = 0\n    let min = 0\n\n    if a:a > a:b\n        if a:a > a:c\n            let max = a:a\n            let min = (a:b < a:c) ? a:b : a:c\n        else\n            let max = a:c\n            let min = a:b\n        endif\n    else\n        if a:b > a:c\n            let max = a:b\n            let min = (a:a < a:c) ? a:a : a:c\n        else\n            let max = a:c\n            let min = a:a\n        endif\n    endif\n\n    return [max, min]\nendfunction", "test": "function! TestFindMaxMin()\n    if assert_equal(FindMaxMin(1, 2, 3), [3, 1]) | cq | endif\n    if assert_equal(FindMaxMin(5, 3, 4), [5, 3]) | cq | endif\n    if assert_equal(FindMaxMin(10, -2, 7), [10, -2]) | cq | endif\n    if assert_equal(FindMaxMin(-1, -3, -2), [-1, -3]) | cq | endif\nendfunction\n\ncall TestFindMaxMin()\nexit(0)", "entry_point": "FindMaxMin", "signature": "function! FindMaxMin(a, b, c)", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: This tuple concept is represented by returning a List in vimscript.\n\n>>> Example call:\nlet [max, min] = FindMaxMin(1, 2, 3)\nassert_equal([3, 1], [max, min])\n", "instruction": "Write a VimScript function `function! FindMaxMin(a, b, c)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: This tuple concept is represented by returning a List in vimscript.\n\n>>> Example call:\nlet [max, min] = FindMaxMin(1, 2, 3)\nassert_equal([3, 1], [max, min])\n", "level": "middle"}
{"task_id": "VimScript/5", "prompt": "\n\" Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\" Parameters:\n\" - xa (double): x-coordinate of point A.\n\" - ya (double): y-coordinate of point A.\n\" - xb (double): x-coordinate of point B.\n\" - yb (double): y-coordinate of point B.\n\"    \n\" Returns:\n\" double: The distance between points A and B.\n\" Example\n\" >>> calculate_distance(0,0,3,4)\n\"     5\nfunction! CalculateDistance(xa, ya, xb, yb)", "canonical_solution": "return sqrt((a:xa - a:xb) * (a:xa - a:xb) + (a:ya - a:yb) * (a:ya - a:yb))\nendfunction", "test": "function! TestCalculateDistance()\n    if !(abs(CalculateDistance(0,0,3,4) - 5) < 0.00001) | cq | endif\n    if !(abs(CalculateDistance(0,0,0,0) - 0) < 0.00001) | cq | endif\n    if !(abs(CalculateDistance(-1,-1,2,2) - 4.242640687) < 0.00001) | cq | endif\n    if !(abs(CalculateDistance(1.5,3.9,4.2,-1.1) - 5.68243) < 0.00001) | cq | endif\nendfunction\n\ncall TestCalculateDistance()\nexit(0)", "entry_point": "CalculateDistance", "signature": "function! CalculateDistance(xa, ya, xb, yb)", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\nExample\n>>> calculate_distance(0,0,3,4)\n    5", "instruction": "Write a VimScript function `function! CalculateDistance(xa, ya, xb, yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\nExample\n>>> calculate_distance(0,0,3,4)\n    5", "level": "easy"}
{"task_id": "VimScript/6", "prompt": "\n\" Find the factorial of N and take the modulo 10007 of the result.\n\" \n\" Parameters:\n\" - N (int): An integer representing the input value (N <= 10000).\n\" \n\" Returns:\n\" int: The result after taking the modulo 10007 of the factorial of N.\n\" \n\" Example:\n\" >>> call ProcessRequest(1)\n\" 1\nfunction! ProcessRequest(n)", "canonical_solution": "\" let a = []\n    let a = range(10002)\n    let a[0] = 1\n    let a[1] = 1\n    for i in range(2, 10000)\n        let a[i] = (a[i-1] * i) % 10007\n    endfor\n    return a[a:n]\nendfunction", "test": "function! TestProcessRequest()\n    if assert_equal(1, ProcessRequest(0)) | cq | endif\n    if assert_equal(1, ProcessRequest(1)) | cq | endif\n    if assert_equal(2, ProcessRequest(2)) | cq | endif\n    if assert_equal(6, ProcessRequest(3)) | cq | endif\n    if assert_equal(24, ProcessRequest(4)) | cq | endif\n    if assert_equal(6266, ProcessRequest(10)) | cq | endif\n    if assert_equal(6991, ProcessRequest(10000)) | cq | endif\nendfunction\n\ncall TestProcessRequest()\nexit(0)", "entry_point": "ProcessRequest", "signature": "function! ProcessRequest(n)", "docstring": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the factorial of N.\n\nExample:\n>>> call ProcessRequest(1)\n1\n", "instruction": "Write a VimScript function `function! ProcessRequest(n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the factorial of N.\n\nExample:\n>>> call ProcessRequest(1)\n1\n", "level": "easy"}
{"task_id": "VimScript/7", "prompt": "\n\" Calculate the area of a triangle given its base and height.\n\" Parameters:\n\" - base (int): The base length of the triangle.\n\" - height (int): The height of the triangle.\n\" Returns:\n\" float: The calculated area of the triangle, rounded to one decimal place.\n\" Example:\n\" >>> calculate_triangle_area(1,2)\n\" 1.0\nfunction! CalculateTriangleArea(base, height)", "canonical_solution": "return a:base * a:height / 2.0 \n    \" The area formula is (base * height) / 2\nendfunction", "test": "function! TestCalculateTriangleArea()\n    if assert_equal(CalculateTriangleArea(1, 2), 1.0) | cq | endif\n    if assert_equal(CalculateTriangleArea(3, 4), 6.0) | cq | endif\n    if assert_equal(CalculateTriangleArea(5, 8), 20.0) | cq | endif\n    if assert_equal(CalculateTriangleArea(7, 3), 10.5) | cq | endif\n    if assert_equal(CalculateTriangleArea(10, 10), 50.0) | cq | endif\nendfunction\n\ncall TestCalculateTriangleArea()\nexit(0)", "entry_point": "CalculateTriangleArea", "signature": "function! CalculateTriangleArea(base, height)", "docstring": "Calculate the area of a triangle given its base and height.\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExample:\n>>> calculate_triangle_area(1,2)\n1.0\n", "instruction": "Write a VimScript function `function! CalculateTriangleArea(base, height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExample:\n>>> calculate_triangle_area(1,2)\n1.0\n", "level": "easy"}
{"task_id": "VimScript/8", "prompt": "\n\" Calculates the Hamming distance between two integers in binary representation.\n\" Parameters:\n\" - a: int, The first positive integer (a <= 1,000,000,000).\n\" - b: int, The second positive integer (b <= 1,000,000,000).\n\" Returns:\n\" - int: The Hamming distance between a and b, i.e., the number of bits that\n\"        need to be flipped to transform a into b in binary.\n\" Example:\n\" >>> echo HammingDistance(1,2)\n\" 2\nfunction! HammingDistance(x, y)", "canonical_solution": "let distance = 0\n    let xor_result = xor(a:x, a:y) \" XOR x and y to get a number where set bits are the differences\n    \" Count the number of bits set in xor_result\n    while xor_result\n        if xor_result % 2\n            let distance += 1\n        endif\n        let xor_result = xor_result / 2\n    endwhile\n    return distance\nendfunction", "test": "function! TestHammingDistance()\n    if assert_equal(HammingDistance(1, 2), 2) | cq | endif \" 01 and 10 have 2 different bits\n    if assert_equal(HammingDistance(4, 7), 2) | cq | endif \" 100 and 111 have 2 different bits\n    if assert_equal(HammingDistance(25, 30), 3) | cq | endif \" Additional test: 11001 and 11110 have 3 different bits\n    if assert_equal(HammingDistance(0, 0), 0) | cq | endif \" Additional test: Same numbers have 0 different bits\n    if assert_equal(HammingDistance(0xFFFFFFF, 0x0000000), 28) | cq | endif \" Additional test: Max unsigned int and 0 have 32 different bits\nendfunction\n\ncall TestHammingDistance()\nexit(0)", "entry_point": "HammingDistance", "signature": "function! HammingDistance(x, y)", "docstring": "Calculates the Hamming distance between two integers in binary representation.\nParameters:\n- a: int, The first positive integer (a <= 1,000,000,000).\n- b: int, The second positive integer (b <= 1,000,000,000).\nReturns:\n- int: The Hamming distance between a and b, i.e., the number of bits that\n        need to be flipped to transform a into b in binary.\nExample:\n>>> echo HammingDistance(1,2)\n 2\n", "instruction": "Write a VimScript function `function! HammingDistance(x, y)` to solve the following problem:\nCalculates the Hamming distance between two integers in binary representation.\nParameters:\n- a: int, The first positive integer (a <= 1,000,000,000).\n- b: int, The second positive integer (b <= 1,000,000,000).\nReturns:\n- int: The Hamming distance between a and b, i.e., the number of bits that\n        need to be flipped to transform a into b in binary.\nExample:\n>>> echo HammingDistance(1,2)\n 2\n", "level": "middle"}
{"task_id": "VimScript/9", "prompt": "\n\" Count the number of odd integers in a given list of numbers.\n\" Parameters:\n\" - numbers (List): A list of integers to evaluate.\n\" Returns:\n\" int: The count of odd numbers in the input list.\n\" Example\n\" >>> let result = CountOddNumbers([1, 4, 3, 2, 5])\n\" >>> echo result\n\"     3\nfunction! CountOddNumbers(numbers)", "canonical_solution": "let ans = 0\n    for num in a:numbers\n        if num % 2 == 1\n            let ans += 1\n        endif\n    endfor\n    return ans\nendfunction", "test": "function! TestCountOddNumbers()\n    if assert_equal(CountOddNumbers([1, 4, 3, 2, 5]), 3) | cq | endif\n    if assert_equal(CountOddNumbers([2, 2, 0, 0]), 0) | cq | endif\n    \" Additional Test Sample\n    if assert_equal(CountOddNumbers([7, 7, 8, 1, 9, 10]), 4) | cq | endif\nendfunction\n\ncall TestCountOddNumbers()\nexit(0)", "entry_point": "CountOddNumbers", "signature": "function! CountOddNumbers(numbers)", "docstring": "Count the number of odd integers in a given list of numbers.\nParameters:\n- numbers (List): A list of integers to evaluate.\nReturns:\nint: The count of odd numbers in the input list.\nExample\n>>> let result = CountOddNumbers([1, 4, 3, 2, 5])\n>>> echo result\n    3\n", "instruction": "Write a VimScript function `function! CountOddNumbers(numbers)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\nParameters:\n- numbers (List): A list of integers to evaluate.\nReturns:\nint: The count of odd numbers in the input list.\nExample\n>>> let result = CountOddNumbers([1, 4, 3, 2, 5])\n>>> echo result\n    3\n", "level": "easy"}
{"task_id": "VimScript/10", "prompt": "\n\" Calculate the sum of even numbers in a given list.\n\" Parameters:\n\" - numbers (list): A list of integers.\n\" - size (int): The size of the list.\n\" Returns:\n\" int: The sum of even numbers in the input list.\n\" Example:\n\" >>> calculate_even_sum([1,4,3,2,5], 5)\n\" 6\nfunction! CalculateEvenSum(numbers, size)", "canonical_solution": "let ans = 0\n    for i in range(a:size)\n        if (a:numbers[i] % 2 == 0) \" Only sum the even numbers\n            let ans += a:numbers[i]\n        endif\n    endfor\n    return ans\nendfunction", "test": "function! TestCalculateEvenSum()\n    let sample1 = [1, 4, 3, 2, 5]\n    let sample2 = [2, 2, 0, 0]\n    let sample3 = [7, 11, 19] \" Additional test with no even numbers\n    let sample4 = [12, 14, 16, 18, 20] \" Additional test with all even numbers\n\n    if assert_equal(CalculateEvenSum(sample1, 5), 6) | cq | endif\n    if assert_equal(CalculateEvenSum(sample2, 4), 4) | cq | endif\n    if assert_equal(CalculateEvenSum(sample3, 3), 0) | cq | endif\n    if assert_equal(CalculateEvenSum(sample4, 5), 12 + 14 + 16 + 18 + 20) | cq | endif\n\nendfunction\n\ncall TestCalculateEvenSum()\nexit(0)", "entry_point": "CalculateEvenSum", "signature": "function! CalculateEvenSum(numbers, size)", "docstring": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\nReturns:\nint: The sum of even numbers in the input list.\nExample:\n>>> calculate_even_sum([1,4,3,2,5], 5)\n6\n", "instruction": "Write a VimScript function `function! CalculateEvenSum(numbers, size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\nReturns:\nint: The sum of even numbers in the input list.\nExample:\n>>> calculate_even_sum([1,4,3,2,5], 5)\n6\n", "level": "easy"}
{"task_id": "VimScript/11", "prompt": "\n\" Determine if two closed intervals intersect.\n\" Args:\n\" a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n\" c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\" Returns:\n\" int: 1 if the intervals intersect, 0 otherwise.\nfunction! AreIntervalsIntersecting(a, b, c, d)", "canonical_solution": "if ((a:c <= a:a && a:b <= a:d) ||\n        \\ (a:a <= a:c && a:c <= a:b && a:b <= a:d) ||\n        \\ (a:a <= a:c && a:d <= a:b) ||\n        \\ (a:c <= a:a && a:a <= a:d && a:d <= a:b))\n        return 1 \" Yes\n    else\n        return 0 \" No\n    endif\nendfunction", "test": "function! TestAreIntervalsIntersecting()\n    if assert_equal(AreIntervalsIntersecting(1, 1, 1, 2), 1) | cq | endif\n    if assert_equal(AreIntervalsIntersecting(3, 5, 2, 6), 1) | cq | endif\n    if assert_equal(AreIntervalsIntersecting(3, 5, 4, 7), 1) | cq | endif\n    if assert_equal(AreIntervalsIntersecting(3, 5, 6, 7), 0) | cq | endif\n    \" Additional test cases\n    if assert_equal(AreIntervalsIntersecting(0, 0, 0, 0), 1) | cq | endif\n    if assert_equal(AreIntervalsIntersecting(1, 3, 2, 4), 1) | cq | endif\n    if assert_equal(AreIntervalsIntersecting(1, 3, 4, 6), 0) | cq | endif\n    if assert_equal(AreIntervalsIntersecting(10, 20, 20, 30), 1) | cq | endif\n    if assert_equal(AreIntervalsIntersecting(10, 20, 21, 30), 0) | cq | endif\nendfunction\n\ncall TestAreIntervalsIntersecting()\nexit(0)", "entry_point": "AreIntervalsIntersecting", "signature": "function! AreIntervalsIntersecting(a, b, c, d)", "docstring": "Determine if two closed intervals intersect.\nArgs:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n", "instruction": "Write a VimScript function `function! AreIntervalsIntersecting(a, b, c, d)` to solve the following problem:\nDetermine if two closed intervals intersect.\nArgs:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n", "level": "easy"}
{"task_id": "VimScript/12", "prompt": "\n\" You are given three digits a, b, c. Two of them are equal, but the third one is different from\n\" the other two. Find the value that occurs exactly once.\n\" Examples:\n\" >>> ExtraNumber(0,0,1) returns 1\n\" >>> ExtraNumber(4,3,4) returns 3\nfunction! ExtraNumber(a, b, c)", "canonical_solution": "if a:a == a:b\n        return a:c\n    elseif a:a == a:c\n        return a:b\n    else\n        return a:a\n    endif\n\nendfunction", "test": "function! TestExtraNumber()\n    if assert_equal(ExtraNumber(2, 7, 2), 7) | cq | endif\n    if assert_equal(ExtraNumber(3, 2, 2), 3) | cq | endif\n    if assert_equal(ExtraNumber(5, 5, 1), 1) | cq | endif\n    if assert_equal(ExtraNumber(500000000, 3, 500000000), 3) | cq | endif\n    if assert_equal(ExtraNumber(500000000, 500000000, 3), 3) | cq | endif\nendfunction\n\ncall TestExtraNumber()\nexit(0)", "entry_point": "ExtraNumber", "signature": "function! ExtraNumber(a, b, c)", "docstring": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\nExamples:\n>>> ExtraNumber(0,0,1) returns 1\n>>> ExtraNumber(4,3,4) returns 3", "instruction": "Write a VimScript function `function! ExtraNumber(a, b, c)` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\nExamples:\n>>> ExtraNumber(0,0,1) returns 1\n>>> ExtraNumber(4,3,4) returns 3", "level": "easy"}
{"task_id": "VimScript/13", "prompt": "\n\" Calculate the total score for a student based on the scores in different subjects.\n\" Parameters:\n\" - subject_scores (list): A list containing the scores for each subject.\n\" Returns:\n\"     int: The total score obtained by summing up the scores in all subjects.\n\" Example:\n\" >>> CalculateTotalScore(100,100,100,100,100)\n\"     500\nfunction! CalculateTotalScore(score1, score2, score3, score4, score5)", "canonical_solution": "return a:score1 + a:score2 + a:score3 + a:score4 + a:score5\nendfunction", "test": "function! TestCalculateTotalScore()\n    if assert_equal(CalculateTotalScore(100, 100, 100, 100, 100), 500) | cq | endif\n    if assert_equal(CalculateTotalScore(0, 0, 0, 0, 0), 0) | cq | endif\n    if assert_equal(CalculateTotalScore(20, 30, 40, 10, 50), 150) | cq | endif\n    if assert_equal(CalculateTotalScore(23, 45, 67, 89, 12), 236) | cq | endif\n    if assert_equal(CalculateTotalScore(5, 5, 5, 5, 5), 25) | cq | endif\nendfunction\n\ncall TestCalculateTotalScore()\nexit(0)", "entry_point": "CalculateTotalScore", "signature": "function! CalculateTotalScore(score1, score2, score3, score4, score5)", "docstring": "Calculate the total score for a student based on the scores in different subjects.\nParameters:\n- subject_scores (list): A list containing the scores for each subject.\nReturns:\n    int: The total score obtained by summing up the scores in all subjects.\nExample:\n>>> CalculateTotalScore(100,100,100,100,100)\n    500\n", "instruction": "Write a VimScript function `function! CalculateTotalScore(score1, score2, score3, score4, score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\nParameters:\n- subject_scores (list): A list containing the scores for each subject.\nReturns:\n    int: The total score obtained by summing up the scores in all subjects.\nExample:\n>>> CalculateTotalScore(100,100,100,100,100)\n    500\n", "level": "easy"}
{"task_id": "VimScript/14", "prompt": "\n\" Decode a series of numbers to reveal the pattern and understand the actual values \n\" each digit represents.\n\" 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\"\n\" Parameters:\n\" - data_str: A string representing a series of numbers. Length does not exceed 100.\n\"\n\" Returns:\n\" int: The result of each data string corresponding to the right-hand side of the equation.\n\"\n\" Example usage:\n\" assert_equal(decode_numbers(\"0000\"), 4)\nfunction! DecodeNumbers(data_str)", "canonical_solution": "let a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1]\n    let ans = 0\n    for i in range(len(a:data_str))\n        let ans += a[str2nr(a:data_str[i])]\n    endfor\n    return ans\nendfunction", "test": "function! TestDecodeNumbers()\n    if assert_equal(DecodeNumbers(\"0000\"), 4) | cq | endif\n    if assert_equal(DecodeNumbers(\"8888\"), 8) | cq | endif\n    if assert_equal(DecodeNumbers(\"1234\"), 1) | cq | endif\n    if assert_equal(DecodeNumbers(\"5678\"), 3) | cq | endif\n    if assert_equal(DecodeNumbers(\"9012\"), 2) | cq | endif\n    if assert_equal(DecodeNumbers(\"1357\"), 0) | cq | endif\n    if assert_equal(DecodeNumbers(\"2468\"), 4) | cq | endif\n    \" Additional test samples\n    if assert_equal(DecodeNumbers(\"9999\"), 4) | cq | endif\n    if assert_equal(DecodeNumbers(\"1111\"), 0) | cq | endif\n    if assert_equal(DecodeNumbers(\"2222\"), 0) | cq | endif\n    if assert_equal(DecodeNumbers(\"3333\"), 0) | cq | endif\n    if assert_equal(DecodeNumbers(\"4444\"), 4) | cq | endif\n    if assert_equal(DecodeNumbers(\"5555\"), 0) | cq | endif\n    if assert_equal(DecodeNumbers(\"6666\"), 4) | cq | endif\n    if assert_equal(DecodeNumbers(\"7777\"), 0) | cq | endif\n    if assert_equal(DecodeNumbers(\"0001\"), 3) | cq | endif\n    if assert_equal(DecodeNumbers(\"2301\"), 1) | cq | endif\nendfunction\n\ncall TestDecodeNumbers()\nexit(0)", "entry_point": "DecodeNumbers", "signature": "function! DecodeNumbers(data_str)", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert_equal(decode_numbers(\"0000\"), 4)", "instruction": "Write a VimScript function `function! DecodeNumbers(data_str)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert_equal(decode_numbers(\"0000\"), 4)", "level": "easy"}
{"task_id": "VimScript/15", "prompt": "\n\" Counts the number of different coloring methods for n squares with m colors,\n\" considering the requirement that adjacent squares and the first/last squares\n\" must have different colors.\n\" Args:\n\" - n (int): The number of squares.\n\" - m (int): The number of colors.\n\" Returns:\n\" int: The count of different coloring methods satisfying the specified conditions.\n\" Result is modulo 1000003.\n\" Example:\n\" >>> count_coloring_methods(1,1)\n\"     1\nfunction! CountColoringMethods(n, m)", "canonical_solution": "\" let f = range()\n    if a:n == 1\n        return a:m\n    endif\n    if a:n == 2\n        return (a:m * (a:m - 1)) % 1000003\n    endif\n    \" Initialize the first three elements\n    \" let f = [0] * 1111\n    let f = range(a:n+1)\n    let f[1] = a:m\n    let f[2] = (a:m * (a:m - 1)) % 1000003\n    \" Formula derived from given code\n    let f[3] = (f[2] * (a:m - 2)) % 1000003\n    for i in range(4, a:n)\n        let f[i] = ((f[i - 1] * (a:m - 2)) % 1000003 + \n                   \\ (f[i - 2] * (a:m - 1)) % 1000003) % 1000003\n    endfor\n    return f[a:n]\nendfunction", "test": "function! TestCountColoringMethods()\n    if assert_equal(CountColoringMethods(1, 1), 1) | cq | endif\n    if assert_equal(CountColoringMethods(2, 2), 2) | cq | endif\n    if assert_equal(CountColoringMethods(3, 3), 6) | cq | endif\n    if assert_equal(CountColoringMethods(4, 2), 2) | cq | endif\n    if assert_equal(CountColoringMethods(1000, 10), 566585) | cq | endif\n    \" Additional test cases\n    if assert_equal(CountColoringMethods(2, 3), 6) | cq | endif\n    if assert_equal(CountColoringMethods(1000, 1000), 67911) | cq | endif\n    if assert_equal(CountColoringMethods(999, 66), 501817) | cq | endif\n    if assert_equal(CountColoringMethods(5, 3), 30) | cq | endif\nendfunction\n\ncall TestCountColoringMethods()\nexit(0)", "entry_point": "CountColoringMethods", "signature": "function! CountColoringMethods(n, m)", "docstring": "Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nArgs:\n- n (int): The number of squares.\n- m (int): The number of colors.\nReturns:\nint: The count of different coloring methods satisfying the specified conditions.\nResult is modulo 1000003.\nExample:\n>>> count_coloring_methods(1,1)\n    1\n", "instruction": "Write a VimScript function `function! CountColoringMethods(n, m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nArgs:\n- n (int): The number of squares.\n- m (int): The number of colors.\nReturns:\nint: The count of different coloring methods satisfying the specified conditions.\nResult is modulo 1000003.\nExample:\n>>> count_coloring_methods(1,1)\n    1\n", "level": "hard"}
{"task_id": "VimScript/16", "prompt": "\n\" Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\" Parameters:\n\" - n (int): The number of coin tosses.\n\" Returns:\n\" The count of valid sequences.\n\" Example:\n\" >>> count_valid_coin_toss_sequences(1)\n\"     2\nfunction! CountValidCoinTossSequences(n)", "canonical_solution": "let a = range(a:n+1)\n    let a[1] = [1, 1]\n    for i in range(2, a:n)\n        let a[i] = [0, 0]\n        let a[i][0] = a[i - 1][1] + a[i - 1][0]\n        let a[i][1] = a[i - 1][0]\n    endfor\n    return a[a:n][0] + a[a:n][1]\nendfunction", "test": "function! TestCountValidCoinTossSequences()\n    if assert_equal(CountValidCoinTossSequences(1), 2) | cq | endif\n    if assert_equal(CountValidCoinTossSequences(2), 3) | cq | endif\n    if assert_equal(CountValidCoinTossSequences(3), 5) | cq | endif\n    if assert_equal(CountValidCoinTossSequences(4), 8) | cq | endif\n    if assert_equal(CountValidCoinTossSequences(5), 13) | cq | endif\n    \" Additional tests\n    if assert_equal(CountValidCoinTossSequences(40), 267914296) | cq | endif\n    if assert_equal(CountValidCoinTossSequences(39), 165580141) | cq | endif\n    if assert_equal(CountValidCoinTossSequences(38), 102334155) | cq | endif\nendfunction\n\ncall TestCountValidCoinTossSequences()\nexit(0)", "entry_point": "CountValidCoinTossSequences", "signature": "function! CountValidCoinTossSequences(n)", "docstring": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\nThe count of valid sequences.\nExample:\n>>> count_valid_coin_toss_sequences(1)\n    2\n", "instruction": "Write a VimScript function `function! CountValidCoinTossSequences(n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\nThe count of valid sequences.\nExample:\n>>> count_valid_coin_toss_sequences(1)\n    2\n", "level": "easy"}
{"task_id": "VimScript/17", "prompt": "\n\" Find the length of the longest consecutive sequence of 1s in the binary\n\" representation of a non-negative integer.\n\" \n\" Parameters:\n\" - n (number): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\"\n\" Returns:\n\" int: The length of the longest consecutive sequence of 1s in the binary\n\" representation of the given integer.\n\"\n\" Examples:\n\" >>> FindLongestConsecutiveOnesLength(7)\n\"     3\nfunction! FindLongestConsecutiveOnesLength(n)", "canonical_solution": "let l:max = 0\n    let l:ans = 0\n    let l:n = a:n\n    while l:n\n        if l:n % 2 == 1\n            let l:ans += 1\n        else\n            if l:ans > l:max\n                let l:max = l:ans\n            endif\n            let l:ans = 0\n        endif\n        let l:n = l:n / 2\n    endwhile\n    if l:ans > l:max\n        let l:max = l:ans\n    endif\n    return l:max\nendfunction", "test": "function! TestFindLongestConsecutiveOnesLength()\n    if assert_equal(FindLongestConsecutiveOnesLength(7), 3) | cq | endif\n    if assert_equal(FindLongestConsecutiveOnesLength(13), 2) | cq | endif\n    if assert_equal(FindLongestConsecutiveOnesLength(12345), 3) | cq | endif\n    if assert_equal(FindLongestConsecutiveOnesLength(0xF0F0F0F000), 4) | cq | endif\n    if assert_equal(FindLongestConsecutiveOnesLength(0xFFFFFFFF), 32) | cq | endif\n    if assert_equal(FindLongestConsecutiveOnesLength(0), 0) | cq | endif\nendfunction\n\ncall TestFindLongestConsecutiveOnesLength()\nexit(0)", "entry_point": "FindLongestConsecutiveOnesLength", "signature": "function! FindLongestConsecutiveOnesLength(n)", "docstring": "Find the length of the longest consecutive sequence of 1s in the binary\nrepresentation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary\nrepresentation of the given integer.\n\nExamples:\n>>> FindLongestConsecutiveOnesLength(7)\n    3\n", "instruction": "Write a VimScript function `function! FindLongestConsecutiveOnesLength(n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary\nrepresentation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary\nrepresentation of the given integer.\n\nExamples:\n>>> FindLongestConsecutiveOnesLength(7)\n    3\n", "level": "middle"}
{"task_id": "VimScript/18", "prompt": "\n\" Creates an ID by combining two words in a specific manner.\n\" Parameters:\n\" - word1 (char*): The first word to be used in the ID.\n\" - word2 (char*): The second word to be used in the ID.\n\"\n\" Returns:\n\" char*: An ID formed by reversing every other character of the second\n\"        word and combining it with the first word.\n\"\n\" Example:\n\" >>> create_id('fish', 'cat')\n\"     'ftiasch'\nfunction! CreateID(word1, word2) abort", "canonical_solution": "let l:length1 = len(a:word1)\n    let l:length2 = len(a:word2)\n    let l:total_length = l:length1 + l:length2\n    let l:id = []\n\n    for l:i in range(l:total_length)\n        if l:i % 2 == 0\n            call add(l:id, a:word1[(l:i / 2) % l:length1])\n        else\n            call add(l:id, a:word2[(l:length2 - 1) - ((l:i - 1) / 2)])\n        endif\n    endfor\n\n    return join(l:id, '')\nendfunction", "test": "function! TestCreateID() abort\n    if assert_equal(CreateID('fish', 'cat'), 'ftiasch') | cq | endif\n    if assert_equal(CreateID('icpc', 'acm'), 'imccpac') | cq | endif\n    if assert_equal(CreateID('oo', 'w'), 'owo') | cq | endif\n    if assert_equal(CreateID('hello', 'world'), 'hdellrloow') | cq | endif\n    if assert_equal(CreateID('abc', 'def'), 'afbecd') | cq | endif\n    if assert_equal(CreateID('buaanb', 'nbbuaa'), 'bauaauabnbbn') | cq | endif\n    if assert_equal(CreateID('xtuisgood', 'ilovextu'), 'xuttuxiesvgooloid') | cq | endif\nendfunction\n\ncall TestCreateID()\nexit(0)", "entry_point": "CreateID", "signature": "function! CreateID(word1, word2) abort", "docstring": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n\nReturns:\nchar*: An ID formed by reversing every other character of the second word and combining it with the first word.\n\nExample:\n>>> create_id('fish', 'cat')\n    'ftiasch'\n", "instruction": "Write a VimScript function `function! CreateID(word1, word2) abort` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n\nReturns:\nchar*: An ID formed by reversing every other character of the second word and combining it with the first word.\n\nExample:\n>>> create_id('fish', 'cat')\n    'ftiasch'\n", "level": "middle"}
{"task_id": "VimScript/19", "prompt": "\n\" Counts the number of different permutation schemes for a binary string of length n,\n\" where the number of '1's is m and the number of '0's is n - m.\n\" Parameters:\n\" - n (int): Length of the binary string.\n\" - m (int): Number of '1's in the binary string.\n\" Returns:\n\" int: The total number of different permutation schemes.\nfunction! CountPermutationsOfBinaryString(n, m) abort", "canonical_solution": "let l:numerator = 1\n    let l:denominator = 1\n    let l:i = 0\n  \n    if (a:n + a:m) % 2 == 1\n      return 0\n    elseif a:n == a:m\n      return 1\n    endif\n  \n    for l:i in range(1, (a:n - a:m) / 2)\n      let l:numerator = l:numerator * (a:n - l:i + 1)\n      let l:denominator = l:denominator * l:i\n      \" Reduce the fraction at each step to prevent overflow\n      if l:numerator % l:denominator == 0\n        let l:numerator = l:numerator / l:denominator\n        let l:denominator = 1\n      endif\n    endfor\n  \n    return l:numerator  \" This is now C(n, (n-m)/2)\n  endfunction", "test": "function! TestCountPermutationsOfBinaryString()\n    if assert_equal(CountPermutationsOfBinaryString(2, 0), 2) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(2, 1), 0) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(3, 0), 0) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(3, 1), 3) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(3, 2), 0) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(30, 2), 145422675) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(4, 2), 4) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(5, 5), 1) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(33, 17), 13884156) | cq | endif\n    if assert_equal(CountPermutationsOfBinaryString(1000, 1000), 1) | cq | endif\n    \" Add more test cases if necessary\nendfunction\n\ncall TestCountPermutationsOfBinaryString()\nexit(0)", "entry_point": "CountPermutationsOfBinaryString", "signature": "function! CountPermutationsOfBinaryString(n, m) abort", "docstring": "Counts the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\nReturns:\nint: The total number of different permutation schemes.", "instruction": "Write a VimScript function `function! CountPermutationsOfBinaryString(n, m) abort` to solve the following problem:\nCounts the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\nReturns:\nint: The total number of different permutation schemes.", "level": "hard"}
{"task_id": "VimScript/20", "prompt": "\n\" Answer the following questions by providing the option A, B, C, or D for each.\n\" Question 1:\n\" Constants like 1e6 belong to which data type?\n\"     A. unsigned int\n\"     B. int\n\"     C. float\n\"     D. double\n\" Question 2:\n\" Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n\"     A. int\n\"     B. long long\n\"     C. double\n\"     D. None of the above\n\" Question 3:\n\" Which statement about left values in expressions is incorrect?\n\"     A. Variable name expressions are left values.\n\"     B. Increment operation requires the operand to be a left value.\n\"     C. Pointer dereference expressions are left values.\n\"     D. Prefix increment operation expressions are left values.\n\" Question 4:\n\" Which statement about functions is incorrect?\n\"     A. Formal parameters of a function are local variables.\n\"     B. Local variables are allocated space in the stack.\n\"     C. The function type is the same as the return value type.\n\"     D. A function can call itself from within its body.\n\" Question 5:\n\" Which statement about pointers is incorrect?\n\"     A. Subtracting two pointers equals the difference in their address values.\n\"     B. Pointer dereference involves resolving based on the pointer's type.\n\"     C. int *p[4], p is an array of int pointers.\n\"     D. Function names can be assigned to function pointers.\n\" You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\nfunction! AnswerQuestions()", "canonical_solution": "return \"DDDBA\"\nendfunction", "test": "function! TestAnswerQuestions()\n    let expected_answers = \"DDDBA\"\n    let result_answers = AnswerQuestions()\n    if assert_equal(expected_answers, result_answers) | cq | endif\nendfunction\n\ncall TestAnswerQuestions()\nexit(0)", "entry_point": "AnswerQuestions", "signature": "function! AnswerQuestions()", "docstring": "Answer the following questions by providing the option A, B, C, or D for each.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "instruction": "Write a VimScript function `function! AnswerQuestions()` to solve the following problem:\nAnswer the following questions by providing the option A, B, C, or D for each.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "level": "easy"}
{"task_id": "VimScript/21", "prompt": "\n\" The task is to determine if it is possible to assemble the wooden squares from n buckets,\n\" where each bucket contains a_i squares with a side length of 1, into a single larger square.\n\" Input: length of list, array of numbers\n\" Example\n\"     >>> Is_Square(1, [9])\n\"     1\n\n\nfunction! Is_Square(length, squares)", "canonical_solution": "    let sum = 0\n    for i in range(a:length)\n        let sum += a:squares[i]\n    endfor\n    let root = float2nr(sqrt(sum))\n     echo root * root == sum\n    return root * root == sum\nendfunction", "test": "function! TestIsSquare()\n    if assert_equal(Is_Square(1, [9]), 1) | cq | endif\n    if assert_equal(Is_Square(2, [14, 2]), 1) | cq | endif\n    if assert_equal(Is_Square(2, [7, 7]), 0) | cq | endif\n    if assert_equal(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]), 0) | cq | endif\n    if assert_equal(Is_Square(6, [1, 3, 5, 7, 9, 11]), 1) | cq | endif\n    if assert_equal(Is_Square(4, [2, 2, 2, 2]), 0) | cq | endif\n    \n    \" Additional test cases\n    if assert_equal(Is_Square(3, [4, 5, 6]), 0) | cq | endif\n    if assert_equal(Is_Square(4, [16, 9, 4, 1]), 0) | cq | endif\n    if assert_equal(Is_Square(5, [1, 1, 1, 1, 1]), 0) | cq | endif\n    if assert_equal(Is_Square(2, [25, 25]), 0) | cq | endif\n    if assert_equal(Is_Square(3, [10, 10, 5]), 1) | cq | endif\n\nendfunction\n\ncall TestIsSquare()\nexit(0)", "entry_point": "Is_Square", "signature": "function! Is_Square(length, squares)", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\nExample\n    >>> Is_Square(1, [9])\n    1\n", "instruction": "Write a VimScript function `function! Is_Square(length, squares)` to solve the following problem:\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\nExample\n    >>> Is_Square(1, [9])\n    1\n", "level": "easy"}
{"task_id": "VimScript/22", "prompt": "\n\" Given integers c and d, where a + b = c and a * b = d, this function computes\n\" the possible value of a (a <= b). If there are multiple pairs (a, b) that satisfy\n\" the conditions, it outputs the pair with the smallest a. If such a pair does not\n\" exist, it returns -1.\n\" \n\" Parameters:\n\"   - c (int): The sum of a and b.\n\"   - d (int): The product of a and b.\n\"\n\" Returns:\n\"   - int: A possible value of a, or -1 if no valid values are found.\n\"\n\" Examples:\n\"   >>> FindIntegers(7, 11)\n\"   -1\nfunction! FindIntegers(c, d)", "canonical_solution": "let i = 0\n    while i <= a:c / 2\n        if i * (a:c - i) == a:d\n            return i\n        endif\n        let i += 1\n    endwhile\n    return -1 \" Return -1 if no valid pairs (a, b) are found.\nendfunction", "test": "function! TestFindIntegers()\n    if assert_equal(FindIntegers(5, 6), 2) | cq | endif\n    if assert_equal(FindIntegers(6, 9), 3) | cq | endif\n    if assert_equal(FindIntegers(7, 12), 3) | cq | endif\n    if assert_equal(FindIntegers(7, 11), -1) | cq | endif\n    if assert_equal(FindIntegers(9, 8), 1) | cq | endif\n    if assert_equal(FindIntegers(10, 25), 5) | cq | endif\n    if assert_equal(FindIntegers(10000, 8765), -1) | cq | endif\nendfunction\n\ncall TestFindIntegers()\nexit(0)", "entry_point": "FindIntegers", "signature": "function! FindIntegers(c, d)", "docstring": "Given integers c and d, where a + b = c and a * b = d, this function computes the possible value of a (a <= b). If there are multiple pairs (a, b) that satisfy the conditions, it outputs the pair with the smallest a. If such a pair does not exist, it returns -1.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  - int: A possible value of a, or -1 if no valid values are found.\n\nExamples:\n  >>> FindIntegers(7, 11)\n  -1", "instruction": "Write a VimScript function `function! FindIntegers(c, d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, this function computes the possible value of a (a <= b). If there are multiple pairs (a, b) that satisfy the conditions, it outputs the pair with the smallest a. If such a pair does not exist, it returns -1.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  - int: A possible value of a, or -1 if no valid values are found.\n\nExamples:\n  >>> FindIntegers(7, 11)\n  -1", "level": "easy"}
{"task_id": "VimScript/23", "prompt": "\n\" Count the number of acute-angled triangles that can be\n\" formed by selecting any 3 edges out of a given set of edges.\n\"\n\" Args:\n\" - edges: A list of integers representing the lengths of the edges.\n\"\n\" Returns:\n\" int: The count of distinct acute-angled triangles that can be formed.\n\"\n\" Examples:\n\" >>> CountAcuteTriangles([1, 1, 1, 1])\n\" 4\nfunction! CountAcuteTriangles(edges)", "canonical_solution": "let sum = 0\n    let edges = sort(a:edges, 'n')\n    let edges_count = len(edges)\n    \" echo edges\n    for i in range(edges_count - 2)\n        for j in range(i + 1, edges_count - 1 - 1)\n            for k in range(j + 1, edges_count - 1)\n                let x = edges[i]\n                let y = edges[j]\n                let z = edges[k]\n                \" echo i . ',' . j . ',' . k\n                if x + y > z && x * x + y * y > z * z\n                    let sum += 1\n                    \" echo sum\n                endif\n            endfor\n        endfor\n    endfor\n\n    return sum\nendfunction", "test": "function! TestCountAcuteTriangles()\n    if assert_equal(CountAcuteTriangles([1, 1, 1, 1]), 4) | cq | endif\n    if assert_equal(CountAcuteTriangles([1, 2, 3]), 0) | cq | endif\n    \" Additional tests to ensure correctness\n    if assert_equal(CountAcuteTriangles([3, 4, 7, 5, 10]), 0) | cq | endif\n    if assert_equal(CountAcuteTriangles([6, 8, 10, 5, 5, 5]), 4) | cq | endif\nendfunction\n\ncall TestCountAcuteTriangles()\nexit(0)", "entry_point": "CountAcuteTriangles", "signature": "function! CountAcuteTriangles(edges)", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges: A list of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> CountAcuteTriangles([1, 1, 1, 1])\n4\n", "instruction": "Write a VimScript function `function! CountAcuteTriangles(edges)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges: A list of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> CountAcuteTriangles([1, 1, 1, 1])\n4\n", "level": "hard"}
{"task_id": "VimScript/24", "prompt": "\n\" Reads an integer and a character, then returns them as a formatted string\n\" separated by a comma.\n\" Parameters:\n\" - integer_value (int): The input integer.\n\" - char_value (char): The input character.\n\" Returns:\n\" - A string containing the integer and character separated by a comma.\n\" Example:\n\" >>> ProcessIntegerAndChar(234,'H')\n\" '234,H'\nfunction! ProcessIntegerAndChar(integer_value, char_value)", "canonical_solution": "let result = a:integer_value . ',' . a:char_value\n    return result\nendfunction", "test": "function! TestProcessIntegerAndChar()\n    \" Test 1\n    if assert_equal('234,H', ProcessIntegerAndChar(234, 'H')) | cq | endif\n    \" Additional tests can be added here with different input values\n    \" Test 2\n    if assert_equal('123,A', ProcessIntegerAndChar(123, 'A')) | cq | endif\n    \" Test 3\n    if assert_equal('0,Z', ProcessIntegerAndChar(0, 'Z')) | cq | endif\nendfunction\n\ncall TestProcessIntegerAndChar()\nexit(0)", "entry_point": "ProcessIntegerAndChar", "signature": "function! ProcessIntegerAndChar(integer_value, char_value)", "docstring": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- A string containing the integer and character separated by a comma.\nExample:\n>>> ProcessIntegerAndChar(234,'H')\n'234,H'", "instruction": "Write a VimScript function `function! ProcessIntegerAndChar(integer_value, char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- A string containing the integer and character separated by a comma.\nExample:\n>>> ProcessIntegerAndChar(234,'H')\n'234,H'", "level": "easy"}
{"task_id": "VimScript/25", "prompt": "\n\" Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\" Parameters:\n\" text (str): The input text to be processed.\n\"\n\" Returns:\n\" str: The transformed text with characters shifted by 5 positions.\n\" Example\n\" >>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"     \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\nfunction! ShiftCharacters(text)", "canonical_solution": "let l:len = len(a:text)\n    let l:result = ''\n    for l:i in range(l:len)\n        let l:char = a:text[l:i]\n        if l:char >=# 'A' && l:char <=# 'E'\n            let l:result .= nr2char(char2nr(l:char) + 21)\n        elseif l:char >=# 'F' && l:char <=# 'Z'\n            let l:result .= nr2char(char2nr(l:char) - 5)\n        else\n            let l:result .= l:char\n        endif\n    endfor\n    return l:result\nendfunction", "test": "function! TestShiftCharacters()\n    let test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\"\n    let test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\"\n    let test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\"\n\n    if assert_equal(ShiftCharacters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") | cq | endif\n    if assert_equal(ShiftCharacters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") | cq | endif\n    if assert_equal(ShiftCharacters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") | cq | endif\n    \" echo \"All tests passed!\"\nendfunction\n\ncall TestShiftCharacters()\n\nexit(0)", "entry_point": "ShiftCharacters", "signature": "function! ShiftCharacters(text)", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\nParameters:\n- text (str): The input text to be processed.\n\nReturns:\n- str: The transformed text with characters shifted by 5 positions.\nExample:\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "instruction": "Write a VimScript function `function! ShiftCharacters(text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\nParameters:\n- text (str): The input text to be processed.\n\nReturns:\n- str: The transformed text with characters shifted by 5 positions.\nExample:\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "level": "middle"}
{"task_id": "VimScript/26", "prompt": "\n\" Classify the integer x based on the following method:\n\" If x is a single-digit number, x belongs to its own class.\n\" Otherwise, sum the digits of x, get a new x, and iterate until the\n\" class is determined.\n\" Parameters:\n\" - x (string): The integer to be classified as a string.\n\"   Returns:\n\"   int: The class to which the integer x belongs.\n\" Example:\n\" >>> echo ClassifyInteger('24')\n\" 6\nfunction! ClassifyInteger(x) abort", "canonical_solution": "let n = 0\n    for i in range(len(a:x))\n        let n += str2nr(a:x[i])\n    endfor\n    while n > 9\n        let t = n\n        let a = 0\n        while t\n            let a += t % 10\n            let t = t / 10\n        endwhile\n        let n = a\n    endwhile\n    return n\nendfunction", "test": "function! TestClassifyInteger() abort\n    if assert_equal(ClassifyInteger('24'), 6) | cq | endif\n    if assert_equal(ClassifyInteger('39'), 3) | cq | endif\n    if assert_equal(ClassifyInteger('123456789'), 9) | cq | endif\n    if assert_equal(ClassifyInteger('123456789012345678901234567890'), 9) | cq | endif\n    if assert_equal(ClassifyInteger('12345'), 6) | cq | endif\n    if assert_equal(ClassifyInteger('999999999'), 9) | cq | endif\nendfunction\n\ncall TestClassifyInteger()\nexit(0)", "entry_point": "ClassifyInteger", "signature": "function! ClassifyInteger(x) abort", "docstring": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the\nclass is determined.\nParameters:\n- x (string): The integer to be classified as a string.\n  Returns:\n  int: The class to which the integer x belongs.\nExample:\n>>> echo ClassifyInteger('24')\n6", "instruction": "Write a VimScript function `function! ClassifyInteger(x) abort` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the\nclass is determined.\nParameters:\n- x (string): The integer to be classified as a string.\n  Returns:\n  int: The class to which the integer x belongs.\nExample:\n>>> echo ClassifyInteger('24')\n6", "level": "easy"}
{"task_id": "VimScript/27", "prompt": "\n\" Transforms the case of a given letter.\n\" Parameters:\n\" - letter (char): The input letter to be transformed.\n\" Returns:\n\" - char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n\" and if the input is uppercase, it returns the lowercase version.\n\" Example:\n\" >>> transform_letter_case('b')\n\"     'Z'\nfunction! TransformLetterCase(letter)", "canonical_solution": "let l:ord_letter = char2nr(a:letter)\n    if l:ord_letter >= char2nr('A') && l:ord_letter <= char2nr('Z')\n        return nr2char(l:ord_letter + char2nr('a') - char2nr('A'))\n    elseif l:ord_letter >= char2nr('a') && l:ord_letter <= char2nr('z')\n        return nr2char(l:ord_letter + char2nr('A') - char2nr('a'))\n    else\n        \" Non-alphabetic characters are returned unchanged\n        return a:letter\n    endif\nendfunction", "test": "function! TestTransformLetterCase()\n    if assert_equal(TransformLetterCase('b'), 'B') | cq | endif\n    if assert_equal(TransformLetterCase('B'), 'b') | cq | endif\n    if assert_equal(TransformLetterCase('z'), 'Z') | cq | endif\n    if assert_equal(TransformLetterCase('Z'), 'z') | cq | endif\n    if assert_equal(TransformLetterCase('m'), 'M') | cq | endif\n    if assert_equal(TransformLetterCase('M'), 'm') | cq | endif\n    if assert_equal(TransformLetterCase('1'), '1') | cq | endif\n    if assert_equal(TransformLetterCase('!'), '!') | cq | endif\nendfunction\n\ncall TestTransformLetterCase()\nexit(0)", "entry_point": "TransformLetterCase", "signature": "function! TransformLetterCase(letter)", "docstring": "Transforms the case of a given letter.\nParameters:\n- letter (char): The input letter to be transformed.\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\nExample:\n>>> transform_letter_case('b')\n     'Z'", "instruction": "Write a VimScript function `function! TransformLetterCase(letter)` to solve the following problem:\nTransforms the case of a given letter.\nParameters:\n- letter (char): The input letter to be transformed.\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\nExample:\n>>> transform_letter_case('b')\n     'Z'", "level": "middle"}
{"task_id": "VimScript/28", "prompt": "\n\" Display the ASCII information for a given character.\n\" Parameters:\n\" - character: The input character for which ASCII information is to be displayed.\n\" Returns:\n\" - ASCII code associated with the input character\n\" Example:\n\" >>> display_ascii_info('A')\n\"     65\nfunction! DisplayAsciiInfo(character)", "canonical_solution": "return char2nr(a:character)\nendfunction", "test": "function! TestDisplayAsciiInfo()\n    \" Replace `| cq |` with `| endif` as `cq` will quit Vim with an error code which is not the desired behavior in a test function.\n    \" Remove exit(0) as it's not needed or appropriate in the context of Vimscript.\n    \" The tests should not end Vim execution but should simply report success or failure.\n    if assert_equal(DisplayAsciiInfo('A'), 65) | cq |endif\n    if assert_equal(DisplayAsciiInfo('B'), 66) | cq |endif\n    if assert_equal(DisplayAsciiInfo('0'), 48) | cq |endif\n    if assert_equal(DisplayAsciiInfo(' '), 32) | cq |endif\n    \" echo \"All tests passed.\"\nendfunction\n\ncall TestDisplayAsciiInfo()\nexit(0)", "entry_point": "DisplayAsciiInfo", "signature": "function! DisplayAsciiInfo(character)", "docstring": "Display the ASCII information for a given character.\nParameters:\n- character: The input character for which ASCII information is to be displayed.\nReturns:\n- ASCII code associated with the input character\nExample:\n>>> display_ascii_info('A')\n    65\n", "instruction": "Write a VimScript function `function! DisplayAsciiInfo(character)` to solve the following problem:\nDisplay the ASCII information for a given character.\nParameters:\n- character: The input character for which ASCII information is to be displayed.\nReturns:\n- ASCII code associated with the input character\nExample:\n>>> display_ascii_info('A')\n    65\n", "level": "easy"}
{"task_id": "VimScript/29", "prompt": "\n\" Evaluate the grade for an input integer.\n\" Parameters:\n\" - score (int): The integer score to be evaluated.\n\" Returns:\n\"     char: The grade corresponding to the input score.\n\"           If the score is between 90 and 100 (inclusive), returns 'A'.\n\"           Otherwise, returns 'B'.\n\" Example\n\" >>> evaluate_integer_grade(90)\n\" A\nfunction! EvaluateIntegerGrade(score)", "canonical_solution": "return ((a:score >= 90 && a:score <= 100) ? 'A' : 'B')\nendfunction", "test": "function! TestEvaluateIntegerGrade()\n    if assert_equal('A', EvaluateIntegerGrade(90)) | cq | endif\n    if assert_equal('B', EvaluateIntegerGrade(89)) | cq | endif\n    if assert_equal('A', EvaluateIntegerGrade(95)) | cq | endif\n    if assert_equal('A', EvaluateIntegerGrade(100)) | cq | endif\n    if assert_equal('B', EvaluateIntegerGrade(101)) | cq | endif\nendfunction\n\ncall TestEvaluateIntegerGrade()\nexit(0)", "entry_point": "EvaluateIntegerGrade", "signature": "function! EvaluateIntegerGrade(score)", "docstring": "Evaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n          If the score is between 90 and 100 (inclusive), returns 'A'.\n          Otherwise, returns 'B'.\nExample\n>>> evaluate_integer_grade(90)\nA", "instruction": "Write a VimScript function `function! EvaluateIntegerGrade(score)` to solve the following problem:\nEvaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n          If the score is between 90 and 100 (inclusive), returns 'A'.\n          Otherwise, returns 'B'.\nExample\n>>> evaluate_integer_grade(90)\nA", "level": "easy"}
{"task_id": "VimScript/30", "prompt": "\n\" Checks if a three-character string has exactly two characters that are the same.\n\"\n\" Args:\n\"     s (String): The three-character string to be checked.\n\"\n\" Returns:\n\"     String: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\"     Examples:\n\"     >>> CheckTwoEqualDigits('112')\n\"     Yes\nfunction! CheckTwoEqualDigits(s)", "canonical_solution": "if (a:s[0] ==# a:s[1] && a:s[1] !=# a:s[2]) ||\n                \\ (a:s[0] ==# a:s[2] && a:s[0] !=# a:s[1]) ||\n                \\ (a:s[1] ==# a:s[2] && a:s[0] !=# a:s[1])\n        return 'Yes'\n    else\n        return 'No'\n    endif\nendfunction", "test": "function! TestCheckTwoEqualDigits()\n    if assert_equal(CheckTwoEqualDigits('112'), 'Yes') | cq | endif\n    if assert_equal(CheckTwoEqualDigits('123'), 'No') | cq | endif\n    if assert_equal(CheckTwoEqualDigits('232'), 'Yes') | cq | endif\n    if assert_equal(CheckTwoEqualDigits('444'), 'No') | cq | endif       \" All three characters are equal, not two\n    if assert_equal(CheckTwoEqualDigits('121'), 'Yes') | cq | endif\n\n    \" Additional test cases to cover more scenarios\n    if assert_equal(CheckTwoEqualDigits('787'), 'Yes') | cq | endif\n    if assert_equal(CheckTwoEqualDigits('999'), 'No') | cq | endif       \" All three characters are equal\n    if assert_equal(CheckTwoEqualDigits('890'), 'No') | cq | endif\n    if assert_equal(CheckTwoEqualDigits('556'), 'Yes') | cq | endif\n    if assert_equal(CheckTwoEqualDigits('353'), 'Yes') | cq | endif      \" No two characters are equal\nendfunction\n\ncall TestCheckTwoEqualDigits()\nexit(0)", "entry_point": "CheckTwoEqualDigits", "signature": "function! CheckTwoEqualDigits(s)", "docstring": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (String): The three-character string to be checked.\n\nReturns:\n    String: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    Examples:\n    >>> CheckTwoEqualDigits('112')\n    Yes", "instruction": "Write a VimScript function `function! CheckTwoEqualDigits(s)` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (String): The three-character string to be checked.\n\nReturns:\n    String: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    Examples:\n    >>> CheckTwoEqualDigits('112')\n    Yes", "level": "easy"}
{"task_id": "VimScript/31", "prompt": "\n\" Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\n\" For example:\n\" >>> minRoundsToSameChar(\"aab\")\n\"     1\nfunction! MinRoundsToSameChar(s)", "canonical_solution": "let charCount = repeat([0], 26)\n    for c in split(a:s, '\\zs')\n        let charCount[char2nr(c) - char2nr('a')] += 1\n    endfor\n    let maxCount = 0\n    for i in charCount\n        if i != 0\n            let maxCount += 1\n        endif\n    endfor\n    return maxCount - 1\nendfunction", "test": "function! TestMinRoundsToSameChar()\n    if assert_equal(MinRoundsToSameChar(\"aab\"), 1) | cq | endif\n    if assert_equal(MinRoundsToSameChar(\"abc\"), 2) | cq | endif\n    if assert_equal(MinRoundsToSameChar(\"aaa\"), 0) | cq | endif\n    if assert_equal(MinRoundsToSameChar(\"abab\"), 1) | cq | endif\n    if assert_equal(MinRoundsToSameChar(\"zzzzz\"), 0) | cq | endif\nendfunction\n\ncall TestMinRoundsToSameChar()\nexit(0)", "entry_point": "MinRoundsToSameChar", "signature": "function! MinRoundsToSameChar(s)", "docstring": "Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n>>> minRoundsToSameChar(\"aab\")\n    1\n", "instruction": "Write a VimScript function `function! MinRoundsToSameChar(s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n>>> minRoundsToSameChar(\"aab\")\n    1\n", "level": "easy"}
{"task_id": "VimScript/32", "prompt": "\n\" Given a sequence of n events, each occurring with a periodicity of a_i years,\n\" the problem is to find the year Y_n when the n-th event occurs. The countdown\n\" for event i+1 only starts the year following the occurrence of event i.\n\" Example:\n\" >>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n\"     36\nfunction! ApocalypseYear(n, signs)", "canonical_solution": "let year = 0\n    let i = 0\n    while i < a:n\n        let period = a:signs[i]\n        let nextOccurrence = (year / period + 1) * period\n        let year = nextOccurrence\n        let i += 1\n    endwhile\n    return year\nendfunction", "test": "function! TestApocalypseYear()\n    if assert_equal(ApocalypseYear(6, [3, 2, 4, 5, 9, 18]), 36) | cq | endif\n    if assert_equal(ApocalypseYear(5, [1, 2, 3, 4, 5]), 5) | cq | endif\n    if assert_equal(ApocalypseYear(5, [1, 1, 1, 1, 1]), 5) | cq | endif\n    if assert_equal(ApocalypseYear(6, [50, 30, 711, 200, 503, 1006]), 2012) | cq | endif\n    if assert_equal(ApocalypseYear(2, [1, 2]), 2) | cq | endif\n    if assert_equal(ApocalypseYear(3, [3, 1, 2]), 6) | cq | endif\n    if assert_equal(ApocalypseYear(3, [2, 3, 4]), 4) | cq | endif\n    if assert_equal(ApocalypseYear(4, [1, 2, 3, 4]), 4) | cq | endif\n    if assert_equal(ApocalypseYear(4, [5, 7, 11, 13]), 13) | cq | endif\n    if assert_equal(ApocalypseYear(5, [2, 2, 2, 2, 2]), 10) | cq | endif\n    if assert_equal(ApocalypseYear(3, [6, 10, 15]), 15) | cq | endif\n    if assert_equal(ApocalypseYear(3, [4, 6, 14]), 14) | cq | endif\n    if assert_equal(ApocalypseYear(4, [50, 30, 711, 200]), 800) | cq | endif\n    if assert_equal(ApocalypseYear(6, [1, 1, 1, 1, 1, 1]), 6) | cq | endif\n    if assert_equal(ApocalypseYear(2, [1000000, 999999]), 1999998) | cq | endif\nendfunction\n\ncall TestApocalypseYear()\nexit(0)", "entry_point": "ApocalypseYear", "signature": "function! ApocalypseYear(n, signs)", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Y_n when the n-th event occurs. The countdown\nfor event i+1 only starts the year following the occurrence of event i.\nExample:\n>>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36\n", "instruction": "Write a VimScript function `function! ApocalypseYear(n, signs)` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Y_n when the n-th event occurs. The countdown\nfor event i+1 only starts the year following the occurrence of event i.\nExample:\n>>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36\n", "level": "easy"}
{"task_id": "VimScript/33", "prompt": "\n\" This problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When\n\" calculating x \u2295 y, if x is not a multiple of y, the result is the remainder\n\" of x divided by y. Otherwise, divide x by y repeatedly until x is no longer\n\" a multiple of y, denoting the final value as x'. Then the result is the\n\" remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4.\n\" Given a prime number p, there will be several queries. For each query, an\n\" integer n is given, and you need to compute the value of n! \u2295 p, where n! is\n\" the factorial of n, i.e., the product of all positive integers less than or\n\" equal to n.\n\"    >>> newModuloFactorial(3, 7)\n\"    6\nfunction! NewModuloFactorial(n, p)", "canonical_solution": "let pj = [1, 1] + repeat([0], a:p - 2)\n    for i in range(2, a:p - 1)\n        let pj[i] = i * pj[i - 1] % a:p\n    endfor\n\n    let ans = 1\n    let n_var = a:n\n    while n_var\n        let ans = ans * pj[n_var % a:p] % a:p\n        if (n_var / a:p) % 2 == 1\n            let ans = a:p - ans\n        endif\n        let n_var = n_var / a:p\n    endwhile\n    return ans\nendfunction", "test": "function! TestNewModuloFactorial()\n    if assert_equal(NewModuloFactorial(3, 7), 6) | cq | endif\n    if assert_equal(NewModuloFactorial(10, 3), 1) | cq | endif\n    if assert_equal(NewModuloFactorial(11, 7), 4) | cq | endif\n    if assert_equal(NewModuloFactorial(45, 7), 1) | cq | endif\n    if assert_equal(NewModuloFactorial(14, 7), 2) | cq | endif\n    if assert_equal(NewModuloFactorial(1919, 10007), 3152) | cq | endif\n    if assert_equal(NewModuloFactorial(810, 10007), 3679) | cq | endif\n    if assert_equal(NewModuloFactorial(3, 7), 6) | cq | endif\n    if assert_equal(NewModuloFactorial(10, 3), 1) | cq | endif\n    if assert_equal(NewModuloFactorial(1, 2), 1) | cq | endif\n    if assert_equal(NewModuloFactorial(5, 11), 10) | cq | endif\n    if assert_equal(NewModuloFactorial(6, 13), 5) | cq | endif\n    if assert_equal(NewModuloFactorial(8, 17), 13) | cq | endif\n    if assert_equal(NewModuloFactorial(15, 19), 16) | cq | endif\n    if assert_equal(NewModuloFactorial(21, 23), 1) | cq | endif\n    if assert_equal(NewModuloFactorial(30, 29), 28) | cq | endif\n    if assert_equal(NewModuloFactorial(100, 101), 100) | cq | endif\nendfunction\n\ncall TestNewModuloFactorial()\nexit(0)", "entry_point": "NewModuloFactorial", "signature": "function! NewModuloFactorial(n, p)", "docstring": "This problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4. Given a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.    >>> newModuloFactorial(3, 7)    6", "instruction": "Write a VimScript function `function! NewModuloFactorial(n, p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"\u2295\". When calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4\u22955=4, 20\u22955=4, 100\u22955=4. Given a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! \u2295 p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.    >>> newModuloFactorial(3, 7)    6", "level": "middle"}
{"task_id": "VimScript/34", "prompt": "\n\" You are given an array a of n integers. You can perform at most one operation where you select three\n\" integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost\n\" of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\" Example\n\" >>> makeEqualAgain(3, [1, 2, 1])\n\"     1\nfunction! MakeEqualAgain(n, a)", "canonical_solution": "let j = 0\n    let p = 1\n    let q = 0\n    let c = 0\n    let d = 0\n    let k = a:n\n    for p in range(1, k)\n        if p == k\n            break\n        endif\n        if a:a[p] != a:a[p - 1]\n            break\n        endif\n    endfor\n    for q in range(k - 1, p-1, -1)\n        if q == p\n            break\n        end\n        if a:a[q] != a:a[p - 1]\n            break\n        endif\n    endfor\n    for d in range(k - 2, -1, -1)\n        if d == -1\n            break\n        endif\n        if a:a[d] != a:a[d + 1]\n            break\n        endif\n    endfor\n    for c in range(0, d)\n        if c == d\n            break\n        endif\n        if a:a[c] != a:a[c + 1]\n            break\n        endif\n    endfor\n    \" echo '[p, q, c, d] = [' . p . ', ' . q . ', ' . c . ', ' . d . ']'\n    if q - p + 1 < d - c + 1\n        return q - p + 1\n    else\n        return d - c + 1\n    endif\nendfunction", "test": "function! TestMakeEqualAgain() abort\n    if assert_equal(MakeEqualAgain(3, [1, 2, 1]), 1) | cq | endif\n    if assert_equal(MakeEqualAgain(5, [5, 5, 1, 5, 5]), 1) | cq | endif\n    if assert_equal(MakeEqualAgain(4, [1, 1, 1, 1]), 0) | cq | endif\n    if assert_equal(MakeEqualAgain(6, [2, 2, 2, 3, 2, 2]), 1) | cq | endif\n    if assert_equal(MakeEqualAgain(1, [1]), 0) | cq | endif\n    if assert_equal(MakeEqualAgain(2, [1, 2]), 1) | cq | endif\n    if assert_equal(MakeEqualAgain(4, [1, 2, 2, 1]), 2) | cq | endif\n    if assert_equal(MakeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]), 2) | cq | endif\n    if assert_equal(MakeEqualAgain(6, [5, 4, 4, 4, 5, 5]), 3) | cq | endif\n    if assert_equal(MakeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]), 5) | cq | endif\n    if assert_equal(MakeEqualAgain(6, [1,2,3,4,5,1]), 4) | cq | endif\n    if assert_equal(MakeEqualAgain(7, [1,1,1,1,1,1,1]), 0) | cq | endif\n    if assert_equal(MakeEqualAgain(8, [8,8,8,1,2,8,8,8]), 2) | cq | endif\n    if assert_equal(MakeEqualAgain(3, [1,2,3]), 2) | cq | endif\n    if assert_equal(MakeEqualAgain(7, [4,3,2,7,1,1,3]), 6) | cq | endif\n    if assert_equal(MakeEqualAgain(9, [9,9,2,9,2,5,5,5,3]), 7) | cq | endif\nendfunction\n\ncall TestMakeEqualAgain()\nexit(0)", "entry_point": "MakeEqualAgain", "signature": "function! MakeEqualAgain(n, a)", "docstring": "You are given an array a of n integers. You can perform at most one operation where you select three\nintegers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost\nof (j - i + 1). Find the minimum cost to make all elements in the array equal.\nExample\n>>> makeEqualAgain(3, [1, 2, 1])\n    1\n", "instruction": "Write a VimScript function `function! MakeEqualAgain(n, a)` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three\nintegers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost\nof (j - i + 1). Find the minimum cost to make all elements in the array equal.\nExample\n>>> makeEqualAgain(3, [1, 2, 1])\n    1\n", "level": "hard"}
{"task_id": "VimScript/35", "prompt": "\n\" Given a sequence of N piles of stones numbered from 1 to N, with each pile containing\n\" a positive number of stones, determine the winner of a game played by Charlie and Dan.\n\" Charlie goes first, and they take turns moving a positive number of stones from the\n\" leftmost non-empty pile to the adjacent right pile. The player who can only move\n\" stones in the last pile loses. Assuming both players use the best possible strategy,\n\" find out who will win the game.\n\" Example:\n\" >>> gameWinner([1, 2, 2])\n\" 'Dan'\nfunction! GameWinner(piles)", "canonical_solution": "let n = len(a:piles)\n    let firstPileStones = a:piles[0]\n\n    if n == 2 \" With only two piles, Charlie always wins.\n        return 'Charlie'\n    elseif firstPileStones == 1 \" If the first pile has only one stone, Dan wins.\n        return 'Dan'\n    else \" In all other cases, Charlie wins.\n        return 'Charlie'\n    endif\nendfunction", "test": "function! TestGameWinner()\n    if assert_equal(GameWinner([1, 2, 2]), 'Dan') | cq | endif\n    if assert_equal(GameWinner([5, 5, 5, 5, 5]), 'Charlie') | cq | endif\n    if assert_equal(GameWinner([2, 1, 2]), 'Charlie') | cq | endif\n    if assert_equal(GameWinner([3, 3, 3, 3]), 'Charlie') | cq | endif\n    if assert_equal(GameWinner([1, 1]), 'Charlie') | cq | endif\n    if assert_equal(GameWinner([2, 1]), 'Charlie') | cq | endif\n    if assert_equal(GameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), 'Dan') | cq | endif\n    if assert_equal(GameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]), 'Charlie') | cq | endif\n    if assert_equal(GameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]), 'Charlie') | cq | endif\n    if assert_equal(GameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), 'Dan') | cq | endif\nendfunction\n\ncall TestGameWinner()\nexit(0)", "entry_point": "GameWinner", "signature": "function! GameWinner(piles)", "docstring": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing\na positive number of stones, determine the winner of a game played by Charlie and Dan.\nCharlie goes first, and they take turns moving a positive number of stones from the\nleftmost non-empty pile to the adjacent right pile. The player who can only move\nstones in the last pile loses. Assuming both players use the best possible strategy,\nfind out who will win the game.\nExample:\n>>> gameWinner([1, 2, 2])\n'Dan'", "instruction": "Write a VimScript function `function! GameWinner(piles)` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing\na positive number of stones, determine the winner of a game played by Charlie and Dan.\nCharlie goes first, and they take turns moving a positive number of stones from the\nleftmost non-empty pile to the adjacent right pile. The player who can only move\nstones in the last pile loses. Assuming both players use the best possible strategy,\nfind out who will win the game.\nExample:\n>>> gameWinner([1, 2, 2])\n'Dan'", "level": "easy"}
{"task_id": "VimScript/36", "prompt": "\n\" Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player \n\" can choose a number i and pay a cost C_i to move i steps to the right and then open the door at\n\" that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n. The task is to determine the \n\" minimum total cost required to open all doors.\n\"\n\" Example:\n\" >>> MinTotalCost(3, [1, 1, 1])\n\" 3\nfunction! MinTotalCost(n, C)", "canonical_solution": "return a:C[a:n-2] * (a:n - 1) + a:C[a:n-1]\nendfunction", "test": "function! TestMinTotalCost() abort\n    if assert_equal(MinTotalCost(5, [4, 3, 3, 3, 3]), 15) | cq | endif\n    if assert_equal(MinTotalCost(3, [1, 1, 1]), 3) | cq | endif\n    if assert_equal(MinTotalCost(4, [5, 4, 3, 2]), 11) | cq | endif\n    if assert_equal(MinTotalCost(4, [100, 99, 98, 97]), 391) | cq | endif\n    if assert_equal(MinTotalCost(6, [10, 9, 8, 7, 6, 5]), 35) | cq | endif\n    if assert_equal(MinTotalCost(7, [2, 2, 2, 2, 2, 2, 2]), 14) | cq | endif\n    if assert_equal(MinTotalCost(8, [9, 7, 7, 7, 7, 7, 7, 7]), 56) | cq | endif\n    if assert_equal(MinTotalCost(9, [3, 2, 2, 2, 2, 2, 2, 2, 2]), 18) | cq | endif\n    if assert_equal(MinTotalCost(10, [6, 5, 5, 5, 5, 5, 5, 5, 5, 5]), 50) | cq | endif\n    if assert_equal(MinTotalCost(11, [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), 11) | cq | endif\nendfunction\n\ncall TestMinTotalCost()\nexit(0)", "entry_point": "MinTotalCost", "signature": "function! MinTotalCost(n, C)", "docstring": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player \ncan choose a number i and pay a cost C_i to move i steps to the right and then open the door at\nthat position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n. The task is to determine the \nminimum total cost required to open all doors.\n\nExample:\n>>> MinTotalCost(3, [1, 1, 1])\n3\n", "instruction": "Write a VimScript function `function! MinTotalCost(n, C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player \ncan choose a number i and pay a cost C_i to move i steps to the right and then open the door at\nthat position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n. The task is to determine the \nminimum total cost required to open all doors.\n\nExample:\n>>> MinTotalCost(3, [1, 1, 1])\n3\n", "level": "easy"}
{"task_id": "VimScript/37", "prompt": "\n\"\n\" Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate\n\" the total number of handshakes that occur. Each student will shake hands with every student already in the\n\" classroom with a smaller ID number. The sequence represents the order in which students enter the\n\" classroom.\n\"\n\" Examples:\n\"    >>> countHandshakes(3, [2, 1, 0])\n\"    0\nfunction! CountHandshakes(n, order)", "canonical_solution": "let ans = 0\n    let tr = repeat([0], 10000) \" N should be defined as a constant representing the maximum possible value of n\n    for i in range(a:n)\n        let x = a:order[i] + 1 \" Convert 0-indexed to 1-indexed\n        let j = x - 1\n        while j > 0\n            let ans += tr[j]\n            let j = j - and(j, -j)\n            \" (j & -j)\n        endwhile\n        let j = x\n        while j <= a:n\n            let tr[j] += 1\n            let j += and(j, -j)\n        endwhile\n    endfor\n    return ans\nendfunction", "test": "call assert_equal(CountHandshakes(4, [2, 1, 3, 0]), 2)\ncall assert_equal(CountHandshakes(6, [0, 1, 2, 3, 4, 5]), 15)\ncall assert_equal(CountHandshakes(3, [1, 2, 0]), 1)\ncall assert_equal(CountHandshakes(4, [3, 2, 1, 0]), 0)\ncall assert_equal(CountHandshakes(4, [0, 1, 2, 3]), 6)\ncall assert_equal(CountHandshakes(6, [5, 4, 3, 2, 1, 0]), 0)\ncall assert_equal(CountHandshakes(4, [0, 2, 1, 3]), 5)\ncall assert_equal(CountHandshakes(5, [3, 1, 4, 2, 0]), 3)\ncall assert_equal(CountHandshakes(4, [1, 0, 3, 2]), 4)\ncall assert_equal(CountHandshakes(3, [2, 0, 1]), 1)\ncall assert_equal(CountHandshakes(5, [1, 3, 0, 2, 4]), 7)\ncall assert_equal(CountHandshakes(5, [4, 3, 2, 1, 0]), 0)\n\nexit(0)", "entry_point": "CountHandshakes", "signature": "function! CountHandshakes(n, order)", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate\nthe total number of handshakes that occur. Each student will shake hands with every student already in the\nclassroom with a smaller ID number. The sequence represents the order in which students enter the\nclassroom.\n\nExamples:\n    >>> countHandshakes(3, [2, 1, 0])\n    0\n", "instruction": "Write a VimScript function `function! CountHandshakes(n, order)` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate\nthe total number of handshakes that occur. Each student will shake hands with every student already in the\nclassroom with a smaller ID number. The sequence represents the order in which students enter the\nclassroom.\n\nExamples:\n    >>> countHandshakes(3, [2, 1, 0])\n    0\n", "level": "middle"}
{"task_id": "VimScript/38", "prompt": "\n\" Given n positive integers representing the count of each number from 1 to n, \n\" find the maximum sum of the mode (most frequent element) for all prefixes of \n\" a sequence constructed from these numbers. The mode is the largest number among \n\" the most frequent elements in a sequence. A sequence that reaches its maximum value \n\" is (3,2,3,1,2,2) when called with maxModeSum(3, [1, 3, 2]) which returns 17.\nfunction! MaxModeSum(n, counts)", "canonical_solution": "let ans = 0\n    let mx = 0\n    let f = repeat([0], 100001)\n    for i in range(a:n, 1, -1)\n        while mx < a:counts[i - 1]\n            let mx += 1\n            let f[mx] = f[mx - 1] + i\n        endwhile\n        let ans += f[a:counts[i - 1]]\n    endfor\n    return ans\nendfunction", "test": "if assert_equal(MaxModeSum(3, [1, 3, 2]), 17) | cq | endif\nif assert_equal(MaxModeSum(4, [4, 1, 2, 3]), 37) | cq | endif\nif assert_equal(MaxModeSum(2, [1, 1]), 4) | cq | endif\nif assert_equal(MaxModeSum(5, [1, 2, 3, 4, 5]), 75) | cq | endif\nif assert_equal(MaxModeSum(1, [100000]), 100000) | cq | endif\nif assert_equal(MaxModeSum(5, [5, 3, 2, 4, 1]), 62) | cq | endif\nif assert_equal(MaxModeSum(3, [100000, 100000, 100000]), 900000) | cq | endif\nif assert_equal(MaxModeSum(3, [2, 2, 5]), 27) | cq | endif\nif assert_equal(MaxModeSum(4, [4, 4, 4, 4]), 64) | cq | endif\nif assert_equal(MaxModeSum(6, [1, 2, 3, 4, 5, 6]), 126) | cq | endif\nif assert_equal(MaxModeSum(3, [3, 1, 2]), 16) | cq | endif\n\nexit(0)", "entry_point": "MaxModeSum", "signature": "function! MaxModeSum(n, counts)", "docstring": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. A sequence that reaches its maximum value is (3,2,3,1,2,2) when called with maxModeSum(3, [1, 3, 2]) which returns 17.", "instruction": "Write a VimScript function `function! MaxModeSum(n, counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. A sequence that reaches its maximum value is (3,2,3,1,2,2) when called with maxModeSum(3, [1, 3, 2]) which returns 17.", "level": "easy"}
{"task_id": "VimScript/39", "prompt": "\n\"\n\" Given an array A of integers, the task is to calculate the sum of the XOR\n\" of all subarrays. A subarray is defined by a pair of indices (L, R) such\n\" that 1 <= L <= R <= n, where n is the size of the array. The XOR sum of\n\" a subarray is the result of XORing all elements from L to R. The final\n\" result is the sum of the XOR sums for all possible subarrays.\n\"\n\" Example cases:\n\"     >>> SumOfXorSubarrays([1, 2, 3, 4, 5], 5)\n\"     39\nfunction! SumOfXorSubarrays(A, n)", "canonical_solution": "let q = repeat([0], a:n + 1)\n    \" let w = repeat(repeat([0], 2), 121)\n    let w = []\n    for i in range(121)\n        call add(w, repeat([0], 2))\n    endfor\n    \" let w = map(copy(q), 'repeat([0], 2)')\n    let ans = 0\n\n    for i in range(1, a:n)\n        let q[i] = xor(q[i - 1] , a:A[i - 1])\n    endfor\n\n    for i in range(0, a:n)\n        for j in range(20, 0, -1)\n            let w[j][and((q[i] >> j), 1)] += 1\n        endfor\n    endfor\n\n    for i in range(0, 20)\n        let ans += w[i][0] * w[i][1] * (1 << i)\n    endfor\n\n    return ans\nendfunction", "test": "function! TestSumOfXorSubarrays()\n    if assert_equal(SumOfXorSubarrays([1, 2, 3, 4, 5], 5), 39) | cq | endif\n    if assert_equal(SumOfXorSubarrays([1, 1, 1], 3), 4) | cq | endif\n    if assert_equal(SumOfXorSubarrays([2, 3, 1], 3), 9) | cq | endif\n    if assert_equal(SumOfXorSubarrays([4, 5, 7, 9], 4), 74) | cq | endif\n    if assert_equal(SumOfXorSubarrays([0, 0, 0, 0], 4), 0) | cq | endif\n    if assert_equal(SumOfXorSubarrays([8, 8, 8, 8, 8], 5), 72) | cq | endif\n    if assert_equal(SumOfXorSubarrays([3, 6, 9, 12, 15], 5), 125) | cq | endif\n    if assert_equal(SumOfXorSubarrays([10, 20, 30, 40, 50], 5), 390) | cq | endif\n    if assert_equal(SumOfXorSubarrays([16, 16, 16, 16, 16, 16], 6), 192) | cq | endif\n    if assert_equal(SumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13], 7), 192) | cq | endif\n    if assert_equal(SumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 10), 218) | cq | endif\nendfunction\n\ncall TestSumOfXorSubarrays()\nexit 0", "entry_point": "SumOfXorSubarrays", "signature": "function! SumOfXorSubarrays(A, n)", "docstring": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays. A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array. The XOR sum of a subarray is the result of XORing all elements from L to R. The final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n     >>> SumOfXorSubarrays([1, 2, 3, 4, 5], 5)\n     39", "instruction": "Write a VimScript function `function! SumOfXorSubarrays(A, n)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays. A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array. The XOR sum of a subarray is the result of XORing all elements from L to R. The final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n     >>> SumOfXorSubarrays([1, 2, 3, 4, 5], 5)\n     39", "level": "hard"}
{"task_id": "VimScript/40", "prompt": "\n\" Given two positive integers n and k, find the number of positive integers x, where\n\" 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\n\" and b >= k. Different legal representations of the same number are counted only once.\n\" Example:\n\" >>> countPowerNumbers(99, 1)\n\"     99\nfunction! CountPowerNumbers(n, k)", "canonical_solution": "let cnt = 0\n    let x = 0\n    let mp = repeat([0], a:n + 1)\n    \n    let i = 2\n    while i * i * i <= (a:n)\n        let t = i * i\n        let m = 2\n        while t <= float2nr(a:n / i)\n            let t *= i\n            let m += 1\n            if m < a:k || mp[t]\n                continue\n            endif\n            if float2nr(sqrt(t)) * float2nr(sqrt(t)) == t\n                let x += 1\n            endif\n            let mp[t] = 1\n            let cnt += 1\n        endwhile\n        let i += 1\n    endwhile\n    if a:k == 1\n        let cnt = a:n\n    elseif a:k >= 3\n        let cnt += 1\n    else\n        let cnt += float2nr(sqrt(a:n)) - x\n    endif\n    return cnt\nendfunction", "test": "function! TestCountPowerNumbers()\n    if assert_equal(CountPowerNumbers(99, 1), 99) | cq | endif\n    if assert_equal(CountPowerNumbers(99, 3), 7) | cq | endif\n    if assert_equal(CountPowerNumbers(99, 2), 12) | cq | endif\n    if assert_equal(CountPowerNumbers(10, 1), 10) | cq | endif\n    if assert_equal(CountPowerNumbers(10, 2), 4) | cq | endif\n    if assert_equal(CountPowerNumbers(500, 1), 500) | cq | endif\n    if assert_equal(CountPowerNumbers(500, 2), 30) | cq | endif\n    if assert_equal(CountPowerNumbers(500, 3), 13) | cq | endif\n    if assert_equal(CountPowerNumbers(1000, 1), 1000) | cq | endif\n    if assert_equal(CountPowerNumbers(1000, 2), 41) | cq | endif\n    if assert_equal(CountPowerNumbers(1000, 3), 17) | cq | endif\n    if assert_equal(CountPowerNumbers(1000, 93), 1) | cq | endif\n    if assert_equal(CountPowerNumbers(50, 2), 10) | cq | endif\n    if assert_equal(CountPowerNumbers(50, 3), 5) | cq | endif\n    if assert_equal(CountPowerNumbers(2, 3), 1) | cq | endif\nendfunction\n\ncall TestCountPowerNumbers()\nexit(0)", "entry_point": "CountPowerNumbers", "signature": "function! CountPowerNumbers(n, k)", "docstring": "Given two positive integers n and k, find the number of positive integers x, where\n1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n>>> countPowerNumbers(99, 1)\n    99\n", "instruction": "Write a VimScript function `function! CountPowerNumbers(n, k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where\n1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n>>> countPowerNumbers(99, 1)\n    99\n", "level": "hard"}
{"task_id": "VimScript/41", "prompt": "\n\" Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\n\" such that the longest balanced subsequence is of length 2 * k. The result should be\n\" calculated modulo 1,000,000,007 (10^9 + 7).\n\"\n\" For example:\n\"     >>> countBalancedSubsequences(2, 2, 2)\n\"     2\nfunction! CountBalancedSubsequences(n, m, k)", "canonical_solution": "let P = 1000000007\n    \" let C = []\n    \" let mp = repeat([0], 2000)\n    \" let C = repeat(mp, 2000)\n    let C = []\n    for i in range(a:n + a:m + 4)\n        call add(C, repeat([0], a:n + a:m + 4))\n    endfor\n    for i in range(a:n + a:m + 2)\n        let C[i][0] = 1\n    endfor\n    for i in range(1, a:n + a:m + 2)\n        for j in range(1, i)\n            let C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P\n        endfor\n    endfor\n\n    \" Calculate the number of balanced subsequences.\n    if a:k > a:n || a:k > a:m\n        return 0\n    endif\n    return (C[a:n + a:m][a:k] - C[a:n + a:m][a:k - 1] + P) % P\nendfunction", "test": "call assert_equal(CountBalancedSubsequences(2, 2, 2), 2)\ncall assert_equal(CountBalancedSubsequences(3, 2, 3), 0)\ncall assert_equal(CountBalancedSubsequences(3, 2, 1), 4)\ncall assert_equal(CountBalancedSubsequences(4, 3, 2), 14)\ncall assert_equal(CountBalancedSubsequences(5, 5, 2), 35)\ncall assert_equal(CountBalancedSubsequences(6, 1, 1), 6)\ncall assert_equal(CountBalancedSubsequences(1, 6, 1), 6)\ncall assert_equal(CountBalancedSubsequences(7, 2, 2), 27)\ncall assert_equal(CountBalancedSubsequences(8, 3, 3), 110)\ncall assert_equal(CountBalancedSubsequences(10, 10, 5), 10659)\ncall assert_equal(CountBalancedSubsequences(20, 20, 10), 574221648)\ncall assert_equal(CountBalancedSubsequences(233, 233, 233), 280916397)\ncall assert_equal(CountBalancedSubsequences(233, 666, 233), 956287259)\ncall assert_equal(CountBalancedSubsequences(233, 233, 666), 0)\n\nexit(0)", "entry_point": "CountBalancedSubsequences", "signature": "function! CountBalancedSubsequences(n, m, k)", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "instruction": "Write a VimScript function `function! CountBalancedSubsequences(n, m, k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "level": "hard"}
{"task_id": "VimScript/42", "prompt": "\n\" Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its\n\" bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected\n\" number of operations to cut the paper such that the remaining area is less than k.\n\" In each operation, a line is randomly chosen that is parallel to the axes, passes through points\n\" with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or\n\" right part of the paper along this line is then discarded.\n\" The answer should be modulo 10^9+7.\n\"\n\" For example:\n\"     >>> expectedCuts(3, 3, 4)\n\"     3\nfunction! ExpectedCuts(n, m, k) abort", "canonical_solution": "let MD = 1000000007\n    let N = 10000\n    let vv = repeat([0], N * 2 + 2)\n    let ans = 1\n    let vv[1] = 1\n    for i in range(2, N * 2)\n        let vv[i] = (vv[i - MD % i] * (MD / i + 1)) % MD\n    endfor\n\n    if a:k > a:n * a:m\n        return 0\n    endif\n    for i in range(((a:k + a:m - 1) / a:m), a:n - 1)\n        let ans = (ans + vv[i + ((a:k + i - 1) / i) - 1]) % MD\n    endfor\n    for j in range(((a:k + a:n - 1) / a:n), a:m - 1)\n        let ans = (ans + vv[((a:k + j - 1) / j + j - 1)]) % MD\n    endfor\n    return ans\nendfunction", "test": "function! TestExpectedCuts() abort\n    if assert_equal(ExpectedCuts(2, 4, 10), 0) | cq | endif\n    if assert_equal(ExpectedCuts(2, 4, 8), 1) | cq | endif\n    if assert_equal(ExpectedCuts(2, 4, 2), 833333342) | cq | endif\n    if assert_equal(ExpectedCuts(2, 4, 6), 250000003) | cq | endif\n    if assert_equal(ExpectedCuts(3, 3, 4), 666666673) | cq | endif\n    if assert_equal(ExpectedCuts(5, 5, 12), 666666673) | cq | endif\n    if assert_equal(ExpectedCuts(6, 7, 20), 722222229) | cq | endif\n    if assert_equal(ExpectedCuts(8, 8, 30), 72727275) | cq | endif\n    if assert_equal(ExpectedCuts(10, 10, 50), 714285721) | cq | endif\n    if assert_equal(ExpectedCuts(1, 10, 5), 945634929) | cq | endif\n    if assert_equal(ExpectedCuts(10, 1, 5), 945634929) | cq | endif\nendfunction\n\ncall TestExpectedCuts()\nexit(0)", "entry_point": "ExpectedCuts", "signature": "function! ExpectedCuts(n, m, k) abort", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "instruction": "Write a VimScript function `function! ExpectedCuts(n, m, k) abort` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "level": "middle"}
{"task_id": "VimScript/43", "prompt": "\n\" Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n\" such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n\" dividing p into exactly k non-empty contiguous segments and sorting each segment (that is, choose k-1\n\" breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]).\n\" The result should be modulo 998244353.\n\" Example\n\" >>> countPermutations(2, 1, [1, 2])\n\"     2\nfunction! CountPermutations(n, k, qq)", "canonical_solution": "let N = 505\n    let P = 998244353\n    let q = repeat([0], N)\n    let m = 0\n    \" let dp = repeat(repeat([0], N), N)\n    let dp = []\n    for i in range(N)\n        call add(dp, repeat([0], N))\n    endfor\n    let jc = repeat([0], N)\n    let f = repeat([0], N)\n    let ans = 0\n\n    for i in range(1, a:n)\n        let q[i] = a:qq[i - 1]\n    endfor\n    let dp[0][0] = 1\n    let f[0] = 1\n    let jc[0] = 1\n    for i in range(1, a:n)\n        let jc[i] = (jc[i - 1] * i) % P\n    endfor\n    for i in range(1, a:n)\n        let f[i] = jc[i]\n        for j in range(1, i - 1)\n            let f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P\n        endfor\n    endfor\n    for i in range(1, a:n)\n        for j in range(i)\n            for k in range(1, a:n+1)\n                let dp[i][k] = (dp[i][k] + dp[j][k - 1] * f[i - j] % P) % P\n            endfor\n        endfor\n    endfor\n    for i in range(1, a:n+1)\n        if q[i] > get(q, i + 1, 0)\n            let m = i\n            break\n        endif\n    endfor\n    if m == a:n\n        for i in range(a:k, a:n+1)\n            let ans = (ans + dp[a:n][i]) % P\n        endfor\n    else\n        for i in range(m + 1, a:n+1)\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break\n            endif\n            let c = a:k + i - a:n - 1\n            if c >= 0\n                let ans = (ans + dp[m][c] * jc[i - m - 1] % P) % P\n            endif\n        endfor\n    endif\n    return ans\nendfunction", "test": "function! TestCountPermutations()\n    if assert_equal(CountPermutations(2, 1, [1, 2]), 2) | cq | endif\n    if assert_equal(CountPermutations(3, 3, [3, 1, 2]), 1) | cq | endif\n    if assert_equal(CountPermutations(6, 3, [1, 2, 3, 6, 5, 4]), 13) | cq | endif\n    if assert_equal(CountPermutations(6, 1, [1, 2, 3, 4, 5, 6]), 720) | cq | endif\n    if assert_equal(CountPermutations(6, 3, [1, 2, 5, 3, 4, 5]), 0) | cq | endif\n    if assert_equal(CountPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]), 1) | cq | endif\n    if assert_equal(CountPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]), 29093) | cq | endif\nendfunction\n\ncall TestCountPermutations()\nexit(0)", "entry_point": "CountPermutations", "signature": "function! CountPermutations(n, k, qq)", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (that is, choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n Example\n >>> countPermutations(2, 1, [1, 2])\n     2", "instruction": "Write a VimScript function `function! CountPermutations(n, k, qq)` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (that is, choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n Example\n >>> countPermutations(2, 1, [1, 2])\n     2", "level": "hard"}
{"task_id": "VimScript/44", "prompt": "\n\" Given an array of n distinct integers representing the heights of Kira's friends,\n\" find the number of ways to choose a triplet (a, b, c) such that the greatest common\n\" divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\" Example\n\" >>> countTriplets([1, 5, 7])\n\"     1\nfunction! CountTriplets(heights, n)", "canonical_solution": "let cnt = 0\n    for i in range(a:n-1)\n        for j in range(i + 1, a:n - 1)\n            for k in range(j + 1, a:n-1)\n                let minVal = min([a:heights[i], a:heights[j], a:heights[k]])\n                let maxVal = max([a:heights[i], a:heights[j], a:heights[k]])\n                let a = minVal\n                let b = maxVal\n                while b != 0\n                    let t = b\n                    let b = a % b\n                    let a = t\n                endwhile\n                if a == 1\n                    let cnt += 1\n                endif\n            endfor\n        endfor\n    endfor\n    return cnt\nendfunction", "test": "function! TestCountTriplets()\n    if assert_equal(CountTriplets([1, 5, 7], 3), 1) | cq | endif\n    if assert_equal(CountTriplets([1, 6, 2, 3], 4), 3) | cq | endif\n    if assert_equal(CountTriplets([16, 4, 8, 2], 4), 0) | cq | endif\n    if assert_equal(CountTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2], 10), 77) | cq | endif\n    if assert_equal(CountTriplets([4, 5, 9, 11, 14], 5), 7) | cq | endif\n    if assert_equal(CountTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2], 11), 104) | cq | endif\n    if assert_equal(CountTriplets([3, 7, 11, 13], 4), 4) | cq | endif\n    if assert_equal(CountTriplets([5, 12, 13, 17, 19], 5), 10) | cq | endif\n    if assert_equal(CountTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 11), 87) | cq | endif\n    if assert_equal(CountTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], 11), 122) | cq | endif\nendfunction\n\ncall TestCountTriplets()\nexit(0)", "entry_point": "CountTriplets", "signature": "function! CountTriplets(heights, n)", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common\ndivisor (GCD) of the maximum and minimum values of the triplet is 1.\nExample\n>>> countTriplets([1, 5, 7])\n    1\n", "instruction": "Write a VimScript function `function! CountTriplets(heights, n)` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common\ndivisor (GCD) of the maximum and minimum values of the triplet is 1.\nExample\n>>> countTriplets([1, 5, 7])\n    1\n", "level": "hard"}
{"task_id": "VimScript/45", "prompt": "\n\" You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation \n\" where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if\n\" they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\" \n\" Note: For each color, there are at most 20 pixels of that color.\n\" \n\" Examples:\n\"     >>> MinOperations(5, [1, 2, 3, 2, 1])\n\"     2\nfunction! MinOperations(n, pixels)", "canonical_solution": "let pre = []\n    let u = []\n    let f = []\n\n    for i in range(a:n+1)\n        let pre += [0]\n        let u += [0]\n        let f += [[]]\n        for j in range(a:n+1)\n            let f[i] += [0]\n        endfor\n    endfor\n\n    for i in range(1, a:n)\n        let pre[i] = u[a:pixels[i-1]]\n        let u[a:pixels[i-1]] = i\n    endfor\n\n    for i in range(1, a:n)\n        for j in range(1, a:n)\n            if i != j\n                let f[i][j] = 1000000\n            else\n                let f[i][j] = 0\n            endif\n        endfor\n    endfor\n\n    for len in range(2, a:n)\n        for i in range(1, a:n - len + 1)\n            let j = i + len - 1\n            let f[i][j] = f[i][j - 1] + 1\n            let l = pre[j]\n            while l >= i\n                let f[i][j] = min([f[i][j], f[i][l] + f[l + 1][j]])\n                let l = pre[l]\n            endwhile\n        endfor\n    endfor\n\n    return f[1][a:n]\nendfunction", "test": "function! TestMinOperations()\n    if assert_equal(MinOperations(5, [1, 2, 3, 2, 1]), 2) | cq | endif\n    if assert_equal(MinOperations(4, [1, 1, 2, 2]), 1) | cq | endif\n    if assert_equal(MinOperations(5, [1, 2, 1, 4, 2]), 3) | cq | endif\n    if assert_equal(MinOperations(5, [5, 5, 5, 5, 5]), 0) | cq | endif\n    if assert_equal(MinOperations(6, [1, 1, 1, 2, 2, 2]), 1) | cq | endif\n    if assert_equal(MinOperations(7, [1, 3, 3, 3, 2, 2, 2]), 2) | cq | endif\n    if assert_equal(MinOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]), 1) | cq | endif\n    if assert_equal(MinOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]), 8) | cq | endif\n    if assert_equal(MinOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]), 5) | cq | endif\n    if assert_equal(MinOperations(3, [3, 3, 3]), 0) | cq | endif\n    if assert_equal(MinOperations(4, [2, 1, 1, 2]), 1) | cq | endif\nendfunction\n\ncall TestMinOperations()\nexit(0)", "entry_point": "MinOperations", "signature": "function! MinOperations(n, pixels)", "docstring": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> MinOperations(5, [1, 2, 3, 2, 1])\n    2\n", "instruction": "Write a VimScript function `function! MinOperations(n, pixels)` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> MinOperations(5, [1, 2, 3, 2, 1])\n    2\n", "level": "hard"}
{"task_id": "VimScript/46", "prompt": "\n\" Given an integer n, this function computes the sum of all numbers from 1 to n\n\" that are multiples of either 3 or 5. Each number that satisfies this condition\n\" is counted only once, even if it is a multiple of both 3 and 5.\n\" Example:\n\" >>> call SumOfMultiples(10)\n\"     33 \" (This includes 3, 5, 6, 9, and 10)\nfunction! SumOfMultiples(n)", "canonical_solution": "let sum = 0\n    for i in range(1,a:n)\n        if i % 3 == 0 || i % 5 == 0\n            let sum += i\n        endif\n    endfor\n    return sum\nendfunction", "test": "function! TestSumOfMultiples()\n    if assert_equal(SumOfMultiples(10), 33) | cq | endif\n    if assert_equal(SumOfMultiples(15), 60) | cq | endif\n    if assert_equal(SumOfMultiples(20), 98) | cq | endif\n    if assert_equal(SumOfMultiples(5), 8) | cq | endif\n    if assert_equal(SumOfMultiples(3), 3) | cq | endif\n    if assert_equal(SumOfMultiples(6), 14) | cq | endif\n    if assert_equal(SumOfMultiples(9), 23) | cq | endif\n    if assert_equal(SumOfMultiples(12), 45) | cq | endif\n    if assert_equal(SumOfMultiples(17), 60) | cq | endif\n    if assert_equal(SumOfMultiples(21), 119) | cq | endif\n    if assert_equal(SumOfMultiples(25), 168) | cq | endif\nendfunction\n\ncall TestSumOfMultiples()\nexit(0)", "entry_point": "SumOfMultiples", "signature": "function! SumOfMultiples(n)", "docstring": "Given an integer n, this function computes the sum of all numbers from 1 to n that are multiples of either 3 or 5. Each number that satisfies this condition is counted only once, even if it is a multiple of both 3 and 5.\nExample:\n>>> call SumOfMultiples(10)\n   33 (This includes 3, 5, 6, 9, and 10)", "instruction": "Write a VimScript function `function! SumOfMultiples(n)` to solve the following problem:\nGiven an integer n, this function computes the sum of all numbers from 1 to n that are multiples of either 3 or 5. Each number that satisfies this condition is counted only once, even if it is a multiple of both 3 and 5.\nExample:\n>>> call SumOfMultiples(10)\n   33 (This includes 3, 5, 6, 9, and 10)", "level": "easy"}
{"task_id": "VimScript/47", "prompt": "\n\" Determine if a given string is a palindrome.\n\" A palindrome is a word, phrase, number, or other sequence of characters that\n\" reads the same forward and backward (ignoring spaces, punctuation, and\n\" capitalization).\n\" Examples\n\" >>> isPalindrome(\"racecar\")\n\"   true\nfunction! IsPalindrome(str)", "canonical_solution": "let start = 0\n    let end = len(a:str) - 1\n    \n    while start < end\n        \" Skip non-alphanumeric characters and handle case insensitivity\n        while start < end && a:str[start] !~ '\\w'\n            let start += 1\n        endwhile\n        while start < end && a:str[end] !~ '\\w'\n            let end -= 1\n        endwhile\n        if tolower(a:str[start]) !=# tolower(a:str[end])\n            return v:false\n        endif\n        let start += 1\n        let end -= 1\n    endwhile\n    return v:true\nendfunction", "test": "function! TestIsPalindrome()\n    if assert_equal(IsPalindrome(\"A man a plan a canal Panama\"), v:true) | cq | endif\n    if assert_equal(IsPalindrome(\"No lemon, no melon\"), v:true) | cq | endif\n    if assert_equal(IsPalindrome(\"Was it a car or a cat I saw\"), v:true) | cq | endif\n    if assert_equal(IsPalindrome(\"Madam, in Eden, I'm Adam\"), v:true) | cq | endif\n    if assert_equal(IsPalindrome(\"Never odd or even\"), v:true) | cq | endif\n    if assert_equal(IsPalindrome(\"Eva, can I see bees in a cave\"), v:true) | cq | endif\n    if assert_equal(IsPalindrome(\"hello\"), v:false) | cq | endif\n    if assert_equal(IsPalindrome(\"GitHub\"), v:false) | cq | endif\n    if assert_equal(IsPalindrome(\"programming\"), v:false) | cq | endif\nendfunction\n\ncall TestIsPalindrome()\n\nexit(0)", "entry_point": "IsPalindrome", "signature": "function! IsPalindrome(str)", "docstring": "Determine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters that\nreads the same forward and backward (ignoring spaces, punctuation, and\ncapitalization).\nExamples\n>>> isPalindrome(\"racecar\")\n  true\n", "instruction": "Write a VimScript function `function! IsPalindrome(str)` to solve the following problem:\nDetermine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters that\nreads the same forward and backward (ignoring spaces, punctuation, and\ncapitalization).\nExamples\n>>> isPalindrome(\"racecar\")\n  true\n", "level": "middle"}
{"task_id": "VimScript/48", "prompt": "\n\" Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n\" For example:\n\" >>> addDigits(38)\n\"     2\n\" Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\nfunction! AddDigits(num)", "canonical_solution": "let x = a:num\n    while x >= 10\n        let sum = 0\n        while x > 0\n            let sum += x % 10\n            let x = x / 10\n        endwhile\n        let x = sum\n    endwhile\n    return x\nendfunction", "test": "function! TestAddDigits()\n    if assert_equal(AddDigits(38), 2) | cq | endif\n    if assert_equal(AddDigits(0), 0) | cq | endif\n    if assert_equal(AddDigits(9), 9) | cq | endif\n    if assert_equal(AddDigits(123), 6) | cq | endif\n    if assert_equal(AddDigits(456), 6) | cq | endif\n    if assert_equal(AddDigits(9999), 9) | cq | endif\n    if assert_equal(AddDigits(100), 1) | cq | endif\n    if assert_equal(AddDigits(1010), 2) | cq | endif\n    if assert_equal(AddDigits(1234), 1) | cq | endif\n    if assert_equal(AddDigits(9876), 3) | cq | endif\n    if assert_equal(AddDigits(199), 1) | cq | endif\nendfunction\n\ncall TestAddDigits()\nexit(0)", "entry_point": "AddDigits", "signature": "function! AddDigits(num)", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n>>> addDigits(38)\n    2\nBecause 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "instruction": "Write a VimScript function `function! AddDigits(num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n>>> addDigits(38)\n    2\nBecause 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "level": "easy"}
{"task_id": "VimScript/49", "prompt": "\n\" You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take\n\" turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of\n\" stones n, determine if you can win the game if both you and your opponent play optimally.\n\" Note: You always take the first turn.\n\"\n\" Here are some cases:\n\" >>> canWinNim(1)\n\" true\nfunction! CanWinNim(n)", "canonical_solution": "return a:n % 4 != 0\n\nendfunction", "test": "function! TestCanWinNim()\n    if assert_equal(CanWinNim(1), 1) | cq | endif\n    if assert_equal(CanWinNim(2), 1) | cq | endif\n    if assert_equal(CanWinNim(3), 1) | cq | endif\n    if assert_equal(CanWinNim(4), 0) | cq | endif\n    if assert_equal(CanWinNim(5), 1) | cq | endif\n    if assert_equal(CanWinNim(6), 1) | cq | endif\n    if assert_equal(CanWinNim(7), 1) | cq | endif\n    if assert_equal(CanWinNim(8), 0) | cq | endif\n    if assert_equal(CanWinNim(9), 1) | cq | endif\n    if assert_equal(CanWinNim(10), 1) | cq | endif\n    if assert_equal(CanWinNim(11), 1) | cq | endif\n    if assert_equal(CanWinNim(12), 0) | cq | endif\n    if assert_equal(CanWinNim(13), 1) | cq | endif\n    if assert_equal(CanWinNim(14), 1) | cq | endif\n    if assert_equal(CanWinNim(15), 1) | cq | endif\n    if assert_equal(CanWinNim(16), 0) | cq | endif\n    if assert_equal(CanWinNim(17), 1) | cq | endif\n    if assert_equal(CanWinNim(18), 1) | cq | endif\n    if assert_equal(CanWinNim(19), 1) | cq | endif\n    if assert_equal(CanWinNim(20), 0) | cq | endif\nendfunction\n\ncall TestCanWinNim()\nexit(0)", "entry_point": "CanWinNim", "signature": "function! CanWinNim(n)", "docstring": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n>>> canWinNim(1)\ntrue", "instruction": "Write a VimScript function `function! CanWinNim(n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n>>> canWinNim(1)\ntrue", "level": "easy"}
{"task_id": "VimScript/50", "prompt": "\n\" Description:\n\"   Given two integers a and b, return the sum if the sum is even,\n\"   or return the product of a and b if the sum is odd.\n\" Examples:\n\"   >>> evenSumOrOddProduct(2, 3)\n\"   6\n\"   >>> evenSumOrOddProduct(5, 5)\n\"   10\nfunction! EvenSumOrOddProduct(a, b)", "canonical_solution": "let sum = a:a + a:b\n    if sum % 2 == 0\n        return sum\n    else\n        return a:a * a:b\n    endif\nendfunction", "test": "function! TestEvenSumOrOddProduct()\n    if assert_equal(EvenSumOrOddProduct(2, 3), 6) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(5, 5), 10) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(1, 1), 2) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(0, 0), 0) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(-1, -1), -2) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(100, 200), 300) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(3, 4), 12) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(-5, 5), 0) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(7, 8), 56) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(9, 10), 90) | cq | endif\n    if assert_equal(EvenSumOrOddProduct(11, 14), 154) | cq | endif\nendfunction\n\ncall TestEvenSumOrOddProduct()\nexit(0)", "entry_point": "EvenSumOrOddProduct", "signature": "function! EvenSumOrOddProduct(a, b)", "docstring": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExamples:\n>>> evenSumOrOddProduct(2, 3)\n6\n>>> evenSumOrOddProduct(5, 5)\n10\n", "instruction": "Write a VimScript function `function! EvenSumOrOddProduct(a, b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExamples:\n>>> evenSumOrOddProduct(2, 3)\n6\n>>> evenSumOrOddProduct(5, 5)\n10\n", "level": "easy"}
