{"task_id": "Haskell/1", "prompt": "module Main where\n\nimport Data.List\n\n{- \n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n  False\n  >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  True\n  \"\"\"\n-}\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =", "canonical_solution": "  any (\\(x, y) -> abs (x - y) < threshold) combinations\n    where\n      combinations = [(x, y) | (x:ys) <- tails numbers, y <- ys]", "test": "check :: ([Float] -> Float -> Bool) -> IO ()\ncheck hasCloseElementsFunc = do\n  let testCases =\n        [ ([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3, True),\n          ([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05, False),\n          ([1.0, 2.0, 5.9, 4.0, 5.0], 0.95, True),\n          ([1.0, 2.0, 5.9, 4.0, 5.0], 0.8, False),\n          ([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1, True),\n          ([1.1, 2.2, 3.1, 4.1, 5.1], 1.0, True),\n          ([1.1, 2.2, 3.1, 4.1, 5.1], 0.5, False)\n        ]\n\n  mapM_ (\\(numbers, threshold, expected) -> testCase numbers threshold expected) testCases\n  where\n    testCase numbers threshold expected = do\n      let result = hasCloseElementsFunc numbers threshold\n      putStrLn $\n        \"Input: \" ++ show numbers ++ \", Threshold: \" ++ show threshold ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\n\nmain :: IO ()\nmain = check hasCloseElements", "entry_point": "hasCloseElements", "signature": "hasCloseElements :: [Float] -> Float -> Bool", "docstring": " \n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n  False\n  >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  True\n  \"\"\"\n\n", "instruction": "Write a Haskell function `hasCloseElements :: [Float] -> Float -> Bool` to solve the following problem:\n \n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n  False\n  >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  True\n  \"\"\"\n\n", "level": "easy"}
{"task_id": "Haskell/2", "prompt": "module Main where\n\nimport Data.List (sort, nub)\n\n{- \n  Returns the third largest number in a non-empty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is non-empty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n-}\nthirdLargest :: [Int] -> Int\nthirdLargest numbers = ", "canonical_solution": "  case uniqueSortedNumbers of\n    (x:_:_:_) -> uniqueSortedNumbers !! 2\n    otherwise -> head uniqueSortedNumbers\n  where\n    uniqueSortedNumbers = reverse . sort . nub $ numbers", "test": "check :: ([Int] -> Int) -> IO ()\ncheck thirdLargestFunc = do\n  let testCases =\n        [ ([3, 2, 1], 1),\n          ([1, 2], 2),\n          ([10, 15, 5, 4, 20], 10),\n          ([5], 5)\n        ]\n\n  mapM_ (\\(numbers, expected) -> testCase numbers expected) testCases\n  where\n    testCase numbers expected = do\n      let result = thirdLargestFunc numbers\n      putStrLn $\n        \"Input: \" ++ show numbers ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check thirdLargest", "entry_point": "thirdLargest", "signature": "thirdLargest :: [Int] -> Int", "docstring": " \n  Returns the third largest number in a nonempty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is nonempty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n\n", "instruction": "Write a Haskell function `thirdLargest :: [Int] -> Int` to solve the following problem:\n \n  Returns the third largest number in a nonempty array. \n  If the third largest number does not exist, returns the largest number.\n  Assumes that the array is nonempty.\n  >>> thirdLargest([3, 2, 1])\n  1\n  >>> thirdLargest([1, 2])\n  2\n\n", "level": "middle"}
{"task_id": "Haskell/3", "prompt": "module Main where\n\n{- \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n-}\ndiagonalSum :: [[Int]] -> Int", "canonical_solution": "diagonalSum mat = sum mainDiagonal + sum secondaryDiagonal - intersect\n  where\n    size = length mat\n    mainDiagonal = [mat !! i !! i | i <- [0..size-1]]\n    secondaryDiagonal = [mat !! i !! (size - 1 - i) | i <- [0..size-1]]\n    intersect = if odd size then mat !! middle !! middle else 0\n    middle = size `div` 2", "test": "check :: ([[Int]] -> Int) -> IO ()\ncheck diagonalSumFunc = do\n  let testCases =\n        [ ([[1,2,3], [4,5,6], [7,8,9]], 25),\n          ([[1,1], [1,1]], 4),\n          ([[5]], 5),\n          ([[1,2], [3,4]], 10),\n          ([[2,0,0], [0,1,0], [0,0,3]], 6)\n        ]\n\n  mapM_ (\\(mat, expected) -> testCase mat expected) testCases\n  where\n    testCase mat expected = do\n      let result = diagonalSumFunc mat\n      putStrLn $\n        \"Input: \" ++ show mat ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check diagonalSum", "entry_point": "diagonalSum", "signature": "diagonalSum :: [[Int]] -> Int", "docstring": " \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n\n", "instruction": "Write a Haskell function `diagonalSum :: [[Int]] -> Int` to solve the following problem:\n \n  Returns the sum of elements on the main diagonal and the secondary diagonal of a square matrix,\n  counting the intersecting elements only once.\n  Assumes the input is a square matrix.\n  >>> diagonalSum [[1,2,3], [4,5,6], [7,8,9]]\n  25\n  >>> diagonalSum [[1,1], [1,1]]\n  4\n  >>> diagonalSum [[5]]\n  5\n  >>> diagonalSum [[1,2], [3,4]]\n  10\n  >>> diagonalSum [[2,0,0], [0,1,0], [0,0,3]]\n  6\n\n", "level": "hard"}
{"task_id": "Haskell/4", "prompt": "module Main where\n\nimport Data.List (tails, inits)\n\n{- \n  Calculates the sum of all possible odd-length subarrays of an array.\n  >>> sumOddLengthSubarrays [1,4,2,5,3]\n  58\n  >>> sumOddLengthSubarrays [1,2]\n  3\n  >>> sumOddLengthSubarrays [10,11,12]\n  66\n  >>> sumOddLengthSubarrays [1,2,3,4,5,6,7]\n  252\n  >>> sumOddLengthSubarrays [1]\n  1\n-}\nsumOddLengthSubarrays :: [Int] -> Int", "canonical_solution": "sumOddLengthSubarrays arr = sum [sum subarr | subarr <- allSubarrays, odd (length subarr)]\n  where\n    allSubarrays = concatMap tails $ inits arr", "test": "check :: ([Int] -> Int) -> IO ()\ncheck sumOddLengthSubarraysFunc = do\n  let testCases =\n        [ ([1,4,2,5,3], 58),\n          ([1,2], 3),\n          ([10,11,12], 66),\n          ([1], 1)\n        ]\n\n  mapM_ (\\(arr, expected) -> testCase arr expected) testCases\n  where\n    testCase arr expected = do\n      let result = sumOddLengthSubarraysFunc arr\n      putStrLn $\n        \"Input: \" ++ show arr ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check sumOddLengthSubarrays", "entry_point": "sumOddLengthSubarrays", "signature": "sumOddLengthSubarrays :: [Int] -> Int", "docstring": " \n  Calculates the sum of all possible oddlength subarrays of an array.\n  >>> sumOddLengthSubarrays [1,4,2,5,3]\n  58\n  >>> sumOddLengthSubarrays [1,2]\n  3\n  >>> sumOddLengthSubarrays [10,11,12]\n  66\n  >>> sumOddLengthSubarrays [1,2,3,4,5,6,7]\n  252\n  >>> sumOddLengthSubarrays [1]\n  1\n\n", "instruction": "Write a Haskell function `sumOddLengthSubarrays :: [Int] -> Int` to solve the following problem:\n \n  Calculates the sum of all possible oddlength subarrays of an array.\n  >>> sumOddLengthSubarrays [1,4,2,5,3]\n  58\n  >>> sumOddLengthSubarrays [1,2]\n  3\n  >>> sumOddLengthSubarrays [10,11,12]\n  66\n  >>> sumOddLengthSubarrays [1,2,3,4,5,6,7]\n  252\n  >>> sumOddLengthSubarrays [1]\n  1\n\n", "level": "easy"}
{"task_id": "Haskell/5", "prompt": "module Main where\n\nimport Data.List (delete, sort)\n\n{- \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n-}\naverageWithoutExtremes :: [Int] -> Maybe Float", "canonical_solution": "averageWithoutExtremes arr\n  | length arr < 3 = Nothing\n  | otherwise = Just $ fromIntegral (sum newArr) / fromIntegral (length newArr)\n  where\n    sortedArr = sort arr\n    newArr = delete (maximum arr) (delete (minimum arr) sortedArr)", "test": "check :: ([Int] -> Maybe Float) -> IO ()\ncheck averageWithoutExtremesFunc = do\n  let testCases =\n        [ ([1,2,3,4,5], Just 3.0),\n          ([1,2], Nothing),\n          ([10,20,30,40,50], Just 30.0),\n          ([5,5,5,5,5], Just 5.0),\n          ([7], Nothing)\n        ]\n\n  mapM_ (\\(arr, expected) -> testCase arr expected) testCases\n  where\n    testCase arr expected = do\n      let result = averageWithoutExtremesFunc arr\n      putStrLn $\n        \"Input: \" ++ show arr ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check averageWithoutExtremes", "entry_point": "averageWithoutExtremes", "signature": "averageWithoutExtremes :: [Int] -> Maybe Float", "docstring": " \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n\n", "instruction": "Write a Haskell function `averageWithoutExtremes :: [Int] -> Maybe Float` to solve the following problem:\n \n  Calculates the average value of an array after removing the smallest and largest numbers.\n  Returns Nothing if the array has less than 3 elements.\n  >>> averageWithoutExtremes [1,2,3,4,5]\n  Just 3.0\n  >>> averageWithoutExtremes [1,2]\n  Nothing\n  >>> averageWithoutExtremes [10,20,30,40,50]\n  Just 30.0\n  >>> averageWithoutExtremes [5,5,5,5,5]\n  Just 5.0\n  >>> averageWithoutExtremes [7]\n  Nothing\n\n", "level": "middle"}
{"task_id": "Haskell/6", "prompt": "module Main where\n\nimport Data.List (sortBy, group, sort)\nimport Data.Ord (comparing)\n\n{- \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n-}\nfrequencySort :: [Int] -> [Int]", "canonical_solution": "frequencySort nums = concat . sortBy compareFrequency $ grouped\n  where\n    grouped = group . sort $ nums\n    compareFrequency a b = case comparing length a b of\n                              EQ -> comparing (negate . head) a b\n                              ord -> ord", "test": "check :: ([Int] -> [Int]) -> IO ()\ncheck frequencySortFunc = do\n  let testCases =\n        [ ([1,1,2,2,2,3], [3,1,1,2,2,2]),\n          ([2,3,1,3,2], [1,3,3,2,2]),\n          ([5,5,4,6,4], [6,5,5,4,4]),\n          ([-1,1,-6,4,5,-6,1,4,1], [5,-1,4,4,-6,-6,1,1,1]),\n          ([1], [1])\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = frequencySortFunc nums\n      putStrLn $\n        \"Input: \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check frequencySort", "entry_point": "frequencySort", "signature": "frequencySort :: [Int] -> [Int]", "docstring": " \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n\n", "instruction": "Write a Haskell function `frequencySort :: [Int] -> [Int]` to solve the following problem:\n \n  Sorts an array based on the frequency of each value in ascending order.\n  If multiple values have the same frequency, they are sorted in descending order of their values.\n  >>> frequencySort [1,1,2,2,2,3]\n  [3,1,1,2,2,2]\n  >>> frequencySort [2,3,1,3,2]\n  [1,3,3,2,2]\n\n", "level": "middle"}
{"task_id": "Haskell/7", "prompt": "module Main where\n\nimport Data.List (find,isPrefixOf)\n\n{- \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n-}\ncanFormArray :: [Int] -> [[Int]] -> Bool", "canonical_solution": "canFormArray [] _ = True\ncanFormArray arr pieces = maybe False (\\piece -> canFormArray (drop (length piece) arr) (filter (/= piece) pieces)) matchedPiece\n  where\n    matchedPiece = find (`isPrefixOf` arr) pieces", "test": "check :: ([Int] -> [[Int]] -> Bool) -> IO ()\ncheck canFormArrayFunc = do\n  let testCases =\n        [ ([85], [[85]], True),\n          ([15,88], [[88],[15]], True),\n          ([49,18,16], [[16,18,49]], False),\n          ([91,4,64,78], [[78],[4,64],[91]], True),\n          ([1,3,5,7], [[2,4,6,8]], False)\n        ]\n\n  mapM_ (\\(arr, pieces, expected) -> testCase arr pieces expected) testCases\n  where\n    testCase arr pieces expected = do\n      let result = canFormArrayFunc arr pieces\n      putStrLn $\n        \"Input: arr = \" ++ show arr ++ \", pieces = \" ++ show pieces ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check canFormArray", "entry_point": "canFormArray", "signature": "canFormArray :: [Int] -> [[Int]] -> Bool", "docstring": " \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n\n", "instruction": "Write a Haskell function `canFormArray :: [Int] -> [[Int]] -> Bool` to solve the following problem:\n \n  Checks if an array arr can be formed by concatenating the arrays in pieces without rearranging the elements within each array in pieces.\n  Each integer in arr and pieces is unique.\n  >>> canFormArray [85] [[85]]\n  True\n  >>> canFormArray [15,88] [[88],[15]]\n  True\n  >>> canFormArray [49,18,16] [[16,18,49]]\n  False\n  >>> canFormArray [91,4,64,78] [[78],[4,64],[91]]\n  True\n  >>> canFormArray [1,3,5,7] [[2,4,6,8]]\n  False\n\n", "level": "middle"}
{"task_id": "Haskell/8", "prompt": "module Main where\n\n{- \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] -2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n-}\ndecrypt :: [Int] -> Int -> [Int]", "canonical_solution": "decrypt code k\n  | k == 0 = replicate (length code) 0\n  | k > 0 = map (\\i -> sum . take k . drop (i + 1) $ cycle code) [0 .. length code - 1]\n  | otherwise = map (\\i -> sum . take (abs k) . drop (i + length code + k) $ cycle code) [0 .. length code - 1]", "test": "check :: ([Int] -> Int -> [Int]) -> IO ()\ncheck decryptFunc = do\n  let testCases =\n        [ ([5,7,1,4], 3, [12,10,16,13]),\n          ([1,2,3,4], 0, [0,0,0,0]),\n          ([2,4,9,3], -2, [12,5,6,13]),\n          ([10,5,7,7], 1, [5,7,7,10]),\n          ([1,2,3,4], 4, [10,10,10,10])\n        ]\n\n  mapM_ (\\(code, k, expected) -> testCase code k expected) testCases\n  where\n    testCase code k expected = do\n      let result = decryptFunc code k\n      putStrLn $\n        \"Input: code = \" ++ show code ++ \", k = \" ++ show k ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check decrypt", "entry_point": "decrypt", "signature": "decrypt :: [Int] -> Int -> [Int]", "docstring": " \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] 2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n\n", "instruction": "Write a Haskell function `decrypt :: [Int] -> Int -> [Int]` to solve the following problem:\n \n  Decrypts a circular array code with a given integer key k.\n  >>> decrypt [5,7,1,4] 3\n  [12,10,16,13]\n  >>> decrypt [1,2,3,4] 0\n  [0,0,0,0]\n  >>> decrypt [2,4,9,3] 2\n  [12,5,6,13]\n  >>> decrypt [10,5,7,7] 1\n  [5,7,7,10]\n  >>> decrypt [1,2,3,4] 4\n  [10,10,10,10]\n\n", "level": "middle"}
{"task_id": "Haskell/9", "prompt": "module Main where\n\n{- \n  Checks if two arrays of strings represent the same string when concatenated.\n  >>> arrayStringsAreEqual [\"ab\", \"c\"] [\"a\", \"bc\"]\n  True\n  >>> arrayStringsAreEqual [\"a\", \"cb\"] [\"ab\", \"c\"]\n  False\n  >>> arrayStringsAreEqual [\"abc\", \"d\", \"defg\"] [\"abcddefg\"]\n  True\n  >>> arrayStringsAreEqual [\"hello\", \"world\"] [\"hello\", \"planet\"]\n  False\n  >>> arrayStringsAreEqual [\"\", \"\"] [\"\", \"\"]\n  True\n-}\narrayStringsAreEqual :: [String] -> [String] -> Bool", "canonical_solution": "arrayStringsAreEqual word1 word2 = concat word1 == concat word2", "test": "check :: ([String] -> [String] -> Bool) -> IO ()\ncheck arrayStringsAreEqualFunc = do\n  let testCases =\n        [ ([\"ab\", \"c\"], [\"a\", \"bc\"], True),\n          ([\"a\", \"cb\"], [\"ab\", \"c\"], False),\n          ([\"abc\", \"d\", \"defg\"], [\"abcddefg\"], True),\n          ([\"hello\", \"world\"], [\"hello\", \"planet\"], False),\n          ([\"\", \"\"], [\"\", \"\"], True)\n        ]\n\n  mapM_ (\\(word1, word2, expected) -> testCase word1 word2 expected) testCases\n  where\n    testCase word1 word2 expected = do\n      let result = arrayStringsAreEqualFunc word1 word2\n      putStrLn $\n        \"Input: word1 = \" ++ show word1 ++ \", word2 = \" ++ show word2 ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check arrayStringsAreEqual", "entry_point": "arrayStringsAreEqual", "signature": "arrayStringsAreEqual :: [String] -> [String] -> Bool", "docstring": " \n  Checks if two arrays of strings represent the same string when concatenated.\n  >>> arrayStringsAreEqual [\"ab\", \"c\"] [\"a\", \"bc\"]\n  True\n  >>> arrayStringsAreEqual [\"a\", \"cb\"] [\"ab\", \"c\"]\n  False\n  >>> arrayStringsAreEqual [\"abc\", \"d\", \"defg\"] [\"abcddefg\"]\n  True\n  >>> arrayStringsAreEqual [\"hello\", \"world\"] [\"hello\", \"planet\"]\n  False\n  >>> arrayStringsAreEqual [\"\", \"\"] [\"\", \"\"]\n  True\n\n", "instruction": "Write a Haskell function `arrayStringsAreEqual :: [String] -> [String] -> Bool` to solve the following problem:\n \n  Checks if two arrays of strings represent the same string when concatenated.\n  >>> arrayStringsAreEqual [\"ab\", \"c\"] [\"a\", \"bc\"]\n  True\n  >>> arrayStringsAreEqual [\"a\", \"cb\"] [\"ab\", \"c\"]\n  False\n  >>> arrayStringsAreEqual [\"abc\", \"d\", \"defg\"] [\"abcddefg\"]\n  True\n  >>> arrayStringsAreEqual [\"hello\", \"world\"] [\"hello\", \"planet\"]\n  False\n  >>> arrayStringsAreEqual [\"\", \"\"] [\"\", \"\"]\n  True\n\n", "level": "easy"}
{"task_id": "Haskell/10", "prompt": "module Main where\n\n{- \n  Returns the maximum total wealth across all customers.\n  The wealth of a customer is the sum of their assets in various banks.\n  >>> maximumWealth [[1,2,3],[3,2,1]]\n  6\n  >>> maximumWealth [[1,5],[7,3],[3,5]]\n  10\n  >>> maximumWealth [[2,8,7],[7,1,3],[1,9,5]]\n  17\n  >>> maximumWealth [[10],[15],[20]]\n  20\n  >>> maximumWealth [[1,2],[3,4],[5,6,7]]\n  18\n-}\nmaximumWealth :: [[Int]] -> Int", "canonical_solution": "maximumWealth accounts = maximum $ map sum accounts", "test": "check :: ([[Int]] -> Int) -> IO ()\ncheck maximumWealthFunc = do\n  let testCases =\n        [ ([[1,2,3],[3,2,1]], 6),\n          ([[1,5],[7,3],[3,5]], 10),\n          ([[2,8,7],[7,1,3],[1,9,5]], 17),\n          ([[10],[15],[20]], 20),\n          ([[1,2],[3,4],[5,6,7]], 18)\n        ]\n\n  mapM_ (\\(accounts, expected) -> testCase accounts expected) testCases\n  where\n    testCase accounts expected = do\n      let result = maximumWealthFunc accounts\n      putStrLn $\n        \"Input: \" ++ show accounts ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check maximumWealth", "entry_point": "maximumWealth", "signature": "maximumWealth :: [[Int]] -> Int", "docstring": " \n  Returns the maximum total wealth across all customers.\n  The wealth of a customer is the sum of their assets in various banks.\n  >>> maximumWealth [[1,2,3],[3,2,1]]\n  6\n  >>> maximumWealth [[1,5],[7,3],[3,5]]\n  10\n  >>> maximumWealth [[2,8,7],[7,1,3],[1,9,5]]\n  17\n  >>> maximumWealth [[10],[15],[20]]\n  20\n  >>> maximumWealth [[1,2],[3,4],[5,6,7]]\n  18\n\n", "instruction": "Write a Haskell function `maximumWealth :: [[Int]] -> Int` to solve the following problem:\n \n  Returns the maximum total wealth across all customers.\n  The wealth of a customer is the sum of their assets in various banks.\n  >>> maximumWealth [[1,2,3],[3,2,1]]\n  6\n  >>> maximumWealth [[1,5],[7,3],[3,5]]\n  10\n  >>> maximumWealth [[2,8,7],[7,1,3],[1,9,5]]\n  17\n  >>> maximumWealth [[10],[15],[20]]\n  20\n  >>> maximumWealth [[1,2],[3,4],[5,6,7]]\n  18\n\n", "level": "easy"}
{"task_id": "Haskell/11", "prompt": "module Main where\n\nimport Data.List (all)\n\n{- \n  Counts the number of consistent strings in the array words based on the characters allowed in the string allowed.\n  A consistent string is one where every character appears in allowed.\n  >>> countConsistentStrings \"ab\" [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n  2\n  >>> countConsistentStrings \"abc\" [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\",\"abcd\",\"abdc\"]\n  7\n  >>> countConsistentStrings \"cad\" [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n  4\n  >>> countConsistentStrings \"z\" [\"z\",\"y\",\"zzz\",\"zyz\"]\n  2\n  >>> countConsistentStrings \"fstqyienx\" [\"n\",\"eeitfns\",\"eqqqsfs\",\"i\",\"feniqis\",\"lhoa\",\"yqyitei\",\"sqtn\",\"kug\",\"z\",\"neqqis\"]\n  11\n-}\ncountConsistentStrings :: String -> [String] -> Int", "canonical_solution": "countConsistentStrings allowed words = length $ filter (isConsistentString allowed) words\n  where\n    isConsistentString chars word = all (`elem` chars) word", "test": "check :: (String -> [String] -> Int) -> IO ()\ncheck countConsistentStringsFunc = do\n  let testCases =\n        [ (\"ab\", [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"], 2),\n          (\"abc\", [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\",\"abcd\",\"abdc\"], 7),\n          (\"cad\", [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"], 4),\n          (\"z\", [\"z\",\"y\",\"zzz\",\"zyz\"], 2)\n        ]\n\n  mapM_ (\\(allowed, words, expected) -> testCase allowed words expected) testCases\n  where\n    testCase allowed words expected = do\n      let result = countConsistentStringsFunc allowed words\n      putStrLn $\n        \"Input: allowed = \" ++ show allowed ++ \", words = \" ++ show words ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countConsistentStrings", "entry_point": "countConsistentStrings", "signature": "countConsistentStrings :: String -> [String] -> Int", "docstring": " \n  Counts the number of consistent strings in the array words based on the characters allowed in the string allowed.\n  A consistent string is one where every character appears in allowed.\n  >>> countConsistentStrings \"ab\" [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n  2\n  >>> countConsistentStrings \"abc\" [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\",\"abcd\",\"abdc\"]\n  7\n  >>> countConsistentStrings \"cad\" [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n  4\n  >>> countConsistentStrings \"z\" [\"z\",\"y\",\"zzz\",\"zyz\"]\n  2\n  >>> countConsistentStrings \"fstqyienx\" [\"n\",\"eeitfns\",\"eqqqsfs\",\"i\",\"feniqis\",\"lhoa\",\"yqyitei\",\"sqtn\",\"kug\",\"z\",\"neqqis\"]\n  11\n\n", "instruction": "Write a Haskell function `countConsistentStrings :: String -> [String] -> Int` to solve the following problem:\n \n  Counts the number of consistent strings in the array words based on the characters allowed in the string allowed.\n  A consistent string is one where every character appears in allowed.\n  >>> countConsistentStrings \"ab\" [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n  2\n  >>> countConsistentStrings \"abc\" [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\",\"abcd\",\"abdc\"]\n  7\n  >>> countConsistentStrings \"cad\" [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n  4\n  >>> countConsistentStrings \"z\" [\"z\",\"y\",\"zzz\",\"zyz\"]\n  2\n  >>> countConsistentStrings \"fstqyienx\" [\"n\",\"eeitfns\",\"eqqqsfs\",\"i\",\"feniqis\",\"lhoa\",\"yqyitei\",\"sqtn\",\"kug\",\"z\",\"neqqis\"]\n  11\n\n", "level": "easy"}
{"task_id": "Haskell/12", "prompt": "module Main where\n\nimport Data.List (delete)\n\n{- \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n-}\ncountUnsatisfiedStudents :: [Int] -> [Int] -> Int", "canonical_solution": "countUnsatisfiedStudents students sandwiches = length (snd (until noOneLikesTopSandwich takeSandwich (students, sandwiches)))\n  where\n    takeSandwich (st:sts, s:ss)\n      | st == s = (sts, ss)\n      | otherwise = (sts ++ [st], s:ss)\n    takeSandwich ([], ss) = ([], ss)\n    noOneLikesTopSandwich (sts, s:ss) = null sts || all (/= s) sts\n    noOneLikesTopSandwich (_, []) = True", "test": "check :: ([Int] -> [Int] -> Int) -> IO ()\ncheck countUnsatisfiedStudentsFunc = do\n  let testCases =\n        [ ([1,1,0,0], [0,1,0,1], 0),\n          ([1,1,1,0,0,1], [1,0,0,0,1,1], 3),\n          ([1,0,0,1,1], [1,1,0,0,0], 1),\n          ([0,0,1,1], [0,1,0,1], 0)\n        ]\n\n  mapM_ (\\(students, sandwiches, expected) -> testCase students sandwiches expected) testCases\n  where\n    testCase students sandwiches expected = do\n      let result = countUnsatisfiedStudentsFunc students sandwiches\n      putStrLn $\n        \"Input: students = \" ++ show students ++ \", sandwiches = \" ++ show sandwiches ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countUnsatisfiedStudents", "entry_point": "countUnsatisfiedStudents", "signature": "countUnsatisfiedStudents :: [Int] -> [Int] -> Int", "docstring": " \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n\n", "instruction": "Write a Haskell function `countUnsatisfiedStudents :: [Int] -> [Int] -> Int` to solve the following problem:\n \n  Returns the number of students who are unable to eat lunch.\n  Students take sandwiches from a stack based on their preferences.\n  >>> countUnsatisfiedStudents [1,1,0,0] [0,1,0,1]\n  0\n  >>> countUnsatisfiedStudents [1,1,1,0,0,1] [1,0,0,0,1,1]\n  3\n\n", "level": "hard"}
{"task_id": "Haskell/13", "prompt": "module Main where\n\n{- \n  Counts how many rectangles can produce a square with the maximum possible side length.\n  >>> countMaxLenSquares [[5,8],[3,9],[5,12],[16,5]]\n  3\n  >>> countMaxLenSquares [[2,3],[3,7],[4,3],[3,7]]\n  3\n-}\ncountMaxLenSquares :: [[Int]] -> Int", "canonical_solution": "countMaxLenSquares rectangles =\n  let maxLen = maximum $ map (\\[l, w] -> min l w) rectangles\n  in length $ filter (\\[l, w] -> min l w >= maxLen) rectangles", "test": "check :: ([[Int]] -> Int) -> IO ()\ncheck countMaxLenSquaresFunc = do\n  let testCases =\n        [ ([[5,8],[3,9],[5,12],[16,5]], 3),\n          ([[2,3],[3,7],[4,3],[3,7]], 3),\n          ([[2,2],[3,3],[4,4],[5,5]], 1),\n          ([[2,5],[3,3],[5,8],[6,10]], 1),\n          ([[1,1],[2,2],[3,3],[4,1],[2,2],[1,4]], 1)\n        ]\n\n  mapM_ (\\(rectangles, expected) -> testCase rectangles expected) testCases\n  where\n    testCase rectangles expected = do\n      let result = countMaxLenSquaresFunc rectangles\n      putStrLn $\n        \"Input: rectangles = \" ++ show rectangles ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countMaxLenSquares", "entry_point": "countMaxLenSquares", "signature": "countMaxLenSquares :: [[Int]] -> Int", "docstring": " \n  Counts how many rectangles can produce a square with the maximum possible side length.\n  >>> countMaxLenSquares [[5,8],[3,9],[5,12],[16,5]]\n  3\n  >>> countMaxLenSquares [[2,3],[3,7],[4,3],[3,7]]\n  3\n\n", "instruction": "Write a Haskell function `countMaxLenSquares :: [[Int]] -> Int` to solve the following problem:\n \n  Counts how many rectangles can produce a square with the maximum possible side length.\n  >>> countMaxLenSquares [[5,8],[3,9],[5,12],[16,5]]\n  3\n  >>> countMaxLenSquares [[2,3],[3,7],[4,3],[3,7]]\n  3\n\n", "level": "easy"}
{"task_id": "Haskell/14", "prompt": "module Main where\n\n{- \n  Returns the highest altitude reached by the cyclist.\n  >>> highestAltitude [-5,1,5,0,-7]\n  1\n  >>> highestAltitude [-4,-3,-2,-1,4,3,2]\n  0\n  >>> highestAltitude [44,32,-9,34,-7,-6,-5,35,37,-6]\n  103\n  >>> highestAltitude [0,0,0,0]\n  0\n  >>> highestAltitude [1,2,3,4]\n  10\n-}\nhighestAltitude :: [Int] -> Int", "canonical_solution": "highestAltitude gain = maximum $ scanl (+) 0 gain", "test": "check :: ([Int] -> Int) -> IO ()\ncheck highestAltitudeFunc = do\n  let testCases =\n        [ ([-5,1,5,0,-7], 1),\n          ([-4,-3,-2,-1,4,3,2], 0),\n          ([44,32,-9,34,-7,-6,-5,35,37,-6], 155),\n          ([0,0,0,0], 0),\n          ([1,2,3,4], 10)\n        ]\n\n  mapM_ (\\(gain, expected) -> testCase gain expected) testCases\n  where\n    testCase gain expected = do\n      let result = highestAltitudeFunc gain\n      putStrLn $\n        \"Input: gain = \" ++ show gain ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check highestAltitude", "entry_point": "highestAltitude", "signature": "highestAltitude :: [Int] -> Int", "docstring": " \n  Returns the highest altitude reached by the cyclist.\n  >>> highestAltitude [5,1,5,0,7]\n  1\n  >>> highestAltitude [4,3,2,1,4,3,2]\n  0\n  >>> highestAltitude [44,32,9,34,7,6,5,35,37,6]\n  103\n  >>> highestAltitude [0,0,0,0]\n  0\n  >>> highestAltitude [1,2,3,4]\n  10\n\n", "instruction": "Write a Haskell function `highestAltitude :: [Int] -> Int` to solve the following problem:\n \n  Returns the highest altitude reached by the cyclist.\n  >>> highestAltitude [5,1,5,0,7]\n  1\n  >>> highestAltitude [4,3,2,1,4,3,2]\n  0\n  >>> highestAltitude [44,32,9,34,7,6,5,35,37,6]\n  103\n  >>> highestAltitude [0,0,0,0]\n  0\n  >>> highestAltitude [1,2,3,4]\n  10\n\n", "level": "easy"}
{"task_id": "Haskell/15", "prompt": "module Main where\n\nimport Data.List (group, sort)\n\n{- \n  Returns the sum of all unique elements in the array.\n  >>> sumOfUnique [1,2,3,2]\n  4\n  >>> sumOfUnique [1,1,1,1,1]\n  0\n  >>> sumOfUnique [1,2,3,4,5]\n  15\n  >>> sumOfUnique []\n  0\n  >>> sumOfUnique [7,7,7,7,7,8,8]\n  0\n-}\nsumOfUnique :: [Int] -> Int", "canonical_solution": "sumOfUnique nums = sum [head x | x <- group (sort nums), length x == 1]", "test": "check :: ([Int] -> Int) -> IO ()\ncheck sumOfUniqueFunc = do\n  let testCases =\n        [ ([1,2,3,2], 4),\n          ([1,1,1,1,1], 0),\n          ([1,2,3,4,5], 15),\n          ([], 0),\n          ([7,7,7,7,7,8,8], 0)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = sumOfUniqueFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check sumOfUnique", "entry_point": "sumOfUnique", "signature": "sumOfUnique :: [Int] -> Int", "docstring": " \n  Returns the sum of all unique elements in the array.\n  >>> sumOfUnique [1,2,3,2]\n  4\n  >>> sumOfUnique [1,1,1,1,1]\n  0\n  >>> sumOfUnique [1,2,3,4,5]\n  15\n  >>> sumOfUnique []\n  0\n  >>> sumOfUnique [7,7,7,7,7,8,8]\n  0\n\n", "instruction": "Write a Haskell function `sumOfUnique :: [Int] -> Int` to solve the following problem:\n \n  Returns the sum of all unique elements in the array.\n  >>> sumOfUnique [1,2,3,2]\n  4\n  >>> sumOfUnique [1,1,1,1,1]\n  0\n  >>> sumOfUnique [1,2,3,4,5]\n  15\n  >>> sumOfUnique []\n  0\n  >>> sumOfUnique [7,7,7,7,7,8,8]\n  0\n\n", "level": "easy"}
{"task_id": "Haskell/16", "prompt": "module Main where\n\nimport Data.List (sort, isInfixOf)\n\n{- \n  Checks if nums can be obtained by rotating its sorted version by some number of positions.\n  >>> isRotationPossible [3,4,5,1,2]\n  True\n  >>> isRotationPossible [2,1,3,4]\n  False\n  >>> isRotationPossible [1,2,3]\n  True\n  >>> isRotationPossible [1,1,1,2,2]\n  True\n  >>> isRotationPossible [2,3,4,5,1,1]\n  True\n-}\nisRotationPossible :: [Int] -> Bool", "canonical_solution": "isRotationPossible nums = isInfixOf nums (numsSorted ++ numsSorted)\n  where\n    numsSorted = sort nums", "test": "check :: ([Int] -> Bool) -> IO ()\ncheck isRotationPossibleFunc = do\n  let testCases =\n        [ ([3,4,5,1,2], True),\n          ([2,1,3,4], False),\n          ([1,2,3], True),\n          ([1,1,1,2,2], True),\n          ([2,3,4,5,1,1], True)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = isRotationPossibleFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check isRotationPossible", "entry_point": "isRotationPossible", "signature": "isRotationPossible :: [Int] -> Bool", "docstring": " \n  Checks if nums can be obtained by rotating its sorted version by some number of positions.\n  >>> isRotationPossible [3,4,5,1,2]\n  True\n  >>> isRotationPossible [2,1,3,4]\n  False\n  >>> isRotationPossible [1,2,3]\n  True\n  >>> isRotationPossible [1,1,1,2,2]\n  True\n  >>> isRotationPossible [2,3,4,5,1,1]\n  True\n\n", "instruction": "Write a Haskell function `isRotationPossible :: [Int] -> Bool` to solve the following problem:\n \n  Checks if nums can be obtained by rotating its sorted version by some number of positions.\n  >>> isRotationPossible [3,4,5,1,2]\n  True\n  >>> isRotationPossible [2,1,3,4]\n  False\n  >>> isRotationPossible [1,2,3]\n  True\n  >>> isRotationPossible [1,1,1,2,2]\n  True\n  >>> isRotationPossible [2,3,4,5,1,1]\n  True\n\n", "level": "easy"}
{"task_id": "Haskell/17", "prompt": "module Main where\n\n{- \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n-}\ncountMatches :: [[String]] -> String -> String -> Int", "canonical_solution": "countMatches items ruleKey ruleValue =\n  length $ filter (matchesRule ruleKey ruleValue) items\n  where\n    matchesRule key value item =\n      case key of\n        \"type\"  -> item !! 0 == value\n        \"color\" -> item !! 1 == value\n        \"name\"  -> item !! 2 == value\n        _       -> False", "test": "check :: ([[String]] -> String -> String -> Int) -> IO ()\ncheck countMatchesFunc = do\n  let testCases =\n        [ ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"color\", \"silver\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], \"type\", \"phone\", 2),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"name\", \"iphone\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"color\", \"blue\", 1),\n          ([[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], \"name\", \"lenovo\", 1)\n        ]\n\n  mapM_ (\\(items, ruleKey, ruleValue, expected) -> testCase items ruleKey ruleValue expected) testCases\n  where\n    testCase items ruleKey ruleValue expected = do\n      let result = countMatchesFunc items ruleKey ruleValue\n      putStrLn $\n        \"Input: items = \" ++ show items ++ \", ruleKey = \" ++ show ruleKey ++ \", ruleValue = \" ++ show ruleValue ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countMatches", "entry_point": "countMatches", "signature": "countMatches :: [[String]] -> String -> String -> Int", "docstring": " \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n\n", "instruction": "Write a Haskell function `countMatches :: [[String]] -> String -> String -> Int` to solve the following problem:\n \n  Counts the number of items that match the given search rule.\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"silver\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]] \"type\" \"phone\"\n  2\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"iphone\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"color\" \"blue\"\n  1\n  >>> countMatches [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]] \"name\" \"lenovo\"\n  1\n\n", "level": "hard"}
{"task_id": "Haskell/18", "prompt": "module Main where\n\nimport Data.List (intercalate)\n\n{- \n  Truncates the sentence s to contain only the first k words.\n  >>> truncateSentence \"Hello World\" 1\n  \"Hello\"\n  >>> truncateSentence \"one two three four\" 2\n  \"one two\"\n  >>> truncateSentence \"What is the solution to this problem\" 4\n  \"What is the solution\"\n  >>> truncateSentence \"HELLO\" 1\n  \"HELLO\"\n  >>> truncateSentence \"hello world hello world\" 3\n  \"hello world hello\"\n-}\ntruncateSentence :: String -> Int -> String", "canonical_solution": "truncateSentence s k = unwords $ take k $ words s", "test": "check :: (String -> Int -> String) -> IO ()\ncheck truncateSentenceFunc = do\n  let testCases =\n        [ (\"Hello World\", 1, \"Hello\"),\n          (\"one two three four\", 2, \"one two\"),\n          (\"What is the solution to this problem\", 4, \"What is the solution\"),\n          (\"HELLO\", 1, \"HELLO\"),\n          (\"hello world hello world\", 3, \"hello world hello\")\n        ]\n\n  mapM_ (\\(s, k, expected) -> testCase s k expected) testCases\n  where\n    testCase s k expected = do\n      let result = truncateSentenceFunc s k\n      putStrLn $\n        \"Input: s = \" ++ show s ++ \", k = \" ++ show k ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check truncateSentence", "entry_point": "truncateSentence", "signature": "truncateSentence :: String -> Int -> String", "docstring": " \n  Truncates the sentence s to contain only the first k words.\n  >>> truncateSentence \"Hello World\" 1\n  \"Hello\"\n  >>> truncateSentence \"one two three four\" 2\n  \"one two\"\n  >>> truncateSentence \"What is the solution to this problem\" 4\n  \"What is the solution\"\n  >>> truncateSentence \"HELLO\" 1\n  \"HELLO\"\n  >>> truncateSentence \"hello world hello world\" 3\n  \"hello world hello\"\n\n", "instruction": "Write a Haskell function `truncateSentence :: String -> Int -> String` to solve the following problem:\n \n  Truncates the sentence s to contain only the first k words.\n  >>> truncateSentence \"Hello World\" 1\n  \"Hello\"\n  >>> truncateSentence \"one two three four\" 2\n  \"one two\"\n  >>> truncateSentence \"What is the solution to this problem\" 4\n  \"What is the solution\"\n  >>> truncateSentence \"HELLO\" 1\n  \"HELLO\"\n  >>> truncateSentence \"hello world hello world\" 3\n  \"hello world hello\"\n\n", "level": "easy"}
{"task_id": "Haskell/19", "prompt": "module Main where\n\n{- \n  Defines a function signFunc that returns 1 for positive x, -1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,-2,3,4,5]\n  -1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [-1,-2,-3,-4,-5]\n  -1\n  >>> signOfProduct [1,5,0,2,-3]\n  0\n  >>> signOfProduct []\n  1\n-}\nsignOfProduct :: [Int] -> Int", "canonical_solution": "signOfProduct nums = signFunc $ product nums\nsignFunc :: Int -> Int\nsignFunc x\n  | x > 0 = 1\n  | x < 0 = -1\n  | otherwise = 0", "test": "check :: ([Int] -> Int) -> IO ()\ncheck signOfProductFunc = do\n  let testCases =\n        [ ([1,-2,3,4,5], -1),\n          ([1,2,3,4,5], 1),\n          ([-1,-2,-3,-4,-5], -1),\n          ([1,5,0,2,-3], 0),\n          ([], 1)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = signOfProductFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check signOfProduct", "entry_point": "signOfProduct", "signature": "signOfProduct :: [Int] -> Int", "docstring": " \n  Defines a function signFunc that returns 1 for positive x, 1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,5,0,2,3]\n  0\n  >>> signOfProduct []\n  1\n\n", "instruction": "Write a Haskell function `signOfProduct :: [Int] -> Int` to solve the following problem:\n \n  Defines a function signFunc that returns 1 for positive x, 1 for negative x, and 0 for x equal to 0.\n  Then calculates the product of an array and applies signFunc to the product.\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,2,3,4,5]\n  1\n  >>> signOfProduct [1,5,0,2,3]\n  0\n  >>> signOfProduct []\n  1\n\n", "level": "easy"}
{"task_id": "Haskell/20", "prompt": "module Main where\n\n{- \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n-}\nminOperationsToIncrease :: [Int] -> Int", "canonical_solution": "minOperationsToIncrease nums = snd $ foldl accumulate (head nums, 0) (tail nums)\n  where\n    accumulate (prev, ops) cur =\n      let newOps = ops + max 0 (prev + 1 - cur)\n      in (max cur (prev + 1), newOps)", "test": "check :: ([Int] -> Int) -> IO ()\ncheck minOperationsToIncreaseFunc = do\n  let testCases =\n        [ ([1,2,3], 0),\n          ([1,1,1], 3),\n          ([1,5,2,4,1], 14),\n          ([8,5,9,2,6], 20),\n          ([3], 0)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = minOperationsToIncreaseFunc nums\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check minOperationsToIncrease", "entry_point": "minOperationsToIncrease", "signature": "minOperationsToIncrease :: [Int] -> Int", "docstring": " \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n\n", "instruction": "Write a Haskell function `minOperationsToIncrease :: [Int] -> Int` to solve the following problem:\n \n  Returns the minimum number of operations needed to make the array strictly increasing.\n  >>> minOperationsToIncrease [1,2,3]\n  0\n  >>> minOperationsToIncrease [1,1,1]\n  3\n  >>> minOperationsToIncrease [1,5,2,4,1]\n  14\n  >>> minOperationsToIncrease [8,5,9,2,6]\n  12\n  >>> minOperationsToIncrease [3]\n  0\n\n", "level": "middle"}
{"task_id": "Haskell/21", "prompt": "module Main where\n\n{- \n  Finds an index i such that nums[i] == target and abs(i - start) is minimized.\n  >>> closestIndex [1,2,3,4,5] 5 3\n  4\n  >>> closestIndex [1] 1 0\n  0\n  >>> closestIndex [1,2,3,4,5,6,7,8,9,10] 5 5\n  4\n  >>> closestIndex [1,2,3,4,3,5] 3 3\n  2\n  >>> closestIndex [1,2,3,4,5,6,7,8,9,10] 7 2\n  6\n-}\nclosestIndex :: [Int] -> Int -> Int -> Int", "canonical_solution": "closestIndex nums target start = snd . minimum $ filter ((== target) . fst) $ zip nums [0..]\n  where\n    distance idx = abs (idx - start)", "test": "check :: ([Int] -> Int -> Int -> Int) -> IO ()\ncheck closestIndexFunc = do\n  let testCases =\n        [ ([1,2,3,4,5], 5, 3, 4),\n          ([1], 1, 0, 0),\n          ([1,2,3,4,5,6,7,8,9,10], 5, 5, 4),\n          ([1,2,3,4,3,5], 3, 3, 2),\n          ([1,2,3,4,5,6,7,8,9,10], 7, 2, 6)\n        ]\n\n  mapM_ (\\(nums, target, start, expected) -> testCase nums target start expected) testCases\n  where\n    testCase nums target start expected = do\n      let result = closestIndexFunc nums target start\n      putStrLn $\n        \"Input: nums = \" ++ show nums ++ \", target = \" ++ show target ++ \", start = \" ++ show start ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check closestIndex", "entry_point": "closestIndex", "signature": "closestIndex :: [Int] -> Int -> Int -> Int", "docstring": " \n  Finds an index i such that nums[i] == target and abs(i  start) is minimized.\n  >>> closestIndex [1,2,3,4,5] 5 3\n  4\n  >>> closestIndex [1] 1 0\n  0\n  >>> closestIndex [1,2,3,4,5,6,7,8,9,10] 5 5\n  4\n  >>> closestIndex [1,2,3,4,3,5] 3 3\n  2\n  >>> closestIndex [1,2,3,4,5,6,7,8,9,10] 7 2\n  6\n\n", "instruction": "Write a Haskell function `closestIndex :: [Int] -> Int -> Int -> Int` to solve the following problem:\n \n  Finds an index i such that nums[i] == target and abs(i  start) is minimized.\n  >>> closestIndex [1,2,3,4,5] 5 3\n  4\n  >>> closestIndex [1] 1 0\n  0\n  >>> closestIndex [1,2,3,4,5,6,7,8,9,10] 5 5\n  4\n  >>> closestIndex [1,2,3,4,3,5] 3 3\n  2\n  >>> closestIndex [1,2,3,4,5,6,7,8,9,10] 7 2\n  6\n\n", "level": "easy"}
{"task_id": "Haskell/22", "prompt": "module Main where\nfindCommonAwardWinners :: [Int] -> [Int] -> [Int]\n{-\nReturns a list of IDs of people who received both the Science Innovation Award and the Special Contribution Award.\nThe function takes two lists of integers: the first for IDs of Science Innovation awardees, and the second for Special Contribution awardees.\nIDs are listed in the order they appear in the Science Innovation Award list.\n\nfindCommonAwardWinners [1,2,3,4] [3,5,6]\n[3]\nfindCommonAwardWinners [10,20,30] [40,50,60]\n[]\nfindCommonAwardWinners [7,8,9,10] [10,9,8]\n[8,9,10]\nfindCommonAwardWinners [15,25,35,45] [25,35,55,65]\n[25,35]\nfindCommonAwardWinners [4,5,6] [6,7,8,9]\n[6]\n-}", "canonical_solution": "findCommonAwardWinners innovation special = filter (`elem` special) innovation", "test": "check :: ([Int] -> [Int] -> [Int]) -> IO ()\ncheck findCommonAwardWinnersFunc = do\n  let testCases =\n        [ (([1,2,3,4], [3,5,6]), [3]),\n          (([10,20,30], [40,50,60]), []),\n          (([7,8,9,10], [10,9,8]), [8,9,10]),\n          (([15,25,35,45], [25,35,55,65]), [25,35]),\n          (([4,5,6], [6,7,8,9]), [6])\n        ]\n\n  mapM_ (\\((innovation, special), expected) -> testCase innovation special expected) testCases\n  where\n    testCase innovation special expected = do\n      let result = findCommonAwardWinnersFunc innovation special\n      putStrLn $\n        \"Input: \" ++ show (innovation, special) ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check findCommonAwardWinners", "entry_point": "findCommonAwardWinners", "signature": "findCommonAwardWinners :: [Int] -> [Int] -> [Int]", "docstring": "\nReturns a list of IDs of people who received both the Science Innovation Award and the Special Contribution Award.\nThe function takes two lists of integers: the first for IDs of Science Innovation awardees, and the second for Special Contribution awardees.\nIDs are listed in the order they appear in the Science Innovation Award list.\n\nfindCommonAwardWinners [1,2,3,4] [3,5,6]\n[3]\nfindCommonAwardWinners [10,20,30] [40,50,60]\n[]\nfindCommonAwardWinners [7,8,9,10] [10,9,8]\n[8,9,10]\nfindCommonAwardWinners [15,25,35,45] [25,35,55,65]\n[25,35]\nfindCommonAwardWinners [4,5,6] [6,7,8,9]\n[6]\n", "instruction": "Write a Haskell function `findCommonAwardWinners :: [Int] -> [Int] -> [Int]` to solve the following problem:\n\nReturns a list of IDs of people who received both the Science Innovation Award and the Special Contribution Award.\nThe function takes two lists of integers: the first for IDs of Science Innovation awardees, and the second for Special Contribution awardees.\nIDs are listed in the order they appear in the Science Innovation Award list.\n\nfindCommonAwardWinners [1,2,3,4] [3,5,6]\n[3]\nfindCommonAwardWinners [10,20,30] [40,50,60]\n[]\nfindCommonAwardWinners [7,8,9,10] [10,9,8]\n[8,9,10]\nfindCommonAwardWinners [15,25,35,45] [25,35,55,65]\n[25,35]\nfindCommonAwardWinners [4,5,6] [6,7,8,9]\n[6]\n", "level": "easy"}
{"task_id": "Haskell/23", "prompt": "module Main where\nimport Data.List (find)\n\ngoldbachConjecture :: Int -> Maybe (Int, Int, Int)\n{- \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (2, 2, 23)\n\n  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n-}", "canonical_solution": "-- Checks if a number is prime\nisPrime :: Int -> Bool\nisPrime n = n > 1 && all (\\x -> n `mod` x /= 0) [2..floor . sqrt $ fromIntegral n]\n\n-- Generates a list of primes up to a given number\nprimesUpTo :: Int -> [Int]\nprimesUpTo n = filter isPrime [2..n]\n\n-- Implementation of the Goldbach Conjecture\n\ngoldbachConjecture n = find (\\(x, y, z) -> isPrime x && isPrime y && isPrime z) \n    [(x, y, n - x - y) | x <- primes, y <- primes, x <= y, y <= n - x - y]\n    where primes = primesUpTo n", "test": "check :: (Int -> Maybe (Int, Int, Int)) -> IO ()\ncheck goldbachConjectureFunc = do\n  let testCases =\n        [ (27, Just (2, 2, 23)),\n          (31, Just (3, 5, 23)),\n          (45, Just (2, 2, 41)),\n          (29, Just (3, 3, 23)),\n          (53, Just (3, 3, 47))\n        ]\n\n  mapM_ (\\(n, expected) -> testCase n expected) testCases\n  where\n    testCase n expected = do\n      let result = goldbachConjectureFunc n\n      putStrLn $\n        \"Input: \" ++ show n ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else \" (Fail)\"\n\nmain :: IO ()\nmain = check goldbachConjecture", "entry_point": "goldbachConjecture", "signature": "goldbachConjecture :: Int -> Maybe (Int, Int, Int)", "docstring": " \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (2, 2, 23)\n\n =  Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n", "instruction": "Write a Haskell function `goldbachConjecture :: Int -> Maybe (Int, Int, Int)` to solve the following problem:\n \n  Validates Goldbach's Conjecture for a given odd number greater than 9.\n  The function finds three prime numbers that sum up to the given odd number.\n  Returns Nothing if no such primes exist.\n\n  Examples:\n  >>> goldbachConjecture 27\n  Just (2, 2, 23)\n\n    Note: The function returns the first combination of primes found, prioritizing the smallest first prime.\n", "level": "hard"}
{"task_id": "Haskell/24", "prompt": "module Main where\nimport Data.List (group, sort)\ncountDigitInFactorial :: Int -> Int -> Int\n{- \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n-}", "canonical_solution": "countDigitInFactorial n a = length . filter (== intToDigit a) . show . factorial $ n\n  where\n    factorial 0 = 1\n    factorial x = x * factorial (x - 1)\n    intToDigit x = head $ show x", "test": "check :: (Int -> Int -> Int) -> IO ()\ncheck countDigitInFactorialFunc = do\n  let testCases =\n        [ ((4, 2), 1),\n          ((5, 1), 1),\n          ((10, 0), 2),\n          ((6, 3), 0),\n          ((9, 5), 0)\n        ]\n\n  mapM_ (\\((n, a), expected) -> testCase n a expected) testCases\n  where\n    testCase n a expected = do\n      let result = countDigitInFactorialFunc n a\n      putStrLn $\n        \"Input: n = \" ++ show n ++ \", a = \" ++ show a ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countDigitInFactorial", "entry_point": "countDigitInFactorial", "signature": "countDigitInFactorial :: Int -> Int -> Int", "docstring": " \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n", "instruction": "Write a Haskell function `countDigitInFactorial :: Int -> Int -> Int` to solve the following problem:\n \n  Counts the number of times a digit appears in the factorial of a number.\n  The function takes two integers, 'n' (the number to calculate the factorial of) and 'a' (the digit to count).\n  >>> countDigitInFactorial 4 2\n  1\n", "level": "middle"}
{"task_id": "Haskell/25", "prompt": "module Main where\nmisplacedLetters :: Int -> Int\n{-\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n-}", "canonical_solution": "misplacedLetters n = derangement n\n  where\n    derangement 0 = 1\n    derangement 1 = 0\n    derangement n = (n - 1) * (derangement (n - 1) + derangement (n - 2))", "test": "check :: (Int -> Int) -> IO ()\ncheck misplacedLettersFunc = do\n  let testCases =\n        [ (1, 0),\n          (4, 9),\n          (5, 44),\n          (6, 265)\n        ]\n\n  mapM_ (\\(letters, expected) -> testCase letters expected) testCases\n  where\n    testCase letters expected = do\n      let result = misplacedLettersFunc letters\n      putStrLn $\n        \"Input: \" ++ show letters ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check misplacedLetters", "entry_point": "misplacedLetters", "signature": "misplacedLetters :: Int -> Int", "docstring": "\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n", "instruction": "Write a Haskell function `misplacedLetters :: Int -> Int` to solve the following problem:\n\n  Calculates the number of ways all letters can be misplaced in envelopes.\n  A letter is considered misplaced if it's not in its corresponding envelope.\n  The function takes an integer n (number of letters and envelopes) and returns the count of all possible misplacements.\n\n  >>> misplacedLetters 1\n  0\n  >>> misplacedLetters 4\n  9\n  >>> misplacedLetters 5\n  44\n  >>> misplacedLetters 6\n  265\n", "level": "easy"}
{"task_id": "Haskell/26", "prompt": "module Main where\nimport Numeric (showIntAtBase, readInt)\nimport Data.Char (intToDigit, digitToInt)\n\nbaseAddition :: Int -> String -> String -> String\n{- \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n-}", "canonical_solution": "baseAddition base num1 num2 = \n  showIntAtBase base intToDigit (num1AsInt + num2AsInt) \"\"\n  where\n    num1AsInt = baseStringToInt base num1\n    num2AsInt = baseStringToInt base num2\n    baseStringToInt b str = fst $ head $ readInt b (const True) digitToInt str", "test": "check :: (Int -> String -> String -> String) -> IO ()\ncheck baseAdditionFunc = do\n  let testCases =\n        [ ((4, \"123\", \"321\"), \"1110\"),\n          ((2, \"1010\", \"1101\"), \"10111\"),\n          ((16, \"1A3\", \"2B4\"), \"457\"),\n          ((10, \"123\", \"456\"), \"579\"),\n          ((8, \"123\", \"456\"), \"601\")\n        ]\n\n  mapM_ (\\((base, num1, num2), expected) -> testCase base num1 num2 expected) testCases\n  where\n    testCase base num1 num2 expected = do\n      let result = baseAdditionFunc base num1 num2\n      putStrLn $\n        \"Base: \" ++ show base ++\n        \", Input 1: \" ++ num1 ++\n        \", Input 2: \" ++ num2 ++\n        \", Expected: \" ++ expected ++ \", Result: \" ++ result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check baseAddition", "entry_point": "baseAddition", "signature": "baseAddition :: Int -> String -> String -> String", "docstring": " \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n", "instruction": "Write a Haskell function `baseAddition :: Int -> String -> String -> String` to solve the following problem:\n \n  Computes the sum of two numbers in a given base.\n  The function takes the base and two strings representing the numbers in that base.\n  Returns the sum as a string in the same base.\n\n  >>> baseAddition 4 \"123\" \"321\"\n  \"1110\"\n  >>> baseAddition 2 \"1010\" \"1101\"\n  \"10111\"\n", "level": "middle"}
{"task_id": "Haskell/27", "prompt": "module Main where\nimport qualified Data.Set as Set\n\ncountMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int\n{-\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n-}", "canonical_solution": "countMazePaths n m t start end obstacles\n  | start == end = 1\n  | otherwise = sum $ map (\\next -> if Set.member next obstacles || not (isValid next)\n                                    then 0\n                                    else countMazePaths n m t next end (Set.insert start obstacles))\n                          [(sx-1, sy), (sx+1, sy), (sx, sy-1), (sx, sy+1)]\n  where\n    (sx, sy) = start\n    isValid (x, y) = x > 0 && x <= n && y > 0 && y <= m", "test": "check :: (Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int) -> IO ()\ncheck countMazePathsFunc = do\n  let testCases =\n        [ ((3, 3, 1, (1, 1), (3, 3), Set.fromList [(2, 2)]), 2),\n          ((4, 4, 2, (1, 1), (4, 4), Set.fromList [(2, 2), (3, 3)]), 4),\n          ((2, 3, 0, (1, 1), (2, 3), Set.empty), 4)\n        ]\n\n  mapM_ (\\(params, expected) -> testCase params expected) testCases\n  where\n    testCase (n, m, t, start, end, obstacles) expected = do\n      let result = countMazePathsFunc n m t start end obstacles\n      putStrLn $\n        \"Input: \" ++ show (n, m, t, start, end, obstacles) ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check countMazePaths", "entry_point": "countMazePaths", "signature": "countMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int", "docstring": "\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n", "instruction": "Write a Haskell function `countMazePaths :: Int -> Int -> Int -> (Int, Int) -> (Int, Int) -> Set.Set (Int, Int) -> Int` to solve the following problem:\n\n  Counts the number of unique paths from a start point to an end point in a maze.\n\n  The maze is represented as an N x M grid with T obstacles. \n  Obstacles are represented as a set of coordinates and are impassable.\n\n  Movement is allowed only up, down, left, or right by one grid cell at a time.\n  Each cell can be visited at most once in a path.\n\n  The function takes the dimensions of the maze (N, M), the number of obstacles (T),\n  the start coordinates (SX, SY), the end coordinates (FX, FY),\n  and a set of obstacle coordinates.\n\n  Example:\n  >>> countMazePaths 3 3 1 (1, 1) (3, 3) (Set.fromList [(2, 2)])\n  2\n", "level": "hard"}
{"task_id": "Haskell/28", "prompt": "module Main where\nimport Data.List (sort)\n\nmaxRemovableLamps :: Int -> Int -> [Int] -> Int\n{- \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n-}", "canonical_solution": "maxRemovableLamps n dist positions = length $ filter removable (tail $ init sortedPositions)\n  where\n    sortedPositions = sort positions\n    removable p = let\n      left = last $ takeWhile (< p) sortedPositions\n      right = head $ dropWhile (<= p) sortedPositions\n      in right - left <= dist", "test": "check :: (Int -> Int -> [Int] -> Int) -> IO ()\ncheck maxRemovableLampsFunc = do\n  let testCases =\n        [ (3, 3, [1, 2, 3], 1),\n          (5, 2, [1, 3, 4, 6, 8], 0),\n          (4, 5, [2, 5, 7, 12], 1),\n          (6, 4, [3, 5, 8, 12, 16, 20], 0),\n          (3, 10, [5, 15, 25], 0)\n        ]\n\n  mapM_ (\\(n, dist, positions, expected) -> testCase n dist positions expected) testCases\n  where\n    testCase n dist positions expected = do\n      let result = maxRemovableLampsFunc n dist positions\n      putStrLn $\n        \"Input: n=\" ++ show n ++ \", dist=\" ++ show dist ++ \", positions=\" ++ show positions ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check maxRemovableLamps", "entry_point": "maxRemovableLamps", "signature": "maxRemovableLamps :: Int -> Int -> [Int] -> Int", "docstring": " \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n", "instruction": "Write a Haskell function `maxRemovableLamps :: Int -> Int -> [Int] -> Int` to solve the following problem:\n \n  Calculates the maximum number of lamps that can be turned off while ensuring adequate lighting.\n  A lamp can be turned off if it's within 'dist' distance from both neighboring lamps.\n  The lamps at the start and end of the range must always be on.\n\n  >>> maxRemovableLamps 3 3 [1, 2, 3]\n  1\n", "level": "hard"}
{"task_id": "Haskell/29", "prompt": "module Main where\nmaxHerbValue :: Int -> [(Int, Int)] -> Int\n{-\n  Calculates the maximum total value of herbs that can be gathered in a given time.\n  Each herb can be picked multiple times, each having a specific time cost and value.\n  \n  >>> maxHerbValue 70 [(71, 100), (69, 1), (1, 2)]\n  140\n-}", "canonical_solution": "maxHerbValue t herbs = dp !! t\n  where\n    dp = [maximum $ 0 : [dp !! (i - time) + value | (time, value) <- herbs, i >= time] | i <- [0..t]]", "test": "check :: (Int -> [(Int, Int)] -> Int) -> IO ()\ncheck maxHerbValueFunc = do\n  let testCases =\n        [ ((70, [(71, 100), (69, 1), (1, 2)]), 140),\n          ((50, [(10, 60), (20, 100), (30, 120)]), 300),\n          ((10, [(5, 50), (3, 20), (2, 14)]), 100),\n          ((0, [(1, 10), (2, 20)]), 0),\n          ((15, [(1, 10), (2, 5), (3, 8)]), 150)\n        ]\n\n  mapM_ (\\((t, herbs), expected) -> testCase t herbs expected) testCases\n  where\n    testCase t herbs expected = do\n      let result = maxHerbValueFunc t herbs\n      putStrLn $\n        \"Input: Time=\" ++ show t ++ \", Herbs=\" ++ show herbs ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check maxHerbValue", "entry_point": "maxHerbValue", "signature": "maxHerbValue :: Int -> [(Int, Int)] -> Int", "docstring": "\n  Calculates the maximum total value of herbs that can be gathered in a given time.\n  Each herb can be picked multiple times, each having a specific time cost and value.\n  \n  >>> maxHerbValue 70 [(71, 100), (69, 1), (1, 2)]\n  140\n", "instruction": "Write a Haskell function `maxHerbValue :: Int -> [(Int, Int)] -> Int` to solve the following problem:\n\n  Calculates the maximum total value of herbs that can be gathered in a given time.\n  Each herb can be picked multiple times, each having a specific time cost and value.\n  \n  >>> maxHerbValue 70 [(71, 100), (69, 1), (1, 2)]\n  140\n", "level": "easy"}
{"task_id": "Haskell/30", "prompt": "module Main where\n\nimport Data.List (permutations, nub, sort)\n\nfindNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]\n{- \n  Finds all possible sets of three 3-digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n-}", "canonical_solution": "findNumberTriplets (a, b, c) = nub [ (x, y, z) | \n    p <- permutations [1..9], \n    let x = toNumber (take 3 p),\n    let y = toNumber (take 3 $ drop 3 p),\n    let z = toNumber (drop 6 p),\n    a * y == b * x, \n    a * z == c * x ]\n\ntoNumber :: [Int] -> Int\ntoNumber = foldl (\\acc x -> acc * 10 + x) 0", "test": "check :: ((Int, Int, Int) -> [(Int, Int, Int)]) -> IO ()\ncheck findNumberTripletsFunc = do\n  let testCases =\n        [ ((1, 2, 3), [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]),\n          ((2, 5, 7), []),\n          ((3, 3, 3), [])\n        ]\n\n  mapM_ (\\(ratios, expected) -> testCase ratios expected) testCases\n  where\n    testCase ratios expected = do\n      let result = findNumberTripletsFunc ratios\n      putStrLn $\n        \"Input: \" ++ show ratios ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if sort result == sort expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check findNumberTriplets", "entry_point": "findNumberTriplets", "signature": "findNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]", "docstring": " \n  Finds all possible sets of three 3digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n", "instruction": "Write a Haskell function `findNumberTriplets :: (Int, Int, Int) -> [(Int, Int, Int)]` to solve the following problem:\n \n  Finds all possible sets of three 3digit numbers which are permutations of 1 to 9 and are in the ratio A:B:C.\n  If no such sets exist, returns an empty list.\n\n  For example:\n  >>> findNumberTriplets (1, 2, 3)\n  [(192, 384, 576), (219, 438, 657), (273, 546, 819), (327, 654, 981)]\n  >>> findNumberTriplets (2, 5, 7)\n  []\n", "level": "hard"}
{"task_id": "Haskell/31", "prompt": "module Main where\ncollatzSequence :: Int -> [Int]\n{- \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n-}", "canonical_solution": "collatzSequence n = reverse $ collatz n\n  where\n    collatz 1 = [1]\n    collatz x\n      | even x = x : collatz (x `div` 2)\n      | otherwise = x : collatz (3 * x + 1)", "test": "check :: (Int -> [Int]) -> IO ()\ncheck collatzSequenceFunc = do\n  let testCases =\n        [ (6, [1, 2, 4, 8,16, 5, 10, 3, 6]),\n          (15, [1,2,4,8,16,5,10,20,40,80,160,53,106,35,70,23,46,15]),\n          (1, [1])\n        ]\n\n  mapM_ (\\(input, expected) -> testCase input expected) testCases\n  where\n    testCase input expected = do\n      let result = collatzSequenceFunc input\n      putStrLn $\n        \"Input: \" ++ show input ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check collatzSequence", "entry_point": "collatzSequence", "signature": "collatzSequence :: Int -> [Int]", "docstring": " \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n", "instruction": "Write a Haskell function `collatzSequence :: Int -> [Int]` to solve the following problem:\n \n  Generates the Collatz sequence for a given positive integer n.\n  The Collatz sequence starts with n and repeatedly applies the following rules:\n  If the number is odd, multiply by 3 and add 1. If the number is even, divide it by 2.\n  The sequence ends when it reaches 1.\n  \n  Examples:\n  >>> collatzSequence 6\n  [1,2,4,8,16,5,10,3,6] \n", "level": "middle"}
{"task_id": "Haskell/32", "prompt": "module Main where\nsentenceWithApples :: Int -> String\n{- \n  Generates a sentence describing the number of apples eaten.\n  If the number of apples is 1, it outputs \"Today, I ate 1 apple.\".\n  If no apples are eaten, it outputs \"Today, I ate 0 apples.\".\n  If more than one apple is eaten, it adds 's' to \"apple\".\n\n  Examples:\n  >>> sentenceWithApples 1\n  \"Today, I ate 1 apple.\"\n\n  >>> sentenceWithApples 0\n  \"Today, I ate 0 apples.\"\n\n  >>> sentenceWithApples 2\n  \"Today, I ate 2 apples.\"\n\n  >>> sentenceWithApples 5\n  \"Today, I ate 5 apples.\"\n-}", "canonical_solution": "sentenceWithApples x \n  | x == 1 = \"Today, I ate 1 apple.\"\n  | otherwise = \"Today, I ate \" ++ show x ++ \" apples.\"", "test": "check :: (Int -> String) -> IO ()\ncheck sentenceWithApplesFunc = do\n  let testCases =\n        [ (1, \"Today, I ate 1 apple.\"),\n          (0, \"Today, I ate 0 apples.\"),\n          (2, \"Today, I ate 2 apples.\"),\n          (5, \"Today, I ate 5 apples.\")\n        ]\n\n  mapM_ (\\(apples, expected) -> testCase apples expected) testCases\n  where\n    testCase apples expected = do\n      let result = sentenceWithApplesFunc apples\n      putStrLn $\n        \"Input: \" ++ show apples ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check sentenceWithApples", "entry_point": "sentenceWithApples", "signature": "sentenceWithApples :: Int -> String", "docstring": " \n  Generates a sentence describing the number of apples eaten.\n  If the number of apples is 1, it outputs \"Today, I ate 1 apple.\".\n  If no apples are eaten, it outputs \"Today, I ate 0 apples.\".\n  If more than one apple is eaten, it adds 's' to \"apple\".\n\n  Examples:\n  >>> sentenceWithApples 1\n  \"Today, I ate 1 apple.\"\n\n  >>> sentenceWithApples 0\n  \"Today, I ate 0 apples.\"\n\n  >>> sentenceWithApples 2\n  \"Today, I ate 2 apples.\"\n\n  >>> sentenceWithApples 5\n  \"Today, I ate 5 apples.\"\n", "instruction": "Write a Haskell function `sentenceWithApples :: Int -> String` to solve the following problem:\n \n  Generates a sentence describing the number of apples eaten.\n  If the number of apples is 1, it outputs \"Today, I ate 1 apple.\".\n  If no apples are eaten, it outputs \"Today, I ate 0 apples.\".\n  If more than one apple is eaten, it adds 's' to \"apple\".\n\n  Examples:\n  >>> sentenceWithApples 1\n  \"Today, I ate 1 apple.\"\n\n  >>> sentenceWithApples 0\n  \"Today, I ate 0 apples.\"\n\n  >>> sentenceWithApples 2\n  \"Today, I ate 2 apples.\"\n\n  >>> sentenceWithApples 5\n  \"Today, I ate 5 apples.\"\n", "level": "easy"}
{"task_id": "Haskell/33", "prompt": "module Main where\nconfigureMethod :: Int -> String\n{- \n  Determines the more time-efficient method for configuring problems, either locally or using Luogu.\n  The local configuration takes 5 minutes per problem, while Luogu takes 3 minutes per problem plus a one-time 11-minute setup.\n  >>> configureMethod 1\n  \"Local\"\n-}", "canonical_solution": "configureMethod n = \n  if 5 * n < 3 * n + 11 then \"Local\" else \"Luogu\"", "test": "check :: (Int -> String) -> IO ()\ncheck configureMethodFunc = do\n  let testCases = \n        [ (1, \"Local\"),\n          (4, \"Local\"),\n          (10, \"Luogu\"),\n          (3, \"Local\"),\n          (20, \"Luogu\")\n        ]\n\n  mapM_ (\\(problems, expected) -> testCase problems expected) testCases\n  where\n    testCase problems expected = do\n      let result = configureMethodFunc problems\n      putStrLn $\n        \"Input: \" ++ show problems ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check configureMethod", "entry_point": "configureMethod", "signature": "configureMethod :: Int -> String", "docstring": " \n  Determines the more timeefficient method for configuring problems, either locally or using Luogu.\n  The local configuration takes 5 minutes per problem, while Luogu takes 3 minutes per problem plus a onetime 11minute setup.\n  >>> configureMethod 1\n  \"Local\"\n", "instruction": "Write a Haskell function `configureMethod :: Int -> String` to solve the following problem:\n \n  Determines the more timeefficient method for configuring problems, either locally or using Luogu.\n  The local configuration takes 5 minutes per problem, while Luogu takes 3 minutes per problem plus a onetime 11minute setup.\n  >>> configureMethod 1\n  \"Local\"\n", "level": "easy"}
{"task_id": "Haskell/34", "prompt": "module Main where\nsortIntegers :: (Int, Int, Int) -> (Int, Int, Int)\n{- \n  Sorts three integers in ascending order.\n  Takes a tuple of three integers and returns a tuple of these integers sorted.\n  \n  Examples:\n  >>> sortIntegers (1, 14, 5)\n  (1, 5, 14)\n  >>> sortIntegers (2, 2, 2)\n  (2, 2, 2)\n  >>> sortIntegers (9, 4, 7)\n  (4, 7, 9)\n  >>> sortIntegers (15, 11, 12)\n  (11, 12, 15)\n  >>> sortIntegers (5, 3, 8)\n  (3, 5, 8)\n-}", "canonical_solution": "sortIntegers (a, b, c) = (minimum [a, b, c], middle [a, b, c], maximum [a, b, c])\n  where\n    middle lst = head $ filter (\\x -> x /= minimum lst && x /= maximum lst) lst ++ [minimum lst]", "test": "check :: ((Int, Int, Int) -> (Int, Int, Int)) -> IO ()\ncheck sortIntegersFunc = do\n  let testCases =\n        [ ((1, 14, 5), (1, 5, 14)),\n          ((2, 2, 2), (2, 2, 2)),\n          ((9, 4, 7), (4, 7, 9)),\n          ((15, 11, 12), (11, 12, 15)),\n          ((5, 3, 8), (3, 5, 8))\n        ]\n\n  mapM_ (\\(inputs, expected) -> testCase inputs expected) testCases\n  where\n    testCase inputs expected = do\n      let result = sortIntegersFunc inputs\n      putStrLn $\n        \"Input: \" ++ show inputs ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check sortIntegers", "entry_point": "sortIntegers", "signature": "sortIntegers :: (Int, Int, Int) -> (Int, Int, Int)", "docstring": " \n  Sorts three integers in ascending order.\n  Takes a tuple of three integers and returns a tuple of these integers sorted.\n  \n  Examples:\n  >>> sortIntegers (1, 14, 5)\n  (1, 5, 14)\n  >>> sortIntegers (2, 2, 2)\n  (2, 2, 2)\n  >>> sortIntegers (9, 4, 7)\n  (4, 7, 9)\n  >>> sortIntegers (15, 11, 12)\n  (11, 12, 15)\n  >>> sortIntegers (5, 3, 8)\n  (3, 5, 8)\n", "instruction": "Write a Haskell function `sortIntegers :: (Int, Int, Int) -> (Int, Int, Int)` to solve the following problem:\n \n  Sorts three integers in ascending order.\n  Takes a tuple of three integers and returns a tuple of these integers sorted.\n  \n  Examples:\n  >>> sortIntegers (1, 14, 5)\n  (1, 5, 14)\n  >>> sortIntegers (2, 2, 2)\n  (2, 2, 2)\n  >>> sortIntegers (9, 4, 7)\n  (4, 7, 9)\n  >>> sortIntegers (15, 11, 12)\n  (11, 12, 15)\n  >>> sortIntegers (5, 3, 8)\n  (3, 5, 8)\n", "level": "middle"}
{"task_id": "Haskell/35", "prompt": "module Main where\ndaysInMonth :: Int -> Int -> Int\n{- \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n-}", "canonical_solution": "isLeapYear :: Int -> Bool\nisLeapYear year = (year `mod` 4 == 0 && year `mod` 100 /= 0) || year `mod` 400 == 0\n\ndaysInMonth year month\n  | month `elem` [1, 3, 5, 7, 8, 10, 12] = 31\n  | month `elem` [4, 6, 9, 11]           = 30\n  | month == 2 && isLeapYear year        = 29\n  | otherwise                             = 28", "test": "check :: (Int -> Int -> Int) -> IO ()\ncheck daysInMonthFunc = do\n  let testCases =\n        [ ((2021, 2), 28),\n          ((2024, 2), 29),\n          ((2021, 4), 30),\n          ((2021, 12), 31),\n          ((1900, 2), 28),\n          ((2000, 2), 29)\n        ]\n\n  mapM_ (\\((year, month), expected) -> testCase year month expected) testCases\n  where\n    testCase year month expected = do\n      let result = daysInMonthFunc year month\n      putStrLn $\n        \"Input: Year \" ++ show year ++ \" Month \" ++ show month ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check daysInMonth", "entry_point": "daysInMonth", "signature": "daysInMonth :: Int -> Int -> Int", "docstring": " \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n", "instruction": "Write a Haskell function `daysInMonth :: Int -> Int -> Int` to solve the following problem:\n \n  Returns the number of days in a given month of a specified year.\n  The function takes into account leap years.\n  >>> daysInMonth 2021 2\n  28\n  >>> daysInMonth 2024 2\n  29\n  >>> daysInMonth 2021 4\n  30\n  >>> daysInMonth 2021 12\n  31\n", "level": "hard"}
{"task_id": "Haskell/36", "prompt": "module Main where\nfindMinimum :: [Int] -> Int\n{- \n  Returns the smallest integer from a list of integers.\n  The function takes a list of non-negative integers and returns the minimum value.\n  >>> findMinimum [10, 20, 5, 8]\n  5\n  >>> findMinimum [4, 3, 2, 1]\n  1\n  >>> findMinimum [15, 22, 8, 9, 6]\n  6\n  >>> findMinimum [33, 17, 45, 19]\n  17\n  >>> findMinimum [7, 7, 7, 7, 7]\n  7\n-}", "canonical_solution": "findMinimum = minimum", "test": "check :: ([Int] -> Int) -> IO ()\ncheck findMinimumFunc = do\n  let testCases =\n        [ ([10, 20, 5, 8], 5),\n          ([4, 3, 2, 1], 1),\n          ([15, 22, 8, 9, 6], 6),\n          ([33, 17, 45, 19], 17),\n          ([7, 7, 7, 7, 7], 7)\n        ]\n\n  mapM_ (\\(nums, expected) -> testCase nums expected) testCases\n  where\n    testCase nums expected = do\n      let result = findMinimumFunc nums\n      putStrLn $\n        \"Input: \" ++ show nums ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check findMinimum", "entry_point": "findMinimum", "signature": "findMinimum :: [Int] -> Int", "docstring": " \n  Returns the smallest integer from a list of integers.\n  The function takes a list of nonnegative integers and returns the minimum value.\n  >>> findMinimum [10, 20, 5, 8]\n  5\n  >>> findMinimum [4, 3, 2, 1]\n  1\n  >>> findMinimum [15, 22, 8, 9, 6]\n  6\n  >>> findMinimum [33, 17, 45, 19]\n  17\n  >>> findMinimum [7, 7, 7, 7, 7]\n  7\n", "instruction": "Write a Haskell function `findMinimum :: [Int] -> Int` to solve the following problem:\n \n  Returns the smallest integer from a list of integers.\n  The function takes a list of nonnegative integers and returns the minimum value.\n  >>> findMinimum [10, 20, 5, 8]\n  5\n  >>> findMinimum [4, 3, 2, 1]\n  1\n  >>> findMinimum [15, 22, 8, 9, 6]\n  6\n  >>> findMinimum [33, 17, 45, 19]\n  17\n  >>> findMinimum [7, 7, 7, 7, 7]\n  7\n", "level": "easy"}
{"task_id": "Haskell/37", "prompt": "module Main where\n\naverageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)\n{- \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n  -- 2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n  -- 1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n-}", "canonical_solution": "averageOfDivisibleAndNonDivisible n k = (average aClass, average bClass)\n  where\n    numbers = [1..n]\n    aClass = filter (\\x -> x `mod` k == 0) numbers\n    bClass = filter (\\x -> x `mod` k /= 0) numbers\n    average xs = fromIntegral (sum xs) / fromIntegral (length xs)", "test": "check :: (Int -> Int -> (Float, Float)) -> IO ()\ncheck averageFunc = do\n  let testCases =\n        [ ((10, 2), (6.0, 5.0)),\n          ((15, 5), (10.0, 7.5)),\n          ((20, 4), (12.0, 10.0)),\n          ((9, 3), (6.0, 4.5))\n        ]\n\n  mapM_ (\\((n, k), (expectedA, expectedB)) -> testCase n k expectedA expectedB) testCases\n  where\n    testCase n k expectedA expectedB = do\n      let (resultA, resultB) = averageFunc n k\n      putStrLn $\n        \"Input: \" ++ show (n, k) ++\n        \", Expected A: \" ++ show expectedA ++ \", Result A: \" ++ show resultA ++\n        \", Expected B: \" ++ show expectedB ++ \", Result B: \" ++ show resultB ++\n        if (resultA, resultB) == (expectedA, expectedB) then \" (Pass)\" else error \"Test failed. Exiting...\"\nmain :: IO ()\nmain = check averageOfDivisibleAndNonDivisible", "entry_point": "averageOfDivisibleAndNonDivisible", "signature": "averageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)", "docstring": " \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n   2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n   1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n", "instruction": "Write a Haskell function `averageOfDivisibleAndNonDivisible :: Int -> Int -> (Float, Float)` to solve the following problem:\n \n  Calculates the average of numbers up to 'n' that are divisible by 'k' (A class)\n  and those that are not (B class). Returns a tuple of two Floats representing\n  the averages of A class and B class numbers, respectively.\n  \n  Example:\n  >>> averageOfDivisibleAndNonDivisible 10 2\n  (6.0, 5.0)\n   2, 4, 6, 8, 10 are divisible by 2 (A class) and their average is 6.0.\n   1, 3, 5, 7, 9 are not divisible by 2 (B class) and their average is 5.0.\n\n", "level": "hard"}
{"task_id": "Haskell/38", "prompt": "module Main where\ndaysToLengthOne :: Int -> Int\n{- \n  Calculates the number of days it takes for a stick of length 'a' to reduce to length 1.\n  Each day, the length of the stick is halved (rounded down).\n  Examples:\n  >>> daysToLengthOne 100\n  7\n  >>> daysToLengthOne 50\n  6\n  >>> daysToLengthOne 25\n  5\n  >>> daysToLengthOne 10\n  4\n  >>> daysToLengthOne 5\n  3\n  >>> daysToLengthOne 3\n  2\n  >>> daysToLengthOne 1\n  1\n-}", "canonical_solution": "daysToLengthOne a = length . takeWhile (>=1) . iterate (`div` 2) $ a", "test": "check :: (Int -> Int) -> IO ()\ncheck daysToLengthOneFunc = do\n  let testCases =\n        [ (100, 7),\n          (50, 6),\n          (25, 5),\n          (10, 4),\n          (5, 3),\n          (3, 2),\n          (1, 1)\n        ]\n\n  mapM_ (\\(length, expectedDays) -> testCase length expectedDays) testCases\n  where\n    testCase length expectedDays = do\n      let result = daysToLengthOneFunc length\n      putStrLn $\n        \"Initial Length: \" ++ show length ++\n        \", Expected Days: \" ++ show expectedDays ++ \", Result: \" ++ show result ++\n        if result == expectedDays then \" (Pass)\" else error \"Test failed. Exiting...\" ++ show result\n      \n\nmain :: IO ()\nmain = check daysToLengthOne", "entry_point": "daysToLengthOne", "signature": "daysToLengthOne :: Int -> Int", "docstring": " \n  Calculates the number of days it takes for a stick of length 'a' to reduce to length 1.\n  Each day, the length of the stick is halved (rounded down).\n  Examples:\n  >>> daysToLengthOne 100\n  7\n  >>> daysToLengthOne 50\n  6\n  >>> daysToLengthOne 25\n  5\n  >>> daysToLengthOne 10\n  4\n  >>> daysToLengthOne 5\n  3\n  >>> daysToLengthOne 3\n  2\n  >>> daysToLengthOne 1\n  1\n", "instruction": "Write a Haskell function `daysToLengthOne :: Int -> Int` to solve the following problem:\n \n  Calculates the number of days it takes for a stick of length 'a' to reduce to length 1.\n  Each day, the length of the stick is halved (rounded down).\n  Examples:\n  >>> daysToLengthOne 100\n  7\n  >>> daysToLengthOne 50\n  6\n  >>> daysToLengthOne 25\n  5\n  >>> daysToLengthOne 10\n  4\n  >>> daysToLengthOne 5\n  3\n  >>> daysToLengthOne 3\n  2\n  >>> daysToLengthOne 1\n  1\n", "level": "easy"}
{"task_id": "Haskell/39", "prompt": "module Main where\nsumSeries :: Int -> Int\n{- \n  Calculates the sum of the series 1 + 2 + 3 + ... + n, where n is a positive integer not greater than 100.\n  The function uses a loop to accumulate the sum.\n\n  Examples:\n  >>> sumSeries 5\n  15\n  >>> sumSeries 10\n  55\n  >>> sumSeries 20\n  210\n  >>> sumSeries 1\n  1\n  >>> sumSeries 50\n  1275\n-}", "canonical_solution": "sumSeries n = sum [1..n]", "test": "check :: (Int -> Int) -> IO ()\ncheck sumSeriesFunc = do\n  let testCases =\n        [ (5, 15),\n          (10, 55),\n          (20, 210),\n          (1, 1),\n          (50, 1275)\n        ]\n\n  mapM_ (\\(n, expected) -> testCase n expected) testCases\n  where\n    testCase n expected = do\n      let result = sumSeriesFunc n\n      putStrLn $\n        \"Input: \" ++ show n ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check sumSeries", "entry_point": "sumSeries", "signature": "sumSeries :: Int -> Int", "docstring": " \n  Calculates the sum of the series 1 + 2 + 3 + ... + n, where n is a positive integer not greater than 100.\n  The function uses a loop to accumulate the sum.\n\n  Examples:\n  >>> sumSeries 5\n  15\n  >>> sumSeries 10\n  55\n  >>> sumSeries 20\n  210\n  >>> sumSeries 1\n  1\n  >>> sumSeries 50\n  1275\n", "instruction": "Write a Haskell function `sumSeries :: Int -> Int` to solve the following problem:\n \n  Calculates the sum of the series 1 + 2 + 3 + ... + n, where n is a positive integer not greater than 100.\n  The function uses a loop to accumulate the sum.\n\n  Examples:\n  >>> sumSeries 5\n  15\n  >>> sumSeries 10\n  55\n  >>> sumSeries 20\n  210\n  >>> sumSeries 1\n  1\n  >>> sumSeries 50\n  1275\n", "level": "easy"}
{"task_id": "Haskell/40", "prompt": "module Main where\nrangeDifference :: [Int] -> Int\n{- \n  Calculates the range difference (extreme difference) of a list of integers.\n  The range difference is defined as the maximum value minus the minimum value in the list.\n  >>> rangeDifference [7, 3, 9, 5]\n  6\n  >>> rangeDifference [10, 20, 30, 40, 50]\n  40\n  >>> rangeDifference [15]\n  0\n  >>> rangeDifference [1, 1, 1, 1]\n  0\n  >>> rangeDifference [8, 6, 7, 5, 3, 0, 9]\n  9\n-}", "canonical_solution": "rangeDifference xs = maximum xs - minimum xs", "test": "check :: ([Int] -> Int) -> IO ()\ncheck rangeDifferenceFunc = do\n  let testCases =\n        [ ([7, 3, 9, 5], 6),\n          ([10, 20, 30, 40, 50], 40),\n          ([15], 0),\n          ([1, 1, 1, 1], 0),\n          ([8, 6, 7, 5, 3, 0, 9], 9)\n        ]\n\n  mapM_ (\\(ints, expected) -> testCase ints expected) testCases\n  where\n    testCase ints expected = do\n      let result = rangeDifferenceFunc ints\n      putStrLn $\n        \"Input: \" ++ show ints ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check rangeDifference", "entry_point": "rangeDifference", "signature": "rangeDifference :: [Int] -> Int", "docstring": " \n  Calculates the range difference (extreme difference) of a list of integers.\n  The range difference is defined as the maximum value minus the minimum value in the list.\n  >>> rangeDifference [7, 3, 9, 5]\n  6\n  >>> rangeDifference [10, 20, 30, 40, 50]\n  40\n  >>> rangeDifference [15]\n  0\n  >>> rangeDifference [1, 1, 1, 1]\n  0\n  >>> rangeDifference [8, 6, 7, 5, 3, 0, 9]\n  9\n", "instruction": "Write a Haskell function `rangeDifference :: [Int] -> Int` to solve the following problem:\n \n  Calculates the range difference (extreme difference) of a list of integers.\n  The range difference is defined as the maximum value minus the minimum value in the list.\n  >>> rangeDifference [7, 3, 9, 5]\n  6\n  >>> rangeDifference [10, 20, 30, 40, 50]\n  40\n  >>> rangeDifference [15]\n  0\n  >>> rangeDifference [1, 1, 1, 1]\n  0\n  >>> rangeDifference [8, 6, 7, 5, 3, 0, 9]\n  9\n", "level": "easy"}
{"task_id": "Haskell/41", "prompt": "absoluteValue :: Int -> Int\n{- \n  Returns the absolute value of an integer.\n  The input integer's absolute value must not exceed 10000.\n  \n  Examples:\n  >>> absoluteValue (-3)\n  3\n  >>> absoluteValue 5\n  5\n  >>> absoluteValue 0\n  0\n-}", "canonical_solution": "absoluteValue n = if n < 0 then -n else n", "test": "check :: (Int -> Int) -> IO ()\ncheck absoluteValueFunc = do\n  let testCases = \n        [ (-3, 3),\n          (5, 5),\n          (0, 0),\n          (-10000, 10000),\n          (9999, 9999)\n        ]\n\n  mapM_ (\\(number, expected) -> testCase number expected) testCases\n  where\n    testCase number expected = do\n      let result = absoluteValueFunc number\n      putStrLn $\n        \"Input: \" ++ show number ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check absoluteValue", "entry_point": "absoluteValue", "signature": "absoluteValue :: Int -> Int", "docstring": " \nReturns the absolute value of an integer.\nThe input integer's absolute value must not exceed 10000.\n\nExamples:\n>>> absoluteValue (-3)\n3\n>>> absoluteValue 5\n5\n>>> absoluteValue 0\n0\n", "instruction": "Write a Haskell function `absoluteValue :: Int -> Int` to solve the following problem: \nReturns the absolute value of an integer.\nThe input integer's absolute value must not exceed 10000.\n\nExamples:\n>>> absoluteValue (-3)\n3\n>>> absoluteValue 5\n5\n>>> absoluteValue 0\n0\n", "level": "easy"}
{"task_id": "Haskell/42", "prompt": "signOfNumber :: Int -> String\n{- \n  Determines whether a given integer is positive, negative, or zero.\n  Returns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n  \n  Examples:\n  >>> signOfNumber 95\n  \"positive\"\n  >>> signOfNumber (-5)\n  \"negative\"\n  >>> signOfNumber 0\n  \"zero\"\n-}", "canonical_solution": "signOfNumber n\n  | n > 0 = \"positive\"\n  | n == 0 = \"zero\"\n  | otherwise = \"negative\"", "test": "check :: (Int -> String) -> IO ()\ncheck signOfNumberFunc = do\n  let testCases = \n        [ (95, \"positive\"),\n          (-5, \"negative\"),\n          (0, \"zero\"),\n          (-1000000000, \"negative\"),\n          (1000000000, \"positive\")\n        ]\n\n  mapM_ (\\(number, expected) -> testCase number expected) testCases\n  where\n    testCase number expected = do\n      let result = signOfNumberFunc number\n      putStrLn $\n        \"Input: \" ++ show number ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check signOfNumber", "entry_point": "signOfNumber", "signature": "signOfNumber :: Int -> String", "docstring": " \nDetermines whether a given integer is positive, negative, or zero.\nReturns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n\nExamples:\n>>> signOfNumber 95\n\"positive\"\n>>> signOfNumber (-5)\n\"negative\"\n>>> signOfNumber 0\n\"zero\"\n", "instruction": "Write a Haskell function `signOfNumber :: Int -> String` to solve the following problem: \nDetermines whether a given integer is positive, negative, or zero.\nReturns \"positive\" if the number is greater than zero, \"negative\" if less than zero, and \"zero\" if the number is exactly zero.\n\nExamples:\n>>> signOfNumber 95\n\"positive\"\n>>> signOfNumber (-5)\n\"negative\"\n>>> signOfNumber 0\n\"zero\"\n", "level": "easy"}
{"task_id": "Haskell/43", "prompt": "powerOfTwo :: Int -> Int\n{- \n  Calculates 2 raised to the power of a given non-negative integer.\n  The input integer n should satisfy 0 <= n < 31 to avoid integer overflow.\n  \n  Examples:\n  >>> powerOfTwo 3\n  8\n  >>> powerOfTwo 5\n  32\n  >>> powerOfTwo 0\n  1\n-}", "canonical_solution": "powerOfTwo n = 2 ^ n", "test": "check :: (Int -> Int) -> IO ()\ncheck powerOfTwoFunc = do\n  let testCases = \n        [ (3, 8),\n          (5, 32),\n          (0, 1),\n          (10, 1024),\n          (30, 1073741824)\n        ]\n\n  mapM_ (\\(number, expected) -> testCase number expected) testCases\n  where\n    testCase number expected = do\n      let result = powerOfTwoFunc number\n      putStrLn $\n        \"Input: \" ++ show number ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check powerOfTwo", "entry_point": "powerOfTwo", "signature": "powerOfTwo :: Int -> Int", "docstring": " \nCalculates 2 raised to the power of a given non-negative integer.\nThe input integer n should satisfy 0 <= n < 31 to avoid integer overflow.\n\nExamples:\n>>> powerOfTwo 3\n8\n>>> powerOfTwo 5\n32\n>>> powerOfTwo 0\n1\n", "instruction": "Write a Haskell function `powerOfTwo :: Int -> Int` to solve the following problem: \nCalculates 2 raised to the power of a given non-negative integer.\nThe input integer n should satisfy 0 <= n < 31 to avoid integer overflow.\n\nExamples:\n>>> powerOfTwo 3\n8\n>>> powerOfTwo 5\n32\n>>> powerOfTwo 0\n1\n", "level": "easy"}
{"task_id": "Haskell/44", "prompt": "multiply :: Int -> Int -> Int\n{- \n  Calculates the product of two positive integers.\n  Takes two integers A and B as input, where 1 <= A, B <= 50000, and returns their product.\n  \n  Examples:\n  >>> multiply 3 4\n  12\n  >>> multiply 36 18\n  648\n  >>> multiply 1 50000\n  50000\n-}", "canonical_solution": "multiply a b = a * b", "test": "check :: (Int -> Int -> Int) -> IO ()\ncheck multiplyFunc = do\n  let testCases = \n        [ ((3, 4), 12),\n          ((36, 18), 648),\n          ((1, 50000), 50000),\n          ((123, 456), 56088),\n          ((50000, 50000), 2500000000)\n        ]\n\n  mapM_ (\\((a, b), expected) -> testCase a b expected) testCases\n  where\n    testCase a b expected = do\n      let result = multiplyFunc a b\n      putStrLn $\n        \"Input: \" ++ show a ++ \" * \" ++ show b ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check multiply", "entry_point": "multiply", "signature": "multiply :: Int -> Int -> Int", "docstring": " \nCalculates the product of two positive integers.\nTakes two integers A and B as input, where 1 <= A, B <= 50000, and returns their product.\n\nExamples:\n>>> multiply 3 4\n12\n>>> multiply 36 18\n648\n>>> multiply 1 50000\n50000\n", "instruction": "Write a Haskell function `multiply :: Int -> Int -> Int` to solve the following problem: \nCalculates the product of two positive integers.\nTakes two integers A and B as input, where 1 <= A, B <= 50000, and returns their product.\n\nExamples:\n>>> multiply 3 4\n12\n>>> multiply 36 18\n648\n>>> multiply 1 50000\n50000\n", "level": "easy"}
{"task_id": "Haskell/45", "prompt": "nthTerm :: Int -> Int -> Int -> Int\n{- \n  Calculates the nth term of an arithmetic sequence given the first two terms and the term number.\n  The difference between any two consecutive terms is constant.\n  Takes three integers as input: the first term a1, the second term a2, and the term number n.\n  The values of a1 and a2 are within the range [-100, 100], and n is in the range [1, 1000].\n  \n  Examples:\n  >>> nthTerm 1 4 100\n  298\n  >>> nthTerm 5 7 10\n  23\n  >>> nthTerm -3 1 5\n  11\n-}", "canonical_solution": "nthTerm a1 a2 n = a1 + (n - 1) * d\n  where d = a2 - a1", "test": "check :: (Int -> Int -> Int -> Int) -> IO ()\ncheck nthTermFunc = do\n  let testCases = \n        [ ((1, 4, 100), 298),\n          ((5, 7, 10), 23),\n          ((-3, 1, 5), 13),\n          ((0, 2, 50), 98)\n        ]\n\n  mapM_ (\\((a1, a2, n), expected) -> testCase a1 a2 n expected) testCases\n  where\n    testCase a1 a2 n expected = do\n      let result = nthTermFunc a1 a2 n\n      putStrLn $\n        \"Input: a1=\" ++ show a1 ++ \", a2=\" ++ show a2 ++ \", n=\" ++ show n ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check nthTerm", "entry_point": "nthTerm", "signature": "nthTerm :: Int -> Int -> Int -> Int", "docstring": " \nCalculates the nth term of an arithmetic sequence given the first two terms and the term number.\nThe difference between any two consecutive terms is constant.\nTakes three integers as input: the first term a1, the second term a2, and the term number n.\nThe values of a1 and a2 are within the range [-100, 100], and n is in the range [1, 1000].\n\nExamples:\n>>> nthTerm 1 4 100\n298\n>>> nthTerm 5 7 10\n23\n>>> nthTerm -3 1 5\n11\n", "instruction": "Write a Haskell function `nthTerm :: Int -> Int -> Int -> Int` to solve the following problem: \nCalculates the nth term of an arithmetic sequence given the first two terms and the term number.\nThe difference between any two consecutive terms is constant.\nTakes three integers as input: the first term a1, the second term a2, and the term number n.\nThe values of a1 and a2 are within the range [-100, 100], and n is in the range [1, 1000].\n\nExamples:\n>>> nthTerm 1 4 100\n298\n>>> nthTerm 5 7 10\n23\n>>> nthTerm -3 1 5\n11\n", "level": "easy"}
{"task_id": "Haskell/46", "prompt": "reverseThreeDigit :: Int -> Int\n{- \n  Reverses a three-digit integer.\n  Takes a three-digit integer as input and returns a new integer that is the reverse of the input.\n  Note: The input will always be a three-digit number, including numbers with leading zeros.\n  \n  Examples:\n  >>> reverseThreeDigit 358\n  853\n  >>> reverseThreeDigit 100\n  1\n  >>> reverseThreeDigit 678\n  876\n-}", "canonical_solution": "reverseThreeDigit n = (n `mod` 10) * 100 + (n `div` 10 `mod` 10) * 10 + (n `div` 100)", "test": "check :: (Int -> Int) -> IO ()\ncheck reverseThreeDigitFunc = do\n  let testCases = \n        [ (358, 853),\n          (100, 1),\n          (678, 876),\n          (250, 52),\n          (999, 999)\n        ]\n\n  mapM_ (\\(number, expected) -> testCase number expected) testCases\n  where\n    testCase number expected = do\n      let result = reverseThreeDigitFunc number\n      putStrLn $\n        \"Input: \" ++ show number ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check reverseThreeDigit", "entry_point": "reverseThreeDigit", "signature": "reverseThreeDigit :: Int -> Int", "docstring": " \nReverses a three-digit integer.\nTakes a three-digit integer as input and returns a new integer that is the reverse of the input.\nNote: The input will always be a three-digit number, including numbers with leading zeros.\n\nExamples:\n>>> reverseThreeDigit 358\n853\n>>> reverseThreeDigit 100\n1\n>>> reverseThreeDigit 678\n876\n", "instruction": "Write a Haskell function `reverseThreeDigit :: Int -> Int` to solve the following problem: \nReverses a three-digit integer.\nTakes a three-digit integer as input and returns a new integer that is the reverse of the input.\nNote: The input will always be a three-digit number, including numbers with leading zeros.\n\nExamples:\n>>> reverseThreeDigit 358\n853\n>>> reverseThreeDigit 100\n1\n>>> reverseThreeDigit 678\n876\n", "level": "easy"}
{"task_id": "Haskell/47", "prompt": "intBoolIntConversion :: Int -> Int\n{- \n  Converts an integer to a boolean and then back to an integer.\n  In Haskell, the boolean value True can be considered as 1, and False as 0.\n  This function takes an integer as input; if the integer is non-zero, it is considered True (and thus converts to 1),\n  otherwise, if it is 0, it is considered False (and converts to 0).\n  \n  Examples:\n  >>> intBoolIntConversion 3\n  1\n  >>> intBoolIntConversion 0\n  0\n  >>> intBoolIntConversion -5\n  1\n-}", "canonical_solution": "intBoolIntConversion n = if n == 0 then 0 else 1", "test": "check :: (Int -> Int) -> IO ()\ncheck intBoolIntConversionFunc = do\n  let testCases = \n        [ (3, 1),\n          (0, 0),\n          (-5, 1),\n          (100, 1),\n          (-100, 1)\n        ]\n\n  mapM_ (\\(number, expected) -> testCase number expected) testCases\n  where\n    testCase number expected = do\n      let result = intBoolIntConversionFunc number\n      putStrLn $\n        \"Input: \" ++ show number ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check intBoolIntConversion", "entry_point": "intBoolIntConversion", "signature": "intBoolIntConversion :: Int -> Int", "docstring": " \nConverts an integer to a boolean and then back to an integer.\nIn Haskell, the boolean value True can be considered as 1, and False as 0.\nThis function takes an integer as input; if the integer is non-zero, it is considered True (and thus converts to 1),\notherwise, if it is 0, it is considered False (and converts to 0).\n\nExamples:\n>>> intBoolIntConversion 3\n1\n>>> intBoolIntConversion 0\n0\n>>> intBoolIntConversion -5\n1\n", "instruction": "Write a Haskell function `intBoolIntConversion :: Int -> Int` to solve the following problem: \nConverts an integer to a boolean and then back to an integer.\nIn Haskell, the boolean value True can be considered as 1, and False as 0.\nThis function takes an integer as input; if the integer is non-zero, it is considered True (and thus converts to 1),\notherwise, if it is 0, it is considered False (and converts to 0).\n\nExamples:\n>>> intBoolIntConversion 3\n1\n>>> intBoolIntConversion 0\n0\n>>> intBoolIntConversion -5\n1\n", "level": "easy"}
{"task_id": "Haskell/48", "prompt": "import Data.Char (chr)\n\nasciiToChar :: Int -> Char\n{- \n  Converts an ASCII code to its corresponding character.\n  Takes an integer representing the ASCII code as input and returns the character that corresponds to that ASCII code.\n  The input is guaranteed to be within the range of visible ASCII characters (greater than 0 and less than 128).\n  \n  Examples:\n  >>> asciiToChar 65\n  'A'\n  >>> asciiToChar 97\n  'a'\n  >>> asciiToChar 48\n  '0'\n-}\n", "canonical_solution": "asciiToChar = chr", "test": "check :: (Int -> Char) -> IO ()\ncheck asciiToCharFunc = do\n  let testCases = \n        [ (65, 'A'),\n          (97, 'a'),\n          (48, '0'),\n          (36, '$'),\n          (57, '9')\n        ]\n\n  mapM_ (\\(code, expected) -> testCase code expected) testCases\n  where\n    testCase code expected = do\n      let result = asciiToCharFunc code\n      putStrLn $\n        \"Input: \" ++ show code ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check asciiToChar", "entry_point": "asciiToChar", "signature": "asciiToChar :: Int -> Char", "docstring": " \nConverts an ASCII code to its corresponding character.\nTakes an integer representing the ASCII code as input and returns the character that corresponds to that ASCII code.\nThe input is guaranteed to be within the range of visible ASCII characters (greater than 0 and less than 128).\n\nExamples:\n>>> asciiToChar 65\n'A'\n>>> asciiToChar 97\n'a'\n>>> asciiToChar 48\n'0'\n\nasciiToChar = chr", "instruction": "Write a Haskell function `asciiToChar :: Int -> Char` to solve the following problem: \nConverts an ASCII code to its corresponding character.\nTakes an integer representing the ASCII code as input and returns the character that corresponds to that ASCII code.\nThe input is guaranteed to be within the range of visible ASCII characters (greater than 0 and less than 128).\n\nExamples:\n>>> asciiToChar 65\n'A'\n>>> asciiToChar 97\n'a'\n>>> asciiToChar 48\n'0'\n\nasciiToChar = chr", "level": "easy"}
{"task_id": "Haskell/49", "prompt": "import Data.Char (ord)\n\ncharToAscii :: Char -> Int\n{- \n  Converts a character to its ASCII code.\n  Takes a character as input (excluding space) and returns the ASCII code of that character as an integer.\n  The input character is guaranteed to be a visible character (i.e., not a space or control character).\n  \n  Examples:\n  >>> charToAscii 'A'\n  65\n  >>> charToAscii 'a'\n  97\n  >>> charToAscii '0'\n  48\n-}", "canonical_solution": "charToAscii = ord", "test": "check :: (Char -> Int) -> IO ()\ncheck charToAsciiFunc = do\n  let testCases = \n        [ ('A', 65),\n          ('a', 97),\n          ('0', 48),\n          ('$', 36),\n          ('9', 57)\n        ]\n\n  mapM_ (\\(char, expected) -> testCase char expected) testCases\n  where\n    testCase char expected = do\n      let result = charToAsciiFunc char\n      putStrLn $\n        \"Input: \" ++ show char ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check charToAscii", "entry_point": "charToAscii", "signature": "charToAscii :: Char -> Int", "docstring": " \nConverts a character to its ASCII code.\nTakes a character as input (excluding space) and returns the ASCII code of that character as an integer.\nThe input character is guaranteed to be a visible character (i.e., not a space or control character).\n\nExamples:\n>>> charToAscii 'A'\n65\n>>> charToAscii 'a'\n97\n>>> charToAscii '0'\n48\n", "instruction": "Write a Haskell function `charToAscii :: Char -> Int` to solve the following problem: \nConverts a character to its ASCII code.\nTakes a character as input (excluding space) and returns the ASCII code of that character as an integer.\nThe input character is guaranteed to be a visible character (i.e., not a space or control character).\n\nExamples:\n>>> charToAscii 'A'\n65\n>>> charToAscii 'a'\n97\n>>> charToAscii '0'\n48\n", "level": "easy"}
{"task_id": "Haskell/50", "prompt": "calculateExpression :: Int -> Int -> Int -> Int\n{- \n  Calculates the value of the expression (a + b) * c.\n  Takes three integers, a, b, and c, as input and returns the result of the expression (a + b) * c.\n  The values of a, b, and c are within the range of -10^4 to 10^4.\n  \n  Examples:\n  >>> calculateExpression 2 3 5\n  25\n  >>> calculateExpression -1 1 10\n  0\n  >>> calculateExpression 10 20 -3\n  -90\n-}", "canonical_solution": "calculateExpression a b c = (a + b) * c", "test": "check :: (Int -> Int -> Int -> Int) -> IO ()\ncheck calculateExpressionFunc = do\n  let testCases = \n        [ ((2, 3, 5), 25),\n          ((-1, 1, 10), 0),\n          ((10, 20, -3), -90),\n          ((0, 0, 100), 0),\n          ((-100, 100, 0), 0)\n        ]\n\n  mapM_ (\\((a, b, c), expected) -> testCase a b c expected) testCases\n  where\n    testCase a b c expected = do\n      let result = calculateExpressionFunc a b c\n      putStrLn $\n        \"Input: a=\" ++ show a ++ \", b=\" ++ show b ++ \", c=\" ++ show c ++\n        \", Expected: \" ++ show expected ++ \", Result: \" ++ show result ++\n        if result == expected then \" (Pass)\" else error \"Test failed. Exiting...\"\n\nmain :: IO ()\nmain = check calculateExpression", "entry_point": "calculateExpression", "signature": "calculateExpression :: Int -> Int -> Int -> Int", "docstring": " \nCalculates the value of the expression (a + b) * c.\nTakes three integers, a, b, and c, as input and returns the result of the expression (a + b) * c.\nThe values of a, b, and c are within the range of -10^4 to 10^4.\n\nExamples:\n>>> calculateExpression 2 3 5\n25\n>>> calculateExpression -1 1 10\n0\n>>> calculateExpression 10 20 -3\n-90\n", "instruction": "Write a Haskell function `calculateExpression :: Int -> Int -> Int -> Int` to solve the following problem: \nCalculates the value of the expression (a + b) * c.\nTakes three integers, a, b, and c, as input and returns the result of the expression (a + b) * c.\nThe values of a, b, and c are within the range of -10^4 to 10^4.\n\nExamples:\n>>> calculateExpression 2 3 5\n25\n>>> calculateExpression -1 1 10\n0\n>>> calculateExpression 10 20 -3\n-90\n", "level": "easy"}
