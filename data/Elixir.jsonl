{"task_id": "Elixir/1", "prompt": "defmodule NumberUtils do\ndef has_close_elements(numbers, threshold) do\n# Check if in given list of numbers, are any two numbers closer to each other than\n# given threshold.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True", "canonical_solution": "check_pairs(numbers, threshold, [])\nend\n\ndefp check_pairs([], _threshold, _checked), do: false\n\ndefp check_pairs([head | tail], threshold, checked) do\nif Enum.any?(checked ++ tail, fn x -> abs(head - x) < threshold end) do\ntrue\nelse\ncheck_pairs(tail, threshold, [head | checked])\nend\nend\nend", "test": "ExUnit.start()\ndefmodule NumberUtilsTest do\nuse ExUnit.Case\n\ntest \"has close elements with threshold 0.3\" do\nassert NumberUtils.has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3)\nrefute NumberUtils.has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05)\nend\n\ntest \"has close elements with threshold 0.95\" do\nassert NumberUtils.has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95)\nrefute NumberUtils.has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\nend\n\ntest \"has close elements with various thresholds\" do\nassert NumberUtils.has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\nassert NumberUtils.has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0)\nrefute NumberUtils.has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\nend\nend", "entry_point": "has_close_elements", "signature": "def has_close_elements(numbers, threshold) do", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Write a Elixir function `def has_close_elements(numbers, threshold) do` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "level": "middle"}
{"task_id": "Elixir/2", "prompt": "defmodule ListUtils do\ndef concat_lists(list1, list2) do\n# Concatenates two lists\n# >>> concat_lists([1, 2, 3], [4, 5, 6])\n# [1, 2, 3, 4, 5, 6]\n# >>> concat_lists([], [1, 2, 3])\n# [1, 2, 3]", "canonical_solution": "list1 ++ list2\nend\nend", "test": "ExUnit.start()\ndefmodule ListUtilsTest do\nuse ExUnit.Case\n\ntest \"concatenates non-empty lists\" do\nassert ListUtils.concat_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\nend\n\ntest \"concatenates an empty list with a non-empty list\" do\nassert ListUtils.concat_lists([], [1, 2, 3]) == [1, 2, 3]\nassert ListUtils.concat_lists([1, 2, 3], []) == [1, 2, 3]\nend\n\ntest \"concatenates two empty lists\" do\nassert ListUtils.concat_lists([], []) == []\nend\nend", "entry_point": "concat_lists", "signature": "def concat_lists(list1, list2) do", "docstring": "Concatenates two lists\n>>> concat_lists([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]\n>>> concat_lists([], [1, 2, 3])\n[1, 2, 3]", "instruction": "Write a Elixir function `def concat_lists(list1, list2) do` to solve the following problem:\nConcatenates two lists\n>>> concat_lists([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]\n>>> concat_lists([], [1, 2, 3])\n[1, 2, 3]", "level": "easy"}
{"task_id": "Elixir/3", "prompt": "defmodule SortedListMerger do\ndef merge_sorted_lists(list1, list2) do\n# Merges two sorted lists into a single sorted list\n# >>> merge_sorted_lists([1, 3, 5], [2, 4, 6])\n# [1, 2, 3, 4, 5, 6]\n# >>> merge_sorted_lists([1, 2, 3], [4, 5, 6])\n# [1, 2, 3, 4, 5, 6]", "canonical_solution": "merge(list1, list2, [])\nend\n\ndefp merge([], list2, acc), do: Enum.reverse(acc) ++ list2\ndefp merge(list1, [], acc), do: Enum.reverse(acc) ++ list1\n\ndefp merge([h1 | t1] = list1, [h2 | t2] = list2, acc) do\nif h1 <= h2 do\nmerge(t1, list2, [h1 | acc])\nelse\nmerge(list1, t2, [h2 | acc])\nend\nend\nend", "test": "ExUnit.start()\ndefmodule SortedListMergerTest do\nuse ExUnit.Case\n\ntest \"merges two non-empty sorted lists\" do\nassert SortedListMerger.merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert SortedListMerger.merge_sorted_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\nend\n\ntest \"merges a non-empty list with an empty list\" do\nassert SortedListMerger.merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3]\nassert SortedListMerger.merge_sorted_lists([1, 2, 3], []) == [1, 2, 3]\nend\n\ntest \"merges two empty lists\" do\nassert SortedListMerger.merge_sorted_lists([], []) == []\nend\nend", "entry_point": "merge_sorted_lists", "signature": "def merge_sorted_lists(list1, list2) do", "docstring": "Merges two sorted lists into a single sorted list\n>>> merge_sorted_lists([1, 3, 5], [2, 4, 6])\n[1, 2, 3, 4, 5, 6]\n>>> merge_sorted_lists([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]", "instruction": "Write a Elixir function `def merge_sorted_lists(list1, list2) do` to solve the following problem:\nMerges two sorted lists into a single sorted list\n>>> merge_sorted_lists([1, 3, 5], [2, 4, 6])\n[1, 2, 3, 4, 5, 6]\n>>> merge_sorted_lists([1, 2, 3], [4, 5, 6])\n[1, 2, 3, 4, 5, 6]", "level": "middle"}
{"task_id": "Elixir/4", "prompt": "defmodule ArrayUtils do\ndef remove_value(nums, val) do\n# Removes all instances of 'val' from 'nums' and returns the new length\n# >>> remove_value([3, 2, 2, 3], 3)\n# 2\n# >>> remove_value([0, 1, 2, 2, 3, 0, 4, 2], 2)\n# 5", "canonical_solution": "nums |> Enum.filter(fn x -> x != val end) |> length()\nend\nend", "test": "ExUnit.start()\ndefmodule ArrayUtilsTest do\nuse ExUnit.Case\n\ntest \"removes value and returns new length\" do\nassert ArrayUtils.remove_value([3, 2, 2, 3], 3) == 2\nassert ArrayUtils.remove_value([0, 1, 2, 2, 3, 0, 4, 2], 2) == 5\nend\n\ntest \"returns same length when value not present\" do\nassert ArrayUtils.remove_value([1, 2, 3, 4, 5], 6) == 5\nend\n\ntest \"returns zero when all elements are the value\" do\nassert ArrayUtils.remove_value([2, 2, 2, 2], 2) == 0\nend\n\ntest \"handles empty list\" do\nassert ArrayUtils.remove_value([], 1) == 0\nend\nend", "entry_point": "remove_value", "signature": "def remove_value(nums, val) do", "docstring": "Removes all instances of 'val' from 'nums' and returns the new length\n>>> remove_value([3, 2, 2, 3], 3)\n2\n>>> remove_value([0, 1, 2, 2, 3, 0, 4, 2], 2)\n5", "instruction": "Write a Elixir function `def remove_value(nums, val) do` to solve the following problem:\nRemoves all instances of 'val' from 'nums' and returns the new length\n>>> remove_value([3, 2, 2, 3], 3)\n2\n>>> remove_value([0, 1, 2, 2, 3, 0, 4, 2], 2)\n5", "level": "easy"}
{"task_id": "Elixir/5", "prompt": "defmodule UniqueArrayUtils do\ndef remove_duplicates(nums) do\n# Removes duplicate elements from a non-strictly increasing array\n# and returns the new length of the array.\n# >>> remove_duplicates([1, 1, 2])\n# 2\n# >>> remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4])\n# 5", "canonical_solution": "nums |> Enum.uniq() |> length()\nend\nend", "test": "ExUnit.start()\ndefmodule UniqueArrayUtilsTest do\nuse ExUnit.Case\n\ntest \"removes duplicates and returns new length\" do\nassert UniqueArrayUtils.remove_duplicates([1, 1, 2]) == 2\nassert UniqueArrayUtils.remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]) == 5\nend\n\ntest \"handles array with no duplicates\" do\nassert UniqueArrayUtils.remove_duplicates([1, 2, 3, 4, 5]) == 5\nend\n\ntest \"handles empty array\" do\nassert UniqueArrayUtils.remove_duplicates([]) == 0\nend\nend", "entry_point": "remove_duplicates", "signature": "def remove_duplicates(nums) do", "docstring": "Removes duplicate elements from a non-strictly increasing array\nand returns the new length of the array.\n>>> remove_duplicates([1, 1, 2])\n2\n>>> remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4])\n5", "instruction": "Write a Elixir function `def remove_duplicates(nums) do` to solve the following problem:\nRemoves duplicate elements from a non-strictly increasing array\nand returns the new length of the array.\n>>> remove_duplicates([1, 1, 2])\n2\n>>> remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4])\n5", "level": "easy"}
{"task_id": "Elixir/6", "prompt": "defmodule MajorityElementFinder do\ndef find_majority_element(nums) do\n# Finds the majority element in an array\n# >>> find_majority_element([3, 2, 3])\n# 3\n# >>> find_majority_element([2, 2, 1, 1, 1, 2, 2])\n# 2", "canonical_solution": "nums\n|> create_frequency_map()\n|> Enum.max_by(fn {_key, val} -> val end)\n|> elem(0)\nend\n\ndefp create_frequency_map(nums) do\nEnum.reduce(nums, %{}, fn num, acc ->\nMap.update(acc, num, 1, &(&1 + 1))\nend)\nend\nend", "test": "ExUnit.start()\ndefmodule MajorityElementFinderTest do\nuse ExUnit.Case\n\ntest \"finds the majority element\" do\nassert MajorityElementFinder.find_majority_element([3, 2, 3]) == 3\nassert MajorityElementFinder.find_majority_element([2, 2, 1, 1, 1, 2, 2]) == 2\nend\n\ntest \"handles single element array\" do\nassert MajorityElementFinder.find_majority_element([1]) == 1\nend\n\ntest \"handles array where all elements are the same\" do\nassert MajorityElementFinder.find_majority_element([2, 2, 2]) == 2\nend\nend", "entry_point": "find_majority_element", "signature": "def find_majority_element(nums) do", "docstring": "Finds the majority element in an array\n>>> find_majority_element([3, 2, 3])\n3\n>>> find_majority_element([2, 2, 1, 1, 1, 2, 2])\n2", "instruction": "Write a Elixir function `def find_majority_element(nums) do` to solve the following problem:\nFinds the majority element in an array\n>>> find_majority_element([3, 2, 3])\n3\n>>> find_majority_element([2, 2, 1, 1, 1, 2, 2])\n2", "level": "easy"}
{"task_id": "Elixir/7", "prompt": "defmodule ArrayRotator do\ndef rotate_right(nums, k) do\n# Rotates the elements of an array to the right by k positions\n# >>> rotate_right([1, 2, 3, 4, 5, 6, 7], 3)\n# [5, 6, 7, 1, 2, 3, 4]\n# >>> rotate_right([-1, -100, 3, 99], 2)\n# [3, 99, -1, -100]", "canonical_solution": "len = length(nums)\n\nif len == 0 do\n# Return the empty array as is\nnums\nelse\nactual_k = rem(k, len)\n{left, right} = Enum.split(nums, len - actual_k)\nright ++ left\nend\nend\nend", "test": "ExUnit.start()\ndefmodule ArrayRotatorTest do\nuse ExUnit.Case\n\ntest \"rotates array to the right by k positions\" do\nassert ArrayRotator.rotate_right([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4]\nassert ArrayRotator.rotate_right([-1, -100, 3, 99], 2) == [3, 99, -1, -100]\nend\n\ntest \"handles rotation larger than array length\" do\nassert ArrayRotator.rotate_right([1, 2, 3], 4) == [3, 1, 2]\nend\n\ntest \"handles zero rotation\" do\nassert ArrayRotator.rotate_right([1, 2, 3], 0) == [1, 2, 3]\nend\n\ntest \"handles empty array\" do\nassert ArrayRotator.rotate_right([], 3) == []\nend\nend", "entry_point": "rotate_right", "signature": "def rotate_right(nums, k) do", "docstring": "Rotates the elements of an array to the right by k positions\n>>> rotate_right([1, 2, 3, 4, 5, 6, 7], 3)\n[5, 6, 7, 1, 2, 3, 4]\n>>> rotate_right([-1, -100, 3, 99], 2)\n[3, 99, -1, -100]", "instruction": "Write a Elixir function `def rotate_right(nums, k) do` to solve the following problem:\nRotates the elements of an array to the right by k positions\n>>> rotate_right([1, 2, 3, 4, 5, 6, 7], 3)\n[5, 6, 7, 1, 2, 3, 4]\n>>> rotate_right([-1, -100, 3, 99], 2)\n[3, 99, -1, -100]", "level": "easy"}
{"task_id": "Elixir/8", "prompt": "defmodule StockProfitCalculator do\ndef max_profit(prices) do\n# Calculates the maximum profit from buying and selling a stock on different days\n# >>> max_profit([7, 1, 5, 3, 6, 4])\n# 5\n# >>> max_profit([7, 6, 4, 3, 1])\n# 0", "canonical_solution": "compute_profit(prices, 0, :infinity)\nend\n\ndefp compute_profit([], max_profit, _min_price), do: max(max_profit, 0)\n\ndefp compute_profit([price | rest], max_profit, min_price) do\nnew_min_price = min(price, min_price)\nnew_max_profit = max(max_profit, price - new_min_price)\ncompute_profit(rest, new_max_profit, new_min_price)\nend\nend", "test": "ExUnit.start()\ndefmodule StockProfitCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates maximum profit\" do\nassert StockProfitCalculator.max_profit([7, 1, 5, 3, 6, 4]) == 5\nassert StockProfitCalculator.max_profit([7, 6, 4, 3, 1]) == 0\nend\n\ntest \"handles empty array\" do\nassert StockProfitCalculator.max_profit([]) == 0\nend\n\ntest \"handles single element array\" do\nassert StockProfitCalculator.max_profit([5]) == 0\nend\nend", "entry_point": "max_profit", "signature": "def max_profit(prices) do", "docstring": "Calculates the maximum profit from buying and selling a stock on different days\n>>> max_profit([7, 1, 5, 3, 6, 4])\n5\n>>> max_profit([7, 6, 4, 3, 1])\n0", "instruction": "Write a Elixir function `def max_profit(prices) do` to solve the following problem:\nCalculates the maximum profit from buying and selling a stock on different days\n>>> max_profit([7, 1, 5, 3, 6, 4])\n5\n>>> max_profit([7, 6, 4, 3, 1])\n0", "level": "middle"}
{"task_id": "Elixir/9", "prompt": "defmodule JumpGame do\ndef can_reach_end?(nums) do\n# Determines if it's possible to reach the last index of the array\n# >>> can_reach_end?([2, 3, 1, 1, 4])\n# true\n# >>> can_reach_end?([3, 2, 1, 0, 4])\n# false", "canonical_solution": "if Enum.empty?(nums), do: false, else: check_jump(nums, 0, 0)\nend\n\ndefp check_jump(_nums, current_index, max_reach) when current_index > max_reach, do: false\n\ndefp check_jump(nums, current_index, _max_reach) when current_index == length(nums) - 1, do: true\n\ndefp check_jump(nums, current_index, max_reach) do\nnew_max_reach = max(current_index + Enum.at(nums, current_index), max_reach)\ncheck_jump(nums, current_index + 1, new_max_reach)\nend\nend", "test": "ExUnit.start()\ndefmodule JumpGameTest do\nuse ExUnit.Case\n\ntest \"can reach the end\" do\nassert JumpGame.can_reach_end?([2, 3, 1, 1, 4])\nrefute JumpGame.can_reach_end?([3, 2, 1, 0, 4])\nend\n\ntest \"handles single element array\" do\nassert JumpGame.can_reach_end?([0])\nend\n\ntest \"handles empty array\" do\nrefute JumpGame.can_reach_end?([])\nend\nend", "entry_point": "can_reach_end?", "signature": "def can_reach_end?(nums) do", "docstring": "Determines if it's possible to reach the last index of the array\n>>> can_reach_end?([2, 3, 1, 1, 4])\ntrue\n>>> can_reach_end?([3, 2, 1, 0, 4])\nfalse", "instruction": "Write a Elixir function `def can_reach_end?(nums) do` to solve the following problem:\nDetermines if it's possible to reach the last index of the array\n>>> can_reach_end?([2, 3, 1, 1, 4])\ntrue\n>>> can_reach_end?([3, 2, 1, 0, 4])\nfalse", "level": "hard"}
{"task_id": "Elixir/10", "prompt": "defmodule ProductCalculator do\ndef calculate_product_except_self(nums) do\n# Give you an integer array nums and return the array answer, where answer [i] is equal to the product of all elements in nums except for nums [i].\n# Example:\n# >>> calculate_product_except_self([1, 2, 3, 4])\n# [24, 12, 8, 6]", "canonical_solution": "zero_count = Enum.count(nums, &(&1 == 0))\n\ncase zero_count do\n0 ->\ntotal_product = Enum.reduce(nums, 1, &*/2)\nEnum.map(nums, fn num -> div(total_product, num) end)\n\n1 ->\ntotal_product_without_zero = Enum.reduce(nums, 1, fn\n0, acc -> acc\nnum, acc -> acc * num\nend)\nEnum.map(nums, fn\n0 -> total_product_without_zero\n_ -> 0\nend)\n\n_ ->\nEnum.map(nums, fn _ -> 0 end)\nend\nend\nend", "test": "ExUnit.start()\ndefmodule ProductCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates product of all elements except self\" do\nassert ProductCalculator.calculate_product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert ProductCalculator.calculate_product_except_self([0, 1]) == [1, 0]\nassert ProductCalculator.calculate_product_except_self([0, 0, 1]) == [0, 0, 0]\nend\nend\n", "entry_point": "calculate_product_except_self", "signature": "def calculate_product_except_self(nums) do", "docstring": "Give you an integer array nums and return the array answer, where answer [i] is equal to the product of all elements in nums except for nums [i].\nExample:\n>>> calculate_product_except_self([1, 2, 3, 4])\n[24, 12, 8, 6]", "instruction": "Write a Elixir function `def calculate_product_except_self(nums) do` to solve the following problem:\nGive you an integer array nums and return the array answer, where answer [i] is equal to the product of all elements in nums except for nums [i].\nExample:\n>>> calculate_product_except_self([1, 2, 3, 4])\n[24, 12, 8, 6]", "level": "middle"}
{"task_id": "Elixir/11", "prompt": "defmodule TwoSum do\ndef find_indices(nums, target) do\n# Find two numbers in the list `nums` that add up to the target value `target`\n# and return their indices.\n# The function iterates through the list, keeping track of each number's complement\n# (target - nums[i]) and its index. If a number exists in the map, it means its complement\n# was already seen, and we found a pair that adds up to the target.\n# Example:\n# >>> find_indices([2, 7, 11, 15], 9)\n# {0, 1}\n# >>> find_indices([3, 2, 4], 6)\n# {1, 2}", "canonical_solution": "find_indices_helper(nums, target, %{}, 0)\nend\n\ndefp find_indices_helper([], _target, _complements, _index), do: nil\n\ndefp find_indices_helper([head | tail], target, complements, index) do\ncomplement = target - head\n\nif Map.has_key?(complements, head) do\n{Map.get(complements, head), index}\nelse\nfind_indices_helper(tail, target, Map.put(complements, complement, index), index + 1)\nend\nend\nend", "test": "ExUnit.start()\ndefmodule TwoSumTest do\nuse ExUnit.Case\n\ntest \"finds indices of two numbers that add up to the target\" do\nassert TwoSum.find_indices([2, 7, 11, 15], 9) == {0, 1}\nassert TwoSum.find_indices([3, 2, 4], 6) == {1, 2}\nassert TwoSum.find_indices([3, 3], 6) == {0, 1}\nend\nend", "entry_point": "find_indices", "signature": "def find_indices(nums, target) do", "docstring": "Find two numbers in the list `nums` that add up to the target value `target`\nand return their indices.\nThe function iterates through the list, keeping track of each number's complement\n(target - nums[i]) and its index. If a number exists in the map, it means its complement\nwas already seen, and we found a pair that adds up to the target.\nExample:\n>>> find_indices([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_indices([3, 2, 4], 6)\n{1, 2}", "instruction": "Write a Elixir function `def find_indices(nums, target) do` to solve the following problem:\nFind two numbers in the list `nums` that add up to the target value `target`\nand return their indices.\nThe function iterates through the list, keeping track of each number's complement\n(target - nums[i]) and its index. If a number exists in the map, it means its complement\nwas already seen, and we found a pair that adds up to the target.\nExample:\n>>> find_indices([2, 7, 11, 15], 9)\n{0, 1}\n>>> find_indices([3, 2, 4], 6)\n{1, 2}", "level": "hard"}
{"task_id": "Elixir/12", "prompt": "defmodule SearchInsertPosition do\ndef find_insert_position(nums, target) do\n# Find the index of a target value in a sorted array or the index where it should be \n# inserted if not present. This function uses binary search for efficient searching.\n# Example:\n# >>> find_insert_position([1, 3, 5, 6], 5)\n# 2", "canonical_solution": "binary_search(nums, target, 0, length(nums) - 1)\nend\n\ndefp binary_search(nums, target, low, high) do\nif low > high do\nlow\nelse\nmid = div(low + high, 2)\ncase nums |> Enum.at(mid) do\nnil -> low\nnum when num < target -> binary_search(nums, target, mid + 1, high)\nnum when num > target -> binary_search(nums, target, low, mid - 1)\n_num -> mid\nend\nend\nend\nend", "test": "ExUnit.start()\ndefmodule SearchInsertPositionTest do\nuse ExUnit.Case\n\ntest \"find insert position\" do\nassert SearchInsertPosition.find_insert_position([1, 3, 5, 6], 5) == 2\nassert SearchInsertPosition.find_insert_position([1, 3, 5, 6], 2) == 1\nassert SearchInsertPosition.find_insert_position([1, 3, 5, 6], 7) == 4\nassert SearchInsertPosition.find_insert_position([1, 3, 5, 6], 0) == 0\nend\nend", "entry_point": "find_insert_position", "signature": "def find_insert_position(nums, target) do", "docstring": "Find the index of a target value in a sorted array or the index where it should be \ninserted if not present. This function uses binary search for efficient searching.\nExample:\n>>> find_insert_position([1, 3, 5, 6], 5)\n2", "instruction": "Write a Elixir function `def find_insert_position(nums, target) do` to solve the following problem:\nFind the index of a target value in a sorted array or the index where it should be \ninserted if not present. This function uses binary search for efficient searching.\nExample:\n>>> find_insert_position([1, 3, 5, 6], 5)\n2", "level": "middle"}
{"task_id": "Elixir/13", "prompt": "defmodule SingleNumberFinder do\ndef find_single_number(nums) do\n# Finds the element that appears exactly once in a list of integers,\n# where every other element appears exactly twice.\n# >>> find_single_number([2, 2, 1])\n# 1", "canonical_solution": "nums\n|> Enum.reduce(%{}, fn x, acc -> Map.update(acc, x, 1, &(&1 + 1)) end)\n|> Enum.find(fn {_key, val} -> val == 1 end)\n|> elem(0)\nend\nend", "test": "ExUnit.start()\ndefmodule SingleNumberFinderTest do\nuse ExUnit.Case\n\ntest \"find single number\" do\nassert SingleNumberFinder.find_single_number([2, 2, 1]) == 1\nassert SingleNumberFinder.find_single_number([4, 1, 2, 1, 2]) == 4\nassert SingleNumberFinder.find_single_number([1]) == 1\nend\nend", "entry_point": "find_single_number", "signature": "def find_single_number(nums) do", "docstring": "Finds the element that appears exactly once in a list of integers,\nwhere every other element appears exactly twice.\n>>> find_single_number([2, 2, 1])\n1", "instruction": "Write a Elixir function `def find_single_number(nums) do` to solve the following problem:\nFinds the element that appears exactly once in a list of integers,\nwhere every other element appears exactly twice.\n>>> find_single_number([2, 2, 1])\n1", "level": "easy"}
{"task_id": "Elixir/14", "prompt": "defmodule DuplicateChecker do\ndef has_duplicates(nums) do\n# Checks if any value in the given list of integers appears at least twice.\n# >>> has_duplicates([1, 2, 3, 4, 5])\n# False\n# >>> has_duplicates([1, 2, 3, 3, 4, 5])\n# True", "canonical_solution": "check_for_duplicates(nums, %{})\nend\n\ndefp check_for_duplicates([], _acc), do: false\n\ndefp check_for_duplicates([head | tail], acc) do\nif Map.get(acc, head) do\ntrue\nelse\ncheck_for_duplicates(tail, Map.put(acc, head, true))\nend\nend\nend", "test": "ExUnit.start()\ndefmodule DuplicateCheckerTest do\nuse ExUnit.Case\n\ntest \"check for duplicates\" do\nrefute DuplicateChecker.has_duplicates([1, 2, 3, 4, 5])\nassert DuplicateChecker.has_duplicates([1, 2, 3, 3, 4, 5])\nend\n\ntest \"check for no duplicates\" do\nrefute DuplicateChecker.has_duplicates([10, 20, 30, 40, 50])\nassert DuplicateChecker.has_duplicates([10, 20, 30, 20, 40, 50])\nend\nend", "entry_point": "has_duplicates", "signature": "def has_duplicates(nums) do", "docstring": "Checks if any value in the given list of integers appears at least twice.\n>>> has_duplicates([1, 2, 3, 4, 5])\nFalse\n>>> has_duplicates([1, 2, 3, 3, 4, 5])\nTrue", "instruction": "Write a Elixir function `def has_duplicates(nums) do` to solve the following problem:\nChecks if any value in the given list of integers appears at least twice.\n>>> has_duplicates([1, 2, 3, 4, 5])\nFalse\n>>> has_duplicates([1, 2, 3, 3, 4, 5])\nTrue", "level": "middle"}
{"task_id": "Elixir/15", "prompt": "defmodule QuickSort do\n# Sorts a list of numbers using the quicksort algorithm.\n# >>> quicksort([3, 2, 5, 1, 4])\n# [1, 2, 3, 4, 5]\n# >>> quicksort([10, 7, 8, 9, 1, 5])\n# [1, 5, 7, 8, 9, 10]", "canonical_solution": "def quicksort([]), do: []\ndef quicksort([pivot | rest]) do\nlesser = Enum.filter(rest, fn x -> x < pivot end)\ngreater = Enum.filter(rest, fn x -> x >= pivot end)\nquicksort(lesser) ++ [pivot] ++ quicksort(greater)\nend\nend", "test": "ExUnit.start()\ndefmodule QuickSortTest do\nuse ExUnit.Case\n\ntest \"quicksort algorithm\" do\nassert QuickSort.quicksort([3, 2, 5, 1, 4]) == [1, 2, 3, 4, 5]\nassert QuickSort.quicksort([10, 7, 8, 9, 1, 5]) == [1, 5, 7, 8, 9, 10]\nend\nend", "entry_point": "quick", "signature": "def quicksort([pivot | rest]) do", "docstring": "Sorts a list of numbers using the quicksort algorithm.\n>>> quicksort([3, 2, 5, 1, 4])\n[1, 2, 3, 4, 5]\n>>> quicksort([10, 7, 8, 9, 1, 5])\n[1, 5, 7, 8, 9, 10]", "instruction": "Write a Elixir function `def quicksort([pivot | rest]) do` to solve the following problem:\nSorts a list of numbers using the quicksort algorithm.\n>>> quicksort([3, 2, 5, 1, 4])\n[1, 2, 3, 4, 5]\n>>> quicksort([10, 7, 8, 9, 1, 5])\n[1, 5, 7, 8, 9, 10]", "level": "middle"}
{"task_id": "Elixir/16", "prompt": "defmodule NumberUtils do\ndef reverse_list(list) do\n# Reverses the order of elements in a given list.\n# >>> reverse_list([1, 2, 3, 4])\n# [4, 3, 2, 1]", "canonical_solution": "do_reverse_list(list, [])\nend\n\ndefp do_reverse_list([], acc), do: acc\ndefp do_reverse_list([head | tail], acc) do\ndo_reverse_list(tail, [head | acc])\nend\nend", "test": "ExUnit.start()\ndefmodule NumberUtilsTest do\nuse ExUnit.Case\n\ntest \"reverse list\" do\nassert NumberUtils.reverse_list([1, 2, 3, 4]) == [4, 3, 2, 1]\nassert NumberUtils.reverse_list([\"a\", \"b\", \"c\"]) == [\"c\", \"b\", \"a\"]\nend\nend", "entry_point": "reverse_list", "signature": "def reverse_list(list) do", "docstring": "Reverses the order of elements in a given list.\n>>> reverse_list([1, 2, 3, 4])\n[4, 3, 2, 1]", "instruction": "Write a Elixir function `def reverse_list(list) do` to solve the following problem:\nReverses the order of elements in a given list.\n>>> reverse_list([1, 2, 3, 4])\n[4, 3, 2, 1]", "level": "easy"}
{"task_id": "Elixir/17", "prompt": "defmodule StringSearchUtils do\ndef find_first_index(haystack, needle) do\n# Finds the first occurrence index of 'needle' in 'haystack'.\n# Returns the index of the first occurrence if found, otherwise -1.\n# \n# Examples:\n# >>> find_first_index(\"hello\", \"ll\")\n# 2\n# >>> find_first_index(\"abcabcabc\", \"abc\")\n# 0\n# >>> find_first_index(\"abcde\", \"fgh\")\n# -1", "canonical_solution": "if needle == \"\" do\n0\nelse\nif String.contains?(haystack, needle) do\nfirst_part = List.first(String.split(haystack, needle))\nString.length(first_part)\nelse\n-1\nend\nend\nend\nend", "test": "ExUnit.start()\n\ndefmodule StringSearchUtilsTest do\nuse ExUnit.Case\n\ntest \"finds the first occurrence of needle in haystack\" do\nassert StringSearchUtils.find_first_index(\"hello\", \"ll\") == 2\nassert StringSearchUtils.find_first_index(\"abcabcabc\", \"abc\") == 0\nend\n\ntest \"returns -1 if needle is not found in haystack\" do\nassert StringSearchUtils.find_first_index(\"abcde\", \"fgh\") == -1\nend\n\ntest \"handles cases with multiple occurrences\" do\nassert StringSearchUtils.find_first_index(\"sadbutsad\", \"sad\") == 0\nend\n\ntest \"handles empty needle\" do\nassert StringSearchUtils.find_first_index(\"hello\", \"\") == 0\nend\nend", "entry_point": "find_first_index", "signature": "def find_first_index(haystack, needle) do", "docstring": "Finds the first occurrence index of 'needle' in 'haystack'.\nReturns the index of the first occurrence if found, otherwise -1.\n\nExamples:\n>>> find_first_index(\"hello\", \"ll\")\n2\n>>> find_first_index(\"abcabcabc\", \"abc\")\n0\n>>> find_first_index(\"abcde\", \"fgh\")\n-1", "instruction": "Write a Elixir function `def find_first_index(haystack, needle) do` to solve the following problem:\nFinds the first occurrence index of 'needle' in 'haystack'.\nReturns the index of the first occurrence if found, otherwise -1.\n\nExamples:\n>>> find_first_index(\"hello\", \"ll\")\n2\n>>> find_first_index(\"abcabcabc\", \"abc\")\n0\n>>> find_first_index(\"abcde\", \"fgh\")\n-1", "level": "easy"}
{"task_id": "Elixir/18", "prompt": "defmodule FishSwimmingUtils do\ndef will_fish_be_in_danger?(s, x) do\n# Determines whether the fish will be in danger given the distance to the detector (s)\n# and the range of the detector (x). The fish swims at 7 meters in the first second\n# and then at 98% of the previous second's speed subsequently.\n# Returns 'y' if the fish will be in danger, 'n' otherwise.\n# \n# Examples:\n# >>> will_fish_be_in_danger?(50, 5)\n# 'y'\n# >>> will_fish_be_in_danger?(13, 2)\n# 'n'", "canonical_solution": "check_danger(0.0, 7.0, s, x)\nend\n\ndefp check_danger(distance, speed, s, x) do\nif distance >= s + x, do: 'n', else: check_danger_condition(distance, speed, s, x)\nend\n\ndefp check_danger_condition(distance, speed, s, x) do\nif distance > s - x and distance < s + x do\nnext_distance = distance + speed\nif next_distance > s + x, do: 'n', else: 'y'\nelse\ncheck_danger(distance + speed, speed * 0.98, s, x)\nend\nend\nend", "test": "ExUnit.start()\n\ndefmodule FishSwimmingUtilsTest do\nuse ExUnit.Case\n\ntest \"fish escapes the danger zone\" do\nassert FishSwimmingUtils.will_fish_be_in_danger?(14, 1) == 'n'\nassert FishSwimmingUtils.will_fish_be_in_danger?(20, 1.5) == 'n'\nend\n\ntest \"fish does not escape the danger zone\" do\nassert FishSwimmingUtils.will_fish_be_in_danger?(13, 2) == 'n'\nend\n\ntest \"edge cases\" do\nassert FishSwimmingUtils.will_fish_be_in_danger?(15, 0.5) == 'n'\nassert FishSwimmingUtils.will_fish_be_in_danger?(50, 5) == 'y'\nend\nend", "entry_point": "will_fish_be_in_danger?", "signature": "def will_fish_be_in_danger?(s, x) do", "docstring": "Determines whether the fish will be in danger given the distance to the detector (s)\nand the range of the detector (x). The fish swims at 7 meters in the first second\nand then at 98% of the previous second's speed subsequently.\nReturns 'y' if the fish will be in danger, 'n' otherwise.\n\nExamples:\n>>> will_fish_be_in_danger?(50, 5)\n'y'\n>>> will_fish_be_in_danger?(13, 2)\n'n'", "instruction": "Write a Elixir function `def will_fish_be_in_danger?(s, x) do` to solve the following problem:\nDetermines whether the fish will be in danger given the distance to the detector (s)\nand the range of the detector (x). The fish swims at 7 meters in the first second\nand then at 98% of the previous second's speed subsequently.\nReturns 'y' if the fish will be in danger, 'n' otherwise.\n\nExamples:\n>>> will_fish_be_in_danger?(50, 5)\n'y'\n>>> will_fish_be_in_danger?(13, 2)\n'n'", "level": "hard"}
{"task_id": "Elixir/19", "prompt": "defmodule NumberGameUtils do\ndef reverse_numbers(nums) do\n# Reverses a list of numbers, ending with 0, excluding the 0 from the output.\n# The function takes a list of integers and returns a list of integers in reverse order,\n# omitting the final 0.\n#\n# Examples:\n# >>> reverse_numbers([2, 5, 7, 0])\n# [7, 5, 2]\n# >>> reverse_numbers([4, 1, 8, 9, 0])\n# [9, 8, 1, 4]\n# >>> reverse_numbers([0])\n# []", "canonical_solution": "nums\n|> Enum.reverse()\n|> Enum.drop_while(&(&1 == 0))\nend\nend", "test": "ExUnit.start()\ndefmodule NumberGameUtilsTest do\nuse ExUnit.Case\n\ntest \"reverses numbers and excludes trailing zero\" do\nassert NumberGameUtils.reverse_numbers([3, 65, 23, 5, 34, 1, 30, 0]) == [30, 1, 34, 5, 23, 65, 3]\nassert NumberGameUtils.reverse_numbers([2, 5, 7, 0]) == [7, 5, 2]\nend\n\ntest \"handles single zero\" do\nassert NumberGameUtils.reverse_numbers([0]) == []\nend\n\ntest \"handles empty list\" do\nassert NumberGameUtils.reverse_numbers([]) == []\nend\nend", "entry_point": "reverse_numbers", "signature": "def reverse_numbers(nums) do", "docstring": "Reverses a list of numbers, ending with 0, excluding the 0 from the output.\nThe function takes a list of integers and returns a list of integers in reverse order,\nomitting the final 0.\n\nExamples:\n>>> reverse_numbers([2, 5, 7, 0])\n[7, 5, 2]\n>>> reverse_numbers([4, 1, 8, 9, 0])\n[9, 8, 1, 4]\n>>> reverse_numbers([0])\n[]", "instruction": "Write a Elixir function `def reverse_numbers(nums) do` to solve the following problem:\nReverses a list of numbers, ending with 0, excluding the 0 from the output.\nThe function takes a list of integers and returns a list of integers in reverse order,\nomitting the final 0.\n\nExamples:\n>>> reverse_numbers([2, 5, 7, 0])\n[7, 5, 2]\n>>> reverse_numbers([4, 1, 8, 9, 0])\n[9, 8, 1, 4]\n>>> reverse_numbers([0])\n[]", "level": "easy"}
{"task_id": "Elixir/20", "prompt": "defmodule FishCutenessUtils do\ndef count_less_cute_neighbors(cuteness_levels) do\n# Counts for each fish how many fishes to its left are less cute.\n# Each fish has a cuteness level represented by an integer, and the cuteness\n# levels of all fish in a line are given as a list of integers.\n# The function returns a list of integers where each integer corresponds to\n# the number of less cute fishes to the left of each fish.\n#\n# Examples:\n# >>> count_less_cute_neighbors([5, 3, 4, 2, 1])\n# [0, 0, 1, 0, 0]\n# >>> count_less_cute_neighbors([2, 2, 3, 3, 1])\n# [0, 1, 2, 3, 0]", "canonical_solution": "Enum.with_index(cuteness_levels)\n|> Enum.map(fn {level, index} ->\nEnum.slice(cuteness_levels, 0, index)\n|> Enum.count(fn x -> x < level end)\nend)\nend\nend", "test": "ExUnit.start()\ndefmodule FishCutenessUtilsTest do\nuse ExUnit.Case\n\ntest \"counts less cute neighbors correctly\" do\nassert FishCutenessUtils.count_less_cute_neighbors([4, 3, 0, 5, 1, 2]) == [0, 0, 0, 3, 1, 2]\nassert FishCutenessUtils.count_less_cute_neighbors([5, 3, 4, 2, 1]) == [0, 0, 1, 0, 0]\nend\n\ntest \"handles equal cuteness levels\" do\nassert FishCutenessUtils.count_less_cute_neighbors([2, 2, 3, 3, 1]) == [0, 0, 2, 2, 0]\nend\n\ntest \"handles single fish\" do\nassert FishCutenessUtils.count_less_cute_neighbors([3]) == [0]\nend\nend", "entry_point": "count_less_cute_neighbors", "signature": "def count_less_cute_neighbors(cuteness_levels) do", "docstring": "Counts for each fish how many fishes to its left are less cute.\nEach fish has a cuteness level represented by an integer, and the cuteness\nlevels of all fish in a line are given as a list of integers.\nThe function returns a list of integers where each integer corresponds to\nthe number of less cute fishes to the left of each fish.\n\nExamples:\n>>> count_less_cute_neighbors([5, 3, 4, 2, 1])\n[0, 0, 1, 0, 0]\n>>> count_less_cute_neighbors([2, 2, 3, 3, 1])\n[0, 1, 2, 3, 0]", "instruction": "Write a Elixir function `def count_less_cute_neighbors(cuteness_levels) do` to solve the following problem:\nCounts for each fish how many fishes to its left are less cute.\nEach fish has a cuteness level represented by an integer, and the cuteness\nlevels of all fish in a line are given as a list of integers.\nThe function returns a list of integers where each integer corresponds to\nthe number of less cute fishes to the left of each fish.\n\nExamples:\n>>> count_less_cute_neighbors([5, 3, 4, 2, 1])\n[0, 0, 1, 0, 0]\n>>> count_less_cute_neighbors([2, 2, 3, 3, 1])\n[0, 1, 2, 3, 0]", "level": "easy"}
{"task_id": "Elixir/21", "prompt": "defmodule JinjinUnhappinessCalculator do\ndef calculate_unhappiness(n, daily_schedules) do\n# Calculate the unhappiness level for the (n+1)-th day\n# Jinjin becomes unhappy if she has more than 8 hours of classes in a day.\n# Unhappiness level for each day is calculated by adding yesterday's unhappiness (if any)\n# to today's total class hours minus 8.\n# The function takes the number of days 'n' and a list of tuples where each tuple represents\n# the school hours and extracurricular class hours for each day.\n#\n# Examples:\n# >>> calculate_unhappiness(3, [{5, 4}, {6, 3}, {7, 2}])\n# 3", "canonical_solution": "Enum.reduce(daily_schedules, 0, fn {school, extra}, acc ->\n# Calculate the unhappiness for the current day\ndaily_unhappiness = school + extra - 8 + acc\n# Accumulate it for the next day\ndaily_unhappiness\nend)\nend\nend", "test": "ExUnit.start()\ndefmodule JinjinUnhappinessCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates cumulative unhappiness correctly\" do\nassert JinjinUnhappinessCalculator.calculate_unhappiness(7, [{5, 3}, {6, 2}, {7, 2}, {5, 3}, {5, 4}, {0, 4}, {0, 6}]) == -4\nassert JinjinUnhappinessCalculator.calculate_unhappiness(3, [{5, 4}, {6, 3}, {7, 2}]) == 3\nend\n\ntest \"handles no unhappiness case\" do\nassert JinjinUnhappinessCalculator.calculate_unhappiness(2, [{8, 0}, {7, 1}]) == 0\nend\n\ntest \"handles single day case\" do\nassert JinjinUnhappinessCalculator.calculate_unhappiness(1, [{9, 0}]) == 1\nend\nend", "entry_point": "calculate_unhappiness", "signature": "def calculate_unhappiness(n, daily_schedules) do", "docstring": "Calculate the unhappiness level for the (n+1)-th day\nJinjin becomes unhappy if she has more than 8 hours of classes in a day.\nUnhappiness level for each day is calculated by adding yesterday's unhappiness (if any)\nto today's total class hours minus 8.\nThe function takes the number of days 'n' and a list of tuples where each tuple represents\nthe school hours and extracurricular class hours for each day.\n\nExamples:\n>>> calculate_unhappiness(3, [{5, 4}, {6, 3}, {7, 2}])\n3", "instruction": "Write a Elixir function `def calculate_unhappiness(n, daily_schedules) do` to solve the following problem:\nCalculate the unhappiness level for the (n+1)-th day\nJinjin becomes unhappy if she has more than 8 hours of classes in a day.\nUnhappiness level for each day is calculated by adding yesterday's unhappiness (if any)\nto today's total class hours minus 8.\nThe function takes the number of days 'n' and a list of tuples where each tuple represents\nthe school hours and extracurricular class hours for each day.\n\nExamples:\n>>> calculate_unhappiness(3, [{5, 4}, {6, 3}, {7, 2}])\n3", "level": "easy"}
{"task_id": "Elixir/22", "prompt": "defmodule GridShapeCalculator do\ndef count_shapes(n, m) do\n# Calculates the number of squares and rectangles (excluding squares) in an N x M grid.\n# The function takes two integers, N and M, representing the dimensions of the grid,\n# and returns a tuple with two integers: the first is the number of squares,\n# and the second is the number of rectangles (excluding squares).\n#\n# Examples:\n# >>> count_shapes(3, 3)\n# {14, 22}\n# >>> count_shapes(1, 4)\n# {4, 6}", "canonical_solution": "squares = Enum.reduce(1..min(n, m), 0, fn i, acc -> acc + (n - i + 1) * (m - i + 1) end)\nrectangles = Enum.reduce(1..n, 0, fn i, acc1 -> acc1 + Enum.reduce(1..m, 0, fn j, acc2 -> acc2 + (n - i + 1) * (m - j + 1) end) end)\n{squares, rectangles - squares}\nend\nend", "test": "ExUnit.start()\ndefmodule GridShapeCalculatorTest do\nuse ExUnit.Case\n\ntest \"counts squares and rectangles correctly\" do\nassert GridShapeCalculator.count_shapes(2, 3) == {8, 10}\nassert GridShapeCalculator.count_shapes(3, 3) == {14, 22}\nend\n\ntest \"handles single row or column grid\" do\nassert GridShapeCalculator.count_shapes(1, 4) == {4, 6}\nassert GridShapeCalculator.count_shapes(5, 1) == {5, 10}\nend\nend", "entry_point": "count_shapes", "signature": "def count_shapes(n, m) do", "docstring": "Calculates the number of squares and rectangles (excluding squares) in an N x M grid.\nThe function takes two integers, N and M, representing the dimensions of the grid,\nand returns a tuple with two integers: the first is the number of squares,\nand the second is the number of rectangles (excluding squares).\n\nExamples:\n>>> count_shapes(3, 3)\n{14, 22}\n>>> count_shapes(1, 4)\n{4, 6}", "instruction": "Write a Elixir function `def count_shapes(n, m) do` to solve the following problem:\nCalculates the number of squares and rectangles (excluding squares) in an N x M grid.\nThe function takes two integers, N and M, representing the dimensions of the grid,\nand returns a tuple with two integers: the first is the number of squares,\nand the second is the number of rectangles (excluding squares).\n\nExamples:\n>>> count_shapes(3, 3)\n{14, 22}\n>>> count_shapes(1, 4)\n{4, 6}", "level": "middle"}
{"task_id": "Elixir/23", "prompt": "defmodule WeatherAnalyzer do\ndef longest_rising_temperature_streak(temperatures) do\n# Calculates the longest streak of consecutive days with rising maximum temperatures.\n# The function takes a list of integers representing daily maximum temperatures and\n# returns the length of the longest consecutive sequence where each temperature is\n# higher than the previous day's temperature.\n#\n# Examples:\n# >>> longest_rising_temperature_streak([3, 4, 5, 1, 2])\n# 3", "canonical_solution": "temperatures\n|> Enum.reduce({0, nil, 0}, fn temp, {max_streak, prev_temp, current_streak} ->\nif prev_temp == nil or temp > prev_temp do\n{max(max_streak, current_streak + 1), temp, current_streak + 1}\nelse\n{max_streak, temp, 1}\nend\nend)\n|> elem(0)\nend\nend", "test": "ExUnit.start()\ndefmodule WeatherAnalyzerTest do\nuse ExUnit.Case\n\ntest \"finds the longest rising temperature streak correctly\" do\nassert WeatherAnalyzer.longest_rising_temperature_streak([1, 2, 3, 2, 4, 5, 6, 8, 5, 9]) == 5\nassert WeatherAnalyzer.longest_rising_temperature_streak([3, 4, 5, 1, 2]) == 3\nend\n\ntest \"handles constant temperatures\" do\nassert WeatherAnalyzer.longest_rising_temperature_streak([5, 5, 5, 5, 5]) == 1\nend\n\ntest \"handles single temperature\" do\nassert WeatherAnalyzer.longest_rising_temperature_streak([7]) == 1\nend\nend", "entry_point": "longest_rising_temperature_streak", "signature": "def longest_rising_temperature_streak(temperatures) do", "docstring": "Calculates the longest streak of consecutive days with rising maximum temperatures.\nThe function takes a list of integers representing daily maximum temperatures and\nreturns the length of the longest consecutive sequence where each temperature is\nhigher than the previous day's temperature.\n\nExamples:\n>>> longest_rising_temperature_streak([3, 4, 5, 1, 2])\n3", "instruction": "Write a Elixir function `def longest_rising_temperature_streak(temperatures) do` to solve the following problem:\nCalculates the longest streak of consecutive days with rising maximum temperatures.\nThe function takes a list of integers representing daily maximum temperatures and\nreturns the length of the longest consecutive sequence where each temperature is\nhigher than the previous day's temperature.\n\nExamples:\n>>> longest_rising_temperature_streak([3, 4, 5, 1, 2])\n3", "level": "middle"}
{"task_id": "Elixir/24", "prompt": "defmodule NotebookTheftCalculator do\ndef calculate_theft(start_time, end_time, notebooks_per_second) do\n# Calculates the number of notebooks that Zhu Bajie can steal from Sha Wujing\n# in the time before Sun Wukong arrives. The function takes two time strings in the format\n# \"HH:MM:SS\" representing the start and end times, and an integer representing the\n# number of notebooks Zhu Bajie can steal per second.\n#\n# Examples:\n# >>> calculate_theft(\"00:00:00\", \"00:00:10\", 10)\n# 100\n# >>> calculate_theft(\"01:23:45\", \"02:00:00\", 5)\n# 10875", "canonical_solution": "start_seconds = time_to_seconds(start_time)\nend_seconds = time_to_seconds(end_time)\n\n# Adjust for end time being on the next day\nend_seconds = if end_seconds < start_seconds, do: end_seconds + 24 * 3600, else: end_seconds\n\n(end_seconds - start_seconds) * notebooks_per_second\nend\n\ndefp time_to_seconds(time) do\n[h, m, s] = time |> String.split(\":\") |> Enum.map(&String.to_integer/1)\nh * 3600 + m * 60 + s\nend\nend", "test": "ExUnit.start()\ndefmodule NotebookTheftCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates notebook theft correctly\" do\nassert NotebookTheftCalculator.calculate_theft(\"00:00:00\", \"00:00:10\", 10) == 100\nassert NotebookTheftCalculator.calculate_theft(\"01:23:45\", \"02:00:00\", 5) == 10875\nend\n\ntest \"handles edge cases\" do\nassert NotebookTheftCalculator.calculate_theft(\"23:59:59\", \"00:00:01\", 1) == 2\nassert NotebookTheftCalculator.calculate_theft(\"12:30:00\", \"12:30:30\", 2) == 60\nend\nend", "entry_point": "calculate_theft", "signature": "def calculate_theft(start_time, end_time, notebooks_per_second) do", "docstring": "Calculates the number of notebooks that Zhu Bajie can steal from Sha Wujing\nin the time before Sun Wukong arrives. The function takes two time strings in the format\n\"HH:MM:SS\" representing the start and end times, and an integer representing the\nnumber of notebooks Zhu Bajie can steal per second.\n\nExamples:\n>>> calculate_theft(\"00:00:00\", \"00:00:10\", 10)\n100\n>>> calculate_theft(\"01:23:45\", \"02:00:00\", 5)\n10875", "instruction": "Write a Elixir function `def calculate_theft(start_time, end_time, notebooks_per_second) do` to solve the following problem:\nCalculates the number of notebooks that Zhu Bajie can steal from Sha Wujing\nin the time before Sun Wukong arrives. The function takes two time strings in the format\n\"HH:MM:SS\" representing the start and end times, and an integer representing the\nnumber of notebooks Zhu Bajie can steal per second.\n\nExamples:\n>>> calculate_theft(\"00:00:00\", \"00:00:10\", 10)\n100\n>>> calculate_theft(\"01:23:45\", \"02:00:00\", 5)\n10875", "level": "hard"}
{"task_id": "Elixir/25", "prompt": "defmodule InfectionCalculator do\ndef total_infected(x, n) do\n# Calculates the total number of individuals infected after 'n' rounds of contagion,\n# with each individual infecting 'x' others in each round. The function takes two integers,\n# 'x' and 'n', and returns the total number of individuals infected.\n#\n# Examples:\n# >>> total_infected(10, 2)\n# 121\n# >>> total_infected(3, 3)\n# 64", "canonical_solution": "calculate_total(1, x, n)\nend\n\ndefp calculate_total(total, _x, 0), do: total\n\ndefp calculate_total(total, x, n) do\ncalculate_total(total + total * x, x, n - 1)\nend\nend", "test": "ExUnit.start()\ndefmodule InfectionCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates total infection correctly\" do\nassert InfectionCalculator.total_infected(10, 2) == 121\nassert InfectionCalculator.total_infected(3, 3) == 64\nend\n\ntest \"handles zero rounds\" do\nassert InfectionCalculator.total_infected(10, 0) == 1\nend\n\ntest \"handles zero infection rate\" do\nassert InfectionCalculator.total_infected(0, 5) == 1\nend\nend", "entry_point": "total_infected", "signature": "def total_infected(x, n) do", "docstring": "Calculates the total number of individuals infected after 'n' rounds of contagion,\nwith each individual infecting 'x' others in each round. The function takes two integers,\n'x' and 'n', and returns the total number of individuals infected.\n\nExamples:\n>>> total_infected(10, 2)\n121\n>>> total_infected(3, 3)\n64", "instruction": "Write a Elixir function `def total_infected(x, n) do` to solve the following problem:\nCalculates the total number of individuals infected after 'n' rounds of contagion,\nwith each individual infecting 'x' others in each round. The function takes two integers,\n'x' and 'n', and returns the total number of individuals infected.\n\nExamples:\n>>> total_infected(10, 2)\n121\n>>> total_infected(3, 3)\n64", "level": "easy"}
{"task_id": "Elixir/26", "prompt": "defmodule ManureTransportUtils do\ndef min_distance(a, b, x, y) do\n# Calculates the minimum distance Farmer John needs to transport manure using a tractor,\n# considering the possibility of using a teleportation portal.\n# The function takes four integers: start point (a), end point (b), and portal points (x, y).\n# The function returns the minimum distance required for transportation.\n#\n# Examples:\n# >>> min_distance(3, 10, 8, 2)\n# 3\n# >>> min_distance(5, 15, 10, 2)\n# 8\n# >>> min_distance(0, 20, 5, 10)\n# 15", "canonical_solution": "normal_distance = abs(a - b)\nportal_distance_via_x = abs(a - x) + abs(b - y)\nportal_distance_via_y = abs(a - y) + abs(b - x)\n\nEnum.min([normal_distance, portal_distance_via_x, portal_distance_via_y])\nend\nend", "test": "ExUnit.start()\n\ndefmodule ManureTransportUtilsTest do\nuse ExUnit.Case\n\ntest \"calculates minimum distance with portal being useful\" do\nassert ManureTransportUtils.min_distance(3, 10, 8, 2) == 3\nend\n\ntest \"calculates minimum distance with portal not being useful\" do\nassert ManureTransportUtils.min_distance(5, 15, 10, 20) == 10\nend\n\ntest \"calculates minimum distance with start and end points being the same\" do\nassert ManureTransportUtils.min_distance(5, 5, 10, 20) == 0\nend\n\ntest \"calculates minimum distance with portal being exactly on the route\" do\nassert ManureTransportUtils.min_distance(0, 20, 5, 10) == 15\nend\nend", "entry_point": "min_distance", "signature": "def min_distance(a, b, x, y) do", "docstring": "Calculates the minimum distance Farmer John needs to transport manure using a tractor,\nconsidering the possibility of using a teleportation portal.\nThe function takes four integers: start point (a), end point (b), and portal points (x, y).\nThe function returns the minimum distance required for transportation.\n\nExamples:\n>>> min_distance(3, 10, 8, 2)\n3\n>>> min_distance(5, 15, 10, 2)\n8\n>>> min_distance(0, 20, 5, 10)\n15", "instruction": "Write a Elixir function `def min_distance(a, b, x, y) do` to solve the following problem:\nCalculates the minimum distance Farmer John needs to transport manure using a tractor,\nconsidering the possibility of using a teleportation portal.\nThe function takes four integers: start point (a), end point (b), and portal points (x, y).\nThe function returns the minimum distance required for transportation.\n\nExamples:\n>>> min_distance(3, 10, 8, 2)\n3\n>>> min_distance(5, 15, 10, 2)\n8\n>>> min_distance(0, 20, 5, 10)\n15", "level": "easy"}
{"task_id": "Elixir/27", "prompt": "defmodule KeypadTyping do\ndefp keypad do\n%{\n\"a\" => 1, \"b\" => 2, \"c\" => 3,\n\"d\" => 1, \"e\" => 2, \"f\" => 3,\n\"g\" => 1, \"h\" => 2, \"i\" => 3,\n\"j\" => 1, \"k\" => 2, \"l\" => 3,\n\"m\" => 1, \"n\" => 2, \"o\" => 3,\n\"p\" => 1, \"q\" => 2, \"r\" => 3, \"s\" => 4,\n\"t\" => 1, \"u\" => 2, \"v\" => 3,\n\"w\" => 1, \"x\" => 2, \"y\" => 3, \"z\" => 4,\n\" \" => 1\n}\nend\n\ndef count_key_presses(sentence) do\n# Counts the number of key presses required to type a given sentence\n# on a traditional mobile phone keypad. Each letter corresponds to a certain\n# number of key presses on a numeric keypad.\n# A space character requires a single key press.\n#\n# Examples:\n# >>> count_key_presses(\"hello world\")\n# 25", "canonical_solution": "sentence\n|> String.graphemes()\n|> Enum.map(&Map.get(keypad(), &1))\n|> Enum.sum()\nend\nend", "test": "ExUnit.start()\n\ndefmodule KeypadTypingTest do\nuse ExUnit.Case\n\ntest \"counts key presses for simple sentences\" do\nassert KeypadTyping.count_key_presses(\"hello world\") == 25\nassert KeypadTyping.count_key_presses(\"good night\") == 18\nend\n\ntest \"counts key presses for sentences with single letter words\" do\nassert KeypadTyping.count_key_presses(\"a b c\") == 8\nassert KeypadTyping.count_key_presses(\"i am here\") == 16\nend\n\ntest \"handles sentences with multiple spaces\" do\nassert KeypadTyping.count_key_presses(\"abc def\") == 13\nend\nend", "entry_point": "count_key_presses", "signature": "def count_key_presses(sentence) do", "docstring": "Counts the number of key presses required to type a given sentence\non a traditional mobile phone keypad. Each letter corresponds to a certain\nnumber of key presses on a numeric keypad.\nA space character requires a single key press.\n\nExamples:\n>>> count_key_presses(\"hello world\")\n25", "instruction": "Write a Elixir function `def count_key_presses(sentence) do` to solve the following problem:\nCounts the number of key presses required to type a given sentence\non a traditional mobile phone keypad. Each letter corresponds to a certain\nnumber of key presses on a numeric keypad.\nA space character requires a single key press.\n\nExamples:\n>>> count_key_presses(\"hello world\")\n25", "level": "easy"}
{"task_id": "Elixir/28", "prompt": "defmodule LightMatrix do\ndef count_monster_spawns(n, torch_positions, glowstone_positions) do\n# Counts the number of points in an n x n grid that will spawn monsters\n# given the positions of torches and glowstones. Torches illuminate a specific pattern\n# around them, while glowstones illuminate all surrounding cells.\n# The function takes the size of the grid (n), a list of torch positions, and a list of glowstone positions.\n# Each position is a tuple {x, y}.\n# It returns the count of points where monsters will spawn.\n#\n# Examples:\n# >>> count_monster_spawns(5, [{3, 3}], [])\n# 12", "canonical_solution": "grid = for x <- 1..n, y <- 1..n, do: {x, y}\nilluminated_torch = torch_positions |> Enum.flat_map(&torch_area/1)\nilluminated_glowstone = glowstone_positions |> Enum.flat_map(&glowstone_area/1)\nilluminated = Enum.uniq(illuminated_torch ++ illuminated_glowstone)\n\nEnum.count(grid -- illuminated)\nend\n\ndefp torch_area({x, y}) do\nfor dx <- -2..2, dy <- -2..2, abs(dx) + abs(dy) <= 2, do: {x + dx, y + dy}\nend\n\ndefp glowstone_area({x, y}) do\nfor dx <- -2..2, dy <- -2..2, do: {x + dx, y + dy}\nend\nend", "test": "ExUnit.start()\n\ndefmodule LightMatrixTest do\nuse ExUnit.Case\n\ntest \"counts monster spawn points with only torches\" do\nassert LightMatrix.count_monster_spawns(5, [{3, 3}], []) == 12\nend\n\ntest \"counts monster spawn points with torches and glowstones\" do\nassert LightMatrix.count_monster_spawns(5, [{2, 2}], [{4, 4}]) == 4\nend\n\ntest \"counts monster spawn points in small grid\" do\nassert LightMatrix.count_monster_spawns(3, [{2, 2}], []) == 0\nend\nend", "entry_point": "count_monster_spawns", "signature": "def count_monster_spawns(n, torch_positions, glowstone_positions) do", "docstring": "Counts the number of points in an n x n grid that will spawn monsters\ngiven the positions of torches and glowstones. Torches illuminate a specific pattern\naround them, while glowstones illuminate all surrounding cells.\nThe function takes the size of the grid (n), a list of torch positions, and a list of glowstone positions.\nEach position is a tuple {x, y}.\nIt returns the count of points where monsters will spawn.\n\nExamples:\n>>> count_monster_spawns(5, [{3, 3}], [])\n12", "instruction": "Write a Elixir function `def count_monster_spawns(n, torch_positions, glowstone_positions) do` to solve the following problem:\nCounts the number of points in an n x n grid that will spawn monsters\ngiven the positions of torches and glowstones. Torches illuminate a specific pattern\naround them, while glowstones illuminate all surrounding cells.\nThe function takes the size of the grid (n), a list of torch positions, and a list of glowstone positions.\nEach position is a tuple {x, y}.\nIt returns the count of points where monsters will spawn.\n\nExamples:\n>>> count_monster_spawns(5, [{3, 3}], [])\n12", "level": "hard"}
{"task_id": "Elixir/29", "prompt": "defmodule BombingAnalysis do\ndef analyze_bombings(bomb_coords, target_coords) do\n# Analyzes a set of bombing coordinates and checks if target points have been hit.\n# The function takes a list of bombing coordinates, each represented by a tuple of\n# four integers (left upper and right lower corner of the bombed area), and a list\n# of target coordinates, each represented by a tuple of two integers (point coordinates).\n# It returns a list of tuples, each containing a boolean (hit or not), the number of times\n# hit, and the round number of the last hit (if applicable).\n#\n# Examples:\n# >>> analyze_bombings([{1, 1, 5, 5}, {5, 5, 10, 10}], [{3, 2}, {5, 5}, {7, 1}])\n# [{true, 1, 1}, {true, 2, 2}, {false, 0, 0}]", "canonical_solution": "Enum.map(target_coords, fn target ->\nhit_info = Enum.reduce(bomb_coords, {false, 0, 0}, fn {x1, y1, x2, y2}, {hit, count, round} ->\nif in_range?(target, {x1, y1, x2, y2}), do: {true, count + 1, round + 1}, else: {hit, count, round}\nend)\ncase hit_info do\n{true, count, round} -> {true, count, round}\n_ -> {false, 0, 0}\nend\nend)\nend\n\ndefp in_range?({x, y}, {x1, y1, x2, y2}), do: x in x1..x2 and y in y1..y2\nend", "test": "ExUnit.start()\n\ndefmodule BombingAnalysisTest do\nuse ExUnit.Case\n\ntest \"analyzes bombing impacts on target points\" do\nassert BombingAnalysis.analyze_bombings([{1, 1, 5, 5}, {5, 5, 10, 10}], [{3, 2}, {5, 5}, {7, 1}]) ==\n[{true, 1, 1}, {true, 2, 2}, {false, 0, 0}]\nassert BombingAnalysis.analyze_bombings([{2, 2, 4, 4}], [{1, 1}, {3, 3}]) ==\n[{false, 0, 0}, {true, 1, 1}]\nend\nend", "entry_point": "analyze_bombings", "signature": "def analyze_bombings(bomb_coords, target_coords) do", "docstring": "Analyzes a set of bombing coordinates and checks if target points have been hit.\nThe function takes a list of bombing coordinates, each represented by a tuple of\nfour integers (left upper and right lower corner of the bombed area), and a list\nof target coordinates, each represented by a tuple of two integers (point coordinates).\nIt returns a list of tuples, each containing a boolean (hit or not), the number of times\nhit, and the round number of the last hit (if applicable).\n\nExamples:\n>>> analyze_bombings([{1, 1, 5, 5}, {5, 5, 10, 10}], [{3, 2}, {5, 5}, {7, 1}])\n[{true, 1, 1}, {true, 2, 2}, {false, 0, 0}]", "instruction": "Write a Elixir function `def analyze_bombings(bomb_coords, target_coords) do` to solve the following problem:\nAnalyzes a set of bombing coordinates and checks if target points have been hit.\nThe function takes a list of bombing coordinates, each represented by a tuple of\nfour integers (left upper and right lower corner of the bombed area), and a list\nof target coordinates, each represented by a tuple of two integers (point coordinates).\nIt returns a list of tuples, each containing a boolean (hit or not), the number of times\nhit, and the round number of the last hit (if applicable).\n\nExamples:\n>>> analyze_bombings([{1, 1, 5, 5}, {5, 5, 10, 10}], [{3, 2}, {5, 5}, {7, 1}])\n[{true, 1, 1}, {true, 2, 2}, {false, 0, 0}]", "level": "hard"}
{"task_id": "Elixir/30", "prompt": "defmodule ExperienceCalculator do\ndef calculate_level_and_exp(operations) do\n# Calculates the final level and remaining experience points after a series of operations.\n# Each operation consists of life points spent and experience points gained.\n# The initial life points are 10, and life points can be gained or spent in each operation.\n# If life points drop to 0 or below, the remaining operations are ignored.\n# Experience points are accumulated to calculate the final level.\n# Leveling up requires 2^m points where m is the current level.\n# Returns a tuple with the final level and remaining experience points.\n# >>> calculate_level_and_exp([{3, 5}, {-2, 8}])\n# {3, 6}", "canonical_solution": "{final_life, total_exp} = Enum.reduce(operations, {10, 0}, fn {life_change, exp_gain}, {life, exp} ->\nnew_life = min(life - life_change, 10)\nif new_life > 0, do: {new_life, exp + exp_gain}, else: {0, exp}\nend)\n\nif final_life > 0, do: calculate_level(total_exp, 0), else: {0, 0}\nend\n\ndefp calculate_level(exp, level) do\nrequired_exp = :math.pow(2, level)\nif exp >= required_exp, do: calculate_level(exp - required_exp, level + 1), else: {level, exp}\nend\nend", "test": "ExUnit.start()\ndefmodule ExperienceCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates final level and experience with valid operations\" do\nassert ExperienceCalculator.calculate_level_and_exp([{3, 5}, {-2, 8}]) == {3, 6}\nend\n\ntest \"handles operations resulting in death\" do\nassert ExperienceCalculator.calculate_level_and_exp([{10, 10}, {10, 20}]) == {0, 0}\nend\n\ntest \"handles operations with life recovery\" do\nassert ExperienceCalculator.calculate_level_and_exp([{-5, 5}, {-4, 10}, {2, 3}]) == {4, 3}\nend\nend", "entry_point": "calculate_level_and_exp", "signature": "def calculate_level_and_exp(operations) do", "docstring": "Calculates the final level and remaining experience points after a series of operations.\nEach operation consists of life points spent and experience points gained.\nThe initial life points are 10, and life points can be gained or spent in each operation.\nIf life points drop to 0 or below, the remaining operations are ignored.\nExperience points are accumulated to calculate the final level.\nLeveling up requires 2^m points where m is the current level.\nReturns a tuple with the final level and remaining experience points.\n>>> calculate_level_and_exp([{3, 5}, {-2, 8}])\n{3, 6}", "instruction": "Write a Elixir function `def calculate_level_and_exp(operations) do` to solve the following problem:\nCalculates the final level and remaining experience points after a series of operations.\nEach operation consists of life points spent and experience points gained.\nThe initial life points are 10, and life points can be gained or spent in each operation.\nIf life points drop to 0 or below, the remaining operations are ignored.\nExperience points are accumulated to calculate the final level.\nLeveling up requires 2^m points where m is the current level.\nReturns a tuple with the final level and remaining experience points.\n>>> calculate_level_and_exp([{3, 5}, {-2, 8}])\n{3, 6}", "level": "hard"}
{"task_id": "Elixir/31", "prompt": "defmodule LightSwitch do\ndef find_open_lights(n) do\n# Determines which lights are left on after a series of toggle operations.\n# Initially, all lights are off. People numbered from 1 to N sequentially toggle the state of lights:\n# Each person toggles the state of lights that are multiples of their own number.\n# The function returns the list of light numbers that remain on after N rounds.\n# >>> find_open_lights(3)\n# [1]\n# >>> find_open_lights(6)\n# [1, 4]", "canonical_solution": "1..n\n|> Enum.filter(fn x ->\nsquared = round(:math.sqrt(x))\nsquared * squared == x\nend)\nend\nend", "test": "ExUnit.start()\ndefmodule LightSwitchTest do\nuse ExUnit.Case\n\ntest \"finds open lights after a series of toggles\" do\nassert LightSwitch.find_open_lights(3) == [1]\nassert LightSwitch.find_open_lights(6) == [1, 4]\nend\n\ntest \"handles no open lights\" do\nassert LightSwitch.find_open_lights(2) == [1]\nend\n\ntest \"handles larger number of lights\" do\nassert LightSwitch.find_open_lights(10) == [1, 4, 9]\nend\nend", "entry_point": "find_open_lights", "signature": "def find_open_lights(n) do", "docstring": "Determines which lights are left on after a series of toggle operations.\nInitially, all lights are off. People numbered from 1 to N sequentially toggle the state of lights:\nEach person toggles the state of lights that are multiples of their own number.\nThe function returns the list of light numbers that remain on after N rounds.\n>>> find_open_lights(3)\n[1]\n>>> find_open_lights(6)\n[1, 4]", "instruction": "Write a Elixir function `def find_open_lights(n) do` to solve the following problem:\nDetermines which lights are left on after a series of toggle operations.\nInitially, all lights are off. People numbered from 1 to N sequentially toggle the state of lights:\nEach person toggles the state of lights that are multiples of their own number.\nThe function returns the list of light numbers that remain on after N rounds.\n>>> find_open_lights(3)\n[1]\n>>> find_open_lights(6)\n[1, 4]", "level": "easy"}
{"task_id": "Elixir/32", "prompt": "defmodule MaxProductFinder do\ndef max_product_partition(n, m) do\n# Finds M positive integers that sum up to N and have the maximum possible product.\n# The output is the lexicographically smallest arrangement of these numbers.\n# If it's not possible to find such numbers, returns an empty list.\n# >>> max_product_partition(8, 3)\n# [2, 3, 3]\n# >>> max_product_partition(10, 2)\n# [5, 5]", "canonical_solution": "if n < m, do: [], else: distribute_numbers(n, m)\nend\n\ndefp distribute_numbers(n, m) do\nbase = div(n, m)\nremainder = rem(n, m)\nList.duplicate(base, m - remainder) ++ List.duplicate(base + 1, remainder)\nend\nend", "test": "ExUnit.start()\ndefmodule MaxProductFinderTest do\nuse ExUnit.Case\n\ntest \"finds numbers with max product\" do\nassert MaxProductFinder.max_product_partition(8, 3) == [2, 3, 3]\nassert MaxProductFinder.max_product_partition(10, 2) == [5, 5]\nend\n\ntest \"handles impossible partitions\" do\nassert MaxProductFinder.max_product_partition(3, 5) == []\nend\n\ntest \"handles single number partition\" do\nassert MaxProductFinder.max_product_partition(5, 1) == [5]\nend\nend", "entry_point": "max_product_partition", "signature": "def max_product_partition(n, m) do", "docstring": "Finds M positive integers that sum up to N and have the maximum possible product.\nThe output is the lexicographically smallest arrangement of these numbers.\nIf it's not possible to find such numbers, returns an empty list.\n>>> max_product_partition(8, 3)\n[2, 3, 3]\n>>> max_product_partition(10, 2)\n[5, 5]", "instruction": "Write a Elixir function `def max_product_partition(n, m) do` to solve the following problem:\nFinds M positive integers that sum up to N and have the maximum possible product.\nThe output is the lexicographically smallest arrangement of these numbers.\nIf it's not possible to find such numbers, returns an empty list.\n>>> max_product_partition(8, 3)\n[2, 3, 3]\n>>> max_product_partition(10, 2)\n[5, 5]", "level": "easy"}
{"task_id": "Elixir/33", "prompt": "defmodule ElevatorTimeCalculator do\ndef total_time(floors) do\n# Calculates the total time for an elevator trip given the floors each passenger wishes to visit.\n# The elevator takes 6 seconds to go up a floor, 4 seconds to go down a floor,\n# 5 seconds for each stop to open the door (only if someone is getting off),\n# and an additional 1 second for each person getting off.\n# The elevator starts and ends at the ground floor (floor 0).\n# >>> total_time([2, 3])\n# 42\n# >>> total_time([1, 5, 2])\n# 68", "canonical_solution": "floors_with_counts = Enum.reduce(floors, %{}, fn floor, acc ->\nMap.update(acc, floor, 1, &(&1 + 1))\nend)\n\nsorted_floors = Enum.sort(floors_with_counts)\n\nEnum.reduce(sorted_floors, {0, 0}, fn {floor, count}, {last_floor, acc_time} ->\nmove_time = if floor > last_floor, do: 6 * (floor - last_floor), else: 4 * (last_floor - floor)\n{floor, acc_time + move_time + 5 + count}\nend)\n|> (fn {highest_floor, time} -> time + 4 * highest_floor end).()\nend\nend", "test": "ExUnit.start()\ndefmodule ElevatorTimeCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates total elevator time for a given trip\" do\nassert ElevatorTimeCalculator.total_time([2, 3]) == 42\nassert ElevatorTimeCalculator.total_time([1, 5, 2]) == 68\nend\n\ntest \"handles a single passenger\" do\nassert ElevatorTimeCalculator.total_time([3]) == 36\nend\n\ntest \"handles passengers to the same floor\" do\nassert ElevatorTimeCalculator.total_time([2, 2, 2]) == 28\nend\nend", "entry_point": "total_time", "signature": "def total_time(floors) do", "docstring": "Calculates the total time for an elevator trip given the floors each passenger wishes to visit.\nThe elevator takes 6 seconds to go up a floor, 4 seconds to go down a floor,\n5 seconds for each stop to open the door (only if someone is getting off),\nand an additional 1 second for each person getting off.\nThe elevator starts and ends at the ground floor (floor 0).\n>>> total_time([2, 3])\n42\n>>> total_time([1, 5, 2])\n68", "instruction": "Write a Elixir function `def total_time(floors) do` to solve the following problem:\nCalculates the total time for an elevator trip given the floors each passenger wishes to visit.\nThe elevator takes 6 seconds to go up a floor, 4 seconds to go down a floor,\n5 seconds for each stop to open the door (only if someone is getting off),\nand an additional 1 second for each person getting off.\nThe elevator starts and ends at the ground floor (floor 0).\n>>> total_time([2, 3])\n42\n>>> total_time([1, 5, 2])\n68", "level": "hard"}
{"task_id": "Elixir/34", "prompt": "defmodule PencilPurchaseCalculator do\ndef minimum_cost(n, packages) do\n# Calculates the minimum cost to buy at least 'n' pencils in fixed packaging.\n# Given the required number of pencils 'n' and a list of packages (each containing the number of pencils and the price),\n# the function returns the minimum cost to buy at least 'n' pencils.\n# Each package type is represented as a tuple with the number of pencils and its price.\n# >>> minimum_cost(57, [{2, 2}, {50, 30}, {30, 27}])\n# 54\n# >>> minimum_cost(100, [{10, 5}, {20, 7}, {30, 10}])\n# 35", "canonical_solution": "packages\n|> Enum.map(fn {quantity, price} ->\npacks_needed = div(n - 1, quantity) + 1\npacks_needed * price\nend)\n|> Enum.min()\nend\nend", "test": "ExUnit.start()\ndefmodule PencilPurchaseCalculatorTest do\nuse ExUnit.Case\n\ntest \"calculates minimum cost for required pencils\" do\nassert PencilPurchaseCalculator.minimum_cost(57, [{2, 2}, {50, 30}, {30, 27}]) == 54\nassert PencilPurchaseCalculator.minimum_cost(100, [{10, 5}, {20, 7}, {30, 10}]) == 35\nend\n\ntest \"handles single package type\" do\nassert PencilPurchaseCalculator.minimum_cost(50, [{10, 10}]) == 50\nend\n\ntest \"handles exact quantity match\" do\nassert PencilPurchaseCalculator.minimum_cost(60, [{30, 15}, {60, 25}, {90, 35}]) == 25\nend\nend", "entry_point": "minimum_cost", "signature": "def minimum_cost(n, packages) do", "docstring": "Calculates the minimum cost to buy at least 'n' pencils in fixed packaging.\nGiven the required number of pencils 'n' and a list of packages (each containing the number of pencils and the price),\nthe function returns the minimum cost to buy at least 'n' pencils.\nEach package type is represented as a tuple with the number of pencils and its price.\n>>> minimum_cost(57, [{2, 2}, {50, 30}, {30, 27}])\n54\n>>> minimum_cost(100, [{10, 5}, {20, 7}, {30, 10}])\n35", "instruction": "Write a Elixir function `def minimum_cost(n, packages) do` to solve the following problem:\nCalculates the minimum cost to buy at least 'n' pencils in fixed packaging.\nGiven the required number of pencils 'n' and a list of packages (each containing the number of pencils and the price),\nthe function returns the minimum cost to buy at least 'n' pencils.\nEach package type is represented as a tuple with the number of pencils and its price.\n>>> minimum_cost(57, [{2, 2}, {50, 30}, {30, 27}])\n54\n>>> minimum_cost(100, [{10, 5}, {20, 7}, {30, 10}])\n35", "level": "easy"}
{"task_id": "Elixir/35", "prompt": "defmodule PasswordGenerator do\ndef generate_password(n, original_string) do\n# Generates a password by shifting each letter in the original string by 'n' positions in the alphabet.\n# The shift wraps around from 'z' to 'a'.\n# >>> generate_password(1, \"abc\")\n# \"bcd\"\n# >>> generate_password(2, \"xyz\")\n# \"zab\"", "canonical_solution": "original_string\n|> String.codepoints()\n|> Enum.map(&shift_char(&1, n))\n|> Enum.join()\nend\n\ndefp shift_char(char, shift) do\nchar_code = char |> String.to_charlist() |> hd() |> Kernel.-(?a)\nshifted_code = rem(char_code + shift, 26) |> Kernel.+(?a)\n<<shifted_code>>\nend\nend", "test": "ExUnit.start()\ndefmodule PasswordGeneratorTest do\nuse ExUnit.Case\n\ntest \"generates password with character shift\" do\nassert PasswordGenerator.generate_password(1, \"abc\") == \"bcd\"\nassert PasswordGenerator.generate_password(2, \"xyz\") == \"zab\"\nend\n\ntest \"handles wrap around from z to a\" do\nassert PasswordGenerator.generate_password(1, \"z\") == \"a\"\nend\n\ntest \"handles large shifts\" do\nassert PasswordGenerator.generate_password(26, \"abc\") == \"abc\"\nassert PasswordGenerator.generate_password(52, \"xyz\") == \"xyz\"\nend\nend", "entry_point": "generate_password", "signature": "def generate_password(n, original_string) do", "docstring": "Generates a password by shifting each letter in the original string by 'n' positions in the alphabet.\nThe shift wraps around from 'z' to 'a'.\n>>> generate_password(1, \"abc\")\n\"bcd\"\n>>> generate_password(2, \"xyz\")\n\"zab\"", "instruction": "Write a Elixir function `def generate_password(n, original_string) do` to solve the following problem:\nGenerates a password by shifting each letter in the original string by 'n' positions in the alphabet.\nThe shift wraps around from 'z' to 'a'.\n>>> generate_password(1, \"abc\")\n\"bcd\"\n>>> generate_password(2, \"xyz\")\n\"zab\"", "level": "middle"}
{"task_id": "Elixir/36", "prompt": "defmodule PalindromeUtils do\n  def count_palindromes(list) do\n  # Counts the number of palindrome numbers in a list.\n  # A palindrome number reads the same backward as forward.\n  # Args:\n  #   list: A list of integers.\n  # Returns:\n  #   An integer representing the count of palindrome numbers in the list.\n  #\n  # Examples:\n  # >>> count_palindromes([121, 131, 20])\n  # 2\n  # >>> count_palindromes([123, 324, 345])\n  # 0\n  # >>> count_palindromes([11, 22, 33, 44, 55])\n  # 5", "canonical_solution": "    list\n    |> Enum.filter(&is_palindrome/1)\n    |> length()\n  end\n\n  defp is_palindrome(number) do\n    original = Integer.to_string(number)\n    reversed = String.reverse(original)\n    original == reversed\n  end\nend", "test": "ExUnit.start()\n\ndefmodule PalindromeUtilsTest do\n  use ExUnit.Case\n\n  test \"counts palindromes with mixed numbers\" do\n    assert PalindromeUtils.count_palindromes([121, 131, 20]) == 2\n  end\n\n  test \"counts no palindromes in list\" do\n    assert PalindromeUtils.count_palindromes([123, 324, 345]) == 0\n  end\n\n  test \"counts all numbers as palindromes\" do\n    assert PalindromeUtils.count_palindromes([11, 22, 33, 44, 55]) == 5\n  end\n\n  test \"handles an empty list\" do\n    assert PalindromeUtils.count_palindromes([]) == 0\n  end\n\n  test \"handles a list with single-digit numbers\" do\n    assert PalindromeUtils.count_palindromes([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9\n  end\nend", "entry_point": "count_palindromes", "signature": "def count_palindromes(list) do", "docstring": " Counts the number of palindrome numbers in a list.\nA palindrome number reads the same backward as forward.\nArgs:\n  list: A list of integers.\nReturns:\n  An integer representing the count of palindrome numbers in the list.\n  \nExamples:\n>>> count_palindromes([121, 131, 20])\n2\n>>> count_palindromes([123, 324, 345])\n0\n>>> count_palindromes([11, 22, 33, 44, 55])\n5", "instruction": "Write a Elixir function `def count_palindromes(list) do` to solve the following problem: Counts the number of palindrome numbers in a list.\nA palindrome number reads the same backward as forward.\nArgs:\n  list: A list of integers.\nReturns:\n  An integer representing the count of palindrome numbers in the list.\n  \nExamples:\n>>> count_palindromes([121, 131, 20])\n2\n>>> count_palindromes([123, 324, 345])\n0\n>>> count_palindromes([11, 22, 33, 44, 55])\n5", "level": "easy"}
{"task_id": "Elixir/37", "prompt": "defmodule SearchUtils do\n  def binary_search(list, target) do\n    # Performs a binary search to find the index of a target value in a sorted list.\n  # Args:\n  #   list: A sorted list of integers.\n  #   target: An integer value to find in the list.\n  # Returns:\n  #   The index of the target in the list if found, otherwise returns -1.\n  #\n  # Examples:\n  # >>> binary_search([1, 2, 3, 4, 5], 3)\n  # 2\n  # >>> binary_search([1, 3, 5, 7, 9], 8)\n  # -1\n  # >>> binary_search([10, 20, 30, 40, 50], 10)\n  # 0\n  # >>> binary_search([], 1)\n  # -1", "canonical_solution": "    do_binary_search(list, target, 0, length(list) - 1)\n  end\n\n  defp do_binary_search(_list, _target, start, finish) when start > finish do\n    -1\n  end\n\n  defp do_binary_search(list, target, start, finish) do\n    mid = div(start + finish, 2)\n    case Enum.at(list, mid) do\n      ^target -> mid\n      num when num < target -> do_binary_search(list, target, mid + 1, finish)\n      _num -> do_binary_search(list, target, start, mid - 1)\n    end\n  end\nend", "test": "ExUnit.start()\n\ndefmodule SearchUtilsTest do\n  use ExUnit.Case\n\n  test \"finds the target in the middle of the list\" do\n    assert SearchUtils.binary_search([1, 2, 3, 4, 5], 3) == 2\n  end\n\n  test \"returns -1 if the target is not in the list\" do\n    assert SearchUtils.binary_search([1, 3, 5, 7, 9], 8) == -1\n  end\n\n  test \"finds the target at the beginning of the list\" do\n    assert SearchUtils.binary_search([10, 20, 30, 40, 50], 10) == 0\n  end\n\n  test \"handles an empty list\" do\n    assert SearchUtils.binary_search([], 1) == -1\n  end\n\n  test \"finds the target at the end of the list\" do\n    assert SearchUtils.binary_search([1, 2, 3, 4, 5], 5) == 4\n  end\nend", "entry_point": "binary_search", "signature": "def binary_search(list, target) do", "docstring": " Performs a binary search to find the index of a target value in a sorted list.\nArgs:\n  list: A sorted list of integers.\n  target: An integer value to find in the list.\nReturns:\n  The index of the target in the list if found, otherwise returns -1.\n  \nExamples:\n>>> binary_search([1, 2, 3, 4, 5], 3)\n2\n>>> binary_search([1, 3, 5, 7, 9], 8)\n-1\n>>> binary_search([10, 20, 30, 40, 50], 10)\n0\n>>> binary_search([], 1)\n-1", "instruction": "Write a Elixir function `def binary_search(list, target) do` to solve the following problem: Performs a binary search to find the index of a target value in a sorted list.\nArgs:\n  list: A sorted list of integers.\n  target: An integer value to find in the list.\nReturns:\n  The index of the target in the list if found, otherwise returns -1.\n  \nExamples:\n>>> binary_search([1, 2, 3, 4, 5], 3)\n2\n>>> binary_search([1, 3, 5, 7, 9], 8)\n-1\n>>> binary_search([10, 20, 30, 40, 50], 10)\n0\n>>> binary_search([], 1)\n-1", "level": "hard"}
{"task_id": "Elixir/38", "prompt": "defmodule SnCalculator do\n  def find_min_n(k) when is_integer(k) do\n    # Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\n  # The sum S_n grows as n increases, and for any given k, there exists an n such that S_n > k.\n  #\n  # Examples:\n  # >>> find_min_n(2)\n  # 4\n  # >>> find_min_n(3)\n  # 11\n  # This means for k=2, the smallest n where the sum of the sequence 1 + 1/2 + ... + 1/n exceeds 2 is 4.\n  # And for k=3, the smallest n where the sum exceeds 3 is 11.", "canonical_solution": "    find_min_n_helper(k, 1, 0)\n  end\n\n  defp find_min_n_helper(k, n, sum) when sum > k do\n    n - 1\n  end\n  defp find_min_n_helper(k, n, sum) do\n    find_min_n_helper(k, n + 1, sum + 1 / n)\n  end\nend", "test": "ExUnit.start()\ndefmodule SnCalculatorTest do\n  use ExUnit.Case\n\n  test \"finds minimum n for k=2\" do\n    assert SnCalculator.find_min_n(2) == 4\n  end\n\n  test \"finds minimum n for k=3\" do\n    assert SnCalculator.find_min_n(3) == 11\n  end\n\n  test \"finds minimum n for small k=1\" do\n    assert SnCalculator.find_min_n(1) == 2\n  end\n\n  test \"finds minimum n for larger k=10\" do\n    assert SnCalculator.find_min_n(10) == 12367\n  end\nend", "entry_point": "find_min_n", "signature": "def find_min_n(k) when is_integer(k) do", "docstring": " Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\nThe sum S_n grows as n increases, and for any given k, there exists an n such that S_n > k.\n  \nExamples:\n>>> find_min_n(2)\n4\n>>> find_min_n(3)\n11\nThis means for k=2, the smallest n where the sum of the sequence 1 + 1/2 + ... + 1/n exceeds 2 is 4.\nAnd for k=3, the smallest n where the sum exceeds 3 is 11.", "instruction": "Write a Elixir function `def find_min_n(k) when is_integer(k) do` to solve the following problem: Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than a given integer k.\nThe sum S_n grows as n increases, and for any given k, there exists an n such that S_n > k.\n  \nExamples:\n>>> find_min_n(2)\n4\n>>> find_min_n(3)\n11\nThis means for k=2, the smallest n where the sum of the sequence 1 + 1/2 + ... + 1/n exceeds 2 is 4.\nAnd for k=3, the smallest n where the sum exceeds 3 is 11.", "level": "easy"}
{"task_id": "Elixir/39", "prompt": "defmodule PenCalculator do\n  def max_pens(a, b) do\n  # Calculates the maximum number of pens that can be bought with a given amount of money.\n  # Each pen costs 1 yuan and 9 jiao (1.9 yuan). The function takes two arguments: `a` (the amount of yuan) and `b` (the amount of jiao).\n  #\n  # Examples:\n  # >>> max_pens(5, 5)\n  # 2\n  # >>> max_pens(20, 0)\n  # 10\n  # This means with 5 yuan and 5 jiao, one can buy 2 pens, and with 20 yuan, one can buy 10 pens.", "canonical_solution": "    total_jiao = a * 10 + b\n    div(total_jiao, 19)\n  end\nend", "test": "ExUnit.start()\ndefmodule PenCalculatorTest do\n  use ExUnit.Case\n\n  test \"calculates maximum pens with exact amount\" do\n    assert PenCalculator.max_pens(3, 8) == 2\n  end\n\n  test \"calculates maximum pens with extra jiao\" do\n    assert PenCalculator.max_pens(20, 0) == 10\n  end\n\n  test \"calculates maximum pens with no extra jiao\" do\n    assert PenCalculator.max_pens(1, 9) == 1\n  end\n\n  test \"calculates with zero yuan and some jiao\" do\n    assert PenCalculator.max_pens(0, 9) == 0\n  end\nend", "entry_point": "max_pens", "signature": "def max_pens(a, b) do", "docstring": " Calculates the maximum number of pens that can be bought with a given amount of money.\nEach pen costs 1 yuan and 9 jiao (1.9 yuan). The function takes two arguments: `a` (the amount of yuan) and `b` (the amount of jiao).\n  \nExamples:\n>>> max_pens(5, 5)\n2\n>>> max_pens(20, 0)\n10\nThis means with 5 yuan and 5 jiao, one can buy 2 pens, and with 20 yuan, one can buy 10 pens.", "instruction": "Write a Elixir function `def max_pens(a, b) do` to solve the following problem: Calculates the maximum number of pens that can be bought with a given amount of money.\nEach pen costs 1 yuan and 9 jiao (1.9 yuan). The function takes two arguments: `a` (the amount of yuan) and `b` (the amount of jiao).\n  \nExamples:\n>>> max_pens(5, 5)\n2\n>>> max_pens(20, 0)\n10\nThis means with 5 yuan and 5 jiao, one can buy 2 pens, and with 20 yuan, one can buy 10 pens.", "level": "easy"}
{"task_id": "Elixir/40", "prompt": "defmodule YearChecker do\n  def leap_year?(year) when is_integer(year) do\n  # Determines if a given year is a leap year.\n  # A year is a leap year if it is divisible by 4 but not by 100, unless it is also divisible by 400.\n  #\n  # Examples:\n  # >>> leap_year?(2020)\n  # true\n  # >>> leap_year?(1900)\n  # false\n  # >>> leap_year?(2000)\n  # true\n  # This means 2020 and 2000 are leap years, but 1900 is not, despite being divisible by 4, because it is not divisible by 400.", "canonical_solution": "    div_by_4 = rem(year, 4) == 0\n    div_by_100 = rem(year, 100) == 0\n    div_by_400 = rem(year, 400) == 0\n\n    div_by_4 and (not div_by_100 or div_by_400)\n  end\nend", "test": "ExUnit.start()\ndefmodule YearCheckerTest do\n  use ExUnit.Case\n\n  test \"year divisible by 4 but not 100 is leap year\" do\n    assert YearChecker.leap_year?(2024) == true\n  end\n\n  test \"year divisible by 100 but not 400 is not leap year\" do\n    assert YearChecker.leap_year?(1900) == false\n  end\n\n  test \"year divisible by 400 is leap year\" do\n    assert YearChecker.leap_year?(2000) == true\n  end\n\n  test \"year not divisible by 4 is not leap year\" do\n    assert YearChecker.leap_year?(2019) == false\n  end\nend", "entry_point": "leap_year", "signature": "def leap_year?(year) when is_integer(year) do", "docstring": " Determines if a given year is a leap year.\nA year is a leap year if it is divisible by 4 but not by 100, unless it is also divisible by 400.\n  \nExamples:\n>>> leap_year?(2020)\ntrue\n>>> leap_year?(1900)\nfalse\n>>> leap_year?(2000)\ntrue\nThis means 2020 and 2000 are leap years, but 1900 is not, despite being divisible by 4, because it is not divisible by 400.", "instruction": "Write a Elixir function `def leap_year?(year) when is_integer(year) do` to solve the following problem: Determines if a given year is a leap year.\nA year is a leap year if it is divisible by 4 but not by 100, unless it is also divisible by 400.\n  \nExamples:\n>>> leap_year?(2020)\ntrue\n>>> leap_year?(1900)\nfalse\n>>> leap_year?(2000)\ntrue\nThis means 2020 and 2000 are leap years, but 1900 is not, despite being divisible by 4, because it is not divisible by 400.", "level": "easy"}
{"task_id": "Elixir/41", "prompt": "defmodule MathOperation do\n  def calculate_expression(a, b, c) do\n    # Calculates the result of the expression (a+b) * c.\n    #\n    # Given three integers a, b, and c, this function computes the value of the expression (a+b) multiplied by c.\n    # It is assumed that all inputs are integers within the range -10^4 to 10^4.\n    #\n    # Examples\n    #   - calculate_expression(1, 2, 3)\n    #     # => 9\n    #   - calculate_expression(-1, -2, 2)\n    #     # => -6\n    #   - calculate_expression(0, 0, 5)\n    #     # => 0", "canonical_solution": "    (a + b) * c\n  end\nend", "test": "ExUnit.start()\ndefmodule MathOperationTest do\n  use ExUnit.Case\n\n  test \"calculate_expression with positive numbers\" do\n    assert MathOperation.calculate_expression(2, 3, 4) == 20\n  end\n\n  test \"calculate_expression with a negative number\" do\n    assert MathOperation.calculate_expression(-2, 3, 4) == 4\n  end\n\n  test \"calculate_expression with zero\" do\n    assert MathOperation.calculate_expression(0, 0, 0) == 0\n    assert MathOperation.calculate_expression(1, -1, 5) == 0\n  end\n\n  test \"calculate_expression with mixed sign numbers\" do\n    assert MathOperation.calculate_expression(-5, 5, 3) == 0\n    assert MathOperation.calculate_expression(10, -2, -3) == -24\n  end\nend", "entry_point": "calculate_expression", "signature": "def calculate_expression(a, b, c) do", "docstring": " Calculates the result of the expression (a+b) * c.\n    \n  Given three integers a, b, and c, this function computes the value of the expression (a+b) multiplied by c.\n  It is assumed that all inputs are integers within the range -10^4 to 10^4.\n    \n  Examples\n    - calculate_expression(1, 2, 3)\n    => 9\n    - calculate_expression(-1, -2, 2)\n    => -6\n    - calculate_expression(0, 0, 5)\n    => 0", "instruction": "Write a Elixir function `def calculate_expression(a, b, c) do` to solve the following problem: Calculates the result of the expression (a+b) * c.\n    \n  Given three integers a, b, and c, this function computes the value of the expression (a+b) multiplied by c.\n  It is assumed that all inputs are integers within the range -10^4 to 10^4.\n    \n  Examples\n    - calculate_expression(1, 2, 3)\n    => 9\n    - calculate_expression(-1, -2, 2)\n    => -6\n    - calculate_expression(0, 0, 5)\n    => 0", "level": "easy"}
{"task_id": "Elixir/42", "prompt": "defmodule AsciiCode do\n  def get_ascii_code(char) when is_binary(char) and byte_size(char) == 1 do\n    # Returns the ASCII code of a given visible character (excluding space).\n    #\n    # This function accepts a single character (string of length 1) as input\n    # and returns its ASCII code as an integer. The character must be a visible\n    # character (not a space).\n    #\n    # Examples\n    #   - get_ascii_code(\"A\")\n    #     # => 65\n    #   - get_ascii_code(\"z\")\n    #     # => 122\n    #   - get_ascii_code(\"!\")\n    #     # => 33", "canonical_solution": "    <<code::integer>> = char\n    code\n  end\nend", "test": "ExUnit.start()\ndefmodule AsciiCodeTest do\n  use ExUnit.Case\n\n  test \"get_ascii_code returns correct ASCII code for uppercase letters\" do\n    assert AsciiCode.get_ascii_code(\"A\") == 65\n    assert AsciiCode.get_ascii_code(\"Z\") == 90\n  end\n\n  test \"get_ascii_code returns correct ASCII code for lowercase letters\" do\n    assert AsciiCode.get_ascii_code(\"a\") == 97\n    assert AsciiCode.get_ascii_code(\"z\") == 122\n  end\n\n  test \"get_ascii_code returns correct ASCII code for digits\" do\n    assert AsciiCode.get_ascii_code(\"0\") == 48\n    assert AsciiCode.get_ascii_code(\"9\") == 57\n  end\n\n  test \"get_ascii_code returns correct ASCII code for special characters\" do\n    assert AsciiCode.get_ascii_code(\"!\") == 33\n    assert AsciiCode.get_ascii_code(\"@\") == 64\n  end\nend", "entry_point": "get_ascii_code", "signature": "def get_ascii_code(char) when is_binary(char) and byte_size(char) == 1 do", "docstring": " Returns the ASCII code of a given visible character (excluding space).\n    \n  This function accepts a single character (string of length 1) as input\n  and returns its ASCII code as an integer. The character must be a visible\n  character (not a space).\n    \n  Examples\n    - get_ascii_code(\"A\")\n    => 65\n    - get_ascii_code(\"z\")\n    => 122\n    - get_ascii_code(\"!\")\n    => 33", "instruction": "Write a Elixir function `def get_ascii_code(char) when is_binary(char) and byte_size(char) == 1 do` to solve the following problem: Returns the ASCII code of a given visible character (excluding space).\n    \n  This function accepts a single character (string of length 1) as input\n  and returns its ASCII code as an integer. The character must be a visible\n  character (not a space).\n    \n  Examples\n    - get_ascii_code(\"A\")\n    => 65\n    - get_ascii_code(\"z\")\n    => 122\n    - get_ascii_code(\"!\")\n    => 33", "level": "easy"}
{"task_id": "Elixir/43", "prompt": "defmodule AsciiConverter do\n  def ascii_to_char(ascii_code) when is_integer(ascii_code) do\n    # Converts an ASCII code to its corresponding character.\n    #\n    # Given an integer representing an ASCII code, this function returns the character associated with that code.\n    # The function guarantees that the input will be an integer less than 128 and greater than 0, corresponding to a visible character.\n    #\n    # Examples\n    #   - ascii_to_char(65)\n    #     # => \"A\"\n    #   - ascii_to_char(97)\n    #     # => \"a\"\n    #   - ascii_to_char(36)\n    #     # => \"$\"", "canonical_solution": "    <<ascii_code::size(8)>>\n  end\nend", "test": "ExUnit.start()\ndefmodule AsciiConverterTest do\n  use ExUnit.Case\n\n  test \"ascii_to_char returns the correct character for uppercase letters\" do\n    assert AsciiConverter.ascii_to_char(65) == \"A\"\n    assert AsciiConverter.ascii_to_char(90) == \"Z\"\n  end\n\n  test \"ascii_to_char returns the correct character for lowercase letters\" do\n    assert AsciiConverter.ascii_to_char(97) == \"a\"\n    assert AsciiConverter.ascii_to_char(122) == \"z\"\n  end\n\n  test \"ascii_to_char returns the correct character for digits\" do\n    assert AsciiConverter.ascii_to_char(48) == \"0\"\n    assert AsciiConverter.ascii_to_char(57) == \"9\"\n  end\n\n  test \"ascii_to_char returns the correct character for special characters\" do\n    assert AsciiConverter.ascii_to_char(33) == \"!\"\n    assert AsciiConverter.ascii_to_char(64) == \"@\"\n  end\nend", "entry_point": "ascii_to_char", "signature": "def ascii_to_char(ascii_code) when is_integer(ascii_code) do", "docstring": " Converts an ASCII code to its corresponding character.\n    \n  Given an integer representing an ASCII code, this function returns the character associated with that code.\n  The function guarantees that the input will be an integer less than 128 and greater than 0, corresponding to a visible character.\n    \n  Examples\n    - ascii_to_char(65)\n    => \"A\"\n    - ascii_to_char(97)\n    => \"a\"\n    - ascii_to_char(36)\n    => \"$\"", "instruction": "Write a Elixir function `def ascii_to_char(ascii_code) when is_integer(ascii_code) do` to solve the following problem: Converts an ASCII code to its corresponding character.\n    \n  Given an integer representing an ASCII code, this function returns the character associated with that code.\n  The function guarantees that the input will be an integer less than 128 and greater than 0, corresponding to a visible character.\n    \n  Examples\n    - ascii_to_char(65)\n    => \"A\"\n    - ascii_to_char(97)\n    => \"a\"\n    - ascii_to_char(36)\n    => \"$\"", "level": "easy"}
{"task_id": "Elixir/44", "prompt": "defmodule TypeConversion do\n  def int_to_bool_to_int(value) when is_integer(value) do\n    # Converts an integer to a boolean and then back to an integer.\n    #\n    # Given an integer, this function first converts the integer to a boolean value\n    # (where any non-zero integer is treated as true, and zero as false), and then\n    # converts this boolean back to an integer (true to 1, false to 0).\n    #\n    # Examples\n    #   - int_to_bool_to_int(0)\n    #     # => 0\n    #   - int_to_bool_to_int(3)\n    #     # => 1\n    #   - int_to_bool_to_int(-1)\n    #     # => 1", "canonical_solution": "    case value do\n      0 -> 0\n      _ -> 1\n    end\n  end\nend", "test": "ExUnit.start()\ndefmodule TypeConversionTest do\n  use ExUnit.Case\n\n  test \"int_to_bool_to_int returns 0 for input 0\" do\n    assert TypeConversion.int_to_bool_to_int(0) == 0\n  end\n\n  test \"int_to_bool_to_int returns 1 for positive integers\" do\n    assert TypeConversion.int_to_bool_to_int(1) == 1\n    assert TypeConversion.int_to_bool_to_int(10) == 1\n  end\n\n  test \"int_to_bool_to_int returns 1 for negative integers\" do\n    assert TypeConversion.int_to_bool_to_int(-1) == 1\n    assert TypeConversion.int_to_bool_to_int(-10) == 1\n  end\nend", "entry_point": "int_to_bool_to_int", "signature": "def int_to_bool_to_int(value) when is_integer(value) do", "docstring": " Converts an integer to a boolean and then back to an integer.\n    \n  Given an integer, this function first converts the integer to a boolean value\n  (where any non-zero integer is treated as true, and zero as false), and then\n  converts this boolean back to an integer (true to 1, false to 0).\n    \n  Examples\n    - int_to_bool_to_int(0)\n    => 0\n    - int_to_bool_to_int(3)\n    => 1\n    - int_to_bool_to_int(-1)\n    => 1", "instruction": "Write a Elixir function `def int_to_bool_to_int(value) when is_integer(value) do` to solve the following problem: Converts an integer to a boolean and then back to an integer.\n    \n  Given an integer, this function first converts the integer to a boolean value\n  (where any non-zero integer is treated as true, and zero as false), and then\n  converts this boolean back to an integer (true to 1, false to 0).\n    \n  Examples\n    - int_to_bool_to_int(0)\n    => 0\n    - int_to_bool_to_int(3)\n    => 1\n    - int_to_bool_to_int(-1)\n    => 1", "level": "easy"}
{"task_id": "Elixir/45", "prompt": "defmodule ReverseNumber do\n  def reverse_three_digit(number) when is_integer(number) do\n    # Reverses a three-digit number.\n    #\n    # Given a three-digit integer, this function returns a new integer that is the reverse of the input number.\n    # It handles leading zeros in the output by returning an integer where the leading zeros are considered in the reversal.\n    #\n    # Examples\n    #   - reverse_three_digit(123)\n    #     # => 321\n    #   - reverse_three_digit(100)\n    #     # => 1 (equivalent to \"001\" when considering leading zeros in integer format)\n    #   - reverse_three_digit(905)\n    #     # => 509", "canonical_solution": "    Integer.to_string(number)\n    |> String.reverse()\n    |> String.to_integer()\n  end\nend", "test": "ExUnit.start()\ndefmodule ReverseNumberTest do\n  use ExUnit.Case\n\n  test \"reverse_three_digit reverses numbers correctly\" do\n    assert ReverseNumber.reverse_three_digit(123) == 321\n    assert ReverseNumber.reverse_three_digit(100) == 1  # Note: Leading zeros are not preserved in integers\n    assert ReverseNumber.reverse_three_digit(905) == 509\n    assert ReverseNumber.reverse_three_digit(210) == 12  # Note: Leading zeros result in a lower integer value\n  end\n\n  test \"reverse_three_digit handles edge cases\" do\n    assert ReverseNumber.reverse_three_digit(999) == 999\n    assert ReverseNumber.reverse_three_digit(101) == 101\n  end\nend", "entry_point": "reverse_three_digit", "signature": "def reverse_three_digit(number) when is_integer(number) do", "docstring": " Reverses a three-digit number.\n    \n  Given a three-digit integer, this function returns a new integer that is the reverse of the input number.\n  It handles leading zeros in the output by returning an integer where the leading zeros are considered in the reversal.\n    \n  Examples\n    - reverse_three_digit(123)\n    => 321\n    - reverse_three_digit(100)\n    => 1 (equivalent to \"001\" when considering leading zeros in integer format)\n    - reverse_three_digit(905)\n    => 509", "instruction": "Write a Elixir function `def reverse_three_digit(number) when is_integer(number) do` to solve the following problem: Reverses a three-digit number.\n    \n  Given a three-digit integer, this function returns a new integer that is the reverse of the input number.\n  It handles leading zeros in the output by returning an integer where the leading zeros are considered in the reversal.\n    \n  Examples\n    - reverse_three_digit(123)\n    => 321\n    - reverse_three_digit(100)\n    => 1 (equivalent to \"001\" when considering leading zeros in integer format)\n    - reverse_three_digit(905)\n    => 509", "level": "easy"}
{"task_id": "Elixir/46", "prompt": "defmodule ArithmeticSequence do\n  def nth_term(a1, a2, n) when is_integer(a1) and is_integer(a2) and is_integer(n) do\n    # Calculates the nth term of an arithmetic sequence.\n    #\n    # Given the first two terms a1 and a2 of an arithmetic sequence, and an integer n,\n    # this function computes the nth term of the sequence. The difference between any\n    # two consecutive terms is constant.\n    #\n    # Examples\n    #   - nth_term(1, 3, 4)\n    #     # => 7 (Sequence: 1, 3, 5, 7)\n    #   - nth_term(10, 20, 5)\n    #     # => 50 (Sequence: 10, 20, 30, 40, 50)\n    #   - nth_term(-5, -2, 10)\n    #     # => 23 (Sequence starts with -5, -2, ...)", "canonical_solution": "    d = a2 - a1  # Common difference\n    a1 + (n - 1) * d\n  end\nend", "test": "ExUnit.start()\ndefmodule ArithmeticSequenceTest do\n  use ExUnit.Case\n\n  test \"nth_term calculates correctly for positive difference\" do\n    assert ArithmeticSequence.nth_term(1, 4, 100) == 298\n    assert ArithmeticSequence.nth_term(0, 5, 20) == 95\n  end\n\n  test \"nth_term calculates correctly for negative difference\" do\n    assert ArithmeticSequence.nth_term(10, 5, 3) == 0\n    assert ArithmeticSequence.nth_term(20, 15, 4) == 5\n  end\n\n  test \"nth_term handles sequences with zero as a term\" do\n    assert ArithmeticSequence.nth_term(-3, 3, 3) == 9\n    assert ArithmeticSequence.nth_term(-10, -5, 5) == 10\n  end\n\n  test \"nth_term calculates correctly for single-digit increments\" do\n    assert ArithmeticSequence.nth_term(1, 2, 100) == 100\n    assert ArithmeticSequence.nth_term(-1, 0, 50) == 48\n  end\nend", "entry_point": "nth_term", "signature": "def nth_term(a1, a2, n) when is_integer(a1) and is_integer(a2) and is_integer(n) do", "docstring": " Calculates the nth term of an arithmetic sequence.\n    \n  Given the first two terms a1 and a2 of an arithmetic sequence, and an integer n,\n  this function computes the nth term of the sequence. The difference between any\n  two consecutive terms is constant.\n    \n  Examples\n    - nth_term(1, 3, 4)\n    => 7 (Sequence: 1, 3, 5, 7)\n    - nth_term(10, 20, 5)\n    => 50 (Sequence: 10, 20, 30, 40, 50)\n    - nth_term(-5, -2, 10)\n    => 23 (Sequence starts with -5, -2, ...)", "instruction": "Write a Elixir function `def nth_term(a1, a2, n) when is_integer(a1) and is_integer(a2) and is_integer(n) do` to solve the following problem: Calculates the nth term of an arithmetic sequence.\n    \n  Given the first two terms a1 and a2 of an arithmetic sequence, and an integer n,\n  this function computes the nth term of the sequence. The difference between any\n  two consecutive terms is constant.\n    \n  Examples\n    - nth_term(1, 3, 4)\n    => 7 (Sequence: 1, 3, 5, 7)\n    - nth_term(10, 20, 5)\n    => 50 (Sequence: 10, 20, 30, 40, 50)\n    - nth_term(-5, -2, 10)\n    => 23 (Sequence starts with -5, -2, ...)", "level": "easy"}
{"task_id": "Elixir/47", "prompt": "defmodule Multiplication do\n  def multiply(a, b) when is_integer(a) and is_integer(b) and a >= 1 and b >= 1 do\n  # Multiplies two positive integers A and B.\n  #\n  # Given two positive integers A and B, this function returns the product A * B.\n  # It is important to consider the range of the product to ensure the correct data type is used,\n  # given that A and B are within the range of 1 to 50,000.\n  #\n  # Examples\n  #   - multiply(3, 4)\n  #     # => 12\n  #   - multiply(10, 20)\n  #     # => 200\n  #   - multiply(50000, 2)\n  #     # => 100000", "canonical_solution": "    a * b\n  end\nend", "test": "ExUnit.start()\ndefmodule MultiplicationTest do\n  use ExUnit.Case\n\n  test \"multiply returns the correct product for small numbers\" do\n    assert Multiplication.multiply(3, 4) == 12\n    assert Multiplication.multiply(7, 5) == 35\n  end\n\n  test \"multiply returns the correct product for larger numbers\" do\n    assert Multiplication.multiply(123, 456) == 56088\n    assert Multiplication.multiply(50000, 2) == 100000\n  end\n\n  test \"multiply handles edge cases\" do\n    assert Multiplication.multiply(1, 50000) == 50000\n    assert Multiplication.multiply(50000, 1) == 50000\n  end\nend", "entry_point": "multiply", "signature": "def multiply(a, b) when is_integer(a) and is_integer(b) and a >= 1 and b >= 1 do", "docstring": " Multiplies two positive integers A and B.\n  \nGiven two positive integers A and B, this function returns the product A * B.\nIt is important to consider the range of the product to ensure the correct data type is used,\ngiven that A and B are within the range of 1 to 50,000.\n  \nExamples\n  - multiply(3, 4)\n  => 12\n  - multiply(10, 20)\n  => 200\n  - multiply(50000, 2)\n  => 100000", "instruction": "Write a Elixir function `def multiply(a, b) when is_integer(a) and is_integer(b) and a >= 1 and b >= 1 do` to solve the following problem: Multiplies two positive integers A and B.\n  \nGiven two positive integers A and B, this function returns the product A * B.\nIt is important to consider the range of the product to ensure the correct data type is used,\ngiven that A and B are within the range of 1 to 50,000.\n  \nExamples\n  - multiply(3, 4)\n  => 12\n  - multiply(10, 20)\n  => 200\n  - multiply(50000, 2)\n  => 100000", "level": "easy"}
{"task_id": "Elixir/48", "prompt": "defmodule PowerOfTwo do\n  def power(n) when is_integer(n) and n >= 0 do\n    # Calculates 2 to the power of n.\n    #\n    # Given a non-negative integer n, this function returns the value of 2 raised to the power of n.\n    # The function is designed to handle values of n from 0 up to 30, considering the size of integers.\n    #\n    # Examples\n    #   - power(0)\n    #     # => 1\n    #   - power(3)\n    #     # => 8\n    #   - power(10)\n    #     # => 1024", "canonical_solution": "    :math.pow(2, n) |> round()\n  end\nend", "test": "ExUnit.start()\ndefmodule PowerOfTwoTest do\n  use ExUnit.Case\n\n  test \"power returns 1 for n = 0\" do\n    assert PowerOfTwo.power(0) == 1\n  end\n\n  test \"power calculates 2^n for small n\" do\n    assert PowerOfTwo.power(1) == 2\n    assert PowerOfTwo.power(2) == 4\n    assert PowerOfTwo.power(3) == 8\n  end\n\n  test \"power calculates 2^n for larger n\" do\n    assert PowerOfTwo.power(10) == 1024\n    assert PowerOfTwo.power(20) == 1048576\n  end\n\n  test \"power handles the maximum n value\" do\n    assert PowerOfTwo.power(30) == 1073741824\n  end\nend", "entry_point": "power", "signature": "def power(n) when is_integer(n) and n >= 0 do", "docstring": " Calculates 2 to the power of n.\n    \n  Given a non-negative integer n, this function returns the value of 2 raised to the power of n.\n  The function is designed to handle values of n from 0 up to 30, considering the size of integers.\n    \n  Examples\n    - power(0)\n    => 1\n    - power(3)\n    => 8\n    - power(10)\n    => 1024", "instruction": "Write a Elixir function `def power(n) when is_integer(n) and n >= 0 do` to solve the following problem: Calculates 2 to the power of n.\n    \n  Given a non-negative integer n, this function returns the value of 2 raised to the power of n.\n  The function is designed to handle values of n from 0 up to 30, considering the size of integers.\n    \n  Examples\n    - power(0)\n    => 1\n    - power(3)\n    => 8\n    - power(10)\n    => 1024", "level": "easy"}
{"task_id": "Elixir/49", "prompt": "defmodule SignChecker do\n  def determine_sign(n) when is_integer(n) do\n    # Determines the sign of an integer N.\n    #\n    # This function takes an integer N as input and returns \"positive\" if N is greater than 0,\n    # \"zero\" if N is exactly 0, and \"negative\" if N is less than 0.\n    #\n    # Examples\n    #   - determine_sign(10)\n    #     \"positive\"\n    #   - determine_sign(0)\n    #     \"zero\"\n    #   - determine_sign(-5)\n    #     \"negative\"", "canonical_solution": "    case n do\n      n when n > 0 -> \"positive\"\n      0 -> \"zero\"\n      _ -> \"negative\"\n    end\n  end\nend", "test": "ExUnit.start()\ndefmodule SignCheckerTest do\n  use ExUnit.Case\n\n  test \"determine_sign returns positive for positive integers\" do\n    assert SignChecker.determine_sign(1) == \"positive\"\n    assert SignChecker.determine_sign(100) == \"positive\"\n  end\n\n  test \"determine_sign returns zero for zero\" do\n    assert SignChecker.determine_sign(0) == \"zero\"\n  end\n\n  test \"determine_sign returns negative for negative integers\" do\n    assert SignChecker.determine_sign(-1) == \"negative\"\n    assert SignChecker.determine_sign(-100) == \"negative\"\n  end\nend", "entry_point": "determine_sign", "signature": "def determine_sign(n) when is_integer(n) do", "docstring": " Determines the sign of an integer N.\n    \n  This function takes an integer N as input and returns \"positive\" if N is greater than 0,\n  \"zero\" if N is exactly 0, and \"negative\" if N is less than 0.\n    \n  Examples\n    - determine_sign(10)\n      \"positive\"\n    - determine_sign(0)\n      \"zero\"\n    - determine_sign(-5)\n      \"negative\"", "instruction": "Write a Elixir function `def determine_sign(n) when is_integer(n) do` to solve the following problem: Determines the sign of an integer N.\n    \n  This function takes an integer N as input and returns \"positive\" if N is greater than 0,\n  \"zero\" if N is exactly 0, and \"negative\" if N is less than 0.\n    \n  Examples\n    - determine_sign(10)\n      \"positive\"\n    - determine_sign(0)\n      \"zero\"\n    - determine_sign(-5)\n      \"negative\"", "level": "easy"}
{"task_id": "Elixir/50", "prompt": "defmodule AbsoluteValue do\n  def abs_value(n) when is_integer(n) do\n    # Returns the absolute value of an integer n.\n    #\n    # This function takes an integer n as input and returns its absolute value.\n    # The absolute value of a number is its value without regard to its sign.\n    # This function is designed to handle integers whose absolute values do not exceed 10000.\n    #\n    # Examples\n    #   - abs_value(-5)\n    #     # => 5\n    #   - abs_value(42)\n    #     # => 42\n    #   - abs_value(0)\n    #     # => 0", "canonical_solution": "    if n < 0, do: -n, else: n\n  end\nend", "test": "ExUnit.start()\ndefmodule AbsoluteValueTest do\n  use ExUnit.Case\n\n  test \"abs_value returns the absolute value for negative numbers\" do\n    assert AbsoluteValue.abs_value(-1) == 1\n    assert AbsoluteValue.abs_value(-10000) == 10000\n  end\n\n  test \"abs_value returns the same value for positive numbers\" do\n    assert AbsoluteValue.abs_value(10) == 10\n    assert AbsoluteValue.abs_value(9999) == 9999\n  end\n\n  test \"abs_value returns 0 for 0\" do\n    assert AbsoluteValue.abs_value(0) == 0\n  end\nend", "entry_point": "abs_value", "signature": "def abs_value(n) when is_integer(n) do", "docstring": " Returns the absolute value of an integer n.\n    \n  This function takes an integer n as input and returns its absolute value.\n  The absolute value of a number is its value without regard to its sign.\n  This function is designed to handle integers whose absolute values do not exceed 10000.\n    \n  Examples\n    - abs_value(-5)\n    => 5\n    - abs_value(42)\n    => 42\n    - abs_value(0)\n    => 0", "instruction": "Write a Elixir function `def abs_value(n) when is_integer(n) do` to solve the following problem: Returns the absolute value of an integer n.\n    \n  This function takes an integer n as input and returns its absolute value.\n  The absolute value of a number is its value without regard to its sign.\n  This function is designed to handle integers whose absolute values do not exceed 10000.\n    \n  Examples\n    - abs_value(-5)\n    => 5\n    - abs_value(42)\n    => 42\n    - abs_value(0)\n    => 0", "level": "easy"}
