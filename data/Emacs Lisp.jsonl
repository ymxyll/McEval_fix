{"task_id": "Emacs Lisp/1", "prompt": "(require 'cl-lib)\n\n(defun has-close-elements (numbers threshold)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;False\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;True", "canonical_solution": "(cl-loop for i from 0 below (length numbers)\nthereis (cl-loop for j from 0 below (length numbers)\nwhen (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\nreturn t)))", "test": ";; Test cases\n(defun check-has-close-elements ()\n(cl-assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(cl-assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(cl-assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(cl-assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(cl-assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(cl-assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(cl-assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)", "entry_point": "has-close-elements", "signature": "(defun has-close-elements (numbers threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Write a Emacs Lisp function `(defun has-close-elements (numbers threshold)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "level": "easy"}
{"task_id": "Emacs Lisp/2", "prompt": "(require 'cl-lib) (defun longest-harmonious-subsequence (nums)\n;; Function to find the longest harmonious subsequence in a list of numbers.\n;; A harmonious subsequence is one where the difference between max and min elements is exactly 1.\n;; Args:\n;; nums: A list of integers.\n;; Returns:\n;; The length of the longest harmonious subsequence.\n;; Example Usage:\n;; (longest-harmonious-subsequence '(1 3 2 2 5 2 3 7) ; Returns 5\n;; (longest-harmonious-subsequence '(1 2 3 4) Returns 2", "canonical_solution": "(let ((num-counts (make-hash-table :test 'equal)))\n;; Count the occurrences of each number.\n(dolist (num nums)\n(puthash num (1+ (gethash num num-counts 0)) num-counts))\n\n(let ((max-length 0))\n;; Check each number and its neighbor (+1) to find the longest subsequence.\n(maphash (lambda (key value)\n(let ((neighbor (gethash (1+ key) num-counts)))\n(when neighbor\n(setq max-length (max max-length (+ value neighbor)))))\n) num-counts)\nmax-length)))", "test": "(defun check-longest-harmonious-subsequence ()\n(cl-assert (equal (longest-harmonious-subsequence '(1 3 2 2 5 2 3 7)) 5))\n(cl-assert (equal (longest-harmonious-subsequence '(1 2 3 4)) 2))\n(cl-assert (equal (longest-harmonious-subsequence '(1 1 1 1)) 0))\n(cl-assert (equal (longest-harmonious-subsequence '()) 0))\n(cl-assert (equal (longest-harmonious-subsequence '(1)) 0)))\n\n(check-longest-harmonious-subsequence)", "entry_point": "longest-harmonious-subsequence", "signature": "(defun longest-harmonious-subsequence (nums)", "docstring": "Function to find the longest harmonious subsequence in a list of numbers.\nA harmonious subsequence is one where the difference between max and min elements is exactly 1.\nArgs:\nnums: A list of integers.\nReturns:\nThe length of the longest harmonious subsequence.\nExample Usage:\n(longest-harmonious-subsequence '(1 3 2 2 5 2 3 7) ; Returns 5\n(longest-harmonious-subsequence '(1 2 3 4) Returns 2", "instruction": "Write a Emacs Lisp function `(defun longest-harmonious-subsequence (nums)` to solve the following problem:\nFunction to find the longest harmonious subsequence in a list of numbers.\nA harmonious subsequence is one where the difference between max and min elements is exactly 1.\nArgs:\nnums: A list of integers.\nReturns:\nThe length of the longest harmonious subsequence.\nExample Usage:\n(longest-harmonious-subsequence '(1 3 2 2 5 2 3 7) ; Returns 5\n(longest-harmonious-subsequence '(1 2 3 4) Returns 2", "level": "middle"}
{"task_id": "Emacs Lisp/3", "prompt": "(require 'cl-lib)\n(defun count-max-after-ops (m n ops)\n;; generate elisp code\n;; Function to find the count of the maximum integer in a m x n matrix after applying operations.\n;; Args:\n;; m: Number of rows in the matrix.\n;; n: Number of columns in the matrix.\n;; ops: List of operations, where each operation is a list [ai, bi].\n;; Returns:\n;; The count of the maximum integer in the matrix after applying all operations.\n;; count-max-after-ops 3 3 '((2 2) (3 3)) ; Returns 4\n;; count-max-after-ops 3 3 '((2 2) (3 1)) ; Returns 2", "canonical_solution": "(let ((min-row m) (min-col n))\n;; For each operation, update the minimum row and column.\n(dolist (op ops)\n(setq min-row (min min-row (car op)))\n(setq min-col (min min-col (cadr op))))\n;; The count of max integer is the product of min-row and min-col.\n(* min-row min-col)))", "test": "(defun check-count-max-after-ops ()\n(cl-assert (equal (count-max-after-ops 3 3 '((2 2) (3 3))) 4))\n(cl-assert (equal (count-max-after-ops 3 3 '((2 2) (3 1))) 2))\n(cl-assert (equal (count-max-after-ops 4 4 '((1 1) (2 2))) 1))\n(cl-assert (equal (count-max-after-ops 5 5 '()) 25))\n(cl-assert (equal (count-max-after-ops 3 3 '((3 3) (2 2))) 4)))\n\n(check-count-max-after-ops)", "entry_point": "count-max-after-ops", "signature": "(defun count-max-after-ops (m n ops)", "docstring": "generate elisp code\nFunction to find the count of the maximum integer in a m x n matrix after applying operations.\nArgs:\nm: Number of rows in the matrix.\nn: Number of columns in the matrix.\nops: List of operations, where each operation is a list [ai, bi].\nReturns:\nThe count of the maximum integer in the matrix after applying all operations.\ncount-max-after-ops 3 3 '((2 2) (3 3)) ; Returns 4\ncount-max-after-ops 3 3 '((2 2) (3 1)) ; Returns 2", "instruction": "Write a Emacs Lisp function `(defun count-max-after-ops (m n ops)` to solve the following problem:\ngenerate elisp code\nFunction to find the count of the maximum integer in a m x n matrix after applying operations.\nArgs:\nm: Number of rows in the matrix.\nn: Number of columns in the matrix.\nops: List of operations, where each operation is a list [ai, bi].\nReturns:\nThe count of the maximum integer in the matrix after applying all operations.\ncount-max-after-ops 3 3 '((2 2) (3 3)) ; Returns 4\ncount-max-after-ops 3 3 '((2 2) (3 1)) ; Returns 2", "level": "easy"}
{"task_id": "Emacs Lisp/4", "prompt": "(require 'cl-lib)\n\n(defun find-common-favorites (andy-list doris-list)\n;; generate elisp code\n;; Function to find common favorite restaurants with the minimum index sum.\n;; Args:\n;; andy-list: List of strings representing Andy's favorite restaurants.\n;; doris-list: List of strings representing Doris's favorite restaurants.\n;; Returns:\n;; List of restaurant names that are common favorites with the least index sum.\n;; Example\n;; andy-list:(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n;; doris-list:(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\")\n;; return:(\"Shogun\")", "canonical_solution": "(let ((restaurant-index-sum (make-hash-table :test 'equal))\n(min-sum most-positive-fixnum)\ncommon-favorites)\n;; Build a hash table with sums of indices for common restaurants.\n(cl-loop for andy-idx from 0 below (length andy-list)\nfor andy-restaurant = (nth andy-idx andy-list)\ndo (let ((doris-idx (cl-position andy-restaurant doris-list :test 'equal)))\n(when doris-idx\n(let ((sum (+ andy-idx doris-idx)))\n(puthash andy-restaurant sum restaurant-index-sum)\n(setq min-sum (min min-sum sum))))))\n;; Collect restaurants with the minimum index sum.\n(maphash (lambda (restaurant sum)\n(when (= sum min-sum)\n(push restaurant common-favorites)))\nrestaurant-index-sum)\ncommon-favorites))", "test": "(defun check-find-common-favorites ()\n(cl-assert (equal (find-common-favorites '(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n'(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\"))\n'(\"Shogun\")))\n(cl-assert (equal (find-common-favorites '(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n'(\"KFC\" \"Shogun\" \"Burger King\"))\n'(\"Shogun\")))\n(cl-assert (equal (find-common-favorites '(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\n'(\"KFC\" \"Burger King\" \"Tapioca Express\" \"Shogun\"))\n'(\"KFC\" \"Burger King\" \"Tapioca Express\" \"Shogun\" )))\n(cl-assert (equal (find-common-favorites '(\"KFC\" \"Shogun\" \"Burger King\")\n'(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\"))\n'(\"Shogun\"))))\n\n(check-find-common-favorites)", "entry_point": "find-common-favorites", "signature": "(defun find-common-favorites (andy-list doris-list)", "docstring": "generate elisp code\nFunction to find common favorite restaurants with the minimum index sum.\nArgs:\nandy-list: List of strings representing Andy's favorite restaurants.\ndoris-list: List of strings representing Doris's favorite restaurants.\nReturns:\nList of restaurant names that are common favorites with the least index sum.\nExample\nandy-list:(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\ndoris-list:(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\")\nreturn:(\"Shogun\")", "instruction": "Write a Emacs Lisp function `(defun find-common-favorites (andy-list doris-list)` to solve the following problem:\ngenerate elisp code\nFunction to find common favorite restaurants with the minimum index sum.\nArgs:\nandy-list: List of strings representing Andy's favorite restaurants.\ndoris-list: List of strings representing Doris's favorite restaurants.\nReturns:\nList of restaurant names that are common favorites with the least index sum.\nExample\nandy-list:(\"Shogun\" \"Tapioca Express\" \"Burger King\" \"KFC\")\ndoris-list:(\"Piatti\" \"The Grill at Torrey Pines\" \"Hungry Hunter Steakhouse\" \"Shogun\")\nreturn:(\"Shogun\")", "level": "hard"}
{"task_id": "Emacs Lisp/5", "prompt": "(require 'cl-lib)\n\n(defun can-plant-flowers (flowerbed n)\n;; generate elisp code\n;; Function to determine if n flowers can be planted without violating the non-adjacency rule.\n;; Args:\n;; flowerbed: List of integers (0 or 1) representing the flowerbed.\n;; n: Integer, the number of flowers to be planted.\n;; Returns:\n;; t if it is possible to plant n flowers, nil otherwise.\n;; Example:\n;; flowerbed: (1 0 0 0 1), n: 1\n;; return: t", "canonical_solution": "(let ((len (length flowerbed))\n(count 0))\n(cl-loop for i from 0 below len do\n(when (and (= (nth i flowerbed) 0)\n(or (= i 0) (/= (nth (1- i) flowerbed) 1))\n(or (= i (1- len)) (/= (nth (1+ i) flowerbed) 1)))\n(setf (nth i flowerbed) 1)\n(setq count (1+ count))))\n(>= count n)))", "test": "(defun check-can-plant-flowers ()\n(cl-assert (equal (can-plant-flowers '(1 0 0 0 1) 1) t))\n(cl-assert (equal (can-plant-flowers '(1 0 0 0 1) 2) nil))\n(cl-assert (equal (can-plant-flowers '(0 0 0 0 0) 3) t))\n(cl-assert (equal (can-plant-flowers '(0 0 1 0 1) 1) t))\n(cl-assert (equal (can-plant-flowers '(1 0 1 0 1 0 1) 0) t))\n(cl-assert (equal (can-plant-flowers '(0) 1) t)))\n\n(check-can-plant-flowers)", "entry_point": "can-plant-flowers", "signature": "(defun can-plant-flowers (flowerbed n)", "docstring": "generate elisp code\nFunction to determine if n flowers can be planted without violating the non-adjacency rule.\nArgs:\nflowerbed: List of integers (0 or 1) representing the flowerbed.\nn: Integer, the number of flowers to be planted.\nReturns:\nt if it is possible to plant n flowers, nil otherwise.\nExample:\nflowerbed: (1 0 0 0 1), n: 1\nreturn: t", "instruction": "Write a Emacs Lisp function `(defun can-plant-flowers (flowerbed n)` to solve the following problem:\ngenerate elisp code\nFunction to determine if n flowers can be planted without violating the non-adjacency rule.\nArgs:\nflowerbed: List of integers (0 or 1) representing the flowerbed.\nn: Integer, the number of flowers to be planted.\nReturns:\nt if it is possible to plant n flowers, nil otherwise.\nExample:\nflowerbed: (1 0 0 0 1), n: 1\nreturn: t", "level": "easy"}
{"task_id": "Emacs Lisp/6", "prompt": "(require 'cl-lib) (defun max-product-of-three (nums)\n;; generate elisp code\n;; Function to find the maximum product of any three numbers in the array.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The maximum product of three numbers.\n;; Example:\n;; nums: (1 2 3 4)\n;; return: 24 (which is 2 * 3 * 4)", "canonical_solution": "(setq nums (sort nums '>))\n;; The maximum product can be the product of the three largest numbers\n;; or the product of the two smallest numbers (if they are negative) and the largest number.\n(max (* (nth 0 nums) (nth 1 nums) (nth 2 nums))\n(* (nth 0 nums) (nth (- (length nums) 1) nums) (nth (- (length nums) 2) nums))))", "test": "(defun check-max-product-of-three ()\n(cl-assert (equal (max-product-of-three '(1 2 3 4)) 24))\n(cl-assert (equal (max-product-of-three '(-1 -2 -3 4)) 24))\n(cl-assert (equal (max-product-of-three '(-4 -3 -2 -1 60)) 720))\n(cl-assert (equal (max-product-of-three '(1 1 1 1)) 1))\n(cl-assert (equal (max-product-of-three '(-1 -2 -3)) -6))\n(cl-assert (equal (max-product-of-three '(-1 0 2 3 4)) 24)))\n\n(check-max-product-of-three)", "entry_point": "max-product-of-three", "signature": "(defun max-product-of-three (nums)", "docstring": "generate elisp code\nFunction to find the maximum product of any three numbers in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe maximum product of three numbers.\nExample:\nnums: (1 2 3 4)\nreturn: 24 (which is 2 * 3 * 4)", "instruction": "Write a Emacs Lisp function `(defun max-product-of-three (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the maximum product of any three numbers in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe maximum product of three numbers.\nExample:\nnums: (1 2 3 4)\nreturn: 24 (which is 2 * 3 * 4)", "level": "easy"}
{"task_id": "Emacs Lisp/7", "prompt": "(require 'cl-lib)\n\n(defun find-error-nums (nums)\n;; generate elisp code\n;; Function to find the duplicated and missing numbers in the array.\n;; Args:\n;; nums: List of integers representing the erroneous set.\n;; Returns:\n;; List containing the duplicated number and the missing number.\n;; Example:\n;; nums: (1 2 2 4)\n;; return: (2 3)", "canonical_solution": "(let ((num-counts (make-hash-table :test 'equal))\n(n (length nums))\nduplicate missing)\n;; Count the occurrences of each number.\n(dolist (num nums)\n(puthash num (1+ (or (gethash num num-counts) 0)) num-counts))\n;; Find the duplicate and missing numbers.\n(dotimes (i n)\n(let ((count (gethash (1+ i) num-counts)))\n(cond ((and count (= count 2)) (setq duplicate (1+ i)))\n((not count) (setq missing (1+ i))))))\n(list duplicate missing)))", "test": "(defun check-find-error-nums ()\n(cl-assert (equal (find-error-nums '(1 2 2 4)) '(2 3)))\n(cl-assert (equal (find-error-nums '(1 3 3)) '(3 2)))\n(cl-assert (equal (find-error-nums '(2 2)) '(2 1)))\n(cl-assert (equal (find-error-nums '(1 5 3 2 2 4)) '(2 6)))\n(cl-assert (equal (find-error-nums '(1 1)) '(1 2))))\n\n(check-find-error-nums)", "entry_point": "find-error-nums", "signature": "(defun find-error-nums (nums)", "docstring": "generate elisp code\nFunction to find the duplicated and missing numbers in the array.\nArgs:\nnums: List of integers representing the erroneous set.\nReturns:\nList containing the duplicated number and the missing number.\nExample:\nnums: (1 2 2 4)\nreturn: (2 3)", "instruction": "Write a Emacs Lisp function `(defun find-error-nums (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the duplicated and missing numbers in the array.\nArgs:\nnums: List of integers representing the erroneous set.\nReturns:\nList containing the duplicated number and the missing number.\nExample:\nnums: (1 2 2 4)\nreturn: (2 3)", "level": "middle"}
{"task_id": "Emacs Lisp/8", "prompt": "(require 'cl-lib)\n\n(defun find-length-of-longest-increasing-subseq (nums)\n;; generate elisp code\n;; Function to find the length of the longest consecutive increasing subsequence.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The length of the longest consecutive increasing subsequence.\n;; Example:\n;; nums: (1 3 5 4 7)\n;; return: 3 (The longest increasing subsequence is [1, 3, 5])", "canonical_solution": "(if (null nums)\n0 ; Return 0 for empty list\n(let ((max-length 0) (current-length 1))\n(cl-loop for i from 1 below (length nums) do\n(if (< (nth (1- i) nums) (nth i nums))\n(setq current-length (1+ current-length))\n(setq max-length (max max-length current-length))\n(setq current-length 1)))\n(max max-length current-length))))", "test": "(defun check-find-length-of-longest-increasing-subseq ()\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(1 3 5 4 7)) 3))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(2 2 2 2 2)) 1))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(1 2 3 4 5)) 5))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '(5 4 3 2 1)) 1))\n(cl-assert (equal (find-length-of-longest-increasing-subseq '()) 0)))\n\n(check-find-length-of-longest-increasing-subseq)", "entry_point": "find-length-of-longest-increasing-subseq", "signature": "(defun find-length-of-longest-increasing-subseq (nums)", "docstring": "generate elisp code\nFunction to find the length of the longest consecutive increasing subsequence.\nArgs:\nnums: List of integers.\nReturns:\nThe length of the longest consecutive increasing subsequence.\nExample:\nnums: (1 3 5 4 7)\nreturn: 3 (The longest increasing subsequence is [1, 3, 5])", "instruction": "Write a Emacs Lisp function `(defun find-length-of-longest-increasing-subseq (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the length of the longest consecutive increasing subsequence.\nArgs:\nnums: List of integers.\nReturns:\nThe length of the longest consecutive increasing subsequence.\nExample:\nnums: (1 3 5 4 7)\nreturn: 3 (The longest increasing subsequence is [1, 3, 5])", "level": "easy"}
{"task_id": "Emacs Lisp/9", "prompt": "(require 'cl-lib)\n\n(defun find-shortest-subarray-with-same-degree (nums)\n;; generate elisp code\n;; Function to find the length of the shortest subarray with the same degree as the original array.\n;; Args:\n;; nums: List of non-negative integers.\n;; Returns:\n;; The length of the shortest subarray with the same degree.\n;; Example:\n;; nums: (1 2 2 3 1)\n;; return: 2 (The degree is 2, and the shortest subarray with degree 2 is [2, 2])\n", "canonical_solution": "(let ((num-freq (make-hash-table :test 'equal))\n(first-occurrence (make-hash-table :test 'equal))\n(max-freq 0)\n(min-length most-positive-fixnum))\n;; Build frequency table and track first occurrence of each number.\n(cl-loop for i from 0 below (length nums) do\n(let ((num (nth i nums)))\n(puthash num (1+ (gethash num num-freq 0)) num-freq)\n(unless (gethash num first-occurrence)\n(puthash num i first-occurrence))))\n;; Determine the degree of the array.\n(maphash (lambda (key value)\n(setq max-freq (max max-freq value)))\nnum-freq)\n;; Find the shortest subarray with the same degree.\n(maphash (lambda (key freq)\n(when (= freq max-freq)\n(let* ((start (gethash key first-occurrence))\n(end (cl-position key nums :start start :from-end t))\n(length (+ 1 (- end start))))\n(setq min-length (min min-length length)))))\nnum-freq)\nmin-length))", "test": "(defun check-find-shortest-subarray-with-same-degree ()\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1 2 2 3 1)) 2))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1 2 2 3 1 4 2)) 6))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1 2 3 4 5)) 1))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(2 1 1 2 1 3 3 3 1 3)) 5))\n(cl-assert (equal (find-shortest-subarray-with-same-degree '(1)) 1)))\n\n(check-find-shortest-subarray-with-same-degree)", "entry_point": "find-shortest-subarray-with-same-degree", "signature": "(defun find-shortest-subarray-with-same-degree (nums)", "docstring": "generate elisp code\nFunction to find the length of the shortest subarray with the same degree as the original array.\nArgs:\nnums: List of non-negative integers.\nReturns:\nThe length of the shortest subarray with the same degree.\nExample:\nnums: (1 2 2 3 1)\nreturn: 2 (The degree is 2, and the shortest subarray with degree 2 is [2, 2])\n", "instruction": "Write a Emacs Lisp function `(defun find-shortest-subarray-with-same-degree (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the length of the shortest subarray with the same degree as the original array.\nArgs:\nnums: List of non-negative integers.\nReturns:\nThe length of the shortest subarray with the same degree.\nExample:\nnums: (1 2 2 3 1)\nreturn: 2 (The degree is 2, and the shortest subarray with degree 2 is [2, 2])\n", "level": "hard"}
{"task_id": "Emacs Lisp/10", "prompt": "(require 'cl-lib)\n\n(defun binary-search (nums target)\n\n;; generate elisp code\n;; Function to perform binary search on a sorted array.\n;; Args:\n;; nums: A sorted list of integers.\n;; target: The target integer to search for.\n;; Returns:\n;; The index of target in nums if found, -1 otherwise.\n;; Example:\n;; nums: (-1 0 3 5 9 12), target: 9\n;; return: 4", "canonical_solution": "(let ((low 0) (high (1- (length nums))))\n(catch 'found\n(while (<= low high)\n(let ((mid (+ low (/ (- high low) 2))))\n(cond\n((= (nth mid nums) target) (throw 'found mid))\n((< (nth mid nums) target) (setq low (1+ mid)))\n(t (setq high (1- mid))))))\n-1)))", "test": "(defun check-binary-search ()\n(cl-assert (equal (binary-search '(-1 0 3 5 9 12) 9) 4))\n(cl-assert (equal (binary-search '(-1 0 3 5 9 12) 2) -1))\n(cl-assert (equal (binary-search '(1 2 3 4 5 6) 4) 3))\n(cl-assert (equal (binary-search '(1 2 3 4 5 6) 6) 5))\n(cl-assert (equal (binary-search '(1) 1) 0))\n(cl-assert (equal (binary-search '() 1) -1)))\n\n(check-binary-search)", "entry_point": "binary-search", "signature": "(defun binary-search (nums target)", "docstring": "generate elisp code\nFunction to perform binary search on a sorted array.\nArgs:\nnums: A sorted list of integers.\ntarget: The target integer to search for.\nReturns:\nThe index of target in nums if found, -1 otherwise.\nExample:\nnums: (-1 0 3 5 9 12), target: 9\nreturn: 4", "instruction": "Write a Emacs Lisp function `(defun binary-search (nums target)` to solve the following problem:\ngenerate elisp code\nFunction to perform binary search on a sorted array.\nArgs:\nnums: A sorted list of integers.\ntarget: The target integer to search for.\nReturns:\nThe index of target in nums if found, -1 otherwise.\nExample:\nnums: (-1 0 3 5 9 12), target: 9\nreturn: 4", "level": "easy"}
{"task_id": "Emacs Lisp/11", "prompt": "(require 'cl-lib)\n\n(defun is-last-character-one-bit (bits)\n;; generate elisp code\n;; Function to determine if the last character in a binary array must be a one-bit character.\n;; Args:\n;; bits: List of integers representing the binary array.\n;; Returns:\n;; t if the last character is a one-bit character, nil otherwise.\n;; Example:\n;; bits: (1 0 0)\n;; return: t (The last character is \"0\", which is a one-bit character)", "canonical_solution": "(let ((i 0))\n(while (< i (1- (length bits)))\n(setq i (+ i (if (= (nth i bits) 1) 2 1))))\n(= i (1- (length bits)))))", "test": "(defun check-is-last-character-one-bit ()\n(cl-assert (equal (is-last-character-one-bit '(1 0 0)) t))\n(cl-assert (equal (is-last-character-one-bit '(1 1 1 0)) nil))\n(cl-assert (equal (is-last-character-one-bit '(0)) t))\n(cl-assert (equal (is-last-character-one-bit '(1 0)) nil))\n(cl-assert (equal (is-last-character-one-bit '(1 1 0)) t)))\n\n(check-is-last-character-one-bit)", "entry_point": "is-last-character-one-bit", "signature": "(defun is-last-character-one-bit (bits)", "docstring": "generate elisp code\nFunction to determine if the last character in a binary array must be a one-bit character.\nArgs:\nbits: List of integers representing the binary array.\nReturns:\nt if the last character is a one-bit character, nil otherwise.\nExample:\nbits: (1 0 0)\nreturn: t (The last character is \"0\", which is a one-bit character)", "instruction": "Write a Emacs Lisp function `(defun is-last-character-one-bit (bits)` to solve the following problem:\ngenerate elisp code\nFunction to determine if the last character in a binary array must be a one-bit character.\nArgs:\nbits: List of integers representing the binary array.\nReturns:\nt if the last character is a one-bit character, nil otherwise.\nExample:\nbits: (1 0 0)\nreturn: t (The last character is \"0\", which is a one-bit character)", "level": "easy"}
{"task_id": "Emacs Lisp/12", "prompt": "(require 'cl-lib)\n\n(defun find-center-index (nums)\n;; generate elisp code\n;; Function to find the center index of an array.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The center index if it exists, -1 otherwise.\n;; Example:\n;; nums: (1 7 3 6 5 6)\n;; return: 3 (Because the sum of the elements to the left of index 3 is equal to the sum of the elements to the right)", "canonical_solution": "(let ((total-sum (apply '+ nums))\n(left-sum 0))\n(catch 'center-found\n(cl-loop for i from 0 below (length nums) do\n(if (= left-sum (- total-sum left-sum (nth i nums)))\n(throw 'center-found i)\n(setq left-sum (+ left-sum (nth i nums)))))\n-1)))", "test": "(defun check-find-center-index ()\n(cl-assert (equal (find-center-index '(1 7 3 6 5 6)) 3))\n(cl-assert (equal (find-center-index '(1 2 3)) -1))\n(cl-assert (equal (find-center-index '(2 1 -1)) 0))\n(cl-assert (equal (find-center-index '(-1 -1 -1 -1 -1 0)) 2))\n(cl-assert (equal (find-center-index '(1)) 0)))\n\n(check-find-center-index)", "entry_point": "find-center-index", "signature": "(defun find-center-index (nums)", "docstring": "generate elisp code\nFunction to find the center index of an array.\nArgs:\nnums: List of integers.\nReturns:\nThe center index if it exists, -1 otherwise.\nExample:\nnums: (1 7 3 6 5 6)\nreturn: 3 (Because the sum of the elements to the left of index 3 is equal to the sum of the elements to the right)", "instruction": "Write a Emacs Lisp function `(defun find-center-index (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the center index of an array.\nArgs:\nnums: List of integers.\nReturns:\nThe center index if it exists, -1 otherwise.\nExample:\nnums: (1 7 3 6 5 6)\nreturn: 3 (Because the sum of the elements to the left of index 3 is equal to the sum of the elements to the right)", "level": "easy"}
{"task_id": "Emacs Lisp/13", "prompt": "(require 'cl-lib)\n\n(defun flood-fill (image sr sc new-color)\n;; generate elisp code\n;; Function to perform flood fill on an image.\n;; Args:\n;; image: A 2D list of integers representing the image.\n;; sr: Starting row index.\n;; sc: Starting column index.\n;; new-color: The new color to apply.\n;; Returns:\n;; The image after performing the flood fill.\n;; Example:\n;; image: ((1 1 1) (1 1 0) (1 0 1)), sr: 1, sc: 1, new-color: 2\n;; return: ((2 2 2) (2 2 0) (2 0 1))", "canonical_solution": "(let ((original-color (nth sc (nth sr image))))\n(when (/= original-color new-color)\n(flood-fill-helper image sr sc original-color new-color))\nimage))\n\n(defun flood-fill-helper (image sr sc original-color new-color)\n\"Helper function for flood-fill.\"\n(when (and (>= sr 0) (< sr (length image))\n(>= sc 0) (< sc (length (nth 0 image)))\n(= (nth sc (nth sr image)) original-color))\n(setf (nth sc (nth sr image)) new-color)\n(flood-fill-helper image (1- sr) sc original-color new-color) ; Up\n(flood-fill-helper image (1+ sr) sc original-color new-color) ; Down\n(flood-fill-helper image sr (1- sc) original-color new-color) ; Left\n(flood-fill-helper image sr (1+ sc) original-color new-color)) ; Right\nnil)", "test": ";; Test cases\n(defun check-flood-fill ()\n(cl-assert (equal (flood-fill '((1 1 1) (1 1 0) (1 0 1)) 1 1 2) '((2 2 2) (2 2 0) (2 0 1))))\n(cl-assert (equal (flood-fill '((0 0 0) (0 0 0)) 0 0 2) '((2 2 2) (2 2 2))))\n(cl-assert (equal (flood-fill '((0 1 2) (1 1 1) (0 0 0)) 1 1 3) '((0 3 2) (3 3 3) (0 0 0)))))\n\n(check-flood-fill)", "entry_point": "flood-fill", "signature": "(defun flood-fill (image sr sc new-color)", "docstring": "generate elisp code\nFunction to perform flood fill on an image.\nArgs:\nimage: A 2D list of integers representing the image.\nsr: Starting row index.\nsc: Starting column index.\nnew-color: The new color to apply.\nReturns:\nThe image after performing the flood fill.\nExample:\nimage: ((1 1 1) (1 1 0) (1 0 1)), sr: 1, sc: 1, new-color: 2\nreturn: ((2 2 2) (2 2 0) (2 0 1))", "instruction": "Write a Emacs Lisp function `(defun flood-fill (image sr sc new-color)` to solve the following problem:\ngenerate elisp code\nFunction to perform flood fill on an image.\nArgs:\nimage: A 2D list of integers representing the image.\nsr: Starting row index.\nsc: Starting column index.\nnew-color: The new color to apply.\nReturns:\nThe image after performing the flood fill.\nExample:\nimage: ((1 1 1) (1 1 0) (1 0 1)), sr: 1, sc: 1, new-color: 2\nreturn: ((2 2 2) (2 2 0) (2 0 1))", "level": "hard"}
{"task_id": "Emacs Lisp/14", "prompt": "(require 'cl-lib)\n\n(defun next-greatest-letter (letters target)\n;; generate elisp code\n;; Function to find the smallest character greater than the target in a sorted array.\n;; Args:\n;; letters: A sorted list of characters.\n;; target: The target character.\n;; Returns:\n;; The smallest character greater than the target, or the first character if none is greater.\n;; Example:\n;; letters: (\"c\" \"f\" \"j\"), target: \"a\"\n;; return: \"c\"", "canonical_solution": "(let ((letters-array (vconcat letters))) ; \u5c06\u5217\u8868\u8f6c\u6362\u4e3a\u6570\u7ec4\n(catch 'found\n(cl-loop for letter across letters-array do\n(when (string-greaterp letter target)\n(throw 'found letter)))\n(aref letters-array 0))))", "test": "(defun check-next-greatest-letter ()\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"a\") \"c\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"c\") \"f\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"d\") \"f\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"g\") \"j\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"j\") \"c\"))\n(cl-assert (equal (next-greatest-letter '(\"c\" \"f\" \"j\") \"k\") \"c\")))\n\n(check-next-greatest-letter)", "entry_point": "next-greatest-letter", "signature": "(defun next-greatest-letter (letters target)", "docstring": "generate elisp code\nFunction to find the smallest character greater than the target in a sorted array.\nArgs:\nletters: A sorted list of characters.\ntarget: The target character.\nReturns:\nThe smallest character greater than the target, or the first character if none is greater.\nExample:\nletters: (\"c\" \"f\" \"j\"), target: \"a\"\nreturn: \"c\"", "instruction": "Write a Emacs Lisp function `(defun next-greatest-letter (letters target)` to solve the following problem:\ngenerate elisp code\nFunction to find the smallest character greater than the target in a sorted array.\nArgs:\nletters: A sorted list of characters.\ntarget: The target character.\nReturns:\nThe smallest character greater than the target, or the first character if none is greater.\nExample:\nletters: (\"c\" \"f\" \"j\"), target: \"a\"\nreturn: \"c\"", "level": "easy"}
{"task_id": "Emacs Lisp/15", "prompt": "(require 'cl-lib)\n\n(defun dominant-index (nums)\n;; generate elisp code\n;; Function to find the index of the dominant element in the array.\n;; The dominant element is the largest element that is at least twice as large as every other number in the array.\n;; Args:\n;; nums: List of integers.\n;; Returns:\n;; The index of the dominant element if it exists, -1 otherwise.\n;; Example:\n;; nums: (3 6 1 0)\n;; return: 1 (6 is the largest element and is twice as large as the other elements)", "canonical_solution": "(let ((max-val most-negative-fixnum)\n(second-max-val most-negative-fixnum)\n(max-index -1))\n;; Find the largest and second-largest elements.\n(cl-loop for i from 0 below (length nums) do\n(let ((val (nth i nums)))\n(when (> val max-val)\n(setq second-max-val max-val)\n(setq max-val val)\n(setq max-index i))\n(when (and (> val second-max-val) (< val max-val))\n(setq second-max-val val))))\n;; Check if the largest element is at least twice as large as the second-largest element.\n(if (>= max-val (* 2 second-max-val))\nmax-index\n-1)))", "test": ";; Test cases\n(defun check-dominant-index ()\n(cl-assert (equal (dominant-index '(3 6 1 0)) 1))\n(cl-assert (equal (dominant-index '(1 2 3 4)) -1))\n(cl-assert (equal (dominant-index '(0 0 0 1)) 3))\n(cl-assert (equal (dominant-index '(1)) 0))\n(cl-assert (equal (dominant-index '(5 1 5 0 2)) 0)))\n\n(check-dominant-index)", "entry_point": "dominant-index", "signature": "(defun dominant-index (nums)", "docstring": "generate elisp code\nFunction to find the index of the dominant element in the array.\nThe dominant element is the largest element that is at least twice as large as every other number in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe index of the dominant element if it exists, -1 otherwise.\nExample:\nnums: (3 6 1 0)\nreturn: 1 (6 is the largest element and is twice as large as the other elements)", "instruction": "Write a Emacs Lisp function `(defun dominant-index (nums)` to solve the following problem:\ngenerate elisp code\nFunction to find the index of the dominant element in the array.\nThe dominant element is the largest element that is at least twice as large as every other number in the array.\nArgs:\nnums: List of integers.\nReturns:\nThe index of the dominant element if it exists, -1 otherwise.\nExample:\nnums: (3 6 1 0)\nreturn: 1 (6 is the largest element and is twice as large as the other elements)", "level": "hard"}
{"task_id": "Emacs Lisp/16", "prompt": "(require 'cl-lib)\n\n(defun is-toeplitz-matrix (matrix)\n;; generate elisp code\n;; Function to check if a matrix is a Toeplitz matrix.\n;; Args:\n;; matrix: A 2D list of integers.\n;; Returns:\n;; t if the matrix is a Toeplitz matrix, nil otherwise.\n;; Example:\n;; matrix: ((1 2 3 4) (5 1 2 3) (9 5 1 2))\n;; return: t (Each diagonal from top-left to bottom-right has the same elements)", "canonical_solution": "(let ((rows (length matrix))\n(cols (length (nth 0 matrix))))\n(catch 'not-toeplitz\n(cl-loop for row from 0 below (1- rows) do\n(cl-loop for col from 0 below (1- cols) do\n(unless (= (nth col (nth row matrix))\n(nth (1+ col) (nth (1+ row) matrix)))\n(throw 'not-toeplitz nil))))\nt)))", "test": "(defun check-is-toeplitz-matrix ()\n(cl-assert (equal (is-toeplitz-matrix '((1 2 3 4) (5 1 2 3) (9 5 1 2))) t))\n(cl-assert (equal (is-toeplitz-matrix '((1 2) (2 2))) nil))\n(cl-assert (equal (is-toeplitz-matrix '((1 2 3) (4 1 2) (5 4 1) (6 5 4))) t))\n(cl-assert (equal (is-toeplitz-matrix '((1))) t))\n(cl-assert (equal (is-toeplitz-matrix '((1 2) (1 2))) nil)))\n\n(check-is-toeplitz-matrix)", "entry_point": "is-toeplitz-matrix", "signature": "(defun is-toeplitz-matrix (matrix)", "docstring": "generate elisp code\nFunction to check if a matrix is a Toeplitz matrix.\nArgs:\nmatrix: A 2D list of integers.\nReturns:\nt if the matrix is a Toeplitz matrix, nil otherwise.\nExample:\nmatrix: ((1 2 3 4) (5 1 2 3) (9 5 1 2))\nreturn: t (Each diagonal from top-left to bottom-right has the same elements)", "instruction": "Write a Emacs Lisp function `(defun is-toeplitz-matrix (matrix)` to solve the following problem:\ngenerate elisp code\nFunction to check if a matrix is a Toeplitz matrix.\nArgs:\nmatrix: A 2D list of integers.\nReturns:\nt if the matrix is a Toeplitz matrix, nil otherwise.\nExample:\nmatrix: ((1 2 3 4) (5 1 2 3) (9 5 1 2))\nreturn: t (Each diagonal from top-left to bottom-right has the same elements)", "level": "easy"}
{"task_id": "Emacs Lisp/17", "prompt": "(require 'cl-lib)\n\n(defun unique-morse-representations (words)\n;; generate elisp code\n;; Function to count the number of unique Morse code translations of words.\n;; Args:\n;; words: List of strings representing words.\n;; Returns:\n;; The number of unique Morse code translations.\n;; Example:\n;; words: (\"gin\" \"zen\" \"gig\" \"msg\")\n;; return: 2", "canonical_solution": "(let ((morse-alist '((\"a\" . \".-\") (\"b\" . \"-...\") (\"c\" . \"-.-.\") (\"d\" . \"-..\")\n(\"e\" . \".\") (\"f\" . \"..-.\") (\"g\" . \"--.\") (\"h\" . \"....\")\n(\"i\" . \"..\") (\"j\" . \".---\") (\"k\" . \"-.-\") (\"l\" . \".-..\")\n(\"m\" . \"--\") (\"n\" . \"-.\") (\"o\" . \"---\") (\"p\" . \".--.\")\n(\"q\" . \"--.-\") (\"r\" . \".-.\") (\"s\" . \"...\") (\"t\" . \"-\")\n(\"u\" . \"..-\") (\"v\" . \"...-\") (\"w\" . \".--\") (\"x\" . \"-..-\")\n(\"y\" . \"-.--\") (\"z\" . \"--..\")))\n(morse-set (make-hash-table :test 'equal)))\n;; Translate each word into Morse code and add to the set.\n(dolist (word words)\n(let ((morse-code (mapconcat (lambda (char)\n(cdr (assoc (string char) morse-alist)))\nword \"\")))\n(puthash morse-code t morse-set)))\n;; Count unique Morse code translations.\n(hash-table-count morse-set)))\n", "test": "(defun check-unique-morse-representations ()\n(cl-assert (equal (unique-morse-representations '(\"gin\" \"zen\" \"gig\" \"msg\")) 2))\n(cl-assert (equal (unique-morse-representations '(\"a\" \"b\" \"c\" \"d\")) 4))\n(cl-assert (equal (unique-morse-representations '(\"cab\" \"abc\" \"bca\")) 3)))\n\n(check-unique-morse-representations)", "entry_point": "unique-morse-representations", "signature": "(defun unique-morse-representations (words)", "docstring": "generate elisp code\nFunction to count the number of unique Morse code translations of words.\nArgs:\nwords: List of strings representing words.\nReturns:\nThe number of unique Morse code translations.\nExample:\nwords: (\"gin\" \"zen\" \"gig\" \"msg\")\nreturn: 2", "instruction": "Write a Emacs Lisp function `(defun unique-morse-representations (words)` to solve the following problem:\ngenerate elisp code\nFunction to count the number of unique Morse code translations of words.\nArgs:\nwords: List of strings representing words.\nReturns:\nThe number of unique Morse code translations.\nExample:\nwords: (\"gin\" \"zen\" \"gig\" \"msg\")\nreturn: 2", "level": "hard"}
{"task_id": "Emacs Lisp/18", "prompt": "(require 'cl-lib)\n\n(defun most-common-word (paragraph banned)\n;; generate elisp code\n;; Function to find the most common non-banned word in a paragraph.\n;; Args:\n;; paragraph: A string containing words.\n;; banned: A list of strings representing banned words.\n;; Returns:\n;; The most common non-banned word in lowercase.\n;; Example:\n;; paragraph: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\n;; banned: (\"hit\")\n;; return: \"ball\"", "canonical_solution": "(let ((word-freq (make-hash-table :test 'equal))\n(banned-set (make-hash-table :test 'equal))\n(max-word nil)\n(max-count 0))\n;; Populate the banned words set.\n(dolist (word banned)\n(puthash (downcase word) t banned-set))\n;; Process the paragraph to count word frequency.\n(dolist (word (split-string (downcase paragraph) \"[^a-zA-Z]+\" t))\n(unless (gethash word banned-set)\n(puthash word (1+ (gethash word word-freq 0)) word-freq)\n(when (> (gethash word word-freq) max-count)\n(setq max-word word)\n(setq max-count (gethash word word-freq)))))\nmax-word))\n", "test": "(defun check-most-common-word ()\n(cl-assert (equal (most-common-word \"Bob hit a ball, the hit BALL flew far after it was hit.\" '(\"hit\")) \"ball\"))\n(cl-assert (equal (most-common-word \"a.\" '()) \"a\"))\n(cl-assert (equal (most-common-word \"a, a, a, a, b,b,b,c, c\" '(\"a\")) \"b\"))\n(cl-assert (equal (most-common-word \"Apple? Orange! Banana; Apple: Melon, Grape,\" '(\"melon\" \"grape\")) \"apple\")))\n\n(check-most-common-word)", "entry_point": "most-common-word", "signature": "(defun most-common-word (paragraph banned)", "docstring": "generate elisp code\nFunction to find the most common non-banned word in a paragraph.\nArgs:\nparagraph: A string containing words.\nbanned: A list of strings representing banned words.\nReturns:\nThe most common non-banned word in lowercase.\nExample:\nparagraph: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\nbanned: (\"hit\")\nreturn: \"ball\"", "instruction": "Write a Emacs Lisp function `(defun most-common-word (paragraph banned)` to solve the following problem:\ngenerate elisp code\nFunction to find the most common non-banned word in a paragraph.\nArgs:\nparagraph: A string containing words.\nbanned: A list of strings representing banned words.\nReturns:\nThe most common non-banned word in lowercase.\nExample:\nparagraph: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\nbanned: (\"hit\")\nreturn: \"ball\"", "level": "hard"}
{"task_id": "Emacs Lisp/19", "prompt": "(require 'cl-lib)\n\n(defun flip-and-invert-image (image)\n;; generate elisp code\n;; Function to flip and invert a binary matrix.\n;; Args:\n;; image: A 2D list of binary values (0s and 1s).\n;; Returns:\n;; The flipped and inverted image.\n;; Example:\n;; image: ((1 1 0) (1 0 1) (0 0 0))\n;; return: ((1 0 0) (0 1 0) (1 1 1))\n", "canonical_solution": "(mapcar (lambda (row)\n(mapcar (lambda (elem) (if (= elem 0) 1 0))\n(reverse row)))\nimage))", "test": "(defun check-flip-and-invert-image ()\n(cl-assert (equal (flip-and-invert-image '((1 1 0) (1 0 1) (0 0 0)))\n'((1 0 0) (0 1 0) (1 1 1))))\n(cl-assert (equal (flip-and-invert-image '((1 1 0 0) (1 0 0 1) (0 1 1 1) (1 0 1 0)))\n'((1 1 0 0) (0 1 1 0) (0 0 0 1) (1 0 1 0))))\n(cl-assert (equal (flip-and-invert-image '((0) (1)))\n'((1) (0))))\n(cl-assert (equal (flip-and-invert-image '((1)))\n'((0)))))\n\n(check-flip-and-invert-image)", "entry_point": "flip-and-invert-image", "signature": "(defun flip-and-invert-image (image)", "docstring": "generate elisp code\nFunction to flip and invert a binary matrix.\nArgs:\nimage: A 2D list of binary values (0s and 1s).\nReturns:\nThe flipped and inverted image.\nExample:\nimage: ((1 1 0) (1 0 1) (0 0 0))\nreturn: ((1 0 0) (0 1 0) (1 1 1))\n", "instruction": "Write a Emacs Lisp function `(defun flip-and-invert-image (image)` to solve the following problem:\ngenerate elisp code\nFunction to flip and invert a binary matrix.\nArgs:\nimage: A 2D list of binary values (0s and 1s).\nReturns:\nThe flipped and inverted image.\nExample:\nimage: ((1 1 0) (1 0 1) (0 0 0))\nreturn: ((1 0 0) (0 1 0) (1 1 1))\n", "level": "easy"}
{"task_id": "Emacs Lisp/20", "prompt": "(require 'cl-lib)\n(defun lemonade-change (bills)\n;; generate elisp code\n;; Function to determine if it's possible to provide change for each customer at a lemonade stand.\n;; Args:\n;; bills: List of integers representing the bills paid by each customer.\n;; Returns:\n;; t if change can be provided to every customer, nil otherwise.\n;; Example:\n;; bills: (5 5 5 10 20)\n;; return: t", "canonical_solution": "(catch 'cannot-change\n(let ((five 0) (ten 0))\n(cl-loop for bill in bills\ndo (cond ((= bill 5)\n(setq five (1+ five)))\n((= bill 10)\n(if (= five 0)\n(throw 'cannot-change nil)\n(setq five (1- five))\n(setq ten (1+ ten))))\n((= bill 20)\n(cond ((and (> ten 0) (> five 0))\n(setq ten (1- ten))\n(setq five (1- five)))\n((>= five 3)\n(setq five (- five 3)))\n(t (throw 'cannot-change nil))))))\nt)))", "test": "(defun check-lemonade-change ()\n(cl-assert (equal (lemonade-change '(5 5 5 10 20)) t))\n(cl-assert (equal (lemonade-change '(5 5 10 10 20)) nil))\n(cl-assert (equal (lemonade-change '(5 5 10)) t))\n(cl-assert (equal (lemonade-change '(10 10)) nil))\n(cl-assert (equal (lemonade-change '(5 5 10 10 20 20 20 20 5 5)) nil)))\n\n(check-lemonade-change)", "entry_point": "lemonade-change", "signature": "(defun lemonade-change (bills)", "docstring": "generate elisp code\nFunction to determine if it's possible to provide change for each customer at a lemonade stand.\nArgs:\nbills: List of integers representing the bills paid by each customer.\nReturns:\nt if change can be provided to every customer, nil otherwise.\nExample:\nbills: (5 5 5 10 20)\nreturn: t", "instruction": "Write a Emacs Lisp function `(defun lemonade-change (bills)` to solve the following problem:\ngenerate elisp code\nFunction to determine if it's possible to provide change for each customer at a lemonade stand.\nArgs:\nbills: List of integers representing the bills paid by each customer.\nReturns:\nt if change can be provided to every customer, nil otherwise.\nExample:\nbills: (5 5 5 10 20)\nreturn: t", "level": "middle"}
{"task_id": "Emacs Lisp/21", "prompt": "(require 'cl-lib)\n(defun find-substring-index (haystack needle)\n;; generate elisp code\n;; This function searches for the first occurrence of the string `needle` within the string `haystack`.\n;; It returns the zero-based index of the first occurrence of `needle` in `haystack`.\n;; If `needle` is not found within `haystack`, the function returns -1.\n;; Example Usage:\n;; (find-substring-index \"hello world\" \"world\") ; Returns 6", "canonical_solution": "(if (string= needle \"\")\n0\n(let ((index (cl-search needle haystack)))\n(if index index -1)))\n)", "test": "\n(defun test-find-substring-index ()\n(cl-assert (equal (find-substring-index \"hello world\" \"world\") 6))\n(cl-assert (equal (find-substring-index \"hello world\" \"hello\") 0))\n(cl-assert (equal (find-substring-index \"hello world\" \"abc\") -1))\n(cl-assert (equal (find-substring-index \"abcabcabc\" \"abc\") 0))\n(cl-assert (equal (find-substring-index \"abcabcabc\" \"cab\") 2))\n(cl-assert (equal (find-substring-index \"openai\" \"ai\") 4))\n(cl-assert (equal (find-substring-index \"openai\" \"\") 0)))\n\n(test-find-substring-index)", "entry_point": "find-substring-index", "signature": "(defun find-substring-index (haystack needle)", "docstring": "generate elisp code\nThis function searches for the first occurrence of the string `needle` within the string `haystack`.\nIt returns the zero-based index of the first occurrence of `needle` in `haystack`.\nIf `needle` is not found within `haystack`, the function returns -1.\nExample Usage:\n(find-substring-index \"hello world\" \"world\") ; Returns 6", "instruction": "Write a Emacs Lisp function `(defun find-substring-index (haystack needle)` to solve the following problem:\ngenerate elisp code\nThis function searches for the first occurrence of the string `needle` within the string `haystack`.\nIt returns the zero-based index of the first occurrence of `needle` in `haystack`.\nIf `needle` is not found within `haystack`, the function returns -1.\nExample Usage:\n(find-substring-index \"hello world\" \"world\") ; Returns 6", "level": "easy"}
{"task_id": "Emacs Lisp/22", "prompt": "(require 'cl-lib)\n\n(defun comet-group-match (comet-name group-name)\n;; generate elisp code\n;; This function determines whether a group should go with a comet based on their names.\n;; Both comet-name and group-name are strings of uppercase letters without spaces or punctuation.\n;; The function calculates the product of letter values (A=1, B=2, ..., Z=26) for both names.\n;; If the mod 47 of both products is equal, it returns \"GO\", else \"STAY\".\n;; Example Usage:\n;; (comet-group-match \"COMETQ\" \"HVNGAT\") ; Should return \"GO\"\n;; (comet-group-match \"ABC\" \"XYZ\") ; Should return \"STAY\"", "canonical_solution": "(let ((name-value (lambda (name)\n(cl-reduce (lambda (a b) (* a b))\n(mapcar (lambda (c) (- c 64)) name)))))\n(if (= (mod (funcall name-value comet-name) 47)\n(mod (funcall name-value group-name) 47))\n\"GO\"\n\"STAY\"))\n)", "test": "(defun test-comet-group-match ()\n(cl-assert (equal (comet-group-match \"COMETQ\" \"HVNGAT\") \"GO\"))\n(cl-assert (equal (comet-group-match \"ABC\" \"XYZ\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"HALLEY\" \"TEAM\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"SWIFT\" \"ROCKY\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"ORION\" \"ORION\") \"GO\"))\n(cl-assert (equal (comet-group-match \"VEGA\" \"NOVA\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"LYRA\" \"SIGMA\") \"STAY\"))\n(cl-assert (equal (comet-group-match \"PULSAR\" \"QUARK\") \"STAY\")))\n\n(test-comet-group-match)", "entry_point": "comet-group-match", "signature": "(defun comet-group-match (comet-name group-name)", "docstring": "generate elisp code\nThis function determines whether a group should go with a comet based on their names.\nBoth comet-name and group-name are strings of uppercase letters without spaces or punctuation.\nThe function calculates the product of letter values (A=1, B=2, ..., Z=26) for both names.\nIf the mod 47 of both products is equal, it returns \"GO\", else \"STAY\".\nExample Usage:\n(comet-group-match \"COMETQ\" \"HVNGAT\") ; Should return \"GO\"\n(comet-group-match \"ABC\" \"XYZ\") ; Should return \"STAY\"", "instruction": "Write a Emacs Lisp function `(defun comet-group-match (comet-name group-name)` to solve the following problem:\ngenerate elisp code\nThis function determines whether a group should go with a comet based on their names.\nBoth comet-name and group-name are strings of uppercase letters without spaces or punctuation.\nThe function calculates the product of letter values (A=1, B=2, ..., Z=26) for both names.\nIf the mod 47 of both products is equal, it returns \"GO\", else \"STAY\".\nExample Usage:\n(comet-group-match \"COMETQ\" \"HVNGAT\") ; Should return \"GO\"\n(comet-group-match \"ABC\" \"XYZ\") ; Should return \"STAY\"", "level": "easy"}
{"task_id": "Emacs Lisp/23", "prompt": "(require 'cl-lib)\n(defun goldbach-conjecture (N)\n;; This function tests Goldbach's conjecture for even numbers from 4 to N.\n;; Goldbach's conjecture states that every even number greater than 2 can be expressed as the sum of two prime numbers.\n;; For each even number, the function finds the pair of prime numbers that add up to it, preferring the pair with the smallest first number.\n;; Example Usage:\n;; (goldbach-conjecture 10) ; Returns '((4 2 2) (6 3 3) (8 3 5) (10 3 7))", "canonical_solution": "(cl-loop for i from 4 to N by 2\ncollect (cl-loop for j from 2 to i\nwhen (and (is-prime j) (is-prime (- i j)))\nreturn (list i j (- i j))))\n) (defun is-prime (n)\n\"Check if N is a prime number.\"\n(when (> n 1)\n(cl-loop for i from 2 to (sqrt n) never (zerop (mod n i)))))\n\n(defun goldbach-conjecture (N)\n\"Generate a list of even numbers from 4 to N with their Goldbach's pair.\"\n(cl-loop for i from 4 to N by 2\ncollect (cl-loop for j from 2 to i\nwhen (and (is-prime j) (is-prime (- i j)))\nreturn (list i j (- i j)))))", "test": "(defun test-goldbach-conjecture ()\n(cl-assert (equal (goldbach-conjecture 10) '((4 2 2) (6 3 3) (8 3 5) (10 3 7))))\n(cl-assert (equal (goldbach-conjecture 12) '((4 2 2) (6 3 3) (8 3 5) (10 3 7) (12 5 7))))\n(cl-assert (equal (goldbach-conjecture 0) nil))\n(cl-assert (equal (goldbach-conjecture 2) nil))\n(cl-assert (equal (goldbach-conjecture 4) '((4 2 2)))))\n\n(test-goldbach-conjecture)", "entry_point": "goldbach-conjecture", "signature": "(defun goldbach-conjecture (N)", "docstring": "This function tests Goldbach's conjecture for even numbers from 4 to N.\nGoldbach's conjecture states that every even number greater than 2 can be expressed as the sum of two prime numbers.\nFor each even number, the function finds the pair of prime numbers that add up to it, preferring the pair with the smallest first number.\nExample Usage:\n(goldbach-conjecture 10) ; Returns '((4 2 2) (6 3 3) (8 3 5) (10 3 7))", "instruction": "Write a Emacs Lisp function `(defun goldbach-conjecture (N)` to solve the following problem:\nThis function tests Goldbach's conjecture for even numbers from 4 to N.\nGoldbach's conjecture states that every even number greater than 2 can be expressed as the sum of two prime numbers.\nFor each even number, the function finds the pair of prime numbers that add up to it, preferring the pair with the smallest first number.\nExample Usage:\n(goldbach-conjecture 10) ; Returns '((4 2 2) (6 3 3) (8 3 5) (10 3 7))", "level": "hard"}
{"task_id": "Emacs Lisp/24", "prompt": "(require 'cl-lib)\n(defun reverse-digits (n)\n;; This function takes an integer N and returns a new integer with its digits reversed.\n;; If the reversed integer would have leading zeros, these are removed in the returned integer.\n;; For example:\n;; (reverse-digits 123) ; Returns 321\n;; (reverse-digits -123); Returns -321\n;; (reverse-digits 1200); Returns 21\n;; (reverse-digits 0) ; Returns 0", "canonical_solution": "(let ((sign (if (< n 0) -1 1)))\n(* sign (string-to-number (reverse-string (number-to-string (abs n))))))\n)\n(defun reverse-string (str)\n\"Reverse a string STR.\"\n(apply 'string (reverse (string-to-list str))))", "test": "(defun test-reverse-digits ()\n(cl-assert (equal (reverse-digits 123) 321))\n(cl-assert (equal (reverse-digits -123) -321))\n(cl-assert (equal (reverse-digits 1200) 21))\n(cl-assert (equal (reverse-digits 0) 0))\n(cl-assert (equal (reverse-digits 5050) 505))\n(cl-assert (equal (reverse-digits -5050) -505)))\n\n(test-reverse-digits)", "entry_point": "reverse-digits", "signature": "(defun reverse-digits (n)", "docstring": "This function takes an integer N and returns a new integer with its digits reversed.\nIf the reversed integer would have leading zeros, these are removed in the returned integer.\nFor example:\n(reverse-digits 123) ; Returns 321\n(reverse-digits -123); Returns -321\n(reverse-digits 1200); Returns 21\n(reverse-digits 0) ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun reverse-digits (n)` to solve the following problem:\nThis function takes an integer N and returns a new integer with its digits reversed.\nIf the reversed integer would have leading zeros, these are removed in the returned integer.\nFor example:\n(reverse-digits 123) ; Returns 321\n(reverse-digits -123); Returns -321\n(reverse-digits 1200); Returns 21\n(reverse-digits 0) ; Returns 0", "level": "easy"}
{"task_id": "Emacs Lisp/25", "prompt": "(require 'cl-lib)\n(defun count-water-pockets (heights)\n;; This function takes a list of integers representing terrain heights and counts the number of low points where water can accumulate.\n;; A water pocket is defined as a low point surrounded by higher terrain on both sides.\n;; Example Usage:\n;; (count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) ; Returns 3\n;; (count-water-pockets '(0 2 2 1 2 0)) ; Returns 1\n;; (count-water-pockets '(0 3 3 3 0)) ; Returns 0", "canonical_solution": "(let ((count 0) (i 1) (len (length heights)))\n(while (< i (- len 1))\n(when (and (< (nth i heights) (nth (1- i) heights))\n(<= (nth i heights) (nth (1+ i) heights)))\n(setq count (1+ count))\n(while (and (< i (- len 1))\n(<= (nth i heights) (nth (1+ i) heights)))\n(setq i (1+ i)))) ; Continue checking next elements in case of consecutive low points\n(setq i (1+ i)))\ncount)\n)", "test": "(defun test-count-water-pockets ()\n(cl-assert (equal (count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) 3))\n(cl-assert (equal (count-water-pockets '(0 2 2 1 2 0)) 1))\n(cl-assert (equal (count-water-pockets '(0 3 3 3 0)) 0))\n(cl-assert (equal (count-water-pockets '(0 1 2 3 2 1 0)) 0))\n(cl-assert (equal (count-water-pockets '(0 1 0 1 0)) 1))\n)\n\n(test-count-water-pockets)", "entry_point": "count-water-pockets", "signature": "(defun count-water-pockets (heights)", "docstring": "This function takes a list of integers representing terrain heights and counts the number of low points where water can accumulate.\nA water pocket is defined as a low point surrounded by higher terrain on both sides.\nExample Usage:\n(count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) ; Returns 3\n(count-water-pockets '(0 2 2 1 2 0)) ; Returns 1\n(count-water-pockets '(0 3 3 3 0)) ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun count-water-pockets (heights)` to solve the following problem:\nThis function takes a list of integers representing terrain heights and counts the number of low points where water can accumulate.\nA water pocket is defined as a low point surrounded by higher terrain on both sides.\nExample Usage:\n(count-water-pockets '(0 1 0 2 1 2 0 0 2 0)) ; Returns 3\n(count-water-pockets '(0 2 2 1 2 0)) ; Returns 1\n(count-water-pockets '(0 3 3 3 0)) ; Returns 0", "level": "middle"}
{"task_id": "Emacs Lisp/26", "prompt": "(require 'cl-lib)\n(defun longest-consecutive-sequence (sequence)\n;; This function takes a list of integers (SEQUENCE) and returns the length of the longest consecutive number sequence.\n;; A consecutive number sequence is a series of numbers in which each number is one more than the previous number.\n;; Example Usage:\n;; (longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) ; Returns 5\n;; (longest-consecutive-sequence '(10 5 1 2 3)) ; Returns 3", "canonical_solution": "(let ((sorted-seq (cl-sort (copy-sequence sequence) '<))\n(max-length 1) (current-length 1))\n(cl-loop for i from 1 below (length sorted-seq)\ndo (if (= (1+ (nth (1- i) sorted-seq)) (nth i sorted-seq))\n(setq current-length (1+ current-length))\n(setq max-length (max max-length current-length))\n(setq current-length 1)))\n(max max-length current-length))\n)", "test": "(defun test-longest-consecutive-sequence ()\n(cl-assert (equal (longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) 5))\n(cl-assert (equal (longest-consecutive-sequence '(10 5 1 2 3)) 3))\n(cl-assert (equal (longest-consecutive-sequence '(7 7 7 7)) 1))\n(cl-assert (equal (longest-consecutive-sequence '(1 2 3 4 5)) 5))\n)\n\n(test-longest-consecutive-sequence)", "entry_point": "longest-consecutive-sequence", "signature": "(defun longest-consecutive-sequence (sequence)", "docstring": "This function takes a list of integers (SEQUENCE) and returns the length of the longest consecutive number sequence.\nA consecutive number sequence is a series of numbers in which each number is one more than the previous number.\nExample Usage:\n(longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) ; Returns 5\n(longest-consecutive-sequence '(10 5 1 2 3)) ; Returns 3", "instruction": "Write a Emacs Lisp function `(defun longest-consecutive-sequence (sequence)` to solve the following problem:\nThis function takes a list of integers (SEQUENCE) and returns the length of the longest consecutive number sequence.\nA consecutive number sequence is a series of numbers in which each number is one more than the previous number.\nExample Usage:\n(longest-consecutive-sequence '(1 5 6 2 3 4 5 6 8 9)) ; Returns 5\n(longest-consecutive-sequence '(10 5 1 2 3)) ; Returns 3", "level": "middle"}
{"task_id": "Emacs Lisp/27", "prompt": "(require 'cl-lib)\n(defun max-pens (yuan jiao)\n;; This function calculates the maximum number of pens that can be bought given a certain amount of money.\n;; Each pen costs 1 yuan and 9 jiao. The function takes two arguments: yuan and jiao, \n;; representing the amount of money available.\n;; Example Usage:\n;; (max-pens 10 3) ; Returns 5, as 10 yuan and 3 jiao can buy a maximum of 5 pens", "canonical_solution": "(let ((total-jiao (+ (* yuan 10) jiao)))\n(/ total-jiao 19))\n)", "test": "(defun test-max-pens ()\n(cl-assert (equal (max-pens 10 3) 5))\n(cl-assert (equal (max-pens 5 0) 2))\n(cl-assert (equal (max-pens 20 1) 10))\n(cl-assert (equal (max-pens 0 19) 1))\n(cl-assert (equal (max-pens 0 18) 0))\n(cl-assert (equal (max-pens 1 8) 0)))\n\n(test-max-pens)", "entry_point": "max-pens", "signature": "(defun max-pens (yuan jiao)", "docstring": "This function calculates the maximum number of pens that can be bought given a certain amount of money.\nEach pen costs 1 yuan and 9 jiao. The function takes two arguments: yuan and jiao, \nrepresenting the amount of money available.\nExample Usage:\n(max-pens 10 3) ; Returns 5, as 10 yuan and 3 jiao can buy a maximum of 5 pens", "instruction": "Write a Emacs Lisp function `(defun max-pens (yuan jiao)` to solve the following problem:\nThis function calculates the maximum number of pens that can be bought given a certain amount of money.\nEach pen costs 1 yuan and 9 jiao. The function takes two arguments: yuan and jiao, \nrepresenting the amount of money available.\nExample Usage:\n(max-pens 10 3) ; Returns 5, as 10 yuan and 3 jiao can buy a maximum of 5 pens", "level": "easy"}
{"task_id": "Emacs Lisp/28", "prompt": "(require 'cl-lib)\n(defun calculate-electricity-bill (kwh)\n;; This function calculates the electricity bill based on a tiered rate structure.\n;; For the first 150 kWh, the rate is 0.4463 per kWh.\n;; For 151 to 400 kWh, the rate is 0.4663 per kWh.\n;; For above 400 kWh, the rate is 0.5663 per kWh.\n;; It takes an integer KWH representing the total kilowatt-hour usage.\n;; Example Usage:\n;; (calculate-electricity-bill 267) ; Should return 121.5 as the bill amount", "canonical_solution": "(let ((bill 0.0))\n(cond\n((<= kwh 150)\n(setq bill (* kwh 0.4463)))\n((<= kwh 400)\n(setq bill (+ (* 150 0.4463) (* (- kwh 150) 0.4663))))\n(t\n(setq bill (+ (* 150 0.4463) (* 250 0.4663) (* (- kwh 400) 0.5663)))))\n(format \"%.1f\" bill))\n)", "test": "(defun test-calculate-electricity-bill ()\n(cl-assert (equal (calculate-electricity-bill 267) \"121.5\"))\n(cl-assert (equal (calculate-electricity-bill 150) \"66.9\"))\n(cl-assert (equal (calculate-electricity-bill 400) \"183.5\"))\n)\n\n(test-calculate-electricity-bill)", "entry_point": "calculate-electricity-bill", "signature": "(defun calculate-electricity-bill (kwh)", "docstring": "This function calculates the electricity bill based on a tiered rate structure.\nFor the first 150 kWh, the rate is 0.4463 per kWh.\nFor 151 to 400 kWh, the rate is 0.4663 per kWh.\nFor above 400 kWh, the rate is 0.5663 per kWh.\nIt takes an integer KWH representing the total kilowatt-hour usage.\nExample Usage:\n(calculate-electricity-bill 267) ; Should return 121.5 as the bill amount", "instruction": "Write a Emacs Lisp function `(defun calculate-electricity-bill (kwh)` to solve the following problem:\nThis function calculates the electricity bill based on a tiered rate structure.\nFor the first 150 kWh, the rate is 0.4463 per kWh.\nFor 151 to 400 kWh, the rate is 0.4663 per kWh.\nFor above 400 kWh, the rate is 0.5663 per kWh.\nIt takes an integer KWH representing the total kilowatt-hour usage.\nExample Usage:\n(calculate-electricity-bill 267) ; Should return 121.5 as the bill amount", "level": "easy"}
{"task_id": "Emacs Lisp/29", "prompt": "(require 'cl-lib)\n(defun steps-to-swim-distance (distance)\n;; This function calculates the number of steps Xiaoyu needs to swim a certain DISTANCE.\n;; Xiaoyu's first step is 2 meters, and each subsequent step is 98% of the previous step.\n;; The function returns the total number of steps required to swim at least the given distance.\n;; Example Usage:\n;; (steps-to-swim-distance 4.3) ; Returns 3 as it takes 3 steps to swim at least 4.3 meters", "canonical_solution": "(let ((current-distance 0)\n(step-distance 2)\n(steps 0))\n(while (< current-distance distance)\n(setq current-distance (+ current-distance step-distance))\n(setq step-distance (* step-distance 0.98))\n(setq steps (1+ steps)))\nsteps)\n)", "test": "(defun test-steps-to-swim-distance ()\n(cl-assert (equal (steps-to-swim-distance 4.3) 3))\n(cl-assert (equal (steps-to-swim-distance 2) 1))\n(cl-assert (equal (steps-to-swim-distance 5) 3))\n(cl-assert (equal (steps-to-swim-distance 10) 6))\n(cl-assert (equal (steps-to-swim-distance 15.5) 9)))\n\n(test-steps-to-swim-distance)", "entry_point": "steps-to-swim-distance", "signature": "(defun steps-to-swim-distance (distance)", "docstring": "This function calculates the number of steps Xiaoyu needs to swim a certain DISTANCE.\nXiaoyu's first step is 2 meters, and each subsequent step is 98% of the previous step.\nThe function returns the total number of steps required to swim at least the given distance.\nExample Usage:\n(steps-to-swim-distance 4.3) ; Returns 3 as it takes 3 steps to swim at least 4.3 meters", "instruction": "Write a Emacs Lisp function `(defun steps-to-swim-distance (distance)` to solve the following problem:\nThis function calculates the number of steps Xiaoyu needs to swim a certain DISTANCE.\nXiaoyu's first step is 2 meters, and each subsequent step is 98% of the previous step.\nThe function returns the total number of steps required to swim at least the given distance.\nExample Usage:\n(steps-to-swim-distance 4.3) ; Returns 3 as it takes 3 steps to swim at least 4.3 meters", "level": "easy"}
{"task_id": "Emacs Lisp/30", "prompt": "(require 'cl-lib)\n(defun total-swim-distance (start-day days)\n;; This function calculates the total distance swum by a fish, which swims 250 km per day except on weekends.\n;; The swimming starts on a day of the week given by START-DAY (1 for Monday, ..., 7 for Sunday) and continues for a number of DAYS.\n;; The function returns the total distance swum in kilometers.\n;; Example Usage:\n;; (total-swim-distance 3 10) ; Returns 2000, as the fish swims for 10 days starting from Wednesday", "canonical_solution": "(let ((distance 0) (day start-day))\n(dotimes (i days)\n(unless (or (= day 6) (= day 7)) ; 6 and 7 represent Saturday and Sunday\n(setq distance (+ distance 250)))\n(setq day (if (= day 7) 1 (1+ day)))) ; Cycle the day of the week\ndistance)\n)", "test": "(defun test-total-swim-distance ()\n(cl-assert (equal (total-swim-distance 3 10) 2000))\n(cl-assert (equal (total-swim-distance 1 7) 1250))\n(cl-assert (equal (total-swim-distance 6 2) 0))\n(cl-assert (equal (total-swim-distance 7 3) 500))\n(cl-assert (equal (total-swim-distance 4 14) 2500))\n(cl-assert (equal (total-swim-distance 1 0) 0)))\n\n(test-total-swim-distance)", "entry_point": "total-swim-distance", "signature": "(defun total-swim-distance (start-day days)", "docstring": "This function calculates the total distance swum by a fish, which swims 250 km per day except on weekends.\nThe swimming starts on a day of the week given by START-DAY (1 for Monday, ..., 7 for Sunday) and continues for a number of DAYS.\nThe function returns the total distance swum in kilometers.\nExample Usage:\n(total-swim-distance 3 10) ; Returns 2000, as the fish swims for 10 days starting from Wednesday", "instruction": "Write a Emacs Lisp function `(defun total-swim-distance (start-day days)` to solve the following problem:\nThis function calculates the total distance swum by a fish, which swims 250 km per day except on weekends.\nThe swimming starts on a day of the week given by START-DAY (1 for Monday, ..., 7 for Sunday) and continues for a number of DAYS.\nThe function returns the total distance swum in kilometers.\nExample Usage:\n(total-swim-distance 3 10) ; Returns 2000, as the fish swims for 10 days starting from Wednesday", "level": "easy"}
{"task_id": "Emacs Lisp/31", "prompt": "(require 'cl-lib)\n(defun calculate-scholarships (students)\n;; This function calculates the total scholarship amount for each student in a list of STUDENTS.\n;; Each student is represented as a list containing their name, final score, class score, whether they are a student leader (Y/N), \n;; whether they are from a western province (Y/N), and the number of papers published.\n;; The function returns a list of lists, each containing the student's name and their total scholarship amount.\n;; Example Usage:\n;; (calculate-scholarships '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1))) \n;; ; Returns (ChenRuiyi 9000 28700)", "canonical_solution": "(let ((max-scholarship 0) (max-student \"\") (total-scholarship 0))\n(dolist (student students)\n(let* ((name (nth 0 student))\n(avg-score (nth 1 student))\n(class-score (nth 2 student))\n(leader (string= (nth 3 student) \"Y\"))\n(western (string= (nth 4 student) \"Y\"))\n(papers (nth 5 student))\n(scholarship 0))\n(when (> avg-score 80)\n(when (>= papers 1)\n(setq scholarship (+ scholarship 8000)))\n(when (and (> avg-score 85) (> class-score 80))\n(setq scholarship (+ scholarship 4000)))\n(when (> avg-score 90)\n(setq scholarship (+ scholarship 2000)))\n(when (and (> avg-score 85) western)\n(setq scholarship (+ scholarship 1000)))\n(when (and (> class-score 80) leader)\n(setq scholarship (+ scholarship 850))))\n(setq total-scholarship (+ total-scholarship scholarship))\n(when (> scholarship max-scholarship)\n(setq max-scholarship scholarship)\n(setq max-student name))))\n(list max-student max-scholarship total-scholarship)))", "test": "(defun test-calculate-scholarships ()\n(let ((student-data '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1) (\"LiXin\" 92 88 \"N\" \"N\" 0) (\"ZhangQin\" 83 87 \"Y\" \"N\" 1))))\n(cl-assert (equal (calculate-scholarships student-data)'(\"ChenRuiyi\" 9000 28700))))\n)\n(test-calculate-scholarships)", "entry_point": "calculate-scholarships", "signature": "(defun calculate-scholarships (students)", "docstring": "This function calculates the total scholarship amount for each student in a list of STUDENTS.\nEach student is represented as a list containing their name, final score, class score, whether they are a student leader (Y/N), \nwhether they are from a western province (Y/N), and the number of papers published.\nThe function returns a list of lists, each containing the student's name and their total scholarship amount.\nExample Usage:\n(calculate-scholarships '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1))) \n; Returns (ChenRuiyi 9000 28700)", "instruction": "Write a Emacs Lisp function `(defun calculate-scholarships (students)` to solve the following problem:\nThis function calculates the total scholarship amount for each student in a list of STUDENTS.\nEach student is represented as a list containing their name, final score, class score, whether they are a student leader (Y/N), \nwhether they are from a western province (Y/N), and the number of papers published.\nThe function returns a list of lists, each containing the student's name and their total scholarship amount.\nExample Usage:\n(calculate-scholarships '((\"YaoLin\" 87 82 \"Y\" \"N\" 0) (\"ChenRuiyi\" 88 78 \"N\" \"Y\" 1))) \n; Returns (ChenRuiyi 9000 28700)", "level": "hard"}
{"task_id": "Emacs Lisp/32", "prompt": "(require 'cl-lib)\n(defun verify-isbn (isbn)\n;; Verifies the correctness of an ISBN number. An ISBN is structured as x-xxx-xxxxx-x,\n;; where 'x' is a digit and '-' is a separator. The last digit is a checksum calculated\n;; as the sum of the first 9 digits multiplied by their position index (1 to 9),\n;; modulo 11. If the checksum is 10, it is represented as 'X'.\n;; This function checks if the given ISBN is valid and returns 'Right' if it is,\n;; or the corrected ISBN if it's not.\n;; Examples:\n;;>>> verify-isbn(\"0-123-45678-9\")\n;;\"Right\"\n;;>>> verify-isbn(\"0-321-14670-2\")\n;;\"0-321-14670-X\"", "canonical_solution": "(let ((clean-isbn (replace-regexp-in-string \"-\" \"\" isbn))\n(checksum 0))\n(cl-loop for i from 0 below 9\ndo (setq checksum (+ checksum (* (string-to-number (substring clean-isbn i (1+ i))) (1+ i)))))\n(setq checksum (mod checksum 11))\n(let ((correct-checksum (if (= checksum 10) \"X\" (number-to-string checksum))))\n(if (string= correct-checksum (substring clean-isbn 9))\n\"Right\"\n(concat (substring isbn 0 12) correct-checksum)))))", "test": "(defun test-verify-isbn ()\n(cl-assert (equal (verify-isbn \"0-670-82162-4\") \"Right\"))\n(princ (verify-isbn \"0-321-14670-2\"))\n(cl-assert (equal (verify-isbn \"0-321-14670-2\") \"0-321-14670-0\"))\n(cl-assert (equal (verify-isbn \"1-234-56789-X\") \"Right\"))\n(cl-assert (equal (verify-isbn \"1-234-56789-0\") \"1-234-56789-X\"))\n(cl-assert (equal (verify-isbn \"0-201-53082-1\") \"Right\"))\n(cl-assert (equal (verify-isbn \"0-201-53082-X\") \"0-201-53082-1\")))\n\n(test-verify-isbn)", "entry_point": "verify-isbn", "signature": "(defun verify-isbn (isbn)", "docstring": "Verifies the correctness of an ISBN number. An ISBN is structured as x-xxx-xxxxx-x,\nwhere 'x' is a digit and '-' is a separator. The last digit is a checksum calculated\nas the sum of the first 9 digits multiplied by their position index (1 to 9),\nmodulo 11. If the checksum is 10, it is represented as 'X'.\nThis function checks if the given ISBN is valid and returns 'Right' if it is,\nor the corrected ISBN if it's not.\nExamples:\n>>> verify-isbn(\"0-123-45678-9\")\n\"Right\"\n>>> verify-isbn(\"0-321-14670-2\")\n\"0-321-14670-X\"", "instruction": "Write a Emacs Lisp function `(defun verify-isbn (isbn)` to solve the following problem:\nVerifies the correctness of an ISBN number. An ISBN is structured as x-xxx-xxxxx-x,\nwhere 'x' is a digit and '-' is a separator. The last digit is a checksum calculated\nas the sum of the first 9 digits multiplied by their position index (1 to 9),\nmodulo 11. If the checksum is 10, it is represented as 'X'.\nThis function checks if the given ISBN is valid and returns 'Right' if it is,\nor the corrected ISBN if it's not.\nExamples:\n>>> verify-isbn(\"0-123-45678-9\")\n\"Right\"\n>>> verify-isbn(\"0-321-14670-2\")\n\"0-321-14670-X\"", "level": "middle"}
{"task_id": "Emacs Lisp/33", "prompt": "(require 'cl-lib)\n(defun process-random-numbers (numbers)\n;; This function takes a list of random numbers and processes it by removing duplicates\n;; and then sorting the remaining numbers in ascending order.\n;; It returns a list where the first element is the count of unique numbers,\n;; and the second element is the sorted list of these unique numbers.\n;; Example:\n;;>>> process-random-numbers '(10 20 30 20 10)\n;;(3 (10 20 30))\n;;>>> process-random-numbers '(5 4 3 2 1 1)\n;;(5 (1 2 3 4 5))", "canonical_solution": "(let ((unique-numbers (cl-remove-duplicates (copy-sequence numbers))))\n(list (length unique-numbers) (sort unique-numbers '<))))", "test": "(defun test-process-random-numbers ()\n(cl-assert (equal (process-random-numbers '(10 20 30 20 10)) '(3 (10 20 30))))\n(cl-assert (equal (process-random-numbers '(5 4 3 2 1 1)) '(5 (1 2 3 4 5))))\n(cl-assert (equal (process-random-numbers '(55 23 67 23 90 100 90)) '(5 (23 55 67 90 100))))\n(cl-assert (equal (process-random-numbers '(1 2 3 4 5)) '(5 (1 2 3 4 5)))))\n\n(test-process-random-numbers)", "entry_point": "process-random-numbers", "signature": "(defun process-random-numbers (numbers)", "docstring": "This function takes a list of random numbers and processes it by removing duplicates\nand then sorting the remaining numbers in ascending order.\nIt returns a list where the first element is the count of unique numbers,\nand the second element is the sorted list of these unique numbers.\nExample:\n>>> process-random-numbers '(10 20 30 20 10)\n(3 (10 20 30))\n>>> process-random-numbers '(5 4 3 2 1 1)\n(5 (1 2 3 4 5))", "instruction": "Write a Emacs Lisp function `(defun process-random-numbers (numbers)` to solve the following problem:\nThis function takes a list of random numbers and processes it by removing duplicates\nand then sorting the remaining numbers in ascending order.\nIt returns a list where the first element is the count of unique numbers,\nand the second element is the sorted list of these unique numbers.\nExample:\n>>> process-random-numbers '(10 20 30 20 10)\n(3 (10 20 30))\n>>> process-random-numbers '(5 4 3 2 1 1)\n(5 (1 2 3 4 5))", "level": "easy"}
{"task_id": "Emacs Lisp/34", "prompt": "(require 'cl-lib)\n(defun maximize-importance (budget items)\n;; This function takes a budget and a list of items, each with a price and importance rating,\n;; and calculates the maximum total importance within the budget.\n;; Each item is represented as a cons cell (price . importance).\n;; The function returns the maximum sum of price times importance for the selected items,\n;; without exceeding the budget.\n;; Example:\n;;>>> maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))\n;;4000\n;;>>> maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))\n;;1450", "canonical_solution": "(let ((dp (make-vector (1+ budget) 0)))\n(dolist (item items)\n(let ((price (car item))\n(importance (cdr item)))\n(cl-loop for j from budget downto price\ndo (setf (aref dp j) (max (aref dp j)\n(+ (aref dp (- j price)) (* price importance)))))))\n(aref dp budget))\n)", "test": "(defun test-maximize-importance ()\n(cl-assert (equal (maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))) 4000))\n(cl-assert (equal (maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))) 1450))\n(cl-assert (equal (maximize-importance 800 '((250 . 3) (350 . 4) (150 . 2))) 2450))\n(cl-assert (equal (maximize-importance 600 '((100 . 1) (200 . 2) (300 . 3))) 1400)))\n\n(test-maximize-importance)", "entry_point": "maximize-importance", "signature": "(defun maximize-importance (budget items)", "docstring": "This function takes a budget and a list of items, each with a price and importance rating,\nand calculates the maximum total importance within the budget.\nEach item is represented as a cons cell (price . importance).\nThe function returns the maximum sum of price times importance for the selected items,\nwithout exceeding the budget.\nExample:\n>>> maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))\n4000\n>>> maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))\n1450", "instruction": "Write a Emacs Lisp function `(defun maximize-importance (budget items)` to solve the following problem:\nThis function takes a budget and a list of items, each with a price and importance rating,\nand calculates the maximum total importance within the budget.\nEach item is represented as a cons cell (price . importance).\nThe function returns the maximum sum of price times importance for the selected items,\nwithout exceeding the budget.\nExample:\n>>> maximize-importance 1000 '((300 . 4) (200 . 3) (400 . 5) (100 . 2))\n4000\n>>> maximize-importance 500 '((150 . 3) (200 . 4) (100 . 2))\n1450", "level": "easy"}
{"task_id": "Emacs Lisp/35", "prompt": "(require 'cl-lib)\n(defun construct-fbi-tree (n binary-string)\n;; This function constructs an FBI tree from a given binary string of length 2^N and \n;; returns its postorder traversal. The tree nodes are of three types: 'B' for all 0s, \n;; 'I' for all 1s, and 'F' for a mix of 0s and 1s. The tree is built recursively \n;; by dividing the string into two equal halves until the base case (single character) is reached.\n;; Example:\n;;>>> construct-fbi-tree 2 \"1010\"\n;;\"IBBF\"\n;;>>> construct-fbi-tree 1 \"01\"\n;;\"FB\"", "canonical_solution": "(defun node-type (string)\n(cond ((string-match-p \"^[0]+$\" string) \"B\")\n((string-match-p \"^[1]+$\" string) \"I\")\n(t \"F\")))\n(defun construct-tree (string)\n(if (= (length string) 1)\n(node-type string)\n(let* ((mid (/ (length string) 2))\n(left (substring string 0 mid))\n(right (substring string mid))\n(left-tree (construct-tree left))\n(right-tree (construct-tree right)))\n(concat left-tree right-tree (node-type string)))))\n(construct-tree binary-string))", "test": "(defun test-construct-fbi-tree ()\n(princ(construct-fbi-tree 2 \"1010\"))\n(cl-assert (equal (construct-fbi-tree 2 \"1010\") \"IBFIBFF\"))\n(cl-assert (equal (construct-fbi-tree 1 \"01\") \"BIF\"))\n(cl-assert (equal (construct-fbi-tree 3 \"10001011\") \"IBFBBBFIBFIIIFF\"))\n(cl-assert (equal (construct-fbi-tree 2 \"1111\") \"IIIIIII\")))\n\n(test-construct-fbi-tree)", "entry_point": "construct-fbi-tree", "signature": "(defun construct-fbi-tree (n binary-string)", "docstring": "This function constructs an FBI tree from a given binary string of length 2^N and \nreturns its postorder traversal. The tree nodes are of three types: 'B' for all 0s, \n'I' for all 1s, and 'F' for a mix of 0s and 1s. The tree is built recursively \nby dividing the string into two equal halves until the base case (single character) is reached.\nExample:\n>>> construct-fbi-tree 2 \"1010\"\n\"IBBF\"\n>>> construct-fbi-tree 1 \"01\"\n\"FB\"", "instruction": "Write a Emacs Lisp function `(defun construct-fbi-tree (n binary-string)` to solve the following problem:\nThis function constructs an FBI tree from a given binary string of length 2^N and \nreturns its postorder traversal. The tree nodes are of three types: 'B' for all 0s, \n'I' for all 1s, and 'F' for a mix of 0s and 1s. The tree is built recursively \nby dividing the string into two equal halves until the base case (single character) is reached.\nExample:\n>>> construct-fbi-tree 2 \"1010\"\n\"IBBF\"\n>>> construct-fbi-tree 1 \"01\"\n\"FB\"", "level": "middle"}
{"task_id": "Emacs Lisp/36", "prompt": "(require 'cl-lib)\n(defun mars-finger-permutation (n m current-permutation)\n;; This function calculates the new arrangement of a Martian's fingers, \n;; given the current permutation, the number of fingers, and a small integer to add. \n;; Martians use a unique counting method with their fingers, where each permutation \n;; of fingers represents a different number. The function finds the permutation that\n;; represents the number obtained by adding the given small integer to the number \n;; represented by the current permutation.\n;; Example:\n;;>>> mars-finger-permutation 5 3 '(1 2 3 4 5)\n;;(1 2 4 5 3)\n;;>>> mars-finger-permutation 3 2 '(1 2 3)\n;;(1 3 2)", "canonical_solution": "(let* ((factorial (lambda (x) (if (<= x 1) 1 (* x (funcall factorial (- x 1))))))\n(perm-to-number (lambda (perm)\n(let ((number 0) (digits (copy-sequence perm)))\n(cl-loop for i from 1 upto (length digits)\ndo (setq number (+ number (* (- (nth (1- i) digits) 1)\n(funcall factorial (- n i)))))\ndo (cl-loop for j from i below (length digits)\nwhen (> (nth j digits) (nth (1- i) digits))\ndo (setf (nth j digits) (- (nth j digits) 1))))\n(1+ number))))\n(number-to-perm (lambda (number)\n(let ((digits (number-sequence 1 n)) (perm '()))\n(cl-loop for i from 1 upto n\ndo (let* ((fact (funcall factorial (- n i)))\n(index (/ (- number 1) fact))\n(digit (nth index digits)))\n(push digit perm)\n(setq digits (delete digit digits))\n(setq number (- number (* index fact)))))\n(nreverse perm)))))\n(funcall number-to-perm (+ (funcall perm-to-number current-permutation) m))))", "test": "(defun test-mars-finger-permutation ()\n(cl-assert (equal (mars-finger-permutation 5 3 '(1 2 3 4 5)) '(1 2 4 5 3)))\n(cl-assert (equal (mars-finger-permutation 3 2 '(1 2 3)) '(2 1 3)))\n(cl-assert (equal (mars-finger-permutation 4 5 '(1 2 3 4)) '(1 4 3 2)))\n(cl-assert (equal (mars-finger-permutation 6 10 '(1 2 3 4 5 6)) '(1 2 4 6 3 5))))\n\n(test-mars-finger-permutation)", "entry_point": "mars-finger-permutation", "signature": "(defun mars-finger-permutation (n m current-permutation)", "docstring": "This function calculates the new arrangement of a Martian's fingers, \ngiven the current permutation, the number of fingers, and a small integer to add. \nMartians use a unique counting method with their fingers, where each permutation \nof fingers represents a different number. The function finds the permutation that\nrepresents the number obtained by adding the given small integer to the number \nrepresented by the current permutation.\nExample:\n>>> mars-finger-permutation 5 3 '(1 2 3 4 5)\n(1 2 4 5 3)\n>>> mars-finger-permutation 3 2 '(1 2 3)\n(1 3 2)", "instruction": "Write a Emacs Lisp function `(defun mars-finger-permutation (n m current-permutation)` to solve the following problem:\nThis function calculates the new arrangement of a Martian's fingers, \ngiven the current permutation, the number of fingers, and a small integer to add. \nMartians use a unique counting method with their fingers, where each permutation \nof fingers represents a different number. The function finds the permutation that\nrepresents the number obtained by adding the given small integer to the number \nrepresented by the current permutation.\nExample:\n>>> mars-finger-permutation 5 3 '(1 2 3 4 5)\n(1 2 4 5 3)\n>>> mars-finger-permutation 3 2 '(1 2 3)\n(1 3 2)", "level": "hard"}
{"task_id": "Emacs Lisp/37", "prompt": "(require 'cl-lib)\n(defun minimum-number-of-groups (price-limit prices)\n;; This function calculates the minimum number of groups needed to distribute souvenirs,\n;; given a list of their prices and a price limit per group. Each group can contain \n;; at most two souvenirs and the total price of souvenirs in each group cannot exceed the limit.\n;; The function sorts the prices in descending order and then pairs the highest priced item \n;; with the lowest priced item that fits within the limit.\n;; Example:\n;;>>> minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)\n;;6\n;;>>> minimum-number-of-groups 50 '(10 20 30 40 50)\n;;3", "canonical_solution": "(let ((sorted-prices (sort prices '>))\n(group-count 0))\n(while sorted-prices\n(setq group-count (1+ group-count))\n(let ((first-price (pop sorted-prices)))\n(when (and sorted-prices (<= (+ first-price (car (last sorted-prices))) price-limit))\n(setq sorted-prices (butlast sorted-prices)))))\ngroup-count))", "test": "(defun test-minimum-number-of-groups ()\n(cl-assert (equal (minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)) 6))\n(cl-assert (equal (minimum-number-of-groups 50 '(10 20 30 40 50)) 3))\n(cl-assert (equal (minimum-number-of-groups 200 '(100 150 80 60)) 3))\n(cl-assert (equal (minimum-number-of-groups 120 '(50 50 20 30)) 2)))\n\n(test-minimum-number-of-groups)", "entry_point": "minimum-number-of-groups", "signature": "(defun minimum-number-of-groups (price-limit prices)", "docstring": "This function calculates the minimum number of groups needed to distribute souvenirs,\ngiven a list of their prices and a price limit per group. Each group can contain \nat most two souvenirs and the total price of souvenirs in each group cannot exceed the limit.\nThe function sorts the prices in descending order and then pairs the highest priced item \nwith the lowest priced item that fits within the limit.\nExample:\n>>> minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)\n6\n>>> minimum-number-of-groups 50 '(10 20 30 40 50)\n3", "instruction": "Write a Emacs Lisp function `(defun minimum-number-of-groups (price-limit prices)` to solve the following problem:\nThis function calculates the minimum number of groups needed to distribute souvenirs,\ngiven a list of their prices and a price limit per group. Each group can contain \nat most two souvenirs and the total price of souvenirs in each group cannot exceed the limit.\nThe function sorts the prices in descending order and then pairs the highest priced item \nwith the lowest priced item that fits within the limit.\nExample:\n>>> minimum-number-of-groups 100 '(90 20 30 50 60 70 80 90)\n6\n>>> minimum-number-of-groups 50 '(10 20 30 40 50)\n3", "level": "easy"}
{"task_id": "Emacs Lisp/38", "prompt": "(require 'cl-lib)\n(defun count-and-sort-numbers (numbers)\n;; This function takes a list of natural numbers and counts the occurrences of each number.\n;; It then sorts these numbers in ascending order and returns a list of pairs. \n;; Each pair contains a number and its count. \n;; The list is sorted by the numbers from smallest to largest.\n;; Example:\n;;>>> count-and-sort-numbers '(2 4 2 4 5 100 2 100)\n;;((2 3) (4 2) (5 1) (100 2))", "canonical_solution": "(let ((counts (make-hash-table :test 'equal))\nkeys)\n;; Count the numbers\n(dolist (num numbers)\n(puthash num (1+ (gethash num counts 0)) counts))\n;; Collect keys\n(maphash (lambda (key value) (push key keys)) counts)\n;; Sort and return\n(sort (mapcar (lambda (key) (list key (gethash key counts))) keys)\n(lambda (a b) (< (car a) (car b))))))", "test": "(defun test-count-and-sort-numbers ()\n(cl-assert (equal (count-and-sort-numbers '(2 4 2 4 5 100 2 100)) '((2 3) (4 2) (5 1) (100 2))))\n(cl-assert (equal (count-and-sort-numbers '(1 2 3 3 3 2 1)) '((1 2) (2 2) (3 3))))\n(cl-assert (equal (count-and-sort-numbers '(5 4 3 2 1)) '((1 1) (2 1) (3 1) (4 1) (5 1))))\n)\n(test-count-and-sort-numbers)", "entry_point": "count-and-sort-numbers", "signature": "(defun count-and-sort-numbers (numbers)", "docstring": "This function takes a list of natural numbers and counts the occurrences of each number.\nIt then sorts these numbers in ascending order and returns a list of pairs. \nEach pair contains a number and its count. \nThe list is sorted by the numbers from smallest to largest.\nExample:\n>>> count-and-sort-numbers '(2 4 2 4 5 100 2 100)\n((2 3) (4 2) (5 1) (100 2))", "instruction": "Write a Emacs Lisp function `(defun count-and-sort-numbers (numbers)` to solve the following problem:\nThis function takes a list of natural numbers and counts the occurrences of each number.\nIt then sorts these numbers in ascending order and returns a list of pairs. \nEach pair contains a number and its count. \nThe list is sorted by the numbers from smallest to largest.\nExample:\n>>> count-and-sort-numbers '(2 4 2 4 5 100 2 100)\n((2 3) (4 2) (5 1) (100 2))", "level": "middle"}
{"task_id": "Emacs Lisp/39", "prompt": "(require 'cl-lib)\n(defun swap-binary-halves (number)\n;; This function takes a non-negative integer that fits in a 32-bit binary representation.\n;; It swaps the first 16 bits (high bits) with the last 16 bits (low bits) and returns the new number in decimal format.\n;; The input number is first represented in 32-bit binary form (with leading zeros if necessary), \n;; then the high and low bits are swapped to form a new number.\n;; Example:\n;;>>> swap-binary-halves 1314520\n;;249036820", "canonical_solution": "(let* ((binary-str (integer-to-binary-string number 32))\n(high-bits (substring binary-str 0 16))\n(low-bits (substring binary-str 16)))\n(string-to-number (concat low-bits high-bits) 2)))\n(defun integer-to-binary-string (number bit-length)\n\"Convert an integer to a binary string with a fixed bit length.\"\n(let ((binary-str \"\"))\n(dotimes (i bit-length binary-str)\n(setq binary-str (concat (if (zerop (logand number (ash 1 i))) \"0\" \"1\") binary-str)))))", "test": "(defun test-swap-binary-halves ()\n(cl-assert (equal (swap-binary-halves 1314520) 249036820))\n(cl-assert (equal (swap-binary-halves 65535) 4294901760))\n(cl-assert (equal (swap-binary-halves 4294901760) 65535))\n(cl-assert (equal (swap-binary-halves 0) 0)))\n\n(test-swap-binary-halves)", "entry_point": "swap-binary-halves", "signature": "(defun swap-binary-halves (number)", "docstring": "This function takes a non-negative integer that fits in a 32-bit binary representation.\nIt swaps the first 16 bits (high bits) with the last 16 bits (low bits) and returns the new number in decimal format.\nThe input number is first represented in 32-bit binary form (with leading zeros if necessary), \nthen the high and low bits are swapped to form a new number.\nExample:\n>>> swap-binary-halves 1314520\n249036820", "instruction": "Write a Emacs Lisp function `(defun swap-binary-halves (number)` to solve the following problem:\nThis function takes a non-negative integer that fits in a 32-bit binary representation.\nIt swaps the first 16 bits (high bits) with the last 16 bits (low bits) and returns the new number in decimal format.\nThe input number is first represented in 32-bit binary form (with leading zeros if necessary), \nthen the high and low bits are swapped to form a new number.\nExample:\n>>> swap-binary-halves 1314520\n249036820", "level": "middle"}
{"task_id": "Emacs Lisp/40", "prompt": "(require 'cl-lib)\n\n(defun median-after-removing-extremes (numbers-list)\n  ;; Function to calculate the median of a list after removing the maximum and minimum values.\n  ;; This function takes a list of integers and returns the median of the list after removing the maximum and minimum values.\n  ;; If the list is empty or contains less than 3 elements, the function returns nil to indicate that the median cannot be calculated.\n  ;; Args:\n  ;;   numbers-list: A list of integers.\n  ;; Returns:\n  ;;   The median of the list after removing the maximum and minimum values, or nil if the list has less than 3 elements.\n  ;; Example Usage:\n  ;; (median-after-removing-extremes '(5 3 1 4 2)) ; Returns 3\n  ;; (median-after-removing-extremes '(1 2 3)) ; Returns 2\n  ;; (median-after-removing-extremes '(1)) ; Returns nil", "canonical_solution": "  (if (< (length numbers-list) 3)\n      nil\n    (let* ((sorted-list (cl-sort (cl-copy-list numbers-list) '<))\n           (trimmed-list (butlast (cdr sorted-list))))\n      (if (my-evenp (length trimmed-list))\n          (/ (+ (nth (/ (length trimmed-list) 2) trimmed-list)\n                (nth (- (/ (length trimmed-list) 2) 1) trimmed-list))\n             2)\n        (nth (/ (length trimmed-list) 2) trimmed-list)))))\n\n(defun my-evenp (n)\n  \"Check whether N is an even number.\"\n  (= 0 (% n 2)))", "test": "(defun check-median-after-removing-extremes ()\n  (cl-assert (equal (median-after-removing-extremes '(5 3 1 4 2)) 3))\n  (cl-assert (equal (median-after-removing-extremes '(1 2 3)) 2))\n  (cl-assert (equal (median-after-removing-extremes '(1)) nil))\n  (cl-assert (equal (median-after-removing-extremes '(7 5 3 9 1 6)) 5))\n  (cl-assert (equal (median-after-removing-extremes '(10 20 30 40 50)) 30)))\n\n(check-median-after-removing-extremes)", "entry_point": "median-after-removing-extremes", "signature": "(defun median-after-removing-extremes (numbers-list)", "docstring": " Function to calculate the median of a list after removing the maximum and minimum values.\nThis function takes a list of integers and returns the median of the list after removing the maximum and minimum values.\nIf the list is empty or contains less than 3 elements, the function returns nil to indicate that the median cannot be calculated.\nArgs:\n  numbers-list: A list of integers.\nReturns:\n  The median of the list after removing the maximum and minimum values, or nil if the list has less than 3 elements.\nExample Usage:\n(median-after-removing-extremes '(5 3 1 4 2)) ; Returns 3\n(median-after-removing-extremes '(1 2 3)) ; Returns 2\n(median-after-removing-extremes '(1)) ; Returns nil", "instruction": "Write a Emacs Lisp function `(defun median-after-removing-extremes (numbers-list)` to solve the following problem: Function to calculate the median of a list after removing the maximum and minimum values.\nThis function takes a list of integers and returns the median of the list after removing the maximum and minimum values.\nIf the list is empty or contains less than 3 elements, the function returns nil to indicate that the median cannot be calculated.\nArgs:\n  numbers-list: A list of integers.\nReturns:\n  The median of the list after removing the maximum and minimum values, or nil if the list has less than 3 elements.\nExample Usage:\n(median-after-removing-extremes '(5 3 1 4 2)) ; Returns 3\n(median-after-removing-extremes '(1 2 3)) ; Returns 2\n(median-after-removing-extremes '(1)) ; Returns nil", "level": "middle"}
{"task_id": "Emacs Lisp/41", "prompt": "(require 'cl-lib)\n\n(defun calculate-expression (a b c)\n  ;; Function to calculate the value of the expression (a+b)\u00d7c.\n  ;; This function takes three integers a, b, and c, and returns the result of (a+b)\u00d7c.\n  ;; Args:\n  ;;   a: An integer.\n  ;;   b: An integer.\n  ;;   c: An integer.\n  ;; Returns:\n  ;;   The result of the expression (a+b)\u00d7c.\n  ;; Example Usage:\n  ;; (calculate-expression 1 2 3) ; Returns 9\n  ;; (calculate-expression -1 -2 2) ; Returns -6", "canonical_solution": "  (let ((sum (+ a b)))\n    (* sum c)))", "test": "(defun check-calculate-expression ()\n  (cl-assert (equal (calculate-expression 1 2 3) 9))\n  (cl-assert (equal (calculate-expression -1 -2 2) -6))\n  (cl-assert (equal (calculate-expression 0 0 1) 0))\n  (cl-assert (equal (calculate-expression 100 -100 0) 0))\n  (cl-assert (equal (calculate-expression 50 50 2) 200)))\n\n(check-calculate-expression)", "entry_point": "calculate-expression", "signature": "(defun calculate-expression (a b c)", "docstring": " Function to calculate the value of the expression (a+b)\u00d7c.\nThis function takes three integers a, b, and c, and returns the result of (a+b)\u00d7c.\nArgs:\n  a: An integer.\n  b: An integer.\n  c: An integer.\nReturns:\n  The result of the expression (a+b)\u00d7c.\nExample Usage:\n(calculate-expression 1 2 3) ; Returns 9\n(calculate-expression -1 -2 2) ; Returns -6", "instruction": "Write a Emacs Lisp function `(defun calculate-expression (a b c)` to solve the following problem: Function to calculate the value of the expression (a+b)\u00d7c.\nThis function takes three integers a, b, and c, and returns the result of (a+b)\u00d7c.\nArgs:\n  a: An integer.\n  b: An integer.\n  c: An integer.\nReturns:\n  The result of the expression (a+b)\u00d7c.\nExample Usage:\n(calculate-expression 1 2 3) ; Returns 9\n(calculate-expression -1 -2 2) ; Returns -6", "level": "easy"}
{"task_id": "Emacs Lisp/42", "prompt": "(require 'cl-lib)\n\n(defun print-ascii-code (char)\n  ;; Function to output the ASCII code of a given character.\n  ;; This function takes a single character (excluding space) as input and returns its ASCII code.\n  ;; Args:\n  ;;   char: A character (type: character).\n  ;; Returns:\n  ;;   The ASCII code of the character as an integer.\n  ;; Example Usage:\n  ;; (print-ascii-code ?A) ; Returns 65\n  ;; (print-ascii-code ?z) ; Returns 122", "canonical_solution": "  char)", "test": "(defun check-print-ascii-code ()\n  (cl-assert (equal (print-ascii-code ?A) 65))\n  (cl-assert (equal (print-ascii-code ?z) 122))\n  (cl-assert (equal (print-ascii-code ?0) 48))\n  (cl-assert (equal (print-ascii-code ?!) 33))\n  (cl-assert (equal (print-ascii-code ?~) 126)))\n\n(check-print-ascii-code)", "entry_point": "print-ascii-code", "signature": "(defun print-ascii-code (char)", "docstring": " Function to output the ASCII code of a given character.\nThis function takes a single character (excluding space) as input and returns its ASCII code.\nArgs:\n  char: A character (type: character).\nReturns:\n  The ASCII code of the character as an integer.\nExample Usage:\n(print-ascii-code ?A) ; Returns 65\n(print-ascii-code ?z) ; Returns 122", "instruction": "Write a Emacs Lisp function `(defun print-ascii-code (char)` to solve the following problem: Function to output the ASCII code of a given character.\nThis function takes a single character (excluding space) as input and returns its ASCII code.\nArgs:\n  char: A character (type: character).\nReturns:\n  The ASCII code of the character as an integer.\nExample Usage:\n(print-ascii-code ?A) ; Returns 65\n(print-ascii-code ?z) ; Returns 122", "level": "easy"}
{"task_id": "Emacs Lisp/43", "prompt": "(require 'cl-lib)\n\n(defun ascii-to-char (ascii-code)\n  ;; Function to convert an ASCII code to the corresponding character.\n  ;; This function takes an integer representing an ASCII code and returns the character it represents.\n  ;; Args:\n  ;;   ascii-code: An integer (the ASCII code).\n  ;; Returns:\n  ;;   The character corresponding to the ASCII code.\n  ;; Example Usage:\n  ;; (ascii-to-char 65) ; Returns \"A\"\n  ;; (ascii-to-char 97) ; Returns \"a\"", "canonical_solution": "  (char-to-string ascii-code))", "test": "(defun check-ascii-to-char ()\n  (cl-assert (equal (ascii-to-char 65) \"A\"))\n  (cl-assert (equal (ascii-to-char 97) \"a\"))\n  (cl-assert (equal (ascii-to-char 48) \"0\"))\n  (cl-assert (equal (ascii-to-char 33) \"!\"))\n  (cl-assert (equal (ascii-to-char 126) \"~\")))\n\n(check-ascii-to-char)", "entry_point": "ascii-to-char", "signature": "(defun ascii-to-char (ascii-code)", "docstring": " Function to convert an ASCII code to the corresponding character.\nThis function takes an integer representing an ASCII code and returns the character it represents.\nArgs:\n  ascii-code: An integer (the ASCII code).\nReturns:\n  The character corresponding to the ASCII code.\nExample Usage:\n(ascii-to-char 65) ; Returns \"A\"\n(ascii-to-char 97) ; Returns \"a\"", "instruction": "Write a Emacs Lisp function `(defun ascii-to-char (ascii-code)` to solve the following problem: Function to convert an ASCII code to the corresponding character.\nThis function takes an integer representing an ASCII code and returns the character it represents.\nArgs:\n  ascii-code: An integer (the ASCII code).\nReturns:\n  The character corresponding to the ASCII code.\nExample Usage:\n(ascii-to-char 65) ; Returns \"A\"\n(ascii-to-char 97) ; Returns \"a\"", "level": "easy"}
{"task_id": "Emacs Lisp/44", "prompt": "(require 'cl-lib)\n\n(defun int-bool-int-conversion (int-val)\n  ;; Function to convert an integer to a boolean and then back to an integer.\n  ;; This function takes an integer, converts it to a boolean value (non-zero becomes true, zero becomes false),\n  ;; and then converts this boolean value back to an integer (true becomes 1, false becomes 0).\n  ;; Args:\n  ;;   int-val: An integer value.\n  ;; Returns:\n  ;;   An integer after conversion to boolean and then back to integer.\n  ;; Example Usage:\n  ;; (int-bool-int-conversion 3) ; Returns 1\n  ;; (int-bool-int-conversion 0) ; Returns 0", "canonical_solution": "  (if (= int-val 0) 0 1))", "test": "(defun check-int-bool-int-conversion ()\n  (cl-assert (equal (int-bool-int-conversion 3) 1))\n  (cl-assert (equal (int-bool-int-conversion 0) 0))\n  (cl-assert (equal (int-bool-int-conversion -1) 1))\n  (cl-assert (equal (int-bool-int-conversion 100) 1))\n  (cl-assert (equal (int-bool-int-conversion -100) 1)))\n\n(check-int-bool-int-conversion)", "entry_point": "int-bool-int-conversion", "signature": "(defun int-bool-int-conversion (int-val)", "docstring": " Function to convert an integer to a boolean and then back to an integer.\nThis function takes an integer, converts it to a boolean value (non-zero becomes true, zero becomes false),\nand then converts this boolean value back to an integer (true becomes 1, false becomes 0).\nArgs:\n  int-val: An integer value.\nReturns:\n  An integer after conversion to boolean and then back to integer.\nExample Usage:\n(int-bool-int-conversion 3) ; Returns 1\n(int-bool-int-conversion 0) ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun int-bool-int-conversion (int-val)` to solve the following problem: Function to convert an integer to a boolean and then back to an integer.\nThis function takes an integer, converts it to a boolean value (non-zero becomes true, zero becomes false),\nand then converts this boolean value back to an integer (true becomes 1, false becomes 0).\nArgs:\n  int-val: An integer value.\nReturns:\n  An integer after conversion to boolean and then back to integer.\nExample Usage:\n(int-bool-int-conversion 3) ; Returns 1\n(int-bool-int-conversion 0) ; Returns 0", "level": "easy"}
{"task_id": "Emacs Lisp/45", "prompt": "(require 'cl-lib)\n\n(defun reverse-three-digit-number (n)\n  ;; Function to reverse a three-digit number.\n  ;; This function takes a three-digit integer and returns its reverse.\n  ;; Note: Leading zeros in the result are not preserved when returned as an integer.\n  ;; Args:\n  ;;   n: A three-digit integer.\n  ;; Returns:\n  ;;   The reversed integer.\n  ;; Example Usage:\n  ;; (reverse-three-digit-number 358) ; Returns 853", "canonical_solution": "  (let* ((str-n (number-to-string n))\n         (reversed-str-n (reverse str-n))\n         (reversed-n (string-to-number (concat reversed-str-n))))\n    reversed-n))", "test": "(defun check-reverse-three-digit-number ()\n  (cl-assert (equal (reverse-three-digit-number 358) 853))\n  (cl-assert (equal (reverse-three-digit-number 678) 876))\n  (cl-assert (equal (reverse-three-digit-number 120) 21)))\n\n(check-reverse-three-digit-number)", "entry_point": "reverse-three-digit-number", "signature": "(defun reverse-three-digit-number (n)", "docstring": " Function to reverse a three-digit number.\nThis function takes a three-digit integer and returns its reverse.\nNote: Leading zeros in the result are not preserved when returned as an integer.\nArgs:\n  n: A three-digit integer.\nReturns:\n  The reversed integer.\nExample Usage:\n(reverse-three-digit-number 358) ; Returns 853", "instruction": "Write a Emacs Lisp function `(defun reverse-three-digit-number (n)` to solve the following problem: Function to reverse a three-digit number.\nThis function takes a three-digit integer and returns its reverse.\nNote: Leading zeros in the result are not preserved when returned as an integer.\nArgs:\n  n: A three-digit integer.\nReturns:\n  The reversed integer.\nExample Usage:\n(reverse-three-digit-number 358) ; Returns 853", "level": "easy"}
{"task_id": "Emacs Lisp/46", "prompt": "(require 'cl-lib)\n\n(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Function to calculate the nth term of an arithmetic sequence.\n  ;; Given the first two terms of an arithmetic sequence, this function computes the nth term.\n  ;; Args:\n  ;;   a1: The first term of the sequence.\n  ;;   a2: The second term of the sequence.\n  ;;   n: The term number to find.\n  ;; Returns:\n  ;;   The value of the nth term in the arithmetic sequence.\n  ;; Example Usage:\n  ;; (nth-term-arithmetic-sequence 1 4 100) ; Returns 298\n  ;; (nth-term-arithmetic-sequence 3 5 10) ; Returns 23", "canonical_solution": "  (let ((difference (- a2 a1)))\n    (+ a1 (* (1- n) difference))))", "test": "(defun check-nth-term-arithmetic-sequence ()\n  (cl-assert (equal (nth-term-arithmetic-sequence 1 4 100) 298))\n  (cl-assert (equal (nth-term-arithmetic-sequence 3 5 10) 21))\n  (cl-assert (equal (nth-term-arithmetic-sequence 5 7 1) 5))\n  (cl-assert (equal (nth-term-arithmetic-sequence -3 -5 3) -7))\n  (cl-assert (equal (nth-term-arithmetic-sequence 10 20 5) 50)))\n\n(check-nth-term-arithmetic-sequence)", "entry_point": "nth-term-arithmetic-sequence", "signature": "(defun nth-term-arithmetic-sequence (a1 a2 n)", "docstring": " Function to calculate the nth term of an arithmetic sequence.\nGiven the first two terms of an arithmetic sequence, this function computes the nth term.\nArgs:\n  a1: The first term of the sequence.\n  a2: The second term of the sequence.\n  n: The term number to find.\nReturns:\n  The value of the nth term in the arithmetic sequence.\nExample Usage:\n(nth-term-arithmetic-sequence 1 4 100) ; Returns 298\n(nth-term-arithmetic-sequence 3 5 10) ; Returns 23", "instruction": "Write a Emacs Lisp function `(defun nth-term-arithmetic-sequence (a1 a2 n)` to solve the following problem: Function to calculate the nth term of an arithmetic sequence.\nGiven the first two terms of an arithmetic sequence, this function computes the nth term.\nArgs:\n  a1: The first term of the sequence.\n  a2: The second term of the sequence.\n  n: The term number to find.\nReturns:\n  The value of the nth term in the arithmetic sequence.\nExample Usage:\n(nth-term-arithmetic-sequence 1 4 100) ; Returns 298\n(nth-term-arithmetic-sequence 3 5 10) ; Returns 23", "level": "easy"}
{"task_id": "Emacs Lisp/47", "prompt": "(require 'cl-lib)\n\n(defun multiply-a-b (a b)\n  ;; Function to multiply two positive integers A and B.\n  ;; This function takes two integers A and B as input and returns their product.\n  ;; The function ensures that the integers are within the specified range (1 <= A,B <= 50000).\n  ;; Args:\n  ;;   a: An integer, the first multiplicand.\n  ;;   b: An integer, the second multiplicand.\n  ;; Returns:\n  ;;   The product of A and B as an integer.\n  ;; Example Usage:\n  ;; (multiply-a-b 3 4) ; Returns 12\n  ;; (multiply-a-b 36 18) ; Returns 648", "canonical_solution": "  (* a b))", "test": "(defun check-multiply-a-b ()\n  (cl-assert (equal (multiply-a-b 3 4) 12))\n  (cl-assert (equal (multiply-a-b 36 18) 648))\n  (cl-assert (equal (multiply-a-b 1 50000) 50000))\n  (cl-assert (equal (multiply-a-b 250 200) 50000))\n  (cl-assert (equal (multiply-a-b 123 456) 56088)))\n\n(check-multiply-a-b)", "entry_point": "multiply-a-b", "signature": "(defun multiply-a-b (a b)", "docstring": " Function to multiply two positive integers A and B.\nThis function takes two integers A and B as input and returns their product.\nThe function ensures that the integers are within the specified range (1 <= A,B <= 50000).\nArgs:\n  a: An integer, the first multiplicand.\n  b: An integer, the second multiplicand.\nReturns:\n  The product of A and B as an integer.\nExample Usage:\n(multiply-a-b 3 4) ; Returns 12\n(multiply-a-b 36 18) ; Returns 648", "instruction": "Write a Emacs Lisp function `(defun multiply-a-b (a b)` to solve the following problem: Function to multiply two positive integers A and B.\nThis function takes two integers A and B as input and returns their product.\nThe function ensures that the integers are within the specified range (1 <= A,B <= 50000).\nArgs:\n  a: An integer, the first multiplicand.\n  b: An integer, the second multiplicand.\nReturns:\n  The product of A and B as an integer.\nExample Usage:\n(multiply-a-b 3 4) ; Returns 12\n(multiply-a-b 36 18) ; Returns 648", "level": "easy"}
{"task_id": "Emacs Lisp/48", "prompt": "(require 'cl-lib)\n\n(defun power-of-two (n)\n  ;; Function to calculate 2 raised to the power of n.\n  ;; Given a non-negative integer n, this function returns the value of 2^n.\n  ;; Args:\n  ;;   n: A non-negative integer, the exponent to raise 2 by.\n  ;; Returns:\n  ;;   The result of 2 raised to the power of n as an integer.\n  ;; Constraints:\n  ;;   0 <= n < 31 to ensure the result is within the range of Emacs Lisp's integer.\n  ;; Example Usage:\n  ;; (power-of-two 3) ; Returns 8\n  ;; (power-of-two 5) ; Returns 32", "canonical_solution": "  (expt 2 n))", "test": "(defun check-power-of-two ()\n  (cl-assert (equal (power-of-two 3) 8))\n  (cl-assert (equal (power-of-two 5) 32))\n  (cl-assert (equal (power-of-two 0) 1))\n  (cl-assert (equal (power-of-two 10) 1024))\n  (cl-assert (equal (power-of-two 15) 32768)))\n\n(check-power-of-two)", "entry_point": "power-of-two", "signature": "(defun power-of-two (n)", "docstring": " Function to calculate 2 raised to the power of n.\nGiven a non-negative integer n, this function returns the value of 2^n.\nArgs:\n  n: A non-negative integer, the exponent to raise 2 by.\nReturns:\n  The result of 2 raised to the power of n as an integer.\nConstraints:\n  0 <= n < 31 to ensure the result is within the range of Emacs Lisp's integer.\nExample Usage:\n(power-of-two 3) ; Returns 8\n(power-of-two 5) ; Returns 32", "instruction": "Write a Emacs Lisp function `(defun power-of-two (n)` to solve the following problem: Function to calculate 2 raised to the power of n.\nGiven a non-negative integer n, this function returns the value of 2^n.\nArgs:\n  n: A non-negative integer, the exponent to raise 2 by.\nReturns:\n  The result of 2 raised to the power of n as an integer.\nConstraints:\n  0 <= n < 31 to ensure the result is within the range of Emacs Lisp's integer.\nExample Usage:\n(power-of-two 3) ; Returns 8\n(power-of-two 5) ; Returns 32", "level": "easy"}
{"task_id": "Emacs Lisp/49", "prompt": "(require 'cl-lib)\n\n(defun determine-sign (n)\n  ;; Function to determine the sign of an integer N.\n  ;; Given an integer N, this function returns 'positive' if N > 0, 'zero' if N = 0, and 'negative' if N < 0.\n  ;; Args:\n  ;;   n: An integer, the number to determine the sign of.\n  ;; Returns:\n  ;;   A string indicating whether the integer is 'positive', 'zero', or 'negative'.\n  ;; Example Usage:\n  ;; (determine-sign 95) ; Returns \"positive\"\n  ;; (determine-sign 0) ; Returns \"zero\"\n  ;; (determine-sign -10) ; Returns \"negative\"", "canonical_solution": "  (cond ((> n 0) \"positive\")\n        ((= n 0) \"zero\")\n        ((< n 0) \"negative\")))", "test": "(defun check-determine-sign ()\n  (cl-assert (equal (determine-sign 95) \"positive\"))\n  (cl-assert (equal (determine-sign 0) \"zero\"))\n  (cl-assert (equal (determine-sign -10) \"negative\"))\n  (cl-assert (equal (determine-sign 1) \"positive\"))\n  (cl-assert (equal (determine-sign -1) \"negative\")))\n\n(check-determine-sign)", "entry_point": "determine-sign", "signature": "(defun determine-sign (n)", "docstring": " Function to determine the sign of an integer N.\nGiven an integer N, this function returns 'positive' if N > 0, 'zero' if N = 0, and 'negative' if N < 0.\nArgs:\n  n: An integer, the number to determine the sign of.\nReturns:\n  A string indicating whether the integer is 'positive', 'zero', or 'negative'.\nExample Usage:\n(determine-sign 95) ; Returns \"positive\"\n(determine-sign 0) ; Returns \"zero\"\n(determine-sign -10) ; Returns \"negative\"", "instruction": "Write a Emacs Lisp function `(defun determine-sign (n)` to solve the following problem: Function to determine the sign of an integer N.\nGiven an integer N, this function returns 'positive' if N > 0, 'zero' if N = 0, and 'negative' if N < 0.\nArgs:\n  n: An integer, the number to determine the sign of.\nReturns:\n  A string indicating whether the integer is 'positive', 'zero', or 'negative'.\nExample Usage:\n(determine-sign 95) ; Returns \"positive\"\n(determine-sign 0) ; Returns \"zero\"\n(determine-sign -10) ; Returns \"negative\"", "level": "easy"}
{"task_id": "Emacs Lisp/50", "prompt": "(require 'cl-lib)\n(defun absolute-value (n)\n;; Function to calculate the absolute value of an integer.\n;; Args:\n;;   n: An integer whose absolute value is to be found. The absolute value of n should not exceed 10000.\n;; Returns:\n;;   The absolute value of n.\n;; Example Usage:\n;; (absolute-value -5) ; Returns 5\n;; (absolute-value 10) ; Returns 10\n;; (absolute-value 0)  ; Returns 0", "canonical_solution": "  (if (< n 0)\n      (- n)\n    n)\n)", "test": "(defun check-absolute-value ()\n  \"Test cases for absolute-value function.\"\n  (cl-assert (equal (absolute-value -5) 5))\n  (cl-assert (equal (absolute-value 10) 10))\n  (cl-assert (equal (absolute-value 0) 0))\n  (cl-assert (equal (absolute-value -10000) 10000))\n  (cl-assert (equal (absolute-value 9999) 9999)))\n\n(check-absolute-value)", "entry_point": "absolute-value", "signature": "(defun absolute-value (n)", "docstring": " Function to calculate the absolute value of an integer.\n Args:\n   n: An integer whose absolute value is to be found. The absolute value of n should not exceed 10000.\n Returns:\n   The absolute value of n.\n Example Usage:\n (absolute-value -5) ; Returns 5\n (absolute-value 10) ; Returns 10\n (absolute-value 0)  ; Returns 0", "instruction": "Write a Emacs Lisp function `(defun absolute-value (n)` to solve the following problem: Function to calculate the absolute value of an integer.\n Args:\n   n: An integer whose absolute value is to be found. The absolute value of n should not exceed 10000.\n Returns:\n   The absolute value of n.\n Example Usage:\n (absolute-value -5) ; Returns 5\n (absolute-value 10) ; Returns 10\n (absolute-value 0)  ; Returns 0", "level": "easy"}
