{"task_id": "Perl/1", "prompt": "use strict;\nuse warnings;\n\nsub has_close_elements {\n# \"\"\"\n# Check if in given list of numbers, are any two numbers closer to each other than\n# given threshold.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True\n# \"\"\"", "canonical_solution": "my ($numbers, $threshold) = @_;\nfor (my $i = 0; $i <= $#$numbers; $i++) {\nfor (my $j = 0; $j <= $#$numbers; $j++) {\nif ($i != $j) {\nmy $distance = abs($numbers->[$i] - $numbers->[$j]);\nif ($distance < $threshold) {\nreturn 1;\n}\n}\n}\n}\nreturn 0;\n}", "test": "# Test cases\nsub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3);\ndie \"Test failed!\" if &$func([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05);\ndie \"Test failed!\" unless &$func([1.0, 2.0, 5.9, 4.0, 5.0], 0.95);\ndie \"Test failed!\" if &$func([1.0, 2.0, 5.9, 4.0, 5.0], 0.8);\ndie \"Test failed!\" unless &$func([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1);\ndie \"Test failed!\" unless &$func([1.1, 2.2, 3.1, 4.1, 5.1], 1.0);\ndie \"Test failed!\" if &$func([1.1, 2.2, 3.1, 4.1, 5.1], 0.5);\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&has_close_elements);", "entry_point": "has_close_elements", "signature": "sub has_close_elements {", "docstring": "\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Write a Perl function `sub has_close_elements {` to solve the following problem:\n\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "level": "easy"}
{"task_id": "Perl/2", "prompt": "use strict;\nuse warnings;\n\nsub transpose_matrix {\n# \"\"\"\n# Transpose a given two-dimensional integer array (matrix).\n# The transpose of a matrix is obtained by flipping a matrix over its main diagonal,\n# switching the matrix's row and column indices.\n# >>> transpose_matrix([[1, 2, 3], [4, 5, 6]])\n# [[1, 4], [2, 5], [3, 6]]\n# >>> transpose_matrix([[1, 2], [3, 4], [5, 6]])\n# [[1, 3, 5], [2, 4, 6]]\n# \"\"\"", "canonical_solution": "my $matrix = shift;\nmy $transposed = [];\nfor my $i (0 .. $#{$matrix->[0]}) {\nmy $row = [];\nforeach my $elem (@$matrix) {\npush @$row, $elem->[$i];\n}\npush @$transposed, $row;\n}\nreturn $transposed;\n}", "test": "sub check {\nmy $func = shift;\nuse Test::More tests => 4;\nis_deeply &$func([[1, 2, 3], [4, 5, 6]]), [[1, 4], [2, 5], [3, 6]], \"Test 1 passed!\";\nis_deeply &$func([[1, 2], [3, 4], [5, 6]]), [[1, 3, 5], [2, 4, 6]], \"Test 2 passed!\";\nis_deeply &$func([[1]]), [[1]], \"Test 3 passed!\";\nis_deeply &$func([[1, 2], [3, 4]]), [[1, 3], [2, 4]], \"Test 4 passed!\";\n}\n\ncheck(\\&transpose_matrix);", "entry_point": "transpose_matrix", "signature": "sub transpose_matrix {", "docstring": "\nTranspose a given two-dimensional integer array (matrix).\nThe transpose of a matrix is obtained by flipping a matrix over its main diagonal,\nswitching the matrix's row and column indices.\n>>> transpose_matrix([[1, 2, 3], [4, 5, 6]])\n[[1, 4], [2, 5], [3, 6]]\n>>> transpose_matrix([[1, 2], [3, 4], [5, 6]])\n[[1, 3, 5], [2, 4, 6]]\n", "instruction": "Write a Perl function `sub transpose_matrix {` to solve the following problem:\n\nTranspose a given two-dimensional integer array (matrix).\nThe transpose of a matrix is obtained by flipping a matrix over its main diagonal,\nswitching the matrix's row and column indices.\n>>> transpose_matrix([[1, 2, 3], [4, 5, 6]])\n[[1, 4], [2, 5], [3, 6]]\n>>> transpose_matrix([[1, 2], [3, 4], [5, 6]])\n[[1, 3, 5], [2, 4, 6]]\n", "level": "easy"}
{"task_id": "Perl/3", "prompt": "use strict;\nuse warnings;\n\nsub projection_area {\n# \"\"\"\n# Calculate the total area of projections on the xy, yz, and zx planes of a stack of cubes.\n# Each value v = grid[i][j] represents a stack of v cubes at cell (i, j).\n# The function returns the total area of all three projections.\n# >>> projection_area([[1,2],[3,4]])\n# 17\n# >>> projection_area([[2]])\n# 5\n# \"\"\"", "canonical_solution": "my ($grid) = @_;\nmy $xy_area = 0;\nmy $yz_area = 0;\nmy $zx_area = 0;\n\nfor my $i (0 .. $#$grid) {\nmy $max_row = 0;\nmy $max_col = 0;\nfor my $j (0 .. $#{$grid->[$i]}) {\n$xy_area += $grid->[$i][$j] > 0 ? 1 : 0; # Count non-zero cells for xy projection\n$max_row = $grid->[$i][$j] if $grid->[$i][$j] > $max_row;\n$max_col = $grid->[$j][$i] if $grid->[$j][$i] > $max_col;\n}\n$yz_area += $max_row;\n$zx_area += $max_col;\n}\nreturn $xy_area + $yz_area + $zx_area;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([[1,2],[3,4]]) == 17;\ndie \"Test failed!\" unless &$func([[2]]) == 5;\ndie \"Test failed!\" unless &$func([[1,0],[0,2]]) == 8;\ndie \"Test failed!\" unless &$func([[1,1,1],[1,0,1],[1,1,1]]) == 14;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&projection_area);", "entry_point": "projection_area", "signature": "sub projection_area {", "docstring": "\nCalculate the total area of projections on the xy, yz, and zx planes of a stack of cubes.\nEach value v = grid[i][j] represents a stack of v cubes at cell (i, j).\nThe function returns the total area of all three projections.\n>>> projection_area([[1,2],[3,4]])\n17\n>>> projection_area([[2]])\n5\n", "instruction": "Write a Perl function `sub projection_area {` to solve the following problem:\n\nCalculate the total area of projections on the xy, yz, and zx planes of a stack of cubes.\nEach value v = grid[i][j] represents a stack of v cubes at cell (i, j).\nThe function returns the total area of all three projections.\n>>> projection_area([[1,2],[3,4]])\n17\n>>> projection_area([[2]])\n5\n", "level": "hard"}
{"task_id": "Perl/4", "prompt": "use strict;\nuse warnings;\n\nsub find_candy_exchange {\n# \"\"\"\n# Find a pair of candy box sizes for Alice and Bob to exchange so they have an equal amount of candy.\n# aliceSizes and bobSizes are arrays representing the number of candies in each box they own.\n# The function returns an array [alice_candy, bob_candy] representing the number of candies in the boxes to be exchanged.\n# If there are multiple answers, any one of them can be returned.\n# >>> find_candy_exchange([1,1], [2,2])\n# [1, 2]\n# >>> find_candy_exchange([1,2,5], [2,4])\n# [5, 4]\n# \"\"\"", "canonical_solution": "my ($aliceSizes, $bobSizes) = @_;\nmy $aliceSum = 0;\nmy $bobSum = 0;\n\nforeach my $candy (@$aliceSizes) {\n$aliceSum += $candy;\n}\n\nforeach my $candy (@$bobSizes) {\n$bobSum += $candy;\n}\n\nmy $diff = $aliceSum - $bobSum;\nforeach my $aliceCandy (@$aliceSizes) {\nforeach my $bobCandy (@$bobSizes) {\nif (2 * ($aliceCandy - $bobCandy) == $diff) {\nreturn [$aliceCandy, $bobCandy];\n}\n}\n}\nreturn [];\n}", "test": "sub check {\nmy $func = shift;\nuse Test::More tests => 3;\nis_deeply &$func([1,1], [2,2]), [1, 2], \"Test 1 passed!\";\nis_deeply &$func([1,2,5], [2,4]), [5, 4], \"Test 2 passed!\";\nis_deeply &$func([2], [1,3]), [2, 3], \"Test 3 passed!\";\n}\n\ncheck(\\&find_candy_exchange);", "entry_point": "find_candy_exchange", "signature": "sub find_candy_exchange {", "docstring": "\nFind a pair of candy box sizes for Alice and Bob to exchange so they have an equal amount of candy.\naliceSizes and bobSizes are arrays representing the number of candies in each box they own.\nThe function returns an array [alice_candy, bob_candy] representing the number of candies in the boxes to be exchanged.\nIf there are multiple answers, any one of them can be returned.\n>>> find_candy_exchange([1,1], [2,2])\n[1, 2]\n>>> find_candy_exchange([1,2,5], [2,4])\n[5, 4]\n", "instruction": "Write a Perl function `sub find_candy_exchange {` to solve the following problem:\n\nFind a pair of candy box sizes for Alice and Bob to exchange so they have an equal amount of candy.\naliceSizes and bobSizes are arrays representing the number of candies in each box they own.\nThe function returns an array [alice_candy, bob_candy] representing the number of candies in the boxes to be exchanged.\nIf there are multiple answers, any one of them can be returned.\n>>> find_candy_exchange([1,1], [2,2])\n[1, 2]\n>>> find_candy_exchange([1,2,5], [2,4])\n[5, 4]\n", "level": "middle"}
{"task_id": "Perl/5", "prompt": "use strict;\nuse warnings;\n\nsub total_surface_area {\n# \"\"\"\n# Calculate the total surface area of irregular three-dimensional shapes formed by 1 x 1 x 1 cubes.\n# The value v = grid[i][j] represents v cubes stacked at cell (i, j).\n# The function returns the total surface area of these shapes, including the bottom area.\n# >>> total_surface_area([[2]])\n# 10\n# >>> total_surface_area([[1,2],[3,4]])\n# 34\n# \"\"\"", "canonical_solution": "my ($grid) = @_;\nmy $n = @$grid;\nmy $area = 0;\n\nfor my $i (0 .. $n - 1) {\nfor my $j (0 .. $n - 1) {\nnext if $grid->[$i][$j] == 0;\n$area += 4 * $grid->[$i][$j] + 2; # top and bottom + sides\n$area -= 2 * min($grid->[$i][$j], $grid->[$i - 1][$j]) if $i > 0; # subtract area shared with top neighbor\n$area -= 2 * min($grid->[$i][$j], $grid->[$i][$j - 1]) if $j > 0; # subtract area shared with left neighbor\n}\n}\n\nreturn $area;\n}\n\nsub min {\nmy ($x, $y) = @_;\nreturn $x < $y ? $x : $y;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([[2]]) == 10;\ndie \"Test failed!\" unless &$func([[1,2],[3,4]]) == 34;\ndie \"Test failed!\" unless &$func([[1,0],[0,2]]) == 16;\ndie \"Test failed!\" unless &$func([[1,1,1],[1,0,1],[1,1,1]]) == 32;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&total_surface_area);", "entry_point": "total_surface_area", "signature": "sub total_surface_area {", "docstring": "\nCalculate the total surface area of irregular three-dimensional shapes formed by 1 x 1 x 1 cubes.\nThe value v = grid[i][j] represents v cubes stacked at cell (i, j).\nThe function returns the total surface area of these shapes, including the bottom area.\n>>> total_surface_area([[2]])\n10\n>>> total_surface_area([[1,2],[3,4]])\n34\n", "instruction": "Write a Perl function `sub total_surface_area {` to solve the following problem:\n\nCalculate the total surface area of irregular three-dimensional shapes formed by 1 x 1 x 1 cubes.\nThe value v = grid[i][j] represents v cubes stacked at cell (i, j).\nThe function returns the total surface area of these shapes, including the bottom area.\n>>> total_surface_area([[2]])\n10\n>>> total_surface_area([[1,2],[3,4]])\n34\n", "level": "hard"}
{"task_id": "Perl/6", "prompt": "use strict;\nuse warnings;\n\nsub is_monotonic {\n# \"\"\"\n# Check if the array nums is monotonic.\n# An array is monotonic if it is either monotonically increasing or monotonically decreasing.\n# An array is monotonically increasing if for all i <= j, nums[i] <= nums[j].\n# An array is monotonically decreasing if for all i <= j, nums[i] >= nums[j].\n# >>> is_monotonic([1, 2, 2, 3])\n# True\n# >>> is_monotonic([6, 5, 4, 4])\n# True\n# >>> is_monotonic([1, 3, 2])\n# False\n# \"\"\"", "canonical_solution": "my ($nums) = @_;\nreturn 0 if @$nums < 1; # Arrays with less than 2 elements are trivially monotonic\n\nmy $increasing = 1;\nmy $decreasing = 1;\n\nfor (my $i = 1; $i < @$nums; $i++) {\n$increasing = 0 if $nums->[$i] < $nums->[$i - 1];\n$decreasing = 0 if $nums->[$i] > $nums->[$i - 1];\n}\n\nreturn $increasing || $decreasing;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([1, 2, 2, 3]);\ndie \"Test failed!\" unless &$func([6, 5, 4, 4]);\ndie \"Test failed!\" if &$func([1, 3, 2]);\ndie \"Test failed!\" unless &$func([10]);\ndie \"Test failed!\" unless &$func([5, 5, 5, 5]);\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&is_monotonic);", "entry_point": "is_monotonic", "signature": "sub is_monotonic {", "docstring": "\nCheck if the array nums is monotonic.\nAn array is monotonic if it is either monotonically increasing or monotonically decreasing.\nAn array is monotonically increasing if for all i <= j, nums[i] <= nums[j].\nAn array is monotonically decreasing if for all i <= j, nums[i] >= nums[j].\n>>> is_monotonic([1, 2, 2, 3])\nTrue\n>>> is_monotonic([6, 5, 4, 4])\nTrue\n>>> is_monotonic([1, 3, 2])\nFalse\n", "instruction": "Write a Perl function `sub is_monotonic {` to solve the following problem:\n\nCheck if the array nums is monotonic.\nAn array is monotonic if it is either monotonically increasing or monotonically decreasing.\nAn array is monotonically increasing if for all i <= j, nums[i] <= nums[j].\nAn array is monotonically decreasing if for all i <= j, nums[i] >= nums[j].\n>>> is_monotonic([1, 2, 2, 3])\nTrue\n>>> is_monotonic([6, 5, 4, 4])\nTrue\n>>> is_monotonic([1, 3, 2])\nFalse\n", "level": "middle"}
{"task_id": "Perl/7", "prompt": "use strict;\nuse warnings;\n\nsub rearrange_even_odd {\n# \"\"\"\n# Rearrange the array nums so that all even elements precede all odd elements.\n# Returns any array that satisfies this condition.\n# >>> rearrange_even_odd([3, 1, 2, 4])\n# [2, 4, 3, 1]\n# >>> rearrange_even_odd([0, 1, 2])\n# [0, 2, 1]\n# \"\"\"", "canonical_solution": "my ($nums) = @_;\nmy @even = grep { $_ % 2 == 0 } @$nums;\nmy @odd = grep { $_ % 2 != 0 } @$nums;\nreturn [@even, @odd];\n}", "test": "sub check {\nmy $func = shift;\nmy @result1 = @{$func->([3, 1, 2, 4])};\ndie \"Test failed!\" unless is_valid_result(\\@result1, [3, 1, 2, 4]);\n\nmy @result2 = @{$func->([0, 1, 2])};\ndie \"Test failed!\" unless is_valid_result(\\@result2, [0, 1, 2]);\n\nprint \"All tests passed!\\n\";\n}\n\nsub is_valid_result {\nmy ($result, $original) = @_;\nmy $evens = 0;\nmy $seen_odd = 0;\n\nforeach my $num (@$result) {\nif ($num % 2 == 0) {\ndie \"Odd number found after even numbers!\" if $seen_odd;\n$evens++;\n} else {\n$seen_odd = 1;\n}\n}\n\nreturn $seen_odd && $evens == scalar(grep { $_ % 2 == 0 } @$original);\n}\n\ncheck(\\&rearrange_even_odd);", "entry_point": "rearrange_even_odd", "signature": "sub rearrange_even_odd {", "docstring": "\nRearrange the array nums so that all even elements precede all odd elements.\nReturns any array that satisfies this condition.\n>>> rearrange_even_odd([3, 1, 2, 4])\n[2, 4, 3, 1]\n>>> rearrange_even_odd([0, 1, 2])\n[0, 2, 1]\n", "instruction": "Write a Perl function `sub rearrange_even_odd {` to solve the following problem:\n\nRearrange the array nums so that all even elements precede all odd elements.\nReturns any array that satisfies this condition.\n>>> rearrange_even_odd([3, 1, 2, 4])\n[2, 4, 3, 1]\n>>> rearrange_even_odd([0, 1, 2])\n[0, 2, 1]\n", "level": "easy"}
{"task_id": "Perl/8", "prompt": "use strict;\nuse warnings;\n\nsub can_divide_into_groups {\n# \"\"\"\n# Check if it's possible to divide a deck of cards into groups with the same number of cards,\n# where each group has the same integer, and the size of each group is at least 2.\n# >>> can_divide_into_groups([1,2,3,4,4,3,2,1])\n# True\n# >>> can_divide_into_groups([1,1,1,2,2,2,3,3])\n# False\n# \"\"\"", "canonical_solution": "my ($cards) = @_;\nmy %count;\n\n# Count the frequency of each number\nforeach my $card (@$cards) {\n$count{$card}++;\n}\n\nmy $group_size = 0;\nforeach my $freq (values %count) {\n$group_size = gcd($group_size, $freq);\n}\n\nreturn $group_size >= 2;\n}\n\n# Function to calculate gcd\nsub gcd {\nmy ($a, $b) = @_;\nreturn $b ? gcd($b, $a % $b) : $a;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([1,2,3,4,4,3,2,1]);\ndie \"Test failed!\" if &$func([1,1,1,2,2,2,3,3]);\ndie \"Test failed!\" unless &$func([1,1,2,2,2,2]);\ndie \"Test failed!\" if &$func([1]);\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&can_divide_into_groups);", "entry_point": "can_divide_into_groups", "signature": "sub can_divide_into_groups {", "docstring": "\nCheck if it's possible to divide a deck of cards into groups with the same number of cards,\nwhere each group has the same integer, and the size of each group is at least 2.\n>>> can_divide_into_groups([1,2,3,4,4,3,2,1])\nTrue\n>>> can_divide_into_groups([1,1,1,2,2,2,3,3])\nFalse\n", "instruction": "Write a Perl function `sub can_divide_into_groups {` to solve the following problem:\n\nCheck if it's possible to divide a deck of cards into groups with the same number of cards,\nwhere each group has the same integer, and the size of each group is at least 2.\n>>> can_divide_into_groups([1,2,3,4,4,3,2,1])\nTrue\n>>> can_divide_into_groups([1,1,1,2,2,2,3,3])\nFalse\n", "level": "middle"}
{"task_id": "Perl/9", "prompt": "use strict;\nuse warnings;\n\nsub sort_array_by_parity {\n# \"\"\"\n# Sort the array nums such that each odd element is at an odd index and each even element is at an even index.\n# Assumes nums contains an equal number of odd and even numbers.\n# >>> sort_array_by_parity([4, 2, 5, 7])\n# [4, 5, 2, 7]\n# >>> sort_array_by_parity([3, 1, 4, 2])\n# [4, 3, 2, 1]\n# \"\"\"", "canonical_solution": "my ($nums) = @_;\nmy @even = grep { $_ % 2 == 0 } @$nums;\nmy @odd = grep { $_ % 2 != 0 } @$nums;\nmy @sorted;\n\nfor (my $i = 0; $i < @$nums / 2; $i++) {\npush @sorted, $even[$i], $odd[$i];\n}\n\nreturn \\@sorted;\n}", "test": "sub check {\nmy $func = shift;\nmy @result1 = @{$func->([4, 2, 5, 7])};\ndie \"Test failed!\" unless is_valid_result(\\@result1);\n\nmy @result2 = @{$func->([3, 1, 4, 2])};\ndie \"Test failed!\" unless is_valid_result(\\@result2);\n\nprint \"All tests passed!\\n\";\n}\n\nsub is_valid_result {\nmy ($result) = @_;\nfor (my $i = 0; $i < @$result; $i++) {\nreturn 0 if $result->[$i] % 2 != $i % 2;\n}\nreturn 1;\n}\n\ncheck(\\&sort_array_by_parity);", "entry_point": "sort_array_by_parity", "signature": "sub sort_array_by_parity {", "docstring": "\nSort the array nums such that each odd element is at an odd index and each even element is at an even index.\nAssumes nums contains an equal number of odd and even numbers.\n>>> sort_array_by_parity([4, 2, 5, 7])\n[4, 5, 2, 7]\n>>> sort_array_by_parity([3, 1, 4, 2])\n[4, 3, 2, 1]\n", "instruction": "Write a Perl function `sub sort_array_by_parity {` to solve the following problem:\n\nSort the array nums such that each odd element is at an odd index and each even element is at an even index.\nAssumes nums contains an equal number of odd and even numbers.\n>>> sort_array_by_parity([4, 2, 5, 7])\n[4, 5, 2, 7]\n>>> sort_array_by_parity([3, 1, 4, 2])\n[4, 3, 2, 1]\n", "level": "easy"}
{"task_id": "Perl/10", "prompt": "use strict;\nuse warnings;\n\nsub is_mountain_array {\n# \"\"\"\n# Check if the array arr is a valid mountain array.\n# A mountain array is defined as an array that has at least three elements,\n# there exists some i with 0 < i < arr.length - 1 such that:\n# arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n# arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n# >>> is_mountain_array([0, 3, 2, 1])\n# True\n# >>> is_mountain_array([2, 1])\n# False\n# >>> is_mountain_array([3, 5, 5])\n# False\n# \"\"\"", "canonical_solution": "my ($arr) = @_;\nmy $n = @$arr;\nreturn 0 if $n < 3;\n\nmy $i = 0;\n\n# Walk up\n$i++ while ($i + 1 < $n && $arr->[$i] < $arr->[$i + 1]);\n\n# Peak can't be first or last\nreturn 0 if $i == 0 || $i == $n - 1;\n\n# Walk down\n$i++ while ($i + 1 < $n && $arr->[$i] > $arr->[$i + 1]);\n\nreturn $i == $n - 1;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([0, 3, 2, 1]);\ndie \"Test failed!\" if &$func([2, 1]);\ndie \"Test failed!\" if &$func([3, 5, 5]);\ndie \"Test failed!\" unless &$func([0, 2, 3, 4, 5, 2, 1, 0]);\ndie \"Test failed!\" if &$func([0, 2, 3, 3, 5, 2, 1, 0]);\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&is_mountain_array);", "entry_point": "is_mountain_array", "signature": "sub is_mountain_array {", "docstring": "\nCheck if the array arr is a valid mountain array.\nA mountain array is defined as an array that has at least three elements,\nthere exists some i with 0 < i < arr.length - 1 such that:\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n>>> is_mountain_array([0, 3, 2, 1])\nTrue\n>>> is_mountain_array([2, 1])\nFalse\n>>> is_mountain_array([3, 5, 5])\nFalse\n", "instruction": "Write a Perl function `sub is_mountain_array {` to solve the following problem:\n\nCheck if the array arr is a valid mountain array.\nA mountain array is defined as an array that has at least three elements,\nthere exists some i with 0 < i < arr.length - 1 such that:\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n>>> is_mountain_array([0, 3, 2, 1])\nTrue\n>>> is_mountain_array([2, 1])\nFalse\n>>> is_mountain_array([3, 5, 5])\nFalse\n", "level": "middle"}
{"task_id": "Perl/11", "prompt": "use strict;\nuse warnings;\n\nsub min_deletion_size {\n# \"\"\"\n# Count the number of columns that do not have non-strictly increasing order.\n# The grid is formed by an array of equal-length strings.\n# >>> min_deletion_size([\"abc\", \"bce\", \"cae\"])\n# 1\n# >>> min_deletion_size([\"cba\", \"daf\", \"ghi\"])\n# 1\n# >>> min_deletion_size([\"a\", \"b\"])\n# 0\n# \"\"\"", "canonical_solution": "my ($strs) = @_;\nmy $deletion_count = 0;\nmy $length = length $strs->[0];\n\nfor my $i (0 .. $length - 1) {\nfor my $j (0 .. @$strs - 2) {\nif (substr($strs->[$j], $i, 1) gt substr($strs->[$j + 1], $i, 1)) {\n$deletion_count++;\nlast;\n}\n}\n}\n\nreturn $deletion_count;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([\"abc\", \"bce\", \"cae\"]) == 1;\ndie \"Test failed!\" unless &$func([\"cba\", \"daf\", \"ghi\"]) == 1;\ndie \"Test failed!\" unless &$func([\"a\", \"b\"]) == 0;\ndie \"Test failed!\" unless &$func([\"zyx\", \"wvu\", \"tsr\"]) == 3;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&min_deletion_size);", "entry_point": "min_deletion_size", "signature": "sub min_deletion_size {", "docstring": "\nCount the number of columns that do not have non-strictly increasing order.\nThe grid is formed by an array of equal-length strings.\n>>> min_deletion_size([\"abc\", \"bce\", \"cae\"])\n1\n>>> min_deletion_size([\"cba\", \"daf\", \"ghi\"])\n1\n>>> min_deletion_size([\"a\", \"b\"])\n0\n", "instruction": "Write a Perl function `sub min_deletion_size {` to solve the following problem:\n\nCount the number of columns that do not have non-strictly increasing order.\nThe grid is formed by an array of equal-length strings.\n>>> min_deletion_size([\"abc\", \"bce\", \"cae\"])\n1\n>>> min_deletion_size([\"cba\", \"daf\", \"ghi\"])\n1\n>>> min_deletion_size([\"a\", \"b\"])\n0\n", "level": "easy"}
{"task_id": "Perl/12", "prompt": "use strict;\nuse warnings;\n\nsub is_alien_sorted {\n# \"\"\"\n# Check if the words are sorted according to the alien language order.\n# The order of the alphabet in the alien language is given by the string 'order'.\n# >>> is_alien_sorted([\"hello\", \"leetcode\"], \"hlabcdefgijkmnopqrstuvwxyz\")\n# True\n# >>> is_alien_sorted([\"word\", \"world\", \"row\"], \"worldabcefghijkmnpqstuvxyz\")\n# False\n# >>> is_alien_sorted([\"apple\", \"app\"], \"abcdefghijklmnopqrstuvwxyz\")\n# False\n# \"\"\"", "canonical_solution": "my ($words, $order) = @_;\nmy %order_map;\n\nfor my $i (0 .. length($order) - 1) {\n$order_map{substr($order, $i, 1)} = $i;\n}\n\nfor my $i (0 .. @$words - 2) {\nreturn 0 unless in_alien_order($words->[$i], $words->[$i + 1], \\%order_map);\n}\n\nreturn 1;\n}\n\nsub in_alien_order {\nmy ($word1, $word2, $order_map) = @_;\nmy $len = length($word1) < length($word2) ? length($word1) : length($word2);\n\nfor my $i (0 .. $len - 1) {\nmy $char1 = substr($word1, $i, 1);\nmy $char2 = substr($word2, $i, 1);\n\nif ($order_map->{$char1} < $order_map->{$char2}) {\nreturn 1;\n} elsif ($order_map->{$char1} > $order_map->{$char2}) {\nreturn 0;\n}\n}\n\nreturn length($word1) <= length($word2);\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([\"hello\", \"leetcode\"], \"hlabcdefgijkmnopqrstuvwxyz\");\ndie \"Test failed!\" if &$func([\"word\", \"world\", \"row\"], \"worldabcefghijkmnpqstuvxyz\");\ndie \"Test failed!\" if &$func([\"apple\", \"app\"], \"abcdefghijklmnopqrstuvwxyz\");\ndie \"Test failed!\" unless &$func([\"apple\"], \"abcdefghijklmnopqrstuvwxyz\");\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&is_alien_sorted);", "entry_point": "is_alien_sorted", "signature": "sub is_alien_sorted {", "docstring": "\nCheck if the words are sorted according to the alien language order.\nThe order of the alphabet in the alien language is given by the string 'order'.\n>>> is_alien_sorted([\"hello\", \"leetcode\"], \"hlabcdefgijkmnopqrstuvwxyz\")\nTrue\n>>> is_alien_sorted([\"word\", \"world\", \"row\"], \"worldabcefghijkmnpqstuvxyz\")\nFalse\n>>> is_alien_sorted([\"apple\", \"app\"], \"abcdefghijklmnopqrstuvwxyz\")\nFalse\n", "instruction": "Write a Perl function `sub is_alien_sorted {` to solve the following problem:\n\nCheck if the words are sorted according to the alien language order.\nThe order of the alphabet in the alien language is given by the string 'order'.\n>>> is_alien_sorted([\"hello\", \"leetcode\"], \"hlabcdefgijkmnopqrstuvwxyz\")\nTrue\n>>> is_alien_sorted([\"word\", \"world\", \"row\"], \"worldabcefghijkmnpqstuvxyz\")\nFalse\n>>> is_alien_sorted([\"apple\", \"app\"], \"abcdefghijklmnopqrstuvwxyz\")\nFalse\n", "level": "middle"}
{"task_id": "Perl/13", "prompt": "use strict;\nuse warnings;\n\nsub find_repeated_element {\n# \"\"\"\n# Find the element that repeats n times in the array nums.\n# The array nums has a length of 2 * n and contains n + 1 unique elements.\n# >>> find_repeated_element([1,2,3,3])\n# 3\n# >>> find_repeated_element([2,1,2,5,3,2])\n# 2\n# >>> find_repeated_element([5,1,5,2,5,3,5,4])\n# 5\n# \"\"\"", "canonical_solution": "my ($nums) = @_;\nmy %count;\n\nforeach my $num (@$nums) {\n$count{$num}++;\nreturn $num if $count{$num} > 1;\n}\n\ndie \"No element found that repeats n times\";\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([1,2,3,3]) == 3;\ndie \"Test failed!\" unless &$func([2,1,2,5,3,2]) == 2;\ndie \"Test failed!\" unless &$func([5,1,5,2,5,3,5,4]) == 5;\ndie \"Test failed!\" unless &$func([10,9,10]) == 10;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&find_repeated_element);", "entry_point": "find_repeated_element", "signature": "sub find_repeated_element {", "docstring": "\nFind the element that repeats n times in the array nums.\nThe array nums has a length of 2 * n and contains n + 1 unique elements.\n>>> find_repeated_element([1,2,3,3])\n3\n>>> find_repeated_element([2,1,2,5,3,2])\n2\n>>> find_repeated_element([5,1,5,2,5,3,5,4])\n5\n", "instruction": "Write a Perl function `sub find_repeated_element {` to solve the following problem:\n\nFind the element that repeats n times in the array nums.\nThe array nums has a length of 2 * n and contains n + 1 unique elements.\n>>> find_repeated_element([1,2,3,3])\n3\n>>> find_repeated_element([2,1,2,5,3,2])\n2\n>>> find_repeated_element([5,1,5,2,5,3,5,4])\n5\n", "level": "easy"}
{"task_id": "Perl/14", "prompt": "use strict;\nuse warnings;\n\nsub max_triangle_perimeter {\n# \"\"\"\n# Return the maximum perimeter of a non-degenerate triangle formed from the array nums.\n# If no non-degenerate triangle can be formed, return 0.\n# >>> max_triangle_perimeter([2, 1, 2])\n# 5\n# >>> max_triangle_perimeter([1, 2, 1])\n# 0\n# >>> max_triangle_perimeter([3, 2, 3, 4])\n# 10\n# \"\"\"", "canonical_solution": "my ($nums) = @_;\nmy $max_perimeter = 0;\n\n# Sort the array in descending order\nmy @sorted_nums = sort { $b <=> $a } @$nums;\n\nfor (my $i = 0; $i < @sorted_nums - 2; $i++) {\nif ($sorted_nums[$i] < $sorted_nums[$i + 1] + $sorted_nums[$i + 2]) {\n$max_perimeter = $sorted_nums[$i] + $sorted_nums[$i + 1] + $sorted_nums[$i + 2];\nlast;\n}\n}\n\nreturn $max_perimeter;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([2, 1, 2]) == 5;\ndie \"Test failed!\" if &$func([1, 2, 1]) != 0;\ndie \"Test failed!\" unless &$func([3, 2, 3, 4]) == 10;\ndie \"Test failed!\" unless &$func([3, 6, 2, 3]) == 8;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&max_triangle_perimeter);", "entry_point": "max_triangle_perimeter", "signature": "sub max_triangle_perimeter {", "docstring": "\nReturn the maximum perimeter of a non-degenerate triangle formed from the array nums.\nIf no non-degenerate triangle can be formed, return 0.\n>>> max_triangle_perimeter([2, 1, 2])\n5\n>>> max_triangle_perimeter([1, 2, 1])\n0\n>>> max_triangle_perimeter([3, 2, 3, 4])\n10\n", "instruction": "Write a Perl function `sub max_triangle_perimeter {` to solve the following problem:\n\nReturn the maximum perimeter of a non-degenerate triangle formed from the array nums.\nIf no non-degenerate triangle can be formed, return 0.\n>>> max_triangle_perimeter([2, 1, 2])\n5\n>>> max_triangle_perimeter([1, 2, 1])\n0\n>>> max_triangle_perimeter([3, 2, 3, 4])\n10\n", "level": "middle"}
{"task_id": "Perl/15", "prompt": "use strict;\nuse warnings;\n\nsub sorted_squares {\n# \"\"\"\n# Return a new array that is the squares of each element in the non-decreasingly sorted array nums,\n# also sorted in non-decreasing order.\n# >>> sorted_squares([-4, -1, 0, 3, 10])\n# [0, 1, 9, 16, 100]\n# >>> sorted_squares([-7, -3, 2, 3, 11])\n# [4, 9, 9, 49, 121]\n# \"\"\"", "canonical_solution": "my ($nums) = @_;\nreturn [sort { $a <=> $b } map { $_ * $_ } @$nums];\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless join(',', @{$func->([-4, -1, 0, 3, 10])}) eq '0,1,9,16,100';\ndie \"Test failed!\" unless join(',', @{$func->([-7, -3, 2, 3, 11])}) eq '4,9,9,49,121';\ndie \"Test failed!\" unless join(',', @{$func->([1, 2, 3, 4])}) eq '1,4,9,16';\ndie \"Test failed!\" unless join(',', @{$func->([-1, 0, 1])}) eq '0,1,1';\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&sorted_squares);", "entry_point": "sorted_squares", "signature": "sub sorted_squares {", "docstring": "\nReturn a new array that is the squares of each element in the non-decreasingly sorted array nums,\nalso sorted in non-decreasing order.\n>>> sorted_squares([-4, -1, 0, 3, 10])\n[0, 1, 9, 16, 100]\n>>> sorted_squares([-7, -3, 2, 3, 11])\n[4, 9, 9, 49, 121]\n", "instruction": "Write a Perl function `sub sorted_squares {` to solve the following problem:\n\nReturn a new array that is the squares of each element in the non-decreasingly sorted array nums,\nalso sorted in non-decreasing order.\n>>> sorted_squares([-4, -1, 0, 3, 10])\n[0, 1, 9, 16, 100]\n>>> sorted_squares([-7, -3, 2, 3, 11])\n[4, 9, 9, 49, 121]\n", "level": "easy"}
{"task_id": "Perl/16", "prompt": "use strict;\nuse warnings;\n\nsub reverse_output {\n# \"\"\"\n# Read a list of strings and output them in reverse order.\n# >>> reverse_output([\"hello\", \"world\", \"Perl\"])\n# Perl\n# world\n# hello\n# \"\"\"", "canonical_solution": "my ($strings) = @_;\nreturn reverse @$strings;\n}", "test": "sub check {\nmy $func = shift;\nmy @test1 = $func->([\"hello\", \"world\", \"Perl\"]);\ndie \"Test failed!\" unless join(',', @test1) eq 'Perl,world,hello';\n\nmy @test2 = $func->([\"line1\", \"line2\", \"line3\", \"line4\"]);\ndie \"Test failed!\" unless join(',', @test2) eq 'line4,line3,line2,line1';\n\nmy @test3 = $func->([\"one string\"]);\ndie \"Test failed!\" unless join(',', @test3) eq 'one string';\n\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&reverse_output);", "entry_point": "reverse_output", "signature": "sub reverse_output {", "docstring": "\nRead a list of strings and output them in reverse order.\n>>> reverse_output([\"hello\", \"world\", \"Perl\"])\nPerl\nworld\nhello\n", "instruction": "Write a Perl function `sub reverse_output {` to solve the following problem:\n\nRead a list of strings and output them in reverse order.\n>>> reverse_output([\"hello\", \"world\", \"Perl\"])\nPerl\nworld\nhello\n", "level": "easy"}
{"task_id": "Perl/17", "prompt": "use strict;\nuse warnings;\n\nsub numbers_above_average {\n# \"\"\"\n# Return all numbers in the array that are greater than the average of the array.\n# >>> numbers_above_average([1, 2, 3, 4, 5])\n# [4, 5]\n# >>> numbers_above_average([10, 20, 30, 40, 50])\n# [40, 50]\n# >>> numbers_above_average([1, 1, 1, 1, 10])\n# [10]\n# \"\"\"", "canonical_solution": "my ($numbers) = @_;\nmy $sum = 0;\nmy $count = @$numbers;\n\nforeach my $num (@$numbers) {\n$sum += $num;\n}\n\nmy $average = $sum / $count;\nreturn [grep { $_ > $average } @$numbers];\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless join(',', @{$func->([1, 2, 3, 4, 5])}) eq '4,5';\ndie \"Test failed!\" unless join(',', @{$func->([10, 20, 30, 40, 50])}) eq '40,50';\ndie \"Test failed!\" unless join(',', @{$func->([1, 1, 1, 1, 10])}) eq '10';\ndie \"Test failed!\" unless join(',', @{$func->([15, 15, 15, 15, 15])}) eq '';\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&numbers_above_average);", "entry_point": "numbers_above_average", "signature": "sub numbers_above_average {", "docstring": "\nReturn all numbers in the array that are greater than the average of the array.\n>>> numbers_above_average([1, 2, 3, 4, 5])\n[4, 5]\n>>> numbers_above_average([10, 20, 30, 40, 50])\n[40, 50]\n>>> numbers_above_average([1, 1, 1, 1, 10])\n[10]\n", "instruction": "Write a Perl function `sub numbers_above_average {` to solve the following problem:\n\nReturn all numbers in the array that are greater than the average of the array.\n>>> numbers_above_average([1, 2, 3, 4, 5])\n[4, 5]\n>>> numbers_above_average([10, 20, 30, 40, 50])\n[40, 50]\n>>> numbers_above_average([1, 1, 1, 1, 10])\n[10]\n", "level": "easy"}
{"task_id": "Perl/18", "prompt": "use strict;\nuse warnings;\n\nsub add_to_array_form {\n# \"\"\"\n# Add an integer k to a number represented in its array form num.\n# >>> add_to_array_form([1, 3, 2, 1], 9)\n# [1, 3, 3, 0]\n# >>> add_to_array_form([2, 7, 4], 181)\n# [4, 5, 5]\n# >>> add_to_array_form([9, 9, 9, 9, 9, 9, 9, 9, 9, 9], 1)\n# [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n# \"\"\"", "canonical_solution": "my ($num, $k) = @_;\nmy $i = @$num - 1;\nmy @result;\n\nwhile ($i >= 0 || $k > 0) {\nif ($i >= 0) {\n$k += $num->[$i];\n}\nunshift @result, $k % 10;\n$k = int($k / 10);\n$i--;\n}\n\nreturn \\@result;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless join(',', @{$func->([1, 3, 2, 1], 9)}) eq '1,3,3,0';\ndie \"Test failed!\" unless join(',', @{$func->([2, 7, 4], 181)}) eq '4,5,5';\ndie \"Test failed!\" unless join(',', @{$func->([9, 9, 9, 9, 9, 9, 9, 9, 9, 9], 1)}) eq '1,0,0,0,0,0,0,0,0,0,0';\ndie \"Test failed!\" unless join(',', @{$func->([0], 23)}) eq '2,3';\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&add_to_array_form);", "entry_point": "add_to_array_form", "signature": "sub add_to_array_form {", "docstring": "\nAdd an integer k to a number represented in its array form num.\n>>> add_to_array_form([1, 3, 2, 1], 9)\n[1, 3, 3, 0]\n>>> add_to_array_form([2, 7, 4], 181)\n[4, 5, 5]\n>>> add_to_array_form([9, 9, 9, 9, 9, 9, 9, 9, 9, 9], 1)\n[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n", "instruction": "Write a Perl function `sub add_to_array_form {` to solve the following problem:\n\nAdd an integer k to a number represented in its array form num.\n>>> add_to_array_form([1, 3, 2, 1], 9)\n[1, 3, 3, 0]\n>>> add_to_array_form([2, 7, 4], 181)\n[4, 5, 5]\n>>> add_to_array_form([9, 9, 9, 9, 9, 9, 9, 9, 9, 9], 1)\n[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n", "level": "easy"}
{"task_id": "Perl/19", "prompt": "use strict;\nuse warnings;\n\nsub find_town_judge {\n# \"\"\"\n# Find the town judge's number if they exist, following the rules:\n# 1. The town judge does not trust anyone.\n# 2. Everybody (except for the town judge) trusts the town judge.\n# 3. There is only one person that satisfies both conditions.\n# The trust array contains pairs [ai, bi] where ai trusts bi.\n# >>> find_town_judge(3, [[1, 3], [2, 3]])\n# 3\n# >>> find_town_judge(3, [[1, 3], [2, 3], [3, 1]])\n# -1\n# >>> find_town_judge(3, [[1, 2], [2, 3]])\n# -1\n# \"\"\"", "canonical_solution": "my ($n, $trust) = @_;\nmy %trusts;\nmy %trusted_by;\n\nforeach my $pair (@$trust) {\n$trusts{$pair->[0]}++;\n$trusted_by{$pair->[1]}++;\n}\n\nforeach my $person (1..$n) {\nif (!$trusts{$person} && ($trusted_by{$person} // 0) == $n - 1) {\nreturn $person;\n}\n}\n\nreturn -1;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func(3, [[1, 3], [2, 3]]) == 3;\ndie \"Test failed!\" if &$func(3, [[1, 3], [2, 3], [3, 1]]) != -1;\ndie \"Test failed!\" if &$func(3, [[1, 2], [2, 3]]) != -1;\ndie \"Test failed!\" unless &$func(4, [[1, 3], [1, 4], [2, 3], [2, 4], [4, 3]]) == 3;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&find_town_judge);", "entry_point": "find_town_judge", "signature": "sub find_town_judge {", "docstring": "\nFind the town judge's number if they exist, following the rules:\n1. The town judge does not trust anyone.\n2. Everybody (except for the town judge) trusts the town judge.\n3. There is only one person that satisfies both conditions.\nThe trust array contains pairs [ai, bi] where ai trusts bi.\n>>> find_town_judge(3, [[1, 3], [2, 3]])\n3\n>>> find_town_judge(3, [[1, 3], [2, 3], [3, 1]])\n-1\n>>> find_town_judge(3, [[1, 2], [2, 3]])\n-1\n", "instruction": "Write a Perl function `sub find_town_judge {` to solve the following problem:\n\nFind the town judge's number if they exist, following the rules:\n1. The town judge does not trust anyone.\n2. Everybody (except for the town judge) trusts the town judge.\n3. There is only one person that satisfies both conditions.\nThe trust array contains pairs [ai, bi] where ai trusts bi.\n>>> find_town_judge(3, [[1, 3], [2, 3]])\n3\n>>> find_town_judge(3, [[1, 3], [2, 3], [3, 1]])\n-1\n>>> find_town_judge(3, [[1, 2], [2, 3]])\n-1\n", "level": "easy"}
{"task_id": "Perl/20", "prompt": "use strict;\nuse warnings;\n\nsub extract_numbers {\n# \"\"\"\n# Extract all numbers from a given string.\n# >>> extract_numbers(\"The room numbers are 12, 34, and 56.\")\n# [12, 34, 56]\n# >>> extract_numbers(\"No numbers here!\")\n# []\n# >>> extract_numbers(\"Version 2.0.1\")\n# [2, 0, 1]\n# \"\"\"", "canonical_solution": "my ($string) = @_;\nmy @numbers = $string =~ /(\\d+)/g;\nreturn \\@numbers;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless join(',', @{$func->(\"The room numbers are 12, 34, and 56.\")}) eq '12,34,56';\ndie \"Test failed!\" unless join(',', @{$func->(\"No numbers here!\")}) eq '';\ndie \"Test failed!\" unless join(',', @{$func->(\"Version 2.0.1\")}) eq '2,0,1';\ndie \"Test failed!\" unless join(',', @{$func->(\"100 ways to code 101\")}) eq '100,101';\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&extract_numbers);", "entry_point": "extract_numbers", "signature": "sub extract_numbers {", "docstring": "\nExtract all numbers from a given string.\n>>> extract_numbers(\"The room numbers are 12, 34, and 56.\")\n[12, 34, 56]\n>>> extract_numbers(\"No numbers here!\")\n[]\n>>> extract_numbers(\"Version 2.0.1\")\n[2, 0, 1]\n", "instruction": "Write a Perl function `sub extract_numbers {` to solve the following problem:\n\nExtract all numbers from a given string.\n>>> extract_numbers(\"The room numbers are 12, 34, and 56.\")\n[12, 34, 56]\n>>> extract_numbers(\"No numbers here!\")\n[]\n>>> extract_numbers(\"Version 2.0.1\")\n[2, 0, 1]\n", "level": "easy"}
{"task_id": "Perl/21", "prompt": "use strict;\nuse warnings;\n\nsub find_substring_index {\n\n# Given two strings, haystack and needle, return the index of the first occurrence of needle in haystack.\n# If needle is not part of haystack, return -1.\n# >>> find_substring_index(\"hellothere\", \"there\")\n# 5\n# >>> find_substring_index(\"justatest\", \"test\")\n# 5\n# >>> find_substring_index(\"nonesuch\", \"none\")\n# 0\n# >>> find_substring_index(\"nonesuch\", \"such\")\n# 4\n# >>> find_substring_index(\"nonesuch\", \"nope\")\n# -1", "canonical_solution": "my ($haystack, $needle) = @_;\nmy $index = index($haystack, $needle);\nreturn $index;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test 1 failed!\" unless &$func(\"hellothere\", \"there\") == 5;\ndie \"Test 2 failed!\" unless &$func(\"justatest\", \"test\") == 5;\ndie \"Test 3 failed!\" unless &$func(\"nonesuch\", \"none\") == 0;\ndie \"Test 4 failed!\" unless &$func(\"nonesuch\", \"such\") == 4;\ndie \"Test 5 failed!\" unless &$func(\"nonesuch\", \"nope\") == -1;\nprint \"All tests passed!\";\n}\n\ncheck(\\&find_substring_index);", "entry_point": "find_substring_index", "signature": "sub find_substring_index {", "docstring": "Given two strings, haystack and needle, return the index of the first occurrence of needle in haystack.\nIf needle is not part of haystack, return -1.\n>>> find_substring_index(\"hellothere\", \"there\")\n5\n>>> find_substring_index(\"justatest\", \"test\")\n5\n>>> find_substring_index(\"nonesuch\", \"none\")\n0\n>>> find_substring_index(\"nonesuch\", \"such\")\n4\n>>> find_substring_index(\"nonesuch\", \"nope\")\n-1", "instruction": "Write a Perl function `sub find_substring_index {` to solve the following problem:\nGiven two strings, haystack and needle, return the index of the first occurrence of needle in haystack.\nIf needle is not part of haystack, return -1.\n>>> find_substring_index(\"hellothere\", \"there\")\n5\n>>> find_substring_index(\"justatest\", \"test\")\n5\n>>> find_substring_index(\"nonesuch\", \"none\")\n0\n>>> find_substring_index(\"nonesuch\", \"such\")\n4\n>>> find_substring_index(\"nonesuch\", \"nope\")\n-1", "level": "middle"}
{"task_id": "Perl/22", "prompt": "use strict;\nuse warnings;\n\nsub find_min_n {\n\n\n\n# Given an integer k, find the smallest integer n such that the sum of the series\n# S_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than k.\n# >>> find_min_n(2)\n# 4\n# >>> find_min_n(3)\n# 11", "canonical_solution": "my ($k) = @_;\nmy $sum = 0;\nmy $n = 0;\nwhile ($sum <= $k) {\n$n++;\n$sum += 1/$n;\n}\nreturn $n;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func(2) == 4;\ndie \"Test failed!\" unless &$func(3) == 11;\ndie \"Test failed!\" unless &$func(0) == 1;\ndie \"Test failed!\" unless &$func(1) == 2;\ndie \"Test failed!\" unless &$func(4) == 31;\ndie \"Test failed!\" unless &$func(5) == 83;\nprint \"All tests passed!\";\n}\n\ncheck(\\&find_min_n);", "entry_point": "find_min_n", "signature": "sub find_min_n {", "docstring": "Given an integer k, find the smallest integer n such that the sum of the series\nS_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than k.\n>>> find_min_n(2)\n4\n>>> find_min_n(3)\n11", "instruction": "Write a Perl function `sub find_min_n {` to solve the following problem:\nGiven an integer k, find the smallest integer n such that the sum of the series\nS_n = 1 + 1/2 + 1/3 + ... + 1/n is greater than k.\n>>> find_min_n(2)\n4\n>>> find_min_n(3)\n11", "level": "easy"}
{"task_id": "Perl/23", "prompt": "use strict;\nuse warnings;\n\nsub count_apples {\n\n\n\n# TaoTao is trying to pick apples from a tree. There are 10 apples on the tree, each at a different height from the ground.\n# TaoTao can reach a certain height. If she can't reach an apple, she can stand on a 30cm high stool to try to reach it.\n# Given the heights of the apples and the maximum height TaoTao can reach, calculate how many apples she can pick.\n# >>> count_apples([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 120)\n# 6", "canonical_solution": "my ($apple_heights, $taotao_height) = @_;\nmy $count = 0;\nforeach my $apple_height (@$apple_heights) {\nif ($apple_height <= $taotao_height + 30) {\n$count++;\n}\n}\nreturn $count;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 130) == 6;\ndie \"Test failed!\" unless &$func([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 120) == 6;\ndie \"Test failed!\" unless &$func([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) == 5;\n}\ncheck(\\&count_apples);", "entry_point": "count_apples", "signature": "sub count_apples {", "docstring": "TaoTao is trying to pick apples from a tree. There are 10 apples on the tree, each at a different height from the ground.\nTaoTao can reach a certain height. If she can't reach an apple, she can stand on a 30cm high stool to try to reach it.\nGiven the heights of the apples and the maximum height TaoTao can reach, calculate how many apples she can pick.\n>>> count_apples([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 120)\n6", "instruction": "Write a Perl function `sub count_apples {` to solve the following problem:\nTaoTao is trying to pick apples from a tree. There are 10 apples on the tree, each at a different height from the ground.\nTaoTao can reach a certain height. If she can't reach an apple, she can stand on a 30cm high stool to try to reach it.\nGiven the heights of the apples and the maximum height TaoTao can reach, calculate how many apples she can pick.\n>>> count_apples([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 120)\n6", "level": "easy"}
{"task_id": "Perl/24", "prompt": "use strict;\nuse warnings;\n\nsub remaining_trees {\n\n# Given the length of a road and a list of regions where trees need to be removed, \n# this function calculates the number of trees remaining on the road after the removal.\n# Each region is represented by a pair of integers indicating the start and end points.\n# The road is represented as a number line with trees at every integer point.\n# The function returns the number of trees remaining after the removal.\n# >>> remaining_trees(1000, [[200, 300], [400, 500], [600, 700]])\n# 698\n# >>> remaining_trees(500, [[100, 200], [300, 400]])\n# 299", "canonical_solution": "my ($length, $regions) = @_;\nmy @road = (1) x ($length + 1);\nforeach my $region (@$regions) {\nmy ($start, $end) = @$region;\nfor (my $i = $start; $i <= $end; $i++) {\n$road[$i] = 0;\n}\n}\nmy $remaining = 0;\nforeach my $tree (@road) {\n$remaining += $tree;\n}\nreturn $remaining;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func(1000, [[200, 300], [400, 500], [600, 700]]) == 698;\ndie \"Test failed!\" unless &$func(500, [[100, 200], [300, 400]]) == 299;\ndie \"Test failed!\" unless &$func(100, [[20, 30], [40, 50], [60, 70]]) == 68;\ndie \"Test failed!\" unless &$func(50, [[10, 20], [30, 40]]) == 29;\ndie \"Test failed!\" unless &$func(1000, [[200, 300], [400, 500], [600, 700], [800, 900]]) == 597;\nprint \"All tests passed\";\n}\n\ncheck(\\&remaining_trees);", "entry_point": "remaining_trees", "signature": "sub remaining_trees {", "docstring": "Given the length of a road and a list of regions where trees need to be removed, \nthis function calculates the number of trees remaining on the road after the removal.\nEach region is represented by a pair of integers indicating the start and end points.\nThe road is represented as a number line with trees at every integer point.\nThe function returns the number of trees remaining after the removal.\n>>> remaining_trees(1000, [[200, 300], [400, 500], [600, 700]])\n698\n>>> remaining_trees(500, [[100, 200], [300, 400]])\n299", "instruction": "Write a Perl function `sub remaining_trees {` to solve the following problem:\nGiven the length of a road and a list of regions where trees need to be removed, \nthis function calculates the number of trees remaining on the road after the removal.\nEach region is represented by a pair of integers indicating the start and end points.\nThe road is represented as a number line with trees at every integer point.\nThe function returns the number of trees remaining after the removal.\n>>> remaining_trees(1000, [[200, 300], [400, 500], [600, 700]])\n698\n>>> remaining_trees(500, [[100, 200], [300, 400]])\n299", "level": "hard"}
{"task_id": "Perl/25", "prompt": "use strict;\nuse warnings;\n\nsub find_larger_prime_factor {\n\n# Given a positive integer n which is the product of two distinct prime numbers, \n# find the larger of the two prime numbers.\n# >>> find_larger_prime_factor(15)\n# 5\n# >>> find_larger_prime_factor(33)\n# 11", "canonical_solution": "my ($n) = @_;\nfor (my $i = 2; $i * $i <= $n; $i++) {\nif ($n % $i == 0) {\nwhile ($n % $i == 0) {\n$n = $n / $i;\n}\n}\n}\nreturn $n;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func(35) == 7;\ndie \"Test failed!\" unless &$func(77) == 11;\ndie \"Test failed!\" unless &$func(91) == 13;\ndie \"Test failed!\" unless &$func(143) == 13;\ndie \"Test failed!\" unless &$func(221) == 17;\ndie \"Test failed!\" unless &$func(323) == 19;\nprint \"All tests passed!\";\n}\n\ncheck(\\&find_larger_prime_factor);", "entry_point": "find_larger_prime_factor", "signature": "sub find_larger_prime_factor {", "docstring": "Given a positive integer n which is the product of two distinct prime numbers, \nfind the larger of the two prime numbers.\n>>> find_larger_prime_factor(15)\n5\n>>> find_larger_prime_factor(33)\n11", "instruction": "Write a Perl function `sub find_larger_prime_factor {` to solve the following problem:\nGiven a positive integer n which is the product of two distinct prime numbers, \nfind the larger of the two prime numbers.\n>>> find_larger_prime_factor(15)\n5\n>>> find_larger_prime_factor(33)\n11", "level": "easy"}
{"task_id": "Perl/26", "prompt": "use strict;\n\nsub calculate_mod_power {\n# \"\"\"\n# Calculates a^b mod p, where a, b, and p are integers.\n# It computes the power of a raised to b and then takes the modulus with p.\n#\n# Args:\n# a (int): The base.\n# b (int): The exponent.\n# p (int): The modulus.\n#\n# Returns:\n# string: A string representation of the equation a^b mod p=s, where s is the result.\n#\n# Examples:\n# >>> calculate_mod_power(3, 4, 5)\n# \"3^4 mod 5=1\"\n# >>> calculate_mod_power(7, 2, 10)\n# \"7^2 mod 10=9\"\n# \"\"\"", "canonical_solution": "my ($a, $b, $p) = @_;\nmy $result = 1;\n\nfor (my $i = 0; $i < $b; $i++) {\n$result = ($result * $a) % $p;\n}\n\nreturn \"$a^$b mod $p=$result\";\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func(3, 4, 5) eq \"3^4 mod 5=1\";\ndie \"Test failed!\" unless &$func(7, 2, 10) eq \"7^2 mod 10=9\";\ndie \"Test failed!\" unless &$func(5, 3, 6) eq \"5^3 mod 6=5\";\ndie \"Test failed!\" unless &$func(10, 2, 9) eq \"10^2 mod 9=1\";\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&calculate_mod_power);", "entry_point": "calculate_mod_power", "signature": "sub calculate_mod_power {", "docstring": "\nCalculates a^b mod p, where a, b, and p are integers.\nIt computes the power of a raised to b and then takes the modulus with p.\n\nArgs:\na (int): The base.\nb (int): The exponent.\np (int): The modulus.\n\nReturns:\nstring: A string representation of the equation a^b mod p=s, where s is the result.\n\nExamples:\n>>> calculate_mod_power(3, 4, 5)\n\"3^4 mod 5=1\"\n>>> calculate_mod_power(7, 2, 10)\n\"7^2 mod 10=9\"\n", "instruction": "Write a Perl function `sub calculate_mod_power {` to solve the following problem:\n\nCalculates a^b mod p, where a, b, and p are integers.\nIt computes the power of a raised to b and then takes the modulus with p.\n\nArgs:\na (int): The base.\nb (int): The exponent.\np (int): The modulus.\n\nReturns:\nstring: A string representation of the equation a^b mod p=s, where s is the result.\n\nExamples:\n>>> calculate_mod_power(3, 4, 5)\n\"3^4 mod 5=1\"\n>>> calculate_mod_power(7, 2, 10)\n\"7^2 mod 10=9\"\n", "level": "easy"}
{"task_id": "Perl/27", "prompt": "use strict;\nuse warnings;\n\nsub count_close_competitors {\nmy ($students_scores) = @_;\n# \"\"\"\n# Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points,\n# and whose total score difference is no more than 10 points.\n# Each student's scores are provided as a tuple (Chinese, Mathematics, English).\n# \n# Args:\n# students_scores (Array of ArrayRefs): An array where each element is an array reference containing three scores for a student.\n# \n# Returns:\n# int: The number of student pairs who are close competitors.\n# \n# Examples:\n# >>> count_close_competitors([[90, 85, 90], [95, 90, 95], [88, 90, 87]])\n# 1\n# >>> count_close_competitors([[100, 100, 100], [95, 90, 85], [80, 85, 90]])\n# 0\n# \"\"\"", "canonical_solution": "my $count = 0;\nfor (my $i = 0; $i < @$students_scores; $i++) {\nfor (my $j = $i + 1; $j < @$students_scores; $j++) {\nif (is_close_competitor($students_scores->[$i], $students_scores->[$j])) {\n$count++;\n}\n}\n}\nreturn $count;\n}\n\nsub is_close_competitor {\nmy ($scores1, $scores2) = @_;\nmy $total_diff = 0;\nfor (my $i = 0; $i < 3; $i++) {\nreturn 0 if abs($scores1->[$i] - $scores2->[$i]) > 5;\n$total_diff += abs($scores1->[$i] - $scores2->[$i]);\n}\nreturn $total_diff <= 10;\n}", "test": "sub check {\ndie \"Test failed!\" unless count_close_competitors([[90, 85, 90], [95, 90, 95], [88, 90, 87]]) == 1;\ndie \"Test failed!\" unless count_close_competitors([[100, 100, 100], [95, 90, 85], [80, 85, 90]]) == 0;\ndie \"Test failed!\" unless count_close_competitors([[110, 105, 100], [102, 107, 103], [90, 90, 90], [85, 80, 85]]) == 0;\ndie \"Test failed!\" if count_close_competitors([[120, 125, 130], [100, 95, 90], [80, 85, 80]]) != 0;\ndie \"Test failed!\" if count_close_competitors([[100, 100, 100]]) != 0;\nprint \"All tests passed!\\n\";\n}\n\ncheck();", "entry_point": "count_close_competitors", "signature": "sub count_close_competitors {", "docstring": "\nCounts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points,\nand whose total score difference is no more than 10 points.\nEach student's scores are provided as a tuple (Chinese, Mathematics, English).\n\nArgs:\nstudents_scores (Array of ArrayRefs): An array where each element is an array reference containing three scores for a student.\n\nReturns:\nint: The number of student pairs who are close competitors.\n\nExamples:\n>>> count_close_competitors([[90, 85, 90], [95, 90, 95], [88, 90, 87]])\n1\n>>> count_close_competitors([[100, 100, 100], [95, 90, 85], [80, 85, 90]])\n0\n", "instruction": "Write a Perl function `sub count_close_competitors {` to solve the following problem:\n\nCounts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points,\nand whose total score difference is no more than 10 points.\nEach student's scores are provided as a tuple (Chinese, Mathematics, English).\n\nArgs:\nstudents_scores (Array of ArrayRefs): An array where each element is an array reference containing three scores for a student.\n\nReturns:\nint: The number of student pairs who are close competitors.\n\nExamples:\n>>> count_close_competitors([[90, 85, 90], [95, 90, 95], [88, 90, 87]])\n1\n>>> count_close_competitors([[100, 100, 100], [95, 90, 85], [80, 85, 90]])\n0\n", "level": "hard"}
{"task_id": "Perl/28", "prompt": "use strict;\nuse warnings;\n\nsub remaining_volume {\nmy ($w, $x, $h, $cuts) = @_;\n# \"\"\"\n# Calculates the remaining volume of a glass cube after making several cuts.\n# Each cut removes a smaller cube from the larger one, defined by two diagonal corner points.\n#\n# Args:\n# $w, $x, $h (int): Dimensions of the glass cube (width, height, depth).\n# $cuts (array ref): Array of cuts, each cut is an array of six integers (x1, y1, z1, x2, y2, z2).\n#\n# Returns:\n# $remaining_volume (int): The volume of the uncut part of the cube.\n#\n# Example:\n# >>> remaining_volume(5, 5, 5, [[1, 1, 1, 2, 2, 2]]) \n# 117\n# \"\"\"", "canonical_solution": "my %cut_cells;\n\nforeach my $cut (@$cuts) {\nmy ($x1, $y1, $z1, $x2, $y2, $z2) = @$cut;\nfor my $i ($x1..$x2) {\nfor my $j ($y1..$y2) {\nfor my $k ($z1..$z2) {\n$cut_cells{\"$i,$j,$k\"} = 1;\n}\n}\n}\n}\n\nmy $removed_volume = scalar keys %cut_cells;\nreturn $w * $x * $h - $removed_volume;\n}", "test": "sub test_remaining_volume {\ndie \"Test failed!\" unless remaining_volume(5, 5, 5, [[1, 1, 1, 2, 2, 2]]) == 117;\ndie \"Test failed!\" unless remaining_volume(6, 6, 6, [[1, 1, 1, 3, 3, 3], [4, 4, 4, 5, 5, 5]]) == 181;\ndie \"Test failed!\" unless remaining_volume(3, 3, 3, [[1, 1, 1, 2, 2, 2], [2, 2, 2, 3, 3, 3]]) == 12;\ndie \"Test failed!\" unless remaining_volume(4, 4, 4, []) == 64;\nprint \"All tests passed!\\n\";\n}\n\ntest_remaining_volume();", "entry_point": "remaining_volume", "signature": "sub remaining_volume {", "docstring": "\nCalculates the remaining volume of a glass cube after making several cuts.\nEach cut removes a smaller cube from the larger one, defined by two diagonal corner points.\n\nArgs:\n$w, $x, $h (int): Dimensions of the glass cube (width, height, depth).\n$cuts (array ref): Array of cuts, each cut is an array of six integers (x1, y1, z1, x2, y2, z2).\n\nReturns:\n$remaining_volume (int): The volume of the uncut part of the cube.\n\nExample:\n>>> remaining_volume(5, 5, 5, [[1, 1, 1, 2, 2, 2]]) \n117\n", "instruction": "Write a Perl function `sub remaining_volume {` to solve the following problem:\n\nCalculates the remaining volume of a glass cube after making several cuts.\nEach cut removes a smaller cube from the larger one, defined by two diagonal corner points.\n\nArgs:\n$w, $x, $h (int): Dimensions of the glass cube (width, height, depth).\n$cuts (array ref): Array of cuts, each cut is an array of six integers (x1, y1, z1, x2, y2, z2).\n\nReturns:\n$remaining_volume (int): The volume of the uncut part of the cube.\n\nExample:\n>>> remaining_volume(5, 5, 5, [[1, 1, 1, 2, 2, 2]]) \n117\n", "level": "middle"}
{"task_id": "Perl/29", "prompt": "use strict;\nuse warnings;\n\nsub generate_snail_matrix {\nmy ($n) = @_;\n# \"\"\"\n# This function generates a snail matrix of size n x n. \n# A snail matrix is a square matrix filled with numbers from 1 to n^2 in a spiral pattern, \n# starting from the top-left corner and spiraling inwards in a clockwise direction.\n# \n# Args:\n# n (int): The size of the matrix.\n# \n# Returns:\n# A 2D array representing the snail matrix.\n#\n# Example:\n# >>> generate_snail_matrix(3)\n# [\n# [1, 2, 3],\n# [8, 9, 4],\n# [7, 6, 5]\n# ]\n# >>> generate_snail_matrix(2)\n# [\n# [1, 2],\n# [4, 3]\n# ]\n# \"\"\"", "canonical_solution": "my @matrix = map { [(0) x $n] } 1..$n;\nmy ($row, $col, $num) = (0, 0, 1);\nmy @directions = ([0,1], [1,0], [0,-1], [-1,0]); # right, down, left, up\nmy $dir = 0;\n\nfor (1..$n*$n) {\n$matrix[$row][$col] = $num++;\nmy $next_row = $row + $directions[$dir][0];\nmy $next_col = $col + $directions[$dir][1];\n\nif ($next_row < 0 or $next_row >= $n or $next_col < 0 or $next_col >= $n or $matrix[$next_row][$next_col] != 0) {\n$dir = ($dir + 1) % 4; # change direction\n$next_row = $row + $directions[$dir][0];\n$next_col = $col + $directions[$dir][1];\n}\n\n($row, $col) = ($next_row, $next_col);\n}\nreturn \\@matrix;\n}", "test": "sub test_snail_matrix {\nmy $func = shift;\nuse Data::Dumper;\n\nmy $result1 = &$func(3);\ndie \"Test failed for n=3!\" unless Dumper($result1) eq Dumper([[1,2,3],[8,9,4],[7,6,5]]);\n\nmy $result2 = &$func(2);\ndie \"Test failed for n=2!\" unless Dumper($result2) eq Dumper([[1,2],[4,3]]);\n\nmy $result3 = &$func(5);\ndie \"Test failed for n=5!\" unless Dumper($result3) eq Dumper([[1,2,3,4,5],[16,17,18,19,6],[15,24,25,20,7],[14,23,22,21,8],[13,12,11,10,9]]);\n\nprint \"All tests passed!\\n\";\n}\n\ntest_snail_matrix(\\&generate_snail_matrix);", "entry_point": "generate_snail_matrix", "signature": "sub generate_snail_matrix {", "docstring": "\nThis function generates a snail matrix of size n x n. \nA snail matrix is a square matrix filled with numbers from 1 to n^2 in a spiral pattern, \nstarting from the top-left corner and spiraling inwards in a clockwise direction.\n\nArgs:\nn (int): The size of the matrix.\n\nReturns:\nA 2D array representing the snail matrix.\n\nExample:\n>>> generate_snail_matrix(3)\n[\n[1, 2, 3],\n[8, 9, 4],\n[7, 6, 5]\n]\n>>> generate_snail_matrix(2)\n[\n[1, 2],\n[4, 3]\n]\n", "instruction": "Write a Perl function `sub generate_snail_matrix {` to solve the following problem:\n\nThis function generates a snail matrix of size n x n. \nA snail matrix is a square matrix filled with numbers from 1 to n^2 in a spiral pattern, \nstarting from the top-left corner and spiraling inwards in a clockwise direction.\n\nArgs:\nn (int): The size of the matrix.\n\nReturns:\nA 2D array representing the snail matrix.\n\nExample:\n>>> generate_snail_matrix(3)\n[\n[1, 2, 3],\n[8, 9, 4],\n[7, 6, 5]\n]\n>>> generate_snail_matrix(2)\n[\n[1, 2],\n[4, 3]\n]\n", "level": "hard"}
{"task_id": "Perl/30", "prompt": "use strict;\nuse warnings;\n\n# Function to add two numbers in a given base\nsub base_addition {\nmy ($base, $num1, $num2) = @_;\n# \"\"\"\n# Adds two numbers in a specified base (ranging from 2 to 36). \n# The numbers are provided as strings and the function returns their sum as a string in the same base.\n#\n# Args:\n# $base: An integer specifying the base (between 2 and 36).\n# $num1: A string representing the first number in the specified base.\n# $num2: A string representing the second number in the specified base.\n#\n# Returns:\n# A string representing the sum of $num1 and $num2 in the specified base.\n#\n# Examples:\n# base_addition(2, '1010', '1101') returns '10111'\n# base_addition(16, '1A3', 'F2') returns '295'\n# base_addition(10, '123', '456') returns '579'\n# \"\"\"", "canonical_solution": "my $dec_num1 = $base == 2 ? oct(\"0b$num1\") : \n$base == 8 ? oct(\"0$num1\") : \n$base == 16 ? hex($num1) : \nbase_to_decimal($num1, $base);\n\nmy $dec_num2 = $base == 2 ? oct(\"0b$num2\") : \n$base == 8 ? oct(\"0$num2\") : \n$base == 16 ? hex($num2) : \nbase_to_decimal($num2, $base);\n\n# Add the numbers in decimal\nmy $sum = $dec_num1 + $dec_num2;\n\n# Convert the sum back to the specified base\nreturn $base == 2 ? sprintf(\"%b\", $sum) : \n$base == 8 ? sprintf(\"%o\", $sum) : \n$base == 16 ? uc(sprintf(\"%X\", $sum)) : \ndecimal_to_base($sum, $base);\n}\n\n# Convert a number from a specific base to decimal\nsub base_to_decimal {\nmy ($num, $base) = @_;\nmy $dec_value = 0;\nmy @digits = reverse split //, uc($num);\nfor my $i (0 .. $#digits) {\nmy $digit = $digits[$i];\n$digit = ord($digit) - 55 if $digit =~ /[A-Z]/; # Convert letters to numbers for bases > 10\n$dec_value += $digit * $base**$i;\n}\nreturn $dec_value;\n}\n\n# Convert a decimal number to a specific base\nsub decimal_to_base {\nmy ($num, $base) = @_;\nreturn 0 if $num == 0;\nmy $res = '';\nwhile ($num > 0) {\nmy $remainder = $num % $base;\n$remainder = chr($remainder + 55) if $remainder >= 10; # Convert numbers to letters for bases > 10\n$res = $remainder . $res;\n$num = int($num / $base);\n}\nreturn $res;\n}", "test": "sub test_base_addition {\ndie \"Test failed: base 2\" unless base_addition(2, '1010', '1101') eq '10111';\ndie \"Test failed: base 16\" unless base_addition(16, '1A3', 'F2') eq '295';\ndie \"Test failed: base 10\" unless base_addition(10, '123', '456') eq '579';\ndie \"Test failed: base 36\" unless base_addition(36, '1Z', '2Y') eq '4X';\ndie \"Test failed: base 5\" unless base_addition(5, '123', '432') eq '1110';\nprint \"All tests passed!\\n\";\n}\n\ntest_base_addition();", "entry_point": "base_addition", "signature": "sub base_addition {", "docstring": "\nAdds two numbers in a specified base (ranging from 2 to 36). \nThe numbers are provided as strings and the function returns their sum as a string in the same base.\n\nArgs:\n$base: An integer specifying the base (between 2 and 36).\n$num1: A string representing the first number in the specified base.\n$num2: A string representing the second number in the specified base.\n\nReturns:\nA string representing the sum of $num1 and $num2 in the specified base.\n\nExamples:\nbase_addition(2, '1010', '1101') returns '10111'\nbase_addition(16, '1A3', 'F2') returns '295'\nbase_addition(10, '123', '456') returns '579'\n", "instruction": "Write a Perl function `sub base_addition {` to solve the following problem:\n\nAdds two numbers in a specified base (ranging from 2 to 36). \nThe numbers are provided as strings and the function returns their sum as a string in the same base.\n\nArgs:\n$base: An integer specifying the base (between 2 and 36).\n$num1: A string representing the first number in the specified base.\n$num2: A string representing the second number in the specified base.\n\nReturns:\nA string representing the sum of $num1 and $num2 in the specified base.\n\nExamples:\nbase_addition(2, '1010', '1101') returns '10111'\nbase_addition(16, '1A3', 'F2') returns '295'\nbase_addition(10, '123', '456') returns '579'\n", "level": "hard"}
{"task_id": "Perl/31", "prompt": "use strict;\nuse warnings;\n\nsub count_maze_paths {\nmy ($N, $M, $T, $SX, $SY, $FX, $FY, $obstacles) = @_;\n# \"\"\"\n# Counts the number of paths from a start point to an end point in a given maze.\n# The maze is represented by a grid of NxM size with T obstacles.\n# Movement is allowed up, down, left, or right, but not through obstacles.\n# Each cell can be visited at most once.\n# \n# Args:\n# $N: Number of rows in the maze.\n# $M: Number of columns in the maze.\n# $T: Total number of obstacles.\n# $SX, $SY: Starting coordinates (1-indexed).\n# $FX, $FY: Finishing coordinates (1-indexed).\n# @obstacles: Array of obstacle coordinates.\n# \n# Returns:\n# The total number of distinct paths from start to end.\n#\n# Example:\n# >>> count_maze_paths(3, 3, 2, 1, 1, 3, 3, [[1, 2], [2, 1]])\n# 0\n# >>> count_maze_paths(2, 2, 1, 1, 1, 2, 2, [[2, 1]])\n# 1\n# \"\"\"", "canonical_solution": "my @maze = map { [(0) x $M] } 1 .. $N;\nforeach my $obstacle (@$obstacles) {\n$maze[$obstacle->[0] - 1][$obstacle->[1] - 1] = 1;\n}\n\nmy $count_paths;\n$count_paths = sub {\nmy ($x, $y) = @_;\nreturn 0 if $x < 0 || $y < 0 || $x >= $N || $y >= $M || $maze[$x][$y];\nreturn 1 if $x == $FX - 1 && $y == $FY - 1;\n$maze[$x][$y] = 1;\nmy $paths = 0;\n$paths += $count_paths->($x + 1, $y);\n$paths += $count_paths->($x - 1, $y);\n$paths += $count_paths->($x, $y + 1);\n$paths += $count_paths->($x, $y - 1);\n$maze[$x][$y] = 0;\nreturn $paths;\n};\n\nreturn $count_paths->($SX - 1, $SY - 1);\n}", "test": "sub check {\ndie \"Test failed!\" unless count_maze_paths(3, 3, 2, 1, 1, 3, 3, [[1, 2], [2, 1]]) == 0;\ndie \"Test failed!\" unless count_maze_paths(2, 2, 1, 1, 1, 2, 2, [[2, 1]]) == 1;\ndie \"Test failed!\" unless count_maze_paths(4, 4, 3, 1, 1, 4, 4, [[2, 2], [2, 3], [3, 2]]) == 4;\ndie \"Test failed!\" unless count_maze_paths(3, 3, 0, 1, 1, 3, 3, []) == 12;\ndie \"Test failed!\" if count_maze_paths(2, 2, 2, 1, 1, 2, 2, [[1, 2], [2, 1]]) != 0;\nprint \"All tests passed!\\n\";\n}\n\ncheck();", "entry_point": "count_maze_paths", "signature": "sub count_maze_paths {", "docstring": "\nCounts the number of paths from a start point to an end point in a given maze.\nThe maze is represented by a grid of NxM size with T obstacles.\nMovement is allowed up, down, left, or right, but not through obstacles.\nEach cell can be visited at most once.\n\nArgs:\n$N: Number of rows in the maze.\n$M: Number of columns in the maze.\n$T: Total number of obstacles.\n$SX, $SY: Starting coordinates (1-indexed).\n$FX, $FY: Finishing coordinates (1-indexed).\n@obstacles: Array of obstacle coordinates.\n\nReturns:\nThe total number of distinct paths from start to end.\n\nExample:\n>>> count_maze_paths(3, 3, 2, 1, 1, 3, 3, [[1, 2], [2, 1]])\n0\n>>> count_maze_paths(2, 2, 1, 1, 1, 2, 2, [[2, 1]])\n1\n", "instruction": "Write a Perl function `sub count_maze_paths {` to solve the following problem:\n\nCounts the number of paths from a start point to an end point in a given maze.\nThe maze is represented by a grid of NxM size with T obstacles.\nMovement is allowed up, down, left, or right, but not through obstacles.\nEach cell can be visited at most once.\n\nArgs:\n$N: Number of rows in the maze.\n$M: Number of columns in the maze.\n$T: Total number of obstacles.\n$SX, $SY: Starting coordinates (1-indexed).\n$FX, $FY: Finishing coordinates (1-indexed).\n@obstacles: Array of obstacle coordinates.\n\nReturns:\nThe total number of distinct paths from start to end.\n\nExample:\n>>> count_maze_paths(3, 3, 2, 1, 1, 3, 3, [[1, 2], [2, 1]])\n0\n>>> count_maze_paths(2, 2, 1, 1, 1, 2, 2, [[2, 1]])\n1\n", "level": "hard"}
{"task_id": "Perl/32", "prompt": "use strict;\nuse warnings;\n\nsub max_lights_to_turn_off {\nmy ($positions, $dist) = @_;\n# \"\"\"\n# Given the positions of n lights, determine the maximum number of lights that can be turned off while ensuring sufficient lighting.\n# Two adjacent lights can be turned off if the distance between them is less than a given threshold (dist), and there is a light on in between them.\n# The lights at the extremes (closest and farthest from the point of reference) must always be on.\n#\n# Args:\n# positions (array ref): An array of integers representing the positions of the lights.\n# dist (integer): The maximum distance allowed for turning off a light.\n#\n# Returns:\n# integer: The maximum number of lights that can be turned off.\n#\n# Example:\n# max_lights_to_turn_off([1, 4, 5, 7, 10], 3)\n# # Returns 0 \n# \"\"\"", "canonical_solution": "my $count = 0;\n\nfor (my $i = 1; $i < @$positions - 1; $i++) {\nif ($positions->[$i + 1] - $positions->[$i - 1] <= $dist) {\n$count++;\n$i++; # Skip the next light as it can't be turned off if this one is off\n}\n}\n\nreturn $count;\n}", "test": "sub test_max_lights_to_turn_off {\ndie \"Test failed!\" unless max_lights_to_turn_off([1, 4, 5, 7, 10], 3) == 1;\ndie \"Test failed!\" unless max_lights_to_turn_off([1, 2, 3, 6, 7], 2) == 1;\ndie \"Test failed!\" unless max_lights_to_turn_off([1, 3, 6, 8, 11, 14], 4) == 0;\ndie \"Test failed!\" if max_lights_to_turn_off([1, 2, 4, 7, 11], 2) != 0;\ndie \"Test failed!\" unless max_lights_to_turn_off([2, 5, 7, 10, 13], 3) == 0;\nprint \"All tests passed!\\n\";\n}\n\ntest_max_lights_to_turn_off();", "entry_point": "max_lights_to_turn_off", "signature": "sub max_lights_to_turn_off {", "docstring": "\nGiven the positions of n lights, determine the maximum number of lights that can be turned off while ensuring sufficient lighting.\nTwo adjacent lights can be turned off if the distance between them is less than a given threshold (dist), and there is a light on in between them.\nThe lights at the extremes (closest and farthest from the point of reference) must always be on.\n\nArgs:\npositions (array ref): An array of integers representing the positions of the lights.\ndist (integer): The maximum distance allowed for turning off a light.\n\nReturns:\ninteger: The maximum number of lights that can be turned off.\n\nExample:\nmax_lights_to_turn_off([1, 4, 5, 7, 10], 3)\nReturns 0 \n", "instruction": "Write a Perl function `sub max_lights_to_turn_off {` to solve the following problem:\n\nGiven the positions of n lights, determine the maximum number of lights that can be turned off while ensuring sufficient lighting.\nTwo adjacent lights can be turned off if the distance between them is less than a given threshold (dist), and there is a light on in between them.\nThe lights at the extremes (closest and farthest from the point of reference) must always be on.\n\nArgs:\npositions (array ref): An array of integers representing the positions of the lights.\ndist (integer): The maximum distance allowed for turning off a light.\n\nReturns:\ninteger: The maximum number of lights that can be turned off.\n\nExample:\nmax_lights_to_turn_off([1, 4, 5, 7, 10], 3)\nReturns 0 \n", "level": "easy"}
{"task_id": "Perl/33", "prompt": "use strict;\nuse warnings;\n\nsub max_herb_value {\nmy ($t, $herbs) = @_;\n# Given a total time and a list of herbs, each with a picking time and value, \n# calculates the maximum total value of herbs that can be picked within the given time.\n# This problem assumes that each herb can be picked an unlimited number of times.\n#\n# Args:\n# t (int): The total time available for picking herbs.\n# herbs (Array of Array Ref): A list where each element is a reference to an array containing\n# two integers - the first is the time required to pick the herb,\n# and the second is the value of the herb.\n#\n# Returns:\n# int: The maximum total value of herbs that can be picked.\n#\n# Examples:\n# max_herb_value(10, [[1, 5], [2, 10], [3, 15]]) should return 50\n# max_herb_value(5, [[2, 4], [3, 5]]) should return 9", "canonical_solution": "my @dp = (0) x ($t + 1);\n\nforeach my $herb (@$herbs) {\nmy ($time, $value) = @$herb;\nfor (my $i = $time; $i <= $t; $i++) {\n$dp[$i] = $dp[$i] > $dp[$i - $time] + $value ? $dp[$i] : $dp[$i - $time] + $value;\n}\n}\n\nreturn $dp[$t];\n}", "test": "sub test_max_herb_value {\ndie \"Test failed!\" unless max_herb_value(10, [[1, 5], [2, 10], [3, 15]]) == 50;\ndie \"Test failed!\" unless max_herb_value(5, [[2, 4], [3, 5]]) == 9;\ndie \"Test failed!\" unless max_herb_value(7, [[1, 2], [2, 5], [3, 7]]) == 17;\ndie \"Test failed!\" if max_herb_value(0, [[1, 10], [2, 20]]) != 0;\ndie \"Test failed!\" unless max_herb_value(20, [[5, 10], [4, 7], [3, 5]]) == 40;\nprint \"All tests passed!\\n\";\n}\n\ntest_max_herb_value();", "entry_point": "max_herb_value", "signature": "sub max_herb_value {", "docstring": "Given a total time and a list of herbs, each with a picking time and value, \ncalculates the maximum total value of herbs that can be picked within the given time.\nThis problem assumes that each herb can be picked an unlimited number of times.\n\nArgs:\nt (int): The total time available for picking herbs.\nherbs (Array of Array Ref): A list where each element is a reference to an array containing\ntwo integers - the first is the time required to pick the herb,\nand the second is the value of the herb.\n\nReturns:\nint: The maximum total value of herbs that can be picked.\n\nExamples:\nmax_herb_value(10, [[1, 5], [2, 10], [3, 15]]) should return 50\nmax_herb_value(5, [[2, 4], [3, 5]]) should return 9", "instruction": "Write a Perl function `sub max_herb_value {` to solve the following problem:\nGiven a total time and a list of herbs, each with a picking time and value, \ncalculates the maximum total value of herbs that can be picked within the given time.\nThis problem assumes that each herb can be picked an unlimited number of times.\n\nArgs:\nt (int): The total time available for picking herbs.\nherbs (Array of Array Ref): A list where each element is a reference to an array containing\ntwo integers - the first is the time required to pick the herb,\nand the second is the value of the herb.\n\nReturns:\nint: The maximum total value of herbs that can be picked.\n\nExamples:\nmax_herb_value(10, [[1, 5], [2, 10], [3, 15]]) should return 50\nmax_herb_value(5, [[2, 4], [3, 5]]) should return 9", "level": "easy"}
{"task_id": "Perl/34", "prompt": "use strict;\nuse warnings;\n\nsub find_ratio_numbers {\nmy ($A, $B, $C) = @_;\n# Finds three 3-digit numbers that are permutations of 1 to 9 and whose ratios match the provided A, B, C.\n# If no such numbers exist, returns \"No!!!\".\n# \n# Args:\n# A (int): The first ratio part.\n# B (int): The second ratio part.\n# C (int): The third ratio part.\n# \n# Returns:\n# A list of tuples containing the three numbers, or \"No!!!\" if no solution exists.\n#\n# Example:\n# find_ratio_numbers(1, 2, 3) might return [(123, 246, 369), (132, 264, 396)]\n# find_ratio_numbers(2, 3, 4) might return \"No!!!\"", "canonical_solution": "my @results;\nfor my $i (123..987) {\nmy $j = $i * $B / $A;\nmy $k = $i * $C / $A;\n\nnext if $j < 123 || $j > 987 || $k < 123 || $k > 987;\nnext if $j != int($j) || $k != int($k);\n\nmy $concat = $i . $j . $k;\nnext if $concat =~ /0/;\nmy $sorted = join '', sort split '', $concat;\nnext unless $sorted eq '123456789';\n\npush @results, [$i, $j, $k];\n}\n\nreturn @results ? @results : \"No!!!\";\n}", "test": "sub test {\nmy $func = shift;\n\nmy @test1 = &$func(1, 2, 3);\ndie \"Test failed: Expected at least one solution for 1:2:3 ratio\" unless @test1;\n\nmy @test2 = &$func(2, 5, 7);\ndie \"Test failed: Expected 'No!!!' for 2:5:7 ratio\" if @test2 && $test2[0] ne 'No!!!';\n\nmy @test3 = &$func(3, 6, 9);\ndie \"Test failed: Expected at least one solution for 3:6:9 ratio\" unless @test3;\n\nprint \"All tests passed!\\n\";\n}\n\ntest(\\&find_ratio_numbers);", "entry_point": "find_ratio_numbers", "signature": "sub find_ratio_numbers {", "docstring": "Finds three 3-digit numbers that are permutations of 1 to 9 and whose ratios match the provided A, B, C.\nIf no such numbers exist, returns \"No!!!\".\n\nArgs:\nA (int): The first ratio part.\nB (int): The second ratio part.\nC (int): The third ratio part.\n\nReturns:\nA list of tuples containing the three numbers, or \"No!!!\" if no solution exists.\n\nExample:\nfind_ratio_numbers(1, 2, 3) might return [(123, 246, 369), (132, 264, 396)]\nfind_ratio_numbers(2, 3, 4) might return \"No!!!\"", "instruction": "Write a Perl function `sub find_ratio_numbers {` to solve the following problem:\nFinds three 3-digit numbers that are permutations of 1 to 9 and whose ratios match the provided A, B, C.\nIf no such numbers exist, returns \"No!!!\".\n\nArgs:\nA (int): The first ratio part.\nB (int): The second ratio part.\nC (int): The third ratio part.\n\nReturns:\nA list of tuples containing the three numbers, or \"No!!!\" if no solution exists.\n\nExample:\nfind_ratio_numbers(1, 2, 3) might return [(123, 246, 369), (132, 264, 396)]\nfind_ratio_numbers(2, 3, 4) might return \"No!!!\"", "level": "middle"}
{"task_id": "Perl/35", "prompt": "use strict;\nuse warnings;\nuse List::Util qw(min);\n\nsub min_level_diff_sum {\nmy ($levels, $k) = @_;\n# Calculates the minimum total difference in levels for a chess tournament given the levels of players and the number of games.\n#\n# Each player has a unique level and can play up to two games, one with black pieces and one with white pieces. \n# The goal is to minimize the total level difference across all games.\n#\n# Args:\n# levels (ArrayRef): An array reference containing the levels of players.\n# k (Int): The number of games to be played.\n#\n# Returns:\n# Int: The minimum total difference in levels.\n#\n# Examples:\n# >>> min_level_diff_sum([10, 20, 15, 30, 25], 2)\n# 10\n# >>> min_level_diff_sum([5, 3, 8, 12, 7, 10], 3)\n# 5", "canonical_solution": "my @sorted_levels = sort { $a <=> $b } @$levels;\n\n# Initialize an array to store the differences\nmy @differences = ();\n\n# Calculate differences between adjacent levels\nfor (my $i = 0; $i < $#sorted_levels; $i++) {\npush @differences, $sorted_levels[$i + 1] - $sorted_levels[$i];\n}\n\n# Sort the differences and pick the smallest k differences\n@differences = sort { $a <=> $b } @differences;\nmy $total_diff = 0;\n$total_diff += $differences[$_] for 0 .. $k - 1;\n\nreturn $total_diff;\n}", "test": "sub test_min_level_diff_sum {\ndie \"Test failed!\" unless min_level_diff_sum([10, 20, 15, 30, 25], 2) == 10;\ndie \"Test failed!\" unless min_level_diff_sum([5, 3, 8, 12, 7, 10], 3) == 5;\ndie \"Test failed!\" unless min_level_diff_sum([40, 35, 30, 25, 20, 15], 2) == 10;\ndie \"Test failed!\" unless min_level_diff_sum([1, 2, 3, 4, 5, 6, 7], 3) == 3;\ndie \"Test failed!\" unless min_level_diff_sum([21, 19, 17, 15, 13, 11, 9], 4) == 8;\nprint \"All tests passed!\\n\";\n}\n\ntest_min_level_diff_sum();", "entry_point": "min_level_diff_sum", "signature": "sub min_level_diff_sum {", "docstring": "Calculates the minimum total difference in levels for a chess tournament given the levels of players and the number of games.\n\nEach player has a unique level and can play up to two games, one with black pieces and one with white pieces. \nThe goal is to minimize the total level difference across all games.\n\nArgs:\nlevels (ArrayRef): An array reference containing the levels of players.\nk (Int): The number of games to be played.\n\nReturns:\nInt: The minimum total difference in levels.\n\nExamples:\n>>> min_level_diff_sum([10, 20, 15, 30, 25], 2)\n10\n>>> min_level_diff_sum([5, 3, 8, 12, 7, 10], 3)\n5", "instruction": "Write a Perl function `sub min_level_diff_sum {` to solve the following problem:\nCalculates the minimum total difference in levels for a chess tournament given the levels of players and the number of games.\n\nEach player has a unique level and can play up to two games, one with black pieces and one with white pieces. \nThe goal is to minimize the total level difference across all games.\n\nArgs:\nlevels (ArrayRef): An array reference containing the levels of players.\nk (Int): The number of games to be played.\n\nReturns:\nInt: The minimum total difference in levels.\n\nExamples:\n>>> min_level_diff_sum([10, 20, 15, 30, 25], 2)\n10\n>>> min_level_diff_sum([5, 3, 8, 12, 7, 10], 3)\n5", "level": "hard"}
{"task_id": "Perl/36", "prompt": "use strict;\nuse warnings;\n\nsub find_words_with_prefix {\nmy ($words, $prefix) = @_;\n# The function find_words_with_prefix will:\n\n# Take an array of words and a prefix string as arguments.\n# Return a list of words that start with the given prefix, sorted in dictionary order.\n# Examples:\n# Example 1:\n# Input: @words = ('apple', 'art', 'banana', 'artist', 'arrow'), $prefix = 'ar'\n# Output: ('arrow', 'art', 'artist')\n\n# Example 2:\n# Input: @words = ('dog', 'cat', 'cow', 'camel', 'donkey'), $prefix = 'ca'\n# Output: ('camel', 'cat')", "canonical_solution": "my @filtered = grep { $_ =~ /^\\Q$prefix\\E/ } @$words;\n\n# Sort the filtered list in dictionary order\n@filtered = sort @filtered;\n\nreturn @filtered;\n}", "test": "sub test_find_words_with_prefix {\nuse Test::More tests => 4;\n\nis_deeply([find_words_with_prefix(['apple', 'art', 'banana', 'artist', 'arrow'], 'ar')],\n['arrow', 'art', 'artist'],\n'Test with prefix \"ar\"');\n\nis_deeply([find_words_with_prefix(['dog', 'cat', 'cow', 'camel', 'donkey'], 'ca')],\n['camel', 'cat'],\n'Test with prefix \"ca\"');\n\nis_deeply([find_words_with_prefix(['hello', 'high', 'hedge', 'host', 'hill'], 'ho')],\n['host'],\n'Test with prefix \"ho\"');\n\nis_deeply([find_words_with_prefix(['blue', 'black', 'brown', 'beige'], 'br')],\n['brown'],\n'Test with prefix \"br\"');\n\ndone_testing();\n}\n\ntest_find_words_with_prefix();", "entry_point": "find_words_with_prefix", "signature": "sub find_words_with_prefix {", "docstring": "The function find_words_with_prefix will:\n\nTake an array of words and a prefix string as arguments.\nReturn a list of words that start with the given prefix, sorted in dictionary order.\nExamples:\nExample 1:\nInput: @words = ('apple', 'art', 'banana', 'artist', 'arrow'), $prefix = 'ar'\nOutput: ('arrow', 'art', 'artist')\n\nExample 2:\nInput: @words = ('dog', 'cat', 'cow', 'camel', 'donkey'), $prefix = 'ca'\nOutput: ('camel', 'cat')", "instruction": "Write a Perl function `sub find_words_with_prefix {` to solve the following problem:\nThe function find_words_with_prefix will:\n\nTake an array of words and a prefix string as arguments.\nReturn a list of words that start with the given prefix, sorted in dictionary order.\nExamples:\nExample 1:\nInput: @words = ('apple', 'art', 'banana', 'artist', 'arrow'), $prefix = 'ar'\nOutput: ('arrow', 'art', 'artist')\n\nExample 2:\nInput: @words = ('dog', 'cat', 'cow', 'camel', 'donkey'), $prefix = 'ca'\nOutput: ('camel', 'cat')", "level": "easy"}
{"task_id": "Perl/37", "prompt": "use strict;\nuse warnings;\n\nsub min_strokes_to_draw_graph {\nmy ($n, $edges) = @_;\n# Calculate the minimum number of strokes needed to draw all edges in an undirected graph.\n# The graph is represented by its vertices and edges, where edges are pairs of vertices.\n# \n# Args:\n# n (int): Number of vertices in the graph.\n# edges (array of array): A list of edges, each represented as a pair of vertex indices.\n#\n# Returns:\n# int: The minimum number of strokes needed to draw the graph.\n#\n# Examples:\n# >>> min_strokes_to_draw_graph(4, [[1, 2], [2, 3], [3, 4], [4, 1]])\n# 1\n# >>> min_strokes_to_draw_graph(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]])\n# 1", "canonical_solution": "my @degree = (0) x ($n + 1);\nmy $odd_degree_count = 0;\n\nforeach my $edge (@$edges) {\n$degree[$edge->[0]]++;\n$degree[$edge->[1]]++;\n}\n\nforeach my $deg (@degree) {\n$odd_degree_count++ if $deg % 2 != 0;\n}\n\nreturn $odd_degree_count ? int(($odd_degree_count + 1) / 2) : 1;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func(4, [[1, 2], [2, 3], [3, 4], [4, 1]]) == 1;\ndie \"Test failed!\" unless &$func(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]]) == 1;\ndie \"Test failed!\" unless &$func(3, [[1, 2], [2, 3]]) == 1;\ndie \"Test failed!\" unless &$func(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 1], [1, 3], [2, 4]]) == 2;\ndie \"Test failed!\" unless &$func(4, [[1, 2], [2, 3], [3, 4]]) == 1;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&min_strokes_to_draw_graph);", "entry_point": "min_strokes_to_draw_graph", "signature": "sub min_strokes_to_draw_graph {", "docstring": "Calculate the minimum number of strokes needed to draw all edges in an undirected graph.\nThe graph is represented by its vertices and edges, where edges are pairs of vertices.\n\nArgs:\nn (int): Number of vertices in the graph.\nedges (array of array): A list of edges, each represented as a pair of vertex indices.\n\nReturns:\nint: The minimum number of strokes needed to draw the graph.\n\nExamples:\n>>> min_strokes_to_draw_graph(4, [[1, 2], [2, 3], [3, 4], [4, 1]])\n1\n>>> min_strokes_to_draw_graph(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]])\n1", "instruction": "Write a Perl function `sub min_strokes_to_draw_graph {` to solve the following problem:\nCalculate the minimum number of strokes needed to draw all edges in an undirected graph.\nThe graph is represented by its vertices and edges, where edges are pairs of vertices.\n\nArgs:\nn (int): Number of vertices in the graph.\nedges (array of array): A list of edges, each represented as a pair of vertex indices.\n\nReturns:\nint: The minimum number of strokes needed to draw the graph.\n\nExamples:\n>>> min_strokes_to_draw_graph(4, [[1, 2], [2, 3], [3, 4], [4, 1]])\n1\n>>> min_strokes_to_draw_graph(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]])\n1", "level": "middle"}
{"task_id": "Perl/38", "prompt": "use strict;\nuse warnings;\nuse List::Util qw(min);\n\nsub min_circle_crosses {\nmy ($circles_x, $circles_y, $radii, $point1, $point2) = @_;\n# \"\"\"\n# Determines the minimum number of times a line between two points crosses the boundaries of given circles.\n# Each circle is defined by its center coordinates and radius, and none of the circles intersect or touch each other.\n# The line does not start or end on any circle.\n#\n# Args:\n# circles_x (ArrayRef): Array of x-coordinates of the circles' centers.\n# circles_y (ArrayRef): Array of y-coordinates of the circles' centers.\n# radii (ArrayRef): Array of radii of the circles.\n# point1 (ArrayRef): Array of x and y coordinates of the start point.\n# point2 (ArrayRef): Array of x and y coordinates of the end point.\n#\n# Returns:\n# Integer: Minimum number of times the line crosses circle boundaries.\n#\n# Examples:\n# min_circle_crosses([1,-3,2,5,-4,12,12], [1,-1,2,5,5,1,1], [8,1,2,1,1,1,2], [-5, 1], [12, 1]) returns 3\n# min_circle_crosses([-4, 4], [4, -4], [2, 2], [-5, 0], [5, 0]) returns 0\n# \"\"\"", "canonical_solution": "my $crosses = 0;\n\nforeach my $i (0 .. $#$circles_x) {\nmy $dx = $circles_x->[$i] - $point1->[0];\nmy $dy = $circles_y->[$i] - $point1->[1];\nmy $distance1 = sqrt($dx * $dx + $dy * $dy) - $radii->[$i];\n\n$dx = $circles_x->[$i] - $point2->[0];\n$dy = $circles_y->[$i] - $point2->[1];\nmy $distance2 = sqrt($dx * $dx + $dy * $dy) - $radii->[$i];\n\n$crosses++ if ($distance1 * $distance2 < 0);\n}\n\nreturn $crosses;\n}", "test": "sub check {\nmy $func = shift;\ndie \"Test failed!\" unless &$func([1, -3, 2], [1, -1, 2], [1, 1, 1], [-2, 1], [3, 2]) == 0;\ndie \"Test failed!\" unless &$func([-4, 4], [4, -4], [2, 2], [-5, 0], [5, 0]) == 0;\ndie \"Test failed!\" unless &$func([0, 5], [0, 5], [3, 3], [-7, 0], [7, 0]) == 0;\ndie \"Test failed!\" if &$func([0, 5], [0, 5], [3, 3], [-7, 0], [7, 0]) != 0;\ndie \"Test failed!\" unless &$func([-2, 2], [-2, 2], [1, 1], [-3, -3], [3, 3]) == 0;\ndie \"Test failed!\" unless &$func([1,-3,2,5,-4,12,12], [1,-1,2,5,5,1,1], [8,1,2,1,1,1,2], [-5, 1], [12, 1]) == 3;\nprint \"All tests passed!\\n\";\n}\n\ncheck(\\&min_circle_crosses);", "entry_point": "min_circle_crosses", "signature": "sub min_circle_crosses {", "docstring": "\nDetermines the minimum number of times a line between two points crosses the boundaries of given circles.\nEach circle is defined by its center coordinates and radius, and none of the circles intersect or touch each other.\nThe line does not start or end on any circle.\n\nArgs:\ncircles_x (ArrayRef): Array of x-coordinates of the circles' centers.\ncircles_y (ArrayRef): Array of y-coordinates of the circles' centers.\nradii (ArrayRef): Array of radii of the circles.\npoint1 (ArrayRef): Array of x and y coordinates of the start point.\npoint2 (ArrayRef): Array of x and y coordinates of the end point.\n\nReturns:\nInteger: Minimum number of times the line crosses circle boundaries.\n\nExamples:\nmin_circle_crosses([1,-3,2,5,-4,12,12], [1,-1,2,5,5,1,1], [8,1,2,1,1,1,2], [-5, 1], [12, 1]) returns 3\nmin_circle_crosses([-4, 4], [4, -4], [2, 2], [-5, 0], [5, 0]) returns 0\n", "instruction": "Write a Perl function `sub min_circle_crosses {` to solve the following problem:\n\nDetermines the minimum number of times a line between two points crosses the boundaries of given circles.\nEach circle is defined by its center coordinates and radius, and none of the circles intersect or touch each other.\nThe line does not start or end on any circle.\n\nArgs:\ncircles_x (ArrayRef): Array of x-coordinates of the circles' centers.\ncircles_y (ArrayRef): Array of y-coordinates of the circles' centers.\nradii (ArrayRef): Array of radii of the circles.\npoint1 (ArrayRef): Array of x and y coordinates of the start point.\npoint2 (ArrayRef): Array of x and y coordinates of the end point.\n\nReturns:\nInteger: Minimum number of times the line crosses circle boundaries.\n\nExamples:\nmin_circle_crosses([1,-3,2,5,-4,12,12], [1,-1,2,5,5,1,1], [8,1,2,1,1,1,2], [-5, 1], [12, 1]) returns 3\nmin_circle_crosses([-4, 4], [4, -4], [2, 2], [-5, 0], [5, 0]) returns 0\n", "level": "middle"}
{"task_id": "Perl/39", "prompt": "use strict;\nuse warnings;\n\nsub max_min_distance {\nmy ($n, $m, $positions) = @_;\n# \"\"\"\n# Calculates the maximum minimum distance between cows in different barns.\n# This function finds the largest possible minimum distance between any two cows,\n# given the positions of the barns and the number of cows.\n#\n# Args:\n# $n (int): Number of barns.\n# $m (int): Number of cows.\n# $positions (array_ref): Array reference of integers representing the positions of the barns.\n#\n# Returns:\n# int: The maximum minimum distance between two cows.\n#\n# Examples:\n# max_min_distance(4, 2, [1, 3, 4, 10]) returns 9\n# \"\"\"", "canonical_solution": "my @sorted_positions = sort { $a <=> $b } @$positions;\n\nmy $left = 0;\nmy $right = $sorted_positions[$n - 1] - $sorted_positions[0];\nmy $result = 0;\n\nwhile ($left <= $right) {\nmy $mid = int(($left + $right) / 2);\nif (can_place_cows(\\@sorted_positions, $m, $mid)) {\n$result = $mid;\n$left = $mid + 1;\n} else {\n$right = $mid - 1;\n}\n}\n\nreturn $result;\n}\n\nsub can_place_cows {\nmy ($positions, $cows, $min_dist) = @_;\nmy $count = 1;\nmy $last_position = $positions->[0];\n\nforeach my $position (@$positions) {\nif ($position - $last_position >= $min_dist) {\n$last_position = $position;\n$count++;\nreturn 1 if $count == $cows;\n}\n}\n\nreturn 0;\n}", "test": "sub test {\ndie \"Test failed!\" unless max_min_distance(4, 2, [1, 3, 4, 10]) == 9;\ndie \"Test failed!\" unless max_min_distance(5, 3, [1, 2, 8, 4, 9]) == 3;\ndie \"Test failed!\" unless max_min_distance(6, 2, [1, 4, 9, 12, 15, 17]) == 16;\ndie \"Test failed!\" unless max_min_distance(3, 2, [1, 5, 10]) == 9;\ndie \"Test failed!\" unless max_min_distance(7, 4, [1, 2, 4, 6, 7, 9, 11]) == 3;\nprint \"All tests passed!\\n\";\n}\n\ntest();", "entry_point": "max_min_distance", "signature": "sub max_min_distance {", "docstring": "\nCalculates the maximum minimum distance between cows in different barns.\nThis function finds the largest possible minimum distance between any two cows,\ngiven the positions of the barns and the number of cows.\n\nArgs:\n$n (int): Number of barns.\n$m (int): Number of cows.\n$positions (array_ref): Array reference of integers representing the positions of the barns.\n\nReturns:\nint: The maximum minimum distance between two cows.\n\nExamples:\nmax_min_distance(4, 2, [1, 3, 4, 10]) returns 9\n", "instruction": "Write a Perl function `sub max_min_distance {` to solve the following problem:\n\nCalculates the maximum minimum distance between cows in different barns.\nThis function finds the largest possible minimum distance between any two cows,\ngiven the positions of the barns and the number of cows.\n\nArgs:\n$n (int): Number of barns.\n$m (int): Number of cows.\n$positions (array_ref): Array reference of integers representing the positions of the barns.\n\nReturns:\nint: The maximum minimum distance between two cows.\n\nExamples:\nmax_min_distance(4, 2, [1, 3, 4, 10]) returns 9\n", "level": "hard"}
{"task_id": "Perl/40", "prompt": "sub max_pens {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "canonical_solution": "    my ($a, $b) = @_;\n    my $total_money = $a + $b / 10; # Convert the total money into Yuan.\n    return int($total_money / 1.9); # The price of one pen is 1.9 Yuan, use int() to get the floor value.\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed for input (5, 0): expected 2 got \" . &$func(5, 0) unless &$func(5, 0) == 2;\n    die \"Test failed for input (3, 8): expected 2 got \" . &$func(3, 8) unless &$func(3, 8) == 2;\n    die \"Test failed for input (20, 5): expected 10 got \" . &$func(20, 5) unless &$func(20, 5) == 10;\n    die \"Test failed for input (0, 9): expected 0 got \" . &$func(0, 9) unless &$func(0, 9) == 0;\n}\n\ncheck(\\&max_pens);", "entry_point": "max_pens", "signature": "sub max_pens {", "docstring": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "instruction": "Write a Perl function `sub max_pens {` to solve the following problem: This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.", "level": "easy"}
{"task_id": "Perl/41", "prompt": "sub calculate_absolute_value {\n    # \"\"\"\n    # Calculate the absolute value of an integer.\n    # The function takes an integer as input and returns its absolute value.\n    # The absolute value of an integer is the non-negative value of the integer without regard to its sign.\n    # Examples:\n    # >>> calculate_absolute_value(-5)\n    # 5\n    # >>> calculate_absolute_value(3)\n    # 3\n    # >>> calculate_absolute_value(0)\n    # 0\n    # \"\"\"", "canonical_solution": "    my ($n) = @_;\n    return $n if $n >= 0;\n    return -$n;\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected 5, got \" . &$func(-5) unless &$func(-5) == 5;\n    die \"Test failed! Expected 3, got \" . &$func(3) unless &$func(3) == 3;\n    die \"Test failed! Expected 0, got \" . &$func(0) unless &$func(0) == 0;\n    die \"Test failed! Expected 10000, got \" . &$func(-10000) unless &$func(-10000) == 10000;\n    die \"Test failed! Expected 999, got \" . &$func(999) unless &$func(999) == 999;\n}\n\ncheck(\\&calculate_absolute_value);", "entry_point": "calculate_absolute_value", "signature": "sub calculate_absolute_value {", "docstring": "Calculate the absolute value of an integer.\n The function takes an integer as input and returns its absolute value.\n The absolute value of an integer is the non-negative value of the integer without regard to its sign.\n Examples:\n >>> calculate_absolute_value(-5)\n 5\n >>> calculate_absolute_value(3)\n 3\n >>> calculate_absolute_value(0)\n 0\n", "instruction": "Write a Perl function `sub calculate_absolute_value {` to solve the following problem:Calculate the absolute value of an integer.\n The function takes an integer as input and returns its absolute value.\n The absolute value of an integer is the non-negative value of the integer without regard to its sign.\n Examples:\n >>> calculate_absolute_value(-5)\n 5\n >>> calculate_absolute_value(3)\n 3\n >>> calculate_absolute_value(0)\n 0\n", "level": "easy"}
{"task_id": "Perl/42", "prompt": "sub determine_sign {\n    # Determine the sign of a given integer N.\n    # The function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\n    # - If N is greater than 0, it returns 'positive'.\n    # - If N is exactly 0, it returns 'zero'.\n    # - If N is less than 0, it returns 'negative'.\n    # Examples:\n    # >>> determine_sign(10)\n    # 'positive'\n    # >>> determine_sign(0)\n    # 'zero'\n    # >>> determine_sign(-5)\n    # 'negative'", "canonical_solution": "    my ($N) = @_;\n    return 'positive' if $N > 0;\n    return 'zero' if $N == 0;\n    return 'negative';\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected 'positive', got \" . &$func(10) unless &$func(10) eq 'positive';\n    die \"Test failed! Expected 'zero', got \" . &$func(0) unless &$func(0) eq 'zero';\n    die \"Test failed! Expected 'negative', got \" . &$func(-1) unless &$func(-1) eq 'negative';\n    die \"Test failed! Expected 'negative', got \" . &$func(-10000) unless &$func(-10000) eq 'negative';\n    die \"Test failed! Expected 'positive', got \" . &$func(999) unless &$func(999) eq 'positive';\n    print \"All tests passed!\\n\";\n}\n\ncheck(\\&determine_sign);", "entry_point": "determine_sign", "signature": "sub determine_sign {", "docstring": " Determine the sign of a given integer N.\n The function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\n - If N is greater than 0, it returns 'positive'.\n - If N is exactly 0, it returns 'zero'.\n - If N is less than 0, it returns 'negative'.\n Examples:\n >>> determine_sign(10)\n 'positive'\n >>> determine_sign(0)\n 'zero'\n >>> determine_sign(-5)\n 'negative'", "instruction": "Write a Perl function `sub determine_sign {` to solve the following problem: Determine the sign of a given integer N.\n The function takes an integer N as input and returns a string indicating whether the number is 'positive', 'zero', or 'negative'.\n - If N is greater than 0, it returns 'positive'.\n - If N is exactly 0, it returns 'zero'.\n - If N is less than 0, it returns 'negative'.\n Examples:\n >>> determine_sign(10)\n 'positive'\n >>> determine_sign(0)\n 'zero'\n >>> determine_sign(-5)\n 'negative'", "level": "easy"}
{"task_id": "Perl/43", "prompt": "sub calculate_power_of_two {\n    # Calculate 2 raised to the power of a given non-negative integer n.\n    # This function takes a single integer argument n (where 0 <= n < 31) and returns the value of 2^n.\n    # It's a straightforward implementation of exponential calculation, specifically for the base 2.\n    # Examples:\n    # >>> calculate_power_of_two(3)\n    # 8\n    # >>> calculate_power_of_two(5)\n    # 32\n    # >>> calculate_power_of_two(0)\n    # 1", "canonical_solution": "    my ($n) = @_;\n    return 2 ** $n;\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected 8, got \" . &$func(3) unless &$func(3) == 8;\n    die \"Test failed! Expected 32, got \" . &$func(5) unless &$func(5) == 32;\n    die \"Test failed! Expected 1, got \" . &$func(0) unless &$func(0) == 1;\n    die \"Test failed! Expected 1024, got \" . &$func(10) unless &$func(10) == 1024;\n    die \"Test failed! Expected 64, got \" . &$func(6) unless &$func(6) == 64;\n}\n\ncheck(\\&calculate_power_of_two);", "entry_point": "calculate_power_of_two", "signature": "sub calculate_power_of_two {", "docstring": " Calculate 2 raised to the power of a given non-negative integer n.\n This function takes a single integer argument n (where 0 <= n < 31) and returns the value of 2^n.\n It's a straightforward implementation of exponential calculation, specifically for the base 2.\n Examples:\n >>> calculate_power_of_two(3)\n 8\n >>> calculate_power_of_two(5)\n 32\n >>> calculate_power_of_two(0)\n 1", "instruction": "Write a Perl function `sub calculate_power_of_two {` to solve the following problem: Calculate 2 raised to the power of a given non-negative integer n.\n This function takes a single integer argument n (where 0 <= n < 31) and returns the value of 2^n.\n It's a straightforward implementation of exponential calculation, specifically for the base 2.\n Examples:\n >>> calculate_power_of_two(3)\n 8\n >>> calculate_power_of_two(5)\n 32\n >>> calculate_power_of_two(0)\n 1", "level": "easy"}
{"task_id": "Perl/44", "prompt": "sub multiply_two_numbers {\n    # Multiply two positive integers A and B, and return their product.\n    # Given two positive integers A and B, this function calculates the product A * B, taking into account the range of the result and selecting an appropriate data type.\n    # The function assumes that 1 <= A, B <= 50000, adhering to the constraints provided in the input format.\n    # Examples:\n    # >>> multiply_two_numbers(3, 4)\n    # 12\n    # >>> multiply_two_numbers(36, 18)\n    # 648\n    # >>> multiply_two_numbers(1, 50000)\n    # 50000", "canonical_solution": "    my ($A, $B) = @_;\n    return $A * $B;\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected 12, got \" . &$func(3, 4) unless &$func(3, 4) == 12;\n    die \"Test failed! Expected 648, got \" . &$func(36, 18) unless &$func(36, 18) == 648;\n    die \"Test failed! Expected 50000, got \" . &$func(1, 50000) unless &$func(1, 50000) == 50000;\n    die \"Test failed! Expected 250000, got \" . &$func(50, 5000) unless &$func(50, 5000) == 250000;\n    die \"Test failed! Expected 1000000, got \" . &$func(200, 5000) unless &$func(200, 5000) == 1000000;\n\n}\n\ncheck(\\&multiply_two_numbers);", "entry_point": "multiply_two_numbers", "signature": "sub multiply_two_numbers {", "docstring": " Multiply two positive integers A and B, and return their product.\n Given two positive integers A and B, this function calculates the product A * B, taking into account the range of the result and selecting an appropriate data type.\n The function assumes that 1 <= A, B <= 50000, adhering to the constraints provided in the input format.\n Examples:\n >>> multiply_two_numbers(3, 4)\n 12\n >>> multiply_two_numbers(36, 18)\n 648\n >>> multiply_two_numbers(1, 50000)\n 50000", "instruction": "Write a Perl function `sub multiply_two_numbers {` to solve the following problem: Multiply two positive integers A and B, and return their product.\n Given two positive integers A and B, this function calculates the product A * B, taking into account the range of the result and selecting an appropriate data type.\n The function assumes that 1 <= A, B <= 50000, adhering to the constraints provided in the input format.\n Examples:\n >>> multiply_two_numbers(3, 4)\n 12\n >>> multiply_two_numbers(36, 18)\n 648\n >>> multiply_two_numbers(1, 50000)\n 50000", "level": "easy"}
{"task_id": "Perl/45", "prompt": "sub calculate_arithmetic_sequence_nth_term {\n    # Calculate the nth term of an arithmetic sequence given the first two terms a1 and a2.\n    # An arithmetic sequence is a sequence of numbers in which the difference between any two consecutive terms is constant.\n    # This function returns the value of the nth term in an arithmetic sequence, where the first two terms a1 and a2 are given,\n    # and the common difference d can be calculated as a2 - a1.\n    # Examples:\n    # >>> calculate_arithmetic_sequence_nth_term(1, 4, 100)\n    # 298", "canonical_solution": "    my ($a1, $a2, $n) = @_;\n    my $d = $a2 - $a1; # Common difference\n    return $a1 + ($n - 1) * $d;\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected 298, got \" . &$func(1, 4, 100) unless &$func(1, 4, 100) == 298;\n    die \"Test failed! Expected 8, got \" . &$func(2, 5, 3) unless &$func(2, 5, 3) == 8;\n    die \"Test failed! Expected 11, got \" . &$func(-1, 3, 5) unless &$func(-1, 3, 5) == 15;\n    die \"Test failed! Expected 200, got \" . &$func(1, 3, 100) unless &$func(1, 3, 100) == 199;\n    die \"Test failed! Expected -97, got \" . &$func(-100, -99, 4) unless &$func(-100, -99, 4) == -97;\n}\n\ncheck(\\&calculate_arithmetic_sequence_nth_term);", "entry_point": "calculate_arithmetic_sequence_nth_term", "signature": "sub calculate_arithmetic_sequence_nth_term {", "docstring": " Calculate the nth term of an arithmetic sequence given the first two terms a1 and a2.\n An arithmetic sequence is a sequence of numbers in which the difference between any two consecutive terms is constant.\n This function returns the value of the nth term in an arithmetic sequence, where the first two terms a1 and a2 are given,\n and the common difference d can be calculated as a2 - a1.\n Examples:\n >>> calculate_arithmetic_sequence_nth_term(1, 4, 100)\n 298", "instruction": "Write a Perl function `sub calculate_arithmetic_sequence_nth_term {` to solve the following problem: Calculate the nth term of an arithmetic sequence given the first two terms a1 and a2.\n An arithmetic sequence is a sequence of numbers in which the difference between any two consecutive terms is constant.\n This function returns the value of the nth term in an arithmetic sequence, where the first two terms a1 and a2 are given,\n and the common difference d can be calculated as a2 - a1.\n Examples:\n >>> calculate_arithmetic_sequence_nth_term(1, 4, 100)\n 298", "level": "easy"}
{"task_id": "Perl/46", "prompt": "sub reverse_three_digit_number {\n    # Reverse a three-digit number.\n    # This function takes a three-digit integer as input and returns its reverse as a string. This is to ensure that the result\n    # preserves any leading zeros that become trailing zeros upon reversal. For example, reversing 100 yields \"001\", not simply 1.\n    # Note: The input is assumed to be strictly a three-digit integer.\n    # Examples:\n    # >>> reverse_three_digit_number(358)\n    # '853'", "canonical_solution": "    my ($n) = @_;\n    my $reversed = reverse $n;\n    return sprintf(\"%03d\", $reversed); # Format to ensure three digits are returned\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected '853', got '\" . &$func(358) . \"'\" unless &$func(358) eq '853';\n    die \"Test failed! Expected '001', got '\" . &$func(100) . \"'\" unless &$func(100) eq '001';\n    die \"Test failed! Expected '876', got '\" . &$func(678) . \"'\" unless &$func(678) eq '876';\n}\n\ncheck(\\&reverse_three_digit_number);", "entry_point": "reverse_three_digit_number", "signature": "sub reverse_three_digit_number {", "docstring": " Reverse a three-digit number.\n This function takes a three-digit integer as input and returns its reverse as a string. This is to ensure that the result\n preserves any leading zeros that become trailing zeros upon reversal. For example, reversing 100 yields \"001\", not simply 1.\n Note: The input is assumed to be strictly a three-digit integer.\n Examples:\n >>> reverse_three_digit_number(358)\n '853'", "instruction": "Write a Perl function `sub reverse_three_digit_number {` to solve the following problem: Reverse a three-digit number.\n This function takes a three-digit integer as input and returns its reverse as a string. This is to ensure that the result\n preserves any leading zeros that become trailing zeros upon reversal. For example, reversing 100 yields \"001\", not simply 1.\n Note: The input is assumed to be strictly a three-digit integer.\n Examples:\n >>> reverse_three_digit_number(358)\n '853'", "level": "easy"}
{"task_id": "Perl/47", "prompt": "sub convert_int_to_bool_to_int {\n    # Convert an integer to a boolean and then back to an integer.\n    # This function takes an integer as input, converts it to a boolean value (where any non-zero integer is considered true and zero is considered false),\n    # and then converts this boolean value back to an integer. In Perl, true is represented by 1 and false by an empty string (''), but for the purpose of this\n    # function, false will be converted back to 0.\n    # Examples:\n    # >>> convert_int_to_bool_to_int(3)\n    # 1\n    # >>> convert_int_to_bool_to_int(0)\n    # 0\n    # >>> convert_int_to_bool_to_int(-1)\n    # 1", "canonical_solution": "    my ($int_value) = @_;\n    my $bool_value = $int_value ? 1 : 0; # Convert to boolean\n    return $bool_value; # Convert boolean back to integer (Perl automatically uses 1 for true)\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected 1, got \" . &$func(3) unless &$func(3) == 1;\n    die \"Test failed! Expected 0, got \" . &$func(0) unless &$func(0) == 0;\n    die \"Test failed! Expected 1, got \" . &$func(-1) unless &$func(-1) == 1;\n    die \"Test failed! Expected 1, got \" . &$func(100) unless &$func(100) == 1;\n    die \"Test failed! Expected 1, got \" . &$func(-100) unless &$func(-100) == 1;\n}\n\ncheck(\\&convert_int_to_bool_to_int);", "entry_point": "convert_int_to_bool_to_int", "signature": "sub convert_int_to_bool_to_int {", "docstring": " Convert an integer to a boolean and then back to an integer.\n This function takes an integer as input, converts it to a boolean value (where any non-zero integer is considered true and zero is considered false),\n and then converts this boolean value back to an integer. In Perl, true is represented by 1 and false by an empty string (''), but for the purpose of this\n function, false will be converted back to 0.\n Examples:\n >>> convert_int_to_bool_to_int(3)\n 1\n >>> convert_int_to_bool_to_int(0)\n 0\n >>> convert_int_to_bool_to_int(-1)\n 1", "instruction": "Write a Perl function `sub convert_int_to_bool_to_int {` to solve the following problem: Convert an integer to a boolean and then back to an integer.\n This function takes an integer as input, converts it to a boolean value (where any non-zero integer is considered true and zero is considered false),\n and then converts this boolean value back to an integer. In Perl, true is represented by 1 and false by an empty string (''), but for the purpose of this\n function, false will be converted back to 0.\n Examples:\n >>> convert_int_to_bool_to_int(3)\n 1\n >>> convert_int_to_bool_to_int(0)\n 0\n >>> convert_int_to_bool_to_int(-1)\n 1", "level": "easy"}
{"task_id": "Perl/48", "prompt": "sub ascii_to_char {\n    # Convert an ASCII code to its corresponding character.\n    # This function takes an integer representing an ASCII code (within the range of visible characters, i.e., >0 and <128) and returns the character that corresponds to that ASCII code.\n    # It is guaranteed that the input will be within the valid range for ASCII codes that correspond to visible characters.\n    # Examples:\n    # >>> ascii_to_char(65)\n    # 'A'\n    # >>> ascii_to_char(97)\n    # 'a'\n    # >>> ascii_to_char(48)\n    # '0'", "canonical_solution": "    my ($ascii_code) = @_;\n    return chr($ascii_code);\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed! Expected 'A', got '\" . &$func(65) . \"'\" unless &$func(65) eq 'A';\n    die \"Test failed! Expected 'a', got '\" . &$func(97) . \"'\" unless &$func(97) eq 'a';\n    die \"Test failed! Expected '0', got '\" . &$func(48) . \"'\" unless &$func(48) eq '0';\n    die \"Test failed! Expected '@', got '\" . &$func(64) . \"'\" unless &$func(64) eq '@';\n    die \"Test failed! Expected '}', got '\" . &$func(125) . \"'\" unless &$func(125) eq '}';\n}\n\ncheck(\\&ascii_to_char);", "entry_point": "ascii_to_char", "signature": "sub ascii_to_char {", "docstring": " Convert an ASCII code to its corresponding character.\n This function takes an integer representing an ASCII code (within the range of visible characters, i.e., >0 and <128) and returns the character that corresponds to that ASCII code.\n It is guaranteed that the input will be within the valid range for ASCII codes that correspond to visible characters.\n Examples:\n >>> ascii_to_char(65)\n 'A'\n >>> ascii_to_char(97)\n 'a'\n >>> ascii_to_char(48)\n '0'", "instruction": "Write a Perl function `sub ascii_to_char {` to solve the following problem: Convert an ASCII code to its corresponding character.\n This function takes an integer representing an ASCII code (within the range of visible characters, i.e., >0 and <128) and returns the character that corresponds to that ASCII code.\n It is guaranteed that the input will be within the valid range for ASCII codes that correspond to visible characters.\n Examples:\n >>> ascii_to_char(65)\n 'A'\n >>> ascii_to_char(97)\n 'a'\n >>> ascii_to_char(48)\n '0'", "level": "easy"}
{"task_id": "Perl/49", "prompt": "sub ascii_code {\n    # This function takes a single character as input and returns its ASCII code.\n    # ASCII (American Standard Code for Information Interchange) is a character encoding standard for electronic communication.\n    # ASCII codes represent text in computers, telecommunications equipment, and other devices that use text.\n    # For example, the ASCII code for 'A' is 65.", "canonical_solution": "    my ($char) = @_;\n    return ord($char);\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed!\" unless &$func('A') == 65;\n    die \"Test failed!\" unless &$func('B') == 66;\n    die \"Test failed!\" unless &$func('C') == 67;\n    die \"Test failed!\" unless &$func('a') == 97;\n    die \"Test failed!\" unless &$func('b') == 98;\n    die \"Test failed!\" unless &$func('c') == 99;\n    die \"Test failed!\" unless &$func('0') == 48;\n    die \"Test failed!\" unless &$func('1') == 49;\n    die \"Test failed!\" unless &$func('2') == 50;\n}\n\ncheck(\\&ascii_code);", "entry_point": "ascii_code", "signature": "sub ascii_code {", "docstring": " This function takes a single character as input and returns its ASCII code.\n ASCII (American Standard Code for Information Interchange) is a character encoding standard for electronic communication.\n ASCII codes represent text in computers, telecommunications equipment, and other devices that use text.\n For example, the ASCII code for 'A' is 65.", "instruction": "Write a Perl function `sub ascii_code {` to solve the following problem: This function takes a single character as input and returns its ASCII code.\n ASCII (American Standard Code for Information Interchange) is a character encoding standard for electronic communication.\n ASCII codes represent text in computers, telecommunications equipment, and other devices that use text.\n For example, the ASCII code for 'A' is 65.", "level": "easy"}
{"task_id": "Perl/50", "prompt": "sub calculate_expression {\n    # This function calculates the value of the expression (a + b) * c.\n    # It takes three integers a, b, and c as input and returns the result of the expression.\n    # For example, if a=2, b=3, and c=5, the function will return 25.", "canonical_solution": "    my ($a, $b, $c) = @_;\n    return ($a + $b) * $c;\n}", "test": "sub check {\n    my $func = shift;\n    die \"Test failed!\" unless &$func(2, 3, 5) == 25;\n    die \"Test failed!\" unless &$func(10, 20, 3) == 90;\n    die \"Test failed!\" unless &$func(-1, 1, 1) == 0;\n    die \"Test failed!\" unless &$func(0, 0, 1) == 0;\n}\n\ncheck(\\&calculate_expression);", "entry_point": "calculate_expression", "signature": "sub calculate_expression {", "docstring": " This function calculates the value of the expression (a + b) * c.\n It takes three integers a, b, and c as input and returns the result of the expression.\n For example, if a=2, b=3, and c=5, the function will return 25.", "instruction": "Write a Perl function `sub calculate_expression {` to solve the following problem: This function calculates the value of the expression (a + b) * c.\n It takes three integers a, b, and c as input and returns the result of the expression.\n For example, if a=2, b=3, and c=5, the function will return 25.", "level": "easy"}
