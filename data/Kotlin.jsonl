{"task_id": "Kotlin/1", "prompt": "/**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean", "canonical_solution": "{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}", "test": "// Test cases\nfun main() {\n    println(\"start\")\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n\n}", "entry_point": "hasCloseElements", "signature": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Write a Kotlin function `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "level": "easy"}
{"task_id": "Kotlin/2", "prompt": "/**\n * Finds all Armstrong numbers within a specified range.\n * An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\n * For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ", "canonical_solution": "{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}", "test": "fun main() {\n    check(findArmstrongNumbersInRange(1, 500) == listOf(1, 153, 370, 371, 407))\n    check(findArmstrongNumbersInRange(500, 1000) == emptyList<Int>())\n    check(findArmstrongNumbersInRange(1, 100) == listOf(1))\n    check(findArmstrongNumbersInRange(100, 200) == listOf(153))\n    check(findArmstrongNumbersInRange(100, 1000) == listOf(153, 370, 371, 407))\n}\n\n\nmain()", "entry_point": "findArmstrongNumbersInRange", "signature": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>", "docstring": "Finds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()", "instruction": "Write a Kotlin function `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` to solve the following problem:\nFinds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()", "level": "middle"}
{"task_id": "Kotlin/3", "prompt": "/**\n * Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\n * to safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\n * so you need to ensure that no M consecutive test tubes contain chemicals.\n *\n * Write a function that calculates the total number of safe placement options.\n *\n * Example:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Constraints:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Note: The result can be a large number, so return it as a Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long", "canonical_solution": "{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}", "test": "fun main() {\n    // Test cases\n    check(countSafePlacementOptions(4, 3) == 13L)\n    check(countSafePlacementOptions(3, 2) == 5L)\n    check(countSafePlacementOptions(5, 2) == 13L)\n    check(countSafePlacementOptions(7, 3) == 81L)\n    check(countSafePlacementOptions(10, 4) == 773L)\n    check(countSafePlacementOptions(12, 5) == 3525L)\n}\n\nmain()", "entry_point": "countSafePlacementOptions", "signature": "fun countSafePlacementOptions(N: Int, M: Int): Long", "docstring": "Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.", "instruction": "Write a Kotlin function `fun countSafePlacementOptions(N: Int, M: Int): Long` to solve the following problem:\nGiven a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.", "level": "easy"}
{"task_id": "Kotlin/4", "prompt": "/**\n * Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\n * that are both prime and palindrome.\n *\n * Example:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n *\n * Note:\n * - A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n * - A palindrome number is a number that reads the same forwards and backwards.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ", "canonical_solution": "{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}", "test": "fun main() {\n    check(countPrimePalindromeNumbers(50) == 1) // There are two prime palindrome numbers between 11 and 50 (11).\n    check(countPrimePalindromeNumbers(150) == 3) // There are three prime palindrome numbers between 11 and 100 (11, 101, 131).\n    check(countPrimePalindromeNumbers(200) == 6) // There are four prime palindrome numbers between 11 and 200 (11, 101, 131, 151, 181, 191).\n    check(countPrimePalindromeNumbers(11) == 1)  // The only prime palindrome number between 11 and 11 is 11 itself.\n}\n\nmain()", "entry_point": "countPrimePalindromeNumbers", "signature": "fun countPrimePalindromeNumbers(n: Int): Int", "docstring": "Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.", "instruction": "Write a Kotlin function `fun countPrimePalindromeNumbers(n: Int): Int` to solve the following problem:\nGiven an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.", "level": "middle"}
{"task_id": "Kotlin/5", "prompt": "\n/**\n    * Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\n    * A Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\n    * The function returns a list of triples (a, b, c) that satisfy the conditions.\n    *\n    * Example:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n    * (3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n    * (5, 12, 13) and (6, 8, 10) are other valid triplets.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ", "canonical_solution": "{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}", "test": "fun main() {\n    val result1 = findPythagoreanTriplets(20)\n    val expected1 = listOf(Triple(3, 4, 5))\n    check(result1 == expected1) // Should print true\n\n    \n    val result2 = findPythagoreanTriplets(30)\n    val expected2 = listOf(Triple(3, 4, 5), Triple(5, 12, 13), Triple(6, 8, 10))\n    check(result2 == expected2) // Should print true\n \n}\n\n\nmain()", "entry_point": "findPythagoreanTriplets", "signature": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>", "docstring": "Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.", "instruction": "Write a Kotlin function `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` to solve the following problem:\nGiven a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.", "level": "middle"}
{"task_id": "Kotlin/6", "prompt": "/**\n * Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\n * and counts the number of words in it. Words in the input string are separated by spaces.\n *\n * Example:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int", "canonical_solution": "{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}", "test": "fun main() {\n    // Test cases\n    check(countWords(\"This is a book\") == 4)\n    check(countWords(\"   Hello   World!  World World \") == 3)\n    check(countWords(\"A  string  with  multiple  spaces\") == 5)\n    check(countWords(\"\") == 0) // Edge case: Empty string should have 0 words\n    check(countWords(\"SingleWord\") == 1) // Edge case: String with a single word\n    check(countWords(\"a a a a a a a a a a a a\") == 1) \n    check(countWords(\"a a a ab ab c c c c c c b a c\") == 4) \n}\n\n\nmain()", "entry_point": "countWords", "signature": "fun countWords(inputString: String): Int", "docstring": "Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5", "instruction": "Write a Kotlin function `fun countWords(inputString: String): Int` to solve the following problem:\nWrite a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5", "level": "hard"}
{"task_id": "Kotlin/7", "prompt": "\n\n/**\n  * Generates a Pascal's Triangle up to the specified number of rows.\n  * In Pascal's Triangle, each number is the sum of the two numbers directly above it.\n  * The function returns a list of lists, where each inner list represents a row in the triangle.\n  *\n  * Example:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ", "canonical_solution": "{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}", "test": "fun main() {\n    check(generatePascalsTriangle(1) == listOf(listOf(1)))\n    check(generatePascalsTriangle(2) == listOf(listOf(1), listOf(1, 1)))\n    check(generatePascalsTriangle(3) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1)))\n    check(generatePascalsTriangle(4) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1)))\n    check(generatePascalsTriangle(5) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1)))\n    check(generatePascalsTriangle(6) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1), listOf(1, 5, 10, 10, 5, 1)))\n\n}\n\nmain()", "entry_point": "generatePascalsTriangle", "signature": "fun generatePascalsTriangle(rows: Int): List<List<Int>>", "docstring": "Generates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]", "instruction": "Write a Kotlin function `fun generatePascalsTriangle(rows: Int): List<List<Int>>` to solve the following problem:\nGenerates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]", "level": "middle"}
{"task_id": "Kotlin/8", "prompt": "/**\n * Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n * - For profit up to 100,000, the bonus is 10%.\n * - For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n * - For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n * - For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n * - For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n * - For profit above 1,000,000, it's 1% for the amount over 1,000,000. \n * The function returns the total bonus amount.\n * Example:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ", "canonical_solution": "{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}", "test": "fun main(){\n    check(calculateBonus(50_000.00) == 5000.00)\n    check(calculateBonus(210_000.00) == 18000.00)\n    check(calculateBonus(150_000.00) == 13750.00)\n    check(calculateBonus(250_000.00) == 20000.00)\n    check(calculateBonus(450_000.00) == 29000.00)\n    check(calculateBonus(650_000.00) == 34250.00)\n    check(calculateBonus(1_050_000.00) == 40000.00)\n    check(calculateBonus(2_000_000.00) == 49500.00)\n}\n\nmain()", "entry_point": "calculateBonus", "signature": "fun calculateBonus(profit: Double): Double", "docstring": "Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00", "instruction": "Write a Kotlin function `fun calculateBonus(profit: Double): Double` to solve the following problem:\nCalculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00", "level": "middle"}
{"task_id": "Kotlin/9", "prompt": "/**\n    * Returns the top ten highest scores from a given list of scores, sorted in descending order.\n    * If there are fewer than ten scores in the list, all scores are returned.\n    * Example:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ", "canonical_solution": "{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}", "test": "fun main(){\n    check(topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5)) == listOf(22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5))\n    check(topTenScores(listOf(5.0, 3.0, 4.0)) == listOf(5.0, 4.0, 3.0))\n    check(topTenScores(listOf(8.0, 7.5, 9.0, 10.0)) == listOf(10.0, 9.0, 8.0, 7.5))\n    check(topTenScores(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) == listOf(12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0))\n    check(topTenScores(listOf(32.0, 31.5, 33.0, 30.0)) == listOf(33.0, 32.0, 31.5, 30.0))\n}\n\nmain()", "entry_point": "topTenScores", "signature": "fun topTenScores(scores: List<Double>): List<Double>", "docstring": "Returns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]", "instruction": "Write a Kotlin function `fun topTenScores(scores: List<Double>): List<Double>` to solve the following problem:\nReturns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]", "level": "easy"}
{"task_id": "Kotlin/10", "prompt": "/**\n * Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\n * If multiple elements have the same absolute value, the one with the smallest row index is returned,\n * and if there is still a tie, the one with the smallest column index is chosen.\n *\n * Example:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Absolute value 12 at row 2, column 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ", "canonical_solution": "{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}", "test": "fun main() {\n    check(findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(1, -2, 3, -4), arrayOf(0, 6, -7, 8), arrayOf(9, -10, -11, -12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(4, 4, -3, -2), arrayOf(-1, 0, 4, 4), arrayOf(-2, -3, 4, -4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0))) == Triple(0, 0, 0))\n}\nmain()", "entry_point": "findMaxAbsElement", "signature": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>", "docstring": "Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)", "instruction": "Write a Kotlin function `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` to solve the following problem:\nFinds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)", "level": "middle"}
{"task_id": "Kotlin/11", "prompt": "/**\n    * Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\n    * The interest is compounded monthly based on the total amount in the account at the end of each month.\n    Example:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ", "canonical_solution": "{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}", "test": "fun main(){\n    check(calculateSavingsInterest(1000.0, 0.01, 6) == 6213.54)\n    check(calculateSavingsInterest(500.0, 0.02, 12) == 6840.17)\n    check(calculateSavingsInterest(2000.0, 0.005, 3) == 6060.2)\n    check(calculateSavingsInterest(750.0, 0.01, 10) == 7925.13)\n}\nmain()", "entry_point": "calculateSavingsInterest", "signature": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double", "docstring": "Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17", "instruction": "Write a Kotlin function `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` to solve the following problem:\nCalculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17", "level": "easy"}
{"task_id": "Kotlin/12", "prompt": "/**\n * Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n * \n * Example:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ", "canonical_solution": "{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}", "test": "fun main() {\n    check(printDivisibleNumbersInRange(1, 10, 2) == listOf(2, 4, 6, 8, 10))\n    check(printDivisibleNumbersInRange(3, 15, 3) == listOf(3, 6, 9, 12, 15))\n    check(printDivisibleNumbersInRange(5, 20, 5) == listOf(5, 10, 15, 20))\n    check(printDivisibleNumbersInRange(7, 21, 7) == listOf(7, 14, 21))\n    check(printDivisibleNumbersInRange(10, 30, 10) == listOf(10, 20, 30))\n}\n\nmain()", "entry_point": "printDivisibleNumbersInRange", "signature": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>", "docstring": "Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]", "instruction": "Write a Kotlin function `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` to solve the following problem:\nGenerates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]", "level": "easy"}
{"task_id": "Kotlin/13", "prompt": "/**\n * Converts a given integer to its octal, decimal, and hexadecimal representations.\n * Args:\n *   number: An integer number to be converted.\n * Returns:\n *   A Triple containing the octal, decimal, and hexadecimal representations of the number.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ", "canonical_solution": "{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}", "test": "fun main() {\n    check(convertNumberToDifferentBases(10) == Triple(\"12\", \"10\", \"A\"))\n    check(convertNumberToDifferentBases(255) == Triple(\"377\", \"255\", \"FF\"))\n    check(convertNumberToDifferentBases(16) == Triple(\"20\", \"16\", \"10\"))\n    check(convertNumberToDifferentBases(1) == Triple(\"1\", \"1\", \"1\"))\n    check(convertNumberToDifferentBases(0) == Triple(\"0\", \"0\", \"0\"))\n    check(convertNumberToDifferentBases(100) == Triple(\"144\", \"100\", \"64\"))\n    check(convertNumberToDifferentBases(500) == Triple(\"764\", \"500\", \"1F4\"))\n}\n\nmain()", "entry_point": "convertNumberToDifferentBases", "signature": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>", "docstring": "Converts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")", "instruction": "Write a Kotlin function `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` to solve the following problem:\nConverts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")", "level": "easy"}
{"task_id": "Kotlin/14", "prompt": "/**\n * Returns a list of all factors of the given number, excluding the number itself.\n * A factor is a number that divides the given number without leaving a remainder.\n * Examples:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ", "canonical_solution": "{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}", "test": "fun main(){\n    check(listFactors(10) == listOf(1, 2, 5))\n    check(listFactors(15) == listOf(1, 3, 5))\n    check(listFactors(7) == listOf(1))\n    check(listFactors(12) == listOf(1, 2, 3, 4, 6))\n    check(listFactors(9) == listOf(1, 3))\n    check(listFactors(17) == listOf(1))\n    check(listFactors(20) == listOf(1, 2, 4, 5, 10))\n}\n\nmain()", "entry_point": "listFactors", "signature": "fun listFactors(number: Int): List<Int>", "docstring": "Returns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]", "instruction": "Write a Kotlin function `fun listFactors(number: Int): List<Int>` to solve the following problem:\nReturns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]", "level": "easy"}
{"task_id": "Kotlin/15", "prompt": "import java.util.LinkedList\n\n/**\n    * Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n    * \n    * The process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\n    * the current number is removed from the sequence. This process continues until only one number remains in the sequence.\n    *\n    * Examples:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ", "canonical_solution": "{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}", "test": "fun main(){\n    check(findLastRemaining(5) == 4)\n    check(findLastRemaining(10) == 4)\n    check(findLastRemaining(6) == 1)\n    check(findLastRemaining(7) == 4)\n    check(findLastRemaining(15) == 5)\n    check(findLastRemaining(20) == 20)\n    check(findLastRemaining(1) == 1)\n}\nmain()", "entry_point": "findLastRemaining", "signature": "fun findLastRemaining(n: Int): Int", "docstring": "Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4", "instruction": "Write a Kotlin function `fun findLastRemaining(n: Int): Int` to solve the following problem:\nFinds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4", "level": "easy"}
{"task_id": "Kotlin/16", "prompt": "/**\n    * Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\n    * starting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\n    Examples:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ", "canonical_solution": "{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}", "test": "fun main(){\n    check(extractAndConvertToDecimal(217) == 13)  // 173 in binary is 10101101, bits 4-7 are 1101\n    check(extractAndConvertToDecimal(173) == 10)  // 173 in binary is 10101101, bits 4-7 are 1010\n    check(extractAndConvertToDecimal(59) == 3)    // 59 in binary is 111011, bits 4-7 are 0011\n    check(extractAndConvertToDecimal(32) == 2)    // 32 in binary is 100000, bits 4-7 are 0010\n    check(extractAndConvertToDecimal(255) == 15)  // 255 in binary is 11111111, bits 4-7 are 1111\n    check(extractAndConvertToDecimal(1) == 0)     // 1 in binary is 1, bits 4-7 are 0000\n\n}\n\nmain()", "entry_point": "extractAndConvertToDecimal", "signature": "fun extractAndConvertToDecimal(number: Int): Int", "docstring": "Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3", "instruction": "Write a Kotlin function `fun extractAndConvertToDecimal(number: Int): Int` to solve the following problem:\nExtracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3", "level": "easy"}
{"task_id": "Kotlin/17", "prompt": "/**\n * Performs a right circular shift on a given unsigned 32-bit integer.\n * The function shifts the bits of the input number to the right by a specified number of positions.\n * The bits that are shifted out on the right are reinserted on the left side.\n * \n * Example:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ", "canonical_solution": "{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}", "test": "fun main() {\n    check(circularRightShift(1023u, 20) == 4190208u)\n    check(circularRightShift(15u, 2) == 3221225475u)\n    check(circularRightShift(256u, 8) == 1u)\n    check(circularRightShift(123u, 5) == 3623878659u)\n    check(circularRightShift(4294967295u, 1) == 4294967295u)\n    check(circularRightShift(1024u, 10) == 1u)\n    check(circularRightShift(0u, 15) == 0u)\n}\nmain()", "entry_point": "circularRightShift", "signature": "fun circularRightShift(num: UInt, shift: Int): UInt", "docstring": "Performs a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u", "instruction": "Write a Kotlin function `fun circularRightShift(num: UInt, shift: Int): UInt` to solve the following problem:\nPerforms a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u", "level": "easy"}
{"task_id": "Kotlin/18", "prompt": "/**\n    * Determines if a given integer is a perfect number. A perfect number is one whose\n    * sum of all positive divisors (excluding itself) equals the number itself.\n    * \n    * Examples:\n    * - isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) returns false because 1 + 2 + 5 \u2260 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ", "canonical_solution": "{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}", "test": "fun main(){\n    check(isPerfectNumber(1) == false)  // 6 is a perfect number\n    check(isPerfectNumber(6) == true)  // 6 is a perfect number\n    check(isPerfectNumber(28) == true)  // 28 is a perfect number\n    check(isPerfectNumber(10) == false)  // 10 is not a perfect number\n    check(isPerfectNumber(496) == true)  // 496 is a perfect number\n    check(isPerfectNumber(8128) == true)  // 8128 is a perfect number\n    check(isPerfectNumber(15) == false)  // 15 is not a perfect number\n    check(isPerfectNumber(20) == false)  // 20 is not a perfect number\n\n\n}\nmain()", "entry_point": "isPerfectNumber", "signature": "fun isPerfectNumber(number: Int): Boolean", "docstring": "Determines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 \u2260 10", "instruction": "Write a Kotlin function `fun isPerfectNumber(number: Int): Boolean` to solve the following problem:\nDetermines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 \u2260 10", "level": "easy"}
{"task_id": "Kotlin/19", "prompt": "\n/**\n * Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\n * Example:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ", "canonical_solution": "{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}", "test": "fun main(){\n    check(calculateMaxVaccinations(10, 200) == 0)\n    check(calculateMaxVaccinations(150, 100) == 2)\n    check(calculateMaxVaccinations(500, 100) == 4)\n    check(calculateMaxVaccinations(300, 50) == 3)\n    check(calculateMaxVaccinations(0, 200) == 0)\n    check(calculateMaxVaccinations(100, 20) == 0)\n    check(calculateMaxVaccinations(120, 100) == 1)\n    check(calculateMaxVaccinations(400, 0) == 3)\n\n}\nmain()", "entry_point": "calculateMaxVaccinations", "signature": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int", "docstring": "Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4", "instruction": "Write a Kotlin function `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` to solve the following problem:\nTime passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4", "level": "hard"}
{"task_id": "Kotlin/20", "prompt": "\n/**\n * Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\n * on two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n * \n * Example:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ", "canonical_solution": "{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}", "test": "fun main(){\n    check(simpleCalculator(10, 5, '+') == 15)\n    check(simpleCalculator(10, 5, '-') == 5)\n    check(simpleCalculator(10, 5, '*') == 50)\n    check(simpleCalculator(10, 5, '/') == 2)\n    check(simpleCalculator(10, 5, '%') == 0)\n    check(simpleCalculator(15, 4, '/') == 3)\n    check(simpleCalculator(15, 4, '%') == 3)\n    check(simpleCalculator(15, 0, '/') == \"invalid calc\")\n    check(simpleCalculator(15, 0, '%') == \"invalid calc\")\n\n}\nmain()", "entry_point": "simpleCalculator", "signature": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any", "docstring": "Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2", "instruction": "Write a Kotlin function `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` to solve the following problem:\nPerform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2", "level": "easy"}
{"task_id": "Kotlin/21", "prompt": "\n/**\n * Calculates the number of passengers on a bus at a specific station.\n * \n * The bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off, \n * so the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers \n * that got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the \n * previous station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n *\n * @param a The number of passengers boarding at the first station.\n * @param n The total number of stations.\n * @param m The number of passengers who get off at the last station.\n * @param x The station number for which the passenger count is required.\n * @return The number of passengers on the bus as it leaves station 'x'.\n *\n * Example:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ", "canonical_solution": "{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}", "test": "fun main() {\n    check(busStationPassengers(5, 7, 32, 5) == 21)\n    check(busStationPassengers(5, 7, 32, 4) == 13)\n    check(busStationPassengers(5, 7, 32, 3) == 10)\n    check(busStationPassengers(5, 7, 32, 2) == 5)\n    \n\n}\nmain()", "entry_point": "busStationPassengers", "signature": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int", "docstring": "Calculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13", "instruction": "Write a Kotlin function `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` to solve the following problem:\nCalculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13", "level": "hard"}
{"task_id": "Kotlin/22", "prompt": "\n/**\n    * Calculate the number of ways a person can mistakenly put letters in envelopes\n    * such that each letter ends up in the wrong envelope.\n    *\n    * This is based on a derangement problem where each item (letter) must not be\n    * in its original position (envelope).\n    *\n    * Parameters:\n    * n - the number of letters and envelopes.\n    *\n    * Returns:\n    * The total number of ways to wrongly place all the letters.\n    *\n    * Examples:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ", "canonical_solution": "{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}", "test": "fun main() {\n    check(countWrongEnvelopeCombinations(2) == 1L)\n    check(countWrongEnvelopeCombinations(3) == 2L)\n    check(countWrongEnvelopeCombinations(4) == 9L) // Additional test case for 4 letters\n    check(countWrongEnvelopeCombinations(5) == 44L) // Additional test case for 5 letters\n    check(countWrongEnvelopeCombinations(15) == 481066515734L) // Additional test case for 15 letters\n}\nmain()", "entry_point": "countWrongEnvelopeCombinations", "signature": "fun countWrongEnvelopeCombinations(n: Int): Long", "docstring": "Calculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2", "instruction": "Write a Kotlin function `fun countWrongEnvelopeCombinations(n: Int): Long` to solve the following problem:\nCalculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2", "level": "easy"}
{"task_id": "Kotlin/23", "prompt": "/**\n * Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\n * It is required that all three denominations are used in the exchange.\n * Example:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ", "canonical_solution": "{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}", "test": "fun main(){\n\n    check(countExchangeWays(50) == 106)\n    check(countExchangeWays(20) == 13)\n    check(countExchangeWays(15) == 6)\n    check(countExchangeWays(12) == 3)\n\n}\n\nmain()", "entry_point": "countExchangeWays", "signature": "fun countExchangeWays(amount: Int): Int", "docstring": "Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13", "instruction": "Write a Kotlin function `fun countExchangeWays(amount: Int): Int` to solve the following problem:\nCalculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13", "level": "easy"}
{"task_id": "Kotlin/24", "prompt": "/**\n    * Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\n    * Hours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n    * \n    * Example:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ", "canonical_solution": "{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}", "test": "fun main(){\n\n\ncheck(addTimes(Triple(1, 2, 3), Triple(4, 5, 6)) == Triple(5, 7, 9))\ncheck(addTimes(Triple(23, 59, 59), Triple(0, 0, 1)) == Triple(24, 0, 0))\ncheck(addTimes(Triple(10, 30, 30), Triple(2, 35, 40)) == Triple(13, 6, 10))\ncheck(addTimes(Triple(0, 0, 0), Triple(0, 0, 0)) == Triple(0, 0, 0))\n\n}\n\nmain()", "entry_point": "addTimes", "signature": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>", "docstring": "Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)", "instruction": "Write a Kotlin function `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` to solve the following problem:\nAdds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)", "level": "easy"}
{"task_id": "Kotlin/25", "prompt": "/**\n    * Finds the mode (most frequent element) and its count in a given list of integers.\n    * If there are multiple modes, the smallest one is returned.\n    *\n    * Example:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 is the mode and it appears 3 times\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Both 1 and 3 are modes but 1 is smaller\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ", "canonical_solution": "{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}", "test": "fun main() {\n    check(findModeAndCount(listOf(1, 2, 2, 2, 3, 5)) == Pair(2, 3))\n    check(findModeAndCount(listOf(1, 1, 2, 3, 3)) == Pair(1, 2))\n    check(findModeAndCount(listOf(4, 4, 4, 5, 5, 6, 6, 6)) == Pair(4, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9)) == Pair(9, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9, 1, 1, 1, 1, 1)) == Pair(1, 5))\n}\n\nmain()", "entry_point": "findModeAndCount", "signature": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>", "docstring": "Finds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller", "instruction": "Write a Kotlin function `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` to solve the following problem:\nFinds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller", "level": "easy"}
{"task_id": "Kotlin/26", "prompt": "/**\n * Processes a given 2D array representing an image, applying a series of operations.\n * Each operation is represented by a character:\n * 'A' - Rotate the image 90 degrees clockwise.\n * 'B' - Rotate the image 90 degrees counterclockwise.\n * 'C' - Flip the image horizontally.\n * 'D' - Flip the image vertically.\n *\n * @param image A 2D array of integers representing the image's pixel grayscale values.\n * @param operations A string of characters representing the operations to be applied in sequence.\n * @return A 2D array of integers representing the processed image.\n *\n * Example:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ", "canonical_solution": "{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}", "test": "fun main() {\n    val image1 = arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10))\n    val result1 = processImage(image1, \"AC\")\n    check(result1.contentDeepEquals(arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))))\n\n    val image2 = arrayOf(arrayOf(1, 2), arrayOf(3, 4))\n    val result2 = processImage(image2, \"A\")\n    check(result2.contentDeepEquals(arrayOf(arrayOf(3, 1), arrayOf(4, 2))))\n\n    val result3 = processImage(image2, \"B\")\n    check(result3.contentDeepEquals(arrayOf(arrayOf(2, 4), arrayOf(1, 3))))\n\n    val result4 = processImage(image2, \"BD\")\n    check(result4.contentDeepEquals(arrayOf(arrayOf(1, 3), arrayOf(2, 4))))\n\n}\n\nmain()", "entry_point": "processImage", "signature": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>", "docstring": "Processes a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))", "instruction": "Write a Kotlin function `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` to solve the following problem:\nProcesses a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))", "level": "hard"}
{"task_id": "Kotlin/27", "prompt": "/**\n    * Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\n    * A prime pair is defined as two prime numbers where the difference between them is exactly 2.\n    * Example:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ", "canonical_solution": "{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}", "test": "fun main(){\n    check(findPrimePairs(10) == listOf(Pair(3, 5), Pair(5, 7)))\n    check(findPrimePairs(100) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13), Pair(17, 19), Pair(29, 31), Pair(41, 43), Pair(59, 61), Pair(71, 73)))\n    check(findPrimePairs(15) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13)))\n    check(findPrimePairs(1) == emptyList<Pair<Int, Int>>())\n}\n\n\nmain()", "entry_point": "findPrimePairs", "signature": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>", "docstring": "Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]", "instruction": "Write a Kotlin function `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` to solve the following problem:\nFinds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]", "level": "easy"}
{"task_id": "Kotlin/28", "prompt": "/**\n * Converts a number from one base to another.\n * The function takes an input number as a string (which can include digits and letters),\n * the base of this number, and the target base for conversion. The bases can range from 2 to 16.\n * The output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n *\n * Examples:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ", "canonical_solution": "{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}", "test": "fun main() {\n    check(convertBase(\"Aab3\", 15, 7) == \"210306\")\n    check(convertBase(\"101\", 2, 10) == \"5\")\n    check(convertBase(\"FF\", 16, 2) == \"11111111\")\n    check(convertBase(\"123\", 10, 16) == \"7B\")\n}\n\nmain()", "entry_point": "convertBase", "signature": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String", "docstring": "Converts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"", "instruction": "Write a Kotlin function `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` to solve the following problem:\nConverts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"", "level": "easy"}
{"task_id": "Kotlin/29", "prompt": "/**\n * Determines whether a given number string is a cyclic number.\n * A cyclic number is one where multiplying it by any number from 1 to its length,\n * results in a permutation of the original number.\n *\n * Examples:\n * >>> isCyclicNumber(\"142857\")\n *     1 // since 142857 is a cyclic number\n * >>> isCyclicNumber(\"123456\")\n *     0 // since 123456 is not a cyclic number\n */\n\nfun isCyclicNumber(numberString: String): Int ", "canonical_solution": "{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}", "test": "fun main(){\n    check(isCyclicNumber(\"142857\") == 1)\n    check(isCyclicNumber(\"123456\") == 0)\n    check(isCyclicNumber(\"076923\") == 0)\n    check(isCyclicNumber(\"1\") == 1)\n    check(isCyclicNumber(\"0\") == 1)\n\n}\n\nmain()", "entry_point": "isCyclicNumber", "signature": "fun isCyclicNumber(numberString: String): Int", "docstring": "Determines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number", "instruction": "Write a Kotlin function `fun isCyclicNumber(numberString: String): Int` to solve the following problem:\nDetermines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number", "level": "middle"}
{"task_id": "Kotlin/30", "prompt": "/**\n    * Sum the given list of fractions and simplify the resulting fraction.\n    * The simplification process involves finding the greatest common divisor (GCD)\n    * of the numerator and the denominator and dividing both by this GCD. \n    * If the denominator after simplification is 1, only the numerator is returned.\n    *\n    * Example:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String", "canonical_solution": "{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b", "test": "fun main() {\n    check(sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\")) == \"5/6\")\n    check(sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\")) == \"3/4\")\n    check(sumAndSimplifyFractions(listOf(\"1/8\", \"3/8\")) == \"1/2\")\n    check(sumAndSimplifyFractions(listOf(\"2/3\", \"1/3\")) == \"1\")\n}\n\n\nmain()", "entry_point": "sumAndSimplifyFractions", "signature": "fun sumAndSimplifyFractions(fractions: List<String>): String", "docstring": "Sum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"", "instruction": "Write a Kotlin function `fun sumAndSimplifyFractions(fractions: List<String>): String` to solve the following problem:\nSum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"", "level": "hard"}
{"task_id": "Kotlin/31", "prompt": "/**\n    * Calculate the number of various denominations of currency required to make up a given amount.\n    * The function takes an integer representing the total amount and returns a list of integers.\n    * The list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\n    * The goal is to minimize the total number of notes by using larger denominations where possible.\n    *\n    * Example:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ", "canonical_solution": "{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}", "test": "fun main() {\n    check(calculateCurrency(735) == listOf(7, 0, 1, 1, 1, 0))\n    check(calculateCurrency(123) == listOf(1, 0, 1, 0, 0, 3))\n    check(calculateCurrency(980) == listOf(9, 1, 1, 1, 0, 0))\n    check(calculateCurrency(50) == listOf(0, 1, 0, 0, 0, 0))\n}\n\nmain()", "entry_point": "calculateCurrency", "signature": "fun calculateCurrency(amount: Int): List<Int>", "docstring": "Calculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123", "instruction": "Write a Kotlin function `fun calculateCurrency(amount: Int): List<Int>` to solve the following problem:\nCalculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123", "level": "easy"}
{"task_id": "Kotlin/32", "prompt": "\n/**\n * Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\n * The search is conducted in ascending order.\n *\n * Example:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ", "canonical_solution": "{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}", "test": "fun main() {\n    check(findNthSquareNumberWithDuplicateDigits(1) == 100)\n    check(findNthSquareNumberWithDuplicateDigits(2) == 121)\n    check(findNthSquareNumberWithDuplicateDigits(3) == 144)  // Example of another test case\n    check(findNthSquareNumberWithDuplicateDigits(4) == 225)  // Example of another test case\n}\n\n\nmain()", "entry_point": "findNthSquareNumberWithDuplicateDigits", "signature": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int", "docstring": "Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121", "instruction": "Write a Kotlin function `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` to solve the following problem:\nFinds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121", "level": "easy"}
{"task_id": "Kotlin/33", "prompt": "/**\n    * Finds the longest word in a given simple English sentence. The sentence ends with a period,\n    * and words are separated by spaces. It assumes no abbreviations or special forms are present.\n    * If there are multiple longest words of the same length, the first one is returned.\n    *\n    * Example:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ", "canonical_solution": "{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}", "test": "fun main() {\n    check(findLongestWord(\"I am a student of Peking University.\") == \"University\")\n    check(findLongestWord(\"Hello world.\") == \"Hello\")\n    check(findLongestWord(\"Short sentences are sweet.\") == \"sentences\")\n    check(findLongestWord(\"Each word has its own length.\") == \"length\")\n}\n\n\nmain()", "entry_point": "findLongestWord", "signature": "fun findLongestWord(sentence: String): String", "docstring": "Finds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"", "instruction": "Write a Kotlin function `fun findLongestWord(sentence: String): String` to solve the following problem:\nFinds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"", "level": "easy"}
{"task_id": "Kotlin/34", "prompt": "/**\n    * Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\n    * Assumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n    *\n    * Example:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // For a leap year\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // For end of the year\n**/\n\nfun getNextDayDate(currentDate: String): String ", "canonical_solution": "{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}", "test": "fun main() {\n    check(getNextDayDate(\"2010-07-05\") == \"2010-07-06\")\n    check(getNextDayDate(\"2020-02-28\") == \"2020-02-29\") // Leap year case\n    check(getNextDayDate(\"2020-12-31\") == \"2021-01-01\") // End of the year case\n    check(getNextDayDate(\"2019-02-28\") == \"2019-03-01\") // Non-leap year February case\n}\n\nmain()", "entry_point": "getNextDayDate", "signature": "fun getNextDayDate(currentDate: String): String", "docstring": "Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year", "instruction": "Write a Kotlin function `fun getNextDayDate(currentDate: String): String` to solve the following problem:\nCalculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year", "level": "hard"}
{"task_id": "Kotlin/35", "prompt": "/**\n    * Calculates the number of days between two given dates.\n    * The dates are provided as year, month, and day.\n    * Accounts for leap years in the calculation.\n    *\n    * Example:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int", "canonical_solution": "{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}", "test": "fun main() {\n    check(daysBetweenDates(2008, 1, 1, 2009, 1, 1) == 366)\n    check(daysBetweenDates(2010, 1, 1, 2010, 1, 3) == 2)\n    check(daysBetweenDates(2020, 5, 15, 2020, 5, 20) == 5)\n    check(daysBetweenDates(2019, 12, 31, 2020, 1, 1) == 1)\n}\n\n\nmain()", "entry_point": "daysBetweenDates", "signature": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int", "docstring": "Calculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2", "instruction": "Write a Kotlin function `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` to solve the following problem:\nCalculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2", "level": "hard"}
{"task_id": "Kotlin/36", "prompt": "\n/**\n * Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\n * An n-gram is a contiguous sequence of n characters from the text.\n * \n * Args:\n * n (Int): The length of each n-gram.\n * text (String): The text to analyze for n-grams.\n * \n * Returns:\n * Pair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\n * and the second element is a list of n-grams with that frequency, in the order they first appear in the text.\n * If the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ", "canonical_solution": "{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}", "test": "fun main() {\n    check(findMostFrequentNGrams(3, \"abcdefabcd\") == Pair(2, listOf(\"abc\", \"bcd\")))\n    check(findMostFrequentNGrams(2, \"abcabc\") == Pair(2, listOf(\"ab\", \"bc\")))\n    check(findMostFrequentNGrams(4, \"abcdefg\") == Pair(1, listOf(\"NO\")))\n    check(findMostFrequentNGrams(2, \"abcdabcd\") == Pair(2, listOf(\"ab\", \"bc\", \"cd\")))\n}\n\n\nmain()", "entry_point": "findMostFrequentNGrams", "signature": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>", "docstring": "Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))", "instruction": "Write a Kotlin function `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` to solve the following problem:\nFinds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))", "level": "middle"}
{"task_id": "Kotlin/37", "prompt": "/**\n * Divide a large number (as a string) by 13 and return the quotient and remainder.\n * The input number can be up to 100 digits long.\n *\n * Example:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ", "canonical_solution": "{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}", "test": "fun main() {\n    check(divideByThirteen(\"2132104848488485\") == Pair(\"164008065268345\", \"0\"))\n    check(divideByThirteen(\"169\") == Pair(\"13\", \"0\"))\n    check(divideByThirteen(\"20\") == Pair(\"1\", \"7\"))\n    check(divideByThirteen(\"130\") == Pair(\"10\", \"0\"))\n    check(divideByThirteen(\"0\") == Pair(\"0\", \"0\"))\n}\n\n\nmain()", "entry_point": "divideByThirteen", "signature": "fun divideByThirteen(number: String): Pair<String, String>", "docstring": "Divide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")", "instruction": "Write a Kotlin function `fun divideByThirteen(number: String): Pair<String, String>` to solve the following problem:\nDivide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")", "level": "easy"}
{"task_id": "Kotlin/38", "prompt": "/**\n    * Extracts all integer numbers from a given string and returns them as a sorted list.\n    * The integers in the string are assumed to be non-negative and separated by non-digit characters.\n    * If no integers are found, returns a list containing only zero.\n    *\n    * Example:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ", "canonical_solution": "{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}", "test": "check(extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\") == listOf(9, 9, 81, 88, 345, 1234, 6781, 11101))\ncheck(extractAndSortIntegers(\"no numbers\") == listOf(0))\ncheck(extractAndSortIntegers(\"123&456*789\") == listOf(123, 456, 789))\ncheck(extractAndSortIntegers(\"abc\") == listOf(0))", "entry_point": "extractAndSortIntegers", "signature": "fun extractAndSortIntegers(input: String): List<Int>", "docstring": "Extracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]", "instruction": "Write a Kotlin function `fun extractAndSortIntegers(input: String): List<Int>` to solve the following problem:\nExtracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]", "level": "easy"}
{"task_id": "Kotlin/39", "prompt": "/**\n * Determines whether a given number x is an element of a set M generated from a starting number k.\n * The set M is generated as follows:\n *   (1) k is an element of M.\n *   (2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n *   (3) No other elements are in M except those generated by the above rules.\n * \n * Example:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ", "canonical_solution": "{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}", "test": "fun main() {\n    check(isElementOfGeneratedSet(0, 22) == \"YES\")\n    check(isElementOfGeneratedSet(1, 10) == \"YES\")\n    check(isElementOfGeneratedSet(2, 13) == \"NO\")\n    check(isElementOfGeneratedSet(3, 30) == \"NO\")\n}\n\n\nmain()", "entry_point": "isElementOfGeneratedSet", "signature": "fun isElementOfGeneratedSet(k: Int, x: Int): String", "docstring": "Determines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"", "instruction": "Write a Kotlin function `fun isElementOfGeneratedSet(k: Int, x: Int): String` to solve the following problem:\nDetermines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"", "level": "middle"}
{"task_id": "Kotlin/40", "prompt": "/**\n    * Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\n    * The input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\n    * The function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\n    Example:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ", "canonical_solution": "{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}", "test": "fun main() {\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"HF\"))) == Pair('F', listOf(307,895)))\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"H\"), Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\"), Pair(834, \"BXPRD\"), Pair(872, \"LJU\"), Pair(791, \"BPJWIA\"), Pair(580, \"AGMVY\"), Pair(619, \"NAFL\"), Pair(233, \"PDJWXK\"))) == Pair('P', listOf(410,567,822,834,791,233)))\n\n \n}\nmain()", "entry_point": "findMostPublishedAuthor", "signature": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>", "docstring": "Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))", "instruction": "Write a Kotlin function `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` to solve the following problem:\nFind the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))", "level": "hard"}
{"task_id": "Kotlin/41", "prompt": "/**\n * Counts the number of pairs of students who are considered \"equal competitors\".\n * Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n * is not greater than 5, and the difference in their total scores is not greater than 10.\n * \n * @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n * @return The number of pairs of students who are considered equal competitors.\n * \n * Example:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ", "canonical_solution": "{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}", "test": "fun main() {\n    check(countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91))) == 2)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(92, 93, 95), Triple(101, 102, 103))) == 1)\n    check(countEqualCompetitors(listOf(Triple(90, 91, 92), Triple(86, 87, 88), Triple(93, 94, 95))) == 1)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(105, 105, 105), Triple(100, 100, 100))) == 1)\n}\n\n\nmain()", "entry_point": "countEqualCompetitors", "signature": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int", "docstring": "Counts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2", "instruction": "Write a Kotlin function `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` to solve the following problem:\nCounts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2", "level": "hard"}
{"task_id": "Kotlin/42", "prompt": "/**\n * Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n * Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n * \n * Example:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ", "canonical_solution": "{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}", "test": "fun main() {\n    check(totalCigarettesSmoked(4, 3) == 5)\n    check(totalCigarettesSmoked(10, 3) == 14)\n    check(totalCigarettesSmoked(1, 2) == 1) // Edge case: Not enough cigarettes to exchange\n    check(totalCigarettesSmoked(20, 5) == 24) // More cigarettes, different exchange rate\n}\n\nmain()", "entry_point": "totalCigarettesSmoked", "signature": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int", "docstring": "Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14", "instruction": "Write a Kotlin function `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` to solve the following problem:\nCalculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14", "level": "easy"}
{"task_id": "Kotlin/43", "prompt": "/**\n * Finds the length of the longest consecutive sequence in a given list of integers.\n * Consecutive sequence means numbers that come sequentially without any gap.\n * \n * Example:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ", "canonical_solution": "{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}", "test": "fun main() {\n    check(longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9)) == 6)\n    check(longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2)) == 4)\n    check(longestConsecutiveSequence(listOf(1, 2, 3, 4, 5, 6)) == 6)\n    check(longestConsecutiveSequence(listOf(100, 4, 200, 1, 3, 2)) == 4)\n}\n\n\nmain()", "entry_point": "longestConsecutiveSequence", "signature": "fun longestConsecutiveSequence(numbers: List<Int>): Int", "docstring": "Finds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4", "instruction": "Write a Kotlin function `fun longestConsecutiveSequence(numbers: List<Int>): Int` to solve the following problem:\nFinds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4", "level": "middle"}
{"task_id": "Kotlin/44", "prompt": "/**\n * Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n * Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n * \n * Example:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ", "canonical_solution": "{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}", "test": "fun main() {\n    check(compareAreas(5, 4, 6) == \"Alice\")\n    check(compareAreas(7, 5, 10) == \"Bob\")\n    // Additional test cases for edge cases\n    check(compareAreas(1, 1, 1) == \"Bob\") // Edge case where all sides are equal\n    check(compareAreas(10, 5, 20) == \"Bob\") // Test case where rectangle is clearly larger\n}\n\n\nmain()", "entry_point": "compareAreas", "signature": "fun compareAreas(a: Int, b: Int, c: Int): String", "docstring": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"", "instruction": "Write a Kotlin function `fun compareAreas(a: Int, b: Int, c: Int): String` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"", "level": "easy"}
{"task_id": "Kotlin/45", "prompt": "\n/**\n    * Finds M positive integers whose sum is N and their product is as large as possible.\n    * Outputs the lexicographically smallest sequence of these M integers.\n    * \n    * Example:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ", "canonical_solution": "{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}", "test": "fun main() {\n    check(maxProductPartition(6, 3) == listOf(2, 2, 2))\n    check(maxProductPartition(8, 3) == listOf(2, 3, 3))\n    check(maxProductPartition(10, 2) == listOf(5, 5))\n    check(maxProductPartition(7, 3) == listOf(2, 2, 3))\n}\n\nmain()", "entry_point": "maxProductPartition", "signature": "fun maxProductPartition(N: Int, M: Int): List<Int>", "docstring": "Finds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]", "instruction": "Write a Kotlin function `fun maxProductPartition(N: Int, M: Int): List<Int>` to solve the following problem:\nFinds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]", "level": "easy"}
{"task_id": "Kotlin/46", "prompt": "/**\n * Calculates the number of characters in the essay title, excluding spaces and newline characters.\n * \n * Example:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.\n */\nfun countTitleCharacters(title: String): Int ", "canonical_solution": "{\n    return title.count { it != ' ' && it != '\\n' }\n}", "test": "fun main() {\n    check(countTitleCharacters(\"234\") == 3)\n    check(countTitleCharacters(\"Ca\\n45\") == 4)\n    check(countTitleCharacters(\"Hello, World!\") == 12) // Assuming \",\" is considered a valid character\n    check(countTitleCharacters(\"A B C D E\") == 5)\n    check(countTitleCharacters(\"\\n\\n\\n\\n\") == 0)\n}\n\n\nmain()", "entry_point": "countTitleCharacters", "signature": "fun countTitleCharacters(title: String): Int", "docstring": "Calculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.", "instruction": "Write a Kotlin function `fun countTitleCharacters(title: String): Int` to solve the following problem:\nCalculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.", "level": "easy"}
{"task_id": "Kotlin/47", "prompt": "/**\n * Counts the number of students who have enrolled in both courses A and B.\n * The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n * and the second list contains the IDs of students enrolled in course B.\n * \n * Example:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ", "canonical_solution": "{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}", "test": "fun main() {\n    check(countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6)) == 4)\n    check(countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14)) == 1)\n    check(countCommonStudents(listOf(1, 2, 3), listOf(4, 5, 6)) == 0)\n    check(countCommonStudents(listOf(1, 2, 3, 4), listOf(2, 4)) == 2)\n}\n\n\nmain()", "entry_point": "countCommonStudents", "signature": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int", "docstring": "Counts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1", "instruction": "Write a Kotlin function `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` to solve the following problem:\nCounts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1", "level": "easy"}
{"task_id": "Kotlin/48", "prompt": "/**\n * Calculates the number of whole apples left after a given time has passed, \n * assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n * \n * @param appleCount The total number of apples initially available.\n * @param timePerApple The time in minutes it takes to eat a single apple.\n * @param timePassed The time in minutes that has elapsed.\n * @return The number of whole apples remaining.\n * \n * Example:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ", "canonical_solution": "{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}", "test": "fun main() {\n    check(remainingApples(50, 10, 200) == 30) // Test case based on example 1\n    check(remainingApples(5, 5, 3) == 4) // Test case based on example 2\n    check(remainingApples(10, 0, 100) == 0) // Test for edge case where timePerApple is 0\n    check(remainingApples(100, 1, 10000) == 0) // Test for case where all apples can be eaten\n}\n\n\nmain()", "entry_point": "remainingApples", "signature": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int", "docstring": "Calculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4", "instruction": "Write a Kotlin function `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` to solve the following problem:\nCalculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4", "level": "hard"}
{"task_id": "Kotlin/49", "prompt": "/**\n * Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n * IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n * \n * Example:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Note:\n * - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n * - The discontinuous ID cannot be the minimum or maximum of the entire ID set.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ", "canonical_solution": "{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}", "test": "fun main() {\n    check(findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9))) == Pair(7, 9))\n    // Add more tests to ensure robustness\n    check(findMissingAndDuplicateIds(listOf(listOf(1, 2, 4,7), listOf(3, 5, 5))) == Pair(6, 5))\n    check(findMissingAndDuplicateIds(listOf(listOf(10, 11,17, 12, 14), listOf(13, 15, 12))) == Pair(16, 12))\n}\n\n\nmain()", "entry_point": "findMissingAndDuplicateIds", "signature": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>", "docstring": "Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.", "instruction": "Write a Kotlin function `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` to solve the following problem:\nFinds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.", "level": "easy"}
{"task_id": "Kotlin/50", "prompt": "/**\n * Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n * \n * @param s The input string of length 8.\n * @return A Triple of integers where the first element is the count of digits,\n * the second element is the count of lowercase letters, and the third element\n * is the count of uppercase letters in the string.\n * \n * Example:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ", "canonical_solution": "{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}", "test": "fun main() {\n    check(countCharacters(\"yLOI2022\") == Triple(4, 1, 3))\n    check(countCharacters(\"IAKIOIOI\") == Triple(0, 0, 8))\n    check(countCharacters(\"1n2s0e1s\") == Triple(4, 4, 0))\n}\n\n\nmain()", "entry_point": "countCharacters", "signature": "fun countCharacters(s: String): Triple<Int, Int, Int>", "docstring": "Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)", "instruction": "Write a Kotlin function `fun countCharacters(s: String): Triple<Int, Int, Int>` to solve the following problem:\nCounts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)", "level": "easy"}
