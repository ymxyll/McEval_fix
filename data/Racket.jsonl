{"task_id": "Racket/1", "prompt": "#lang racket\n(require rackunit)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;False\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;True\n(define (has-close-elements numbers threshold)", "canonical_solution": "(define (check-distance lst elem)\n(cond\n[(null? lst) #f]\n[(< (abs (- elem (car lst))) threshold) #t]\n[else (check-distance (cdr lst) elem)]))\n\n(define (iter elems)\n(cond\n[(null? elems) #f]\n[else (or (check-distance (cdr elems) (car elems))\n(iter (cdr elems)))]))\n\n(iter numbers))", "test": ";; Test cases\n(define (check has-close-elements)\n(define tests\n(list (check-equal? (has-close-elements (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)\n(check-equal? (has-close-elements (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)\n(check-equal? (has-close-elements (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)\n(check-equal? (has-close-elements (list 1.0 2.0 5.9 4.0 5.0) 0.8) #f)\n(check-equal? (has-close-elements (list 1.0 2.0 3.0 4.0 5.0 2.0) 0.1) #t)\n(check-equal? (has-close-elements (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)\n(check-equal? (has-close-elements (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)))\n(andmap identity tests))\n\n(check has-close-elements)", "entry_point": "has-close-elements", "signature": "(define (has-close-elements", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Write a Racket function `(define (has-close-elements` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "level": "middle"}
{"task_id": "Racket/2", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array `arr`, this function returns `true` if the array can be\n;; partitioned into three non-empty parts with equal sums, and `false` otherwise.\n;; Formally, it checks if there exist indices i + 1 < j with\n;; (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n;;\n;; Examples:\n;; >>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n;; #t\n;; >>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n;; #f\n\n(define (can-partition-into-three-equals arr)", "canonical_solution": "(define total-sum (apply + arr))\n(if (not (= (remainder total-sum 3) 0))\n#f\n(let* ([target (/ total-sum 3)]\n[count 0]\n[sum 0])\n(for ([a arr])\n(set! sum (+ sum a))\n(when (= sum target)\n(set! count (add1 count))\n(set! sum 0)))\n(>= count 3))))", "test": "(define (check can-partition-into-three-equals)\n(define tests\n(list (check-equal? (can-partition-into-three-equals (list 0 2 1 -6 6 -7 9 1 2 0 1)) #t)\n(check-equal? (can-partition-into-three-equals (list 0 2 1 -6 6 7 9 -1 2 0 1)) #f)\n(check-equal? (can-partition-into-three-equals (list 3 3 3 3 3 3)) #t)\n(check-equal? (can-partition-into-three-equals (list 1 1 1 1)) #f)\n(check-equal? (can-partition-into-three-equals (list 1 -1 1 -1)) #f)))\n(andmap identity tests))\n\n(check can-partition-into-three-equals)", "entry_point": "can-partition-into-three-equals", "signature": "(define (can-partition-into-three-equals", "docstring": "Function Description:\nGiven an integer array `arr`, this function returns `true` if the array can be\npartitioned into three non-empty parts with equal sums, and `false` otherwise.\nFormally, it checks if there exist indices i + 1 < j with\n(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n\nExamples:\n>>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n#t\n>>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n#f\n\n", "instruction": "Write a Racket function `(define (can-partition-into-three-equals` to solve the following problem:\nFunction Description:\nGiven an integer array `arr`, this function returns `true` if the array can be\npartitioned into three non-empty parts with equal sums, and `false` otherwise.\nFormally, it checks if there exist indices i + 1 < j with\n(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]).\n\nExamples:\n>>> can-partition-into-three-equals([0 2 1 -6 6 -7 9 1 2 0 1])\n#t\n>>> can-partition-into-three-equals([0 2 1 -6 6 7 9 -1 2 0 1])\n#f\n\n", "level": "easy"}
{"task_id": "Racket/3", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\n;; this function returns 'true' if these points form a boomerang.\n;; A 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n;;\n;; Examples:\n;; >>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n;; #t\n;; >>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n;; #f\n\n(define (is-boomerang points)", "canonical_solution": "(define (slope p1 p2)\n(/ (- (cadr p2) (cadr p1))\n(- (car p2) (car p1))))\n\n(define (distinct-points? pts)\n(and (not (equal? (car pts) (cadr pts)))\n(not (equal? (car pts) (caddr pts)))\n(not (equal? (cadr pts) (caddr pts)))))\n\n(and (distinct-points? points)\n(not (= (slope (car points) (cadr points))\n(slope (car points) (caddr points))))))", "test": "(define (check is-boomerang)\n(define tests\n(list (check-equal? (is-boomerang (list (list 1 1) (list 2 3) (list 3 2))) #t)\n(check-equal? (is-boomerang (list (list 1 1) (list 2 2) (list 3 3))) #f)\n(check-equal? (is-boomerang (list (list 0 0) (list 1 1) (list 1 0))) #t)\n(check-equal? (is-boomerang (list (list 1 1) (list 1 1) (list 2 2))) #f)\n(check-equal? (is-boomerang (list (list 1 2) (list 3 4) (list 5 6))) #f)))\n(andmap identity tests))\n\n(check is-boomerang)", "entry_point": "is-boomerang", "signature": "(define (is-boomerang", "docstring": "Function Description:\nGiven an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\nthis function returns 'true' if these points form a boomerang.\nA 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n\nExamples:\n>>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n#t\n>>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n#f\n\n", "instruction": "Write a Racket function `(define (is-boomerang` to solve the following problem:\nFunction Description:\nGiven an array of points 'points', where points[i] = [xi, yi] represents a point on the X-Y plane,\nthis function returns 'true' if these points form a boomerang.\nA 'boomerang' is defined as a set of three points that are distinct and not in a straight line.\n\nExamples:\n>>> is-boomerang([[1, 1], [2, 3], [3, 2]])\n#t\n>>> is-boomerang([[1, 1], [2, 2], [3, 3]])\n#f\n\n", "level": "middle"}
{"task_id": "Racket/4", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of stone weights (each weight is a positive integer), this function simulates a process\n;; where in each round, the two heaviest stones are smashed together. The possible outcomes are:\n;; - If x == y (both stones have the same weight), both stones are completely smashed;\n;; - If x != y (stones have different weights), the stone with weight x is completely smashed, and\n;; the stone with weight y has a new weight of y-x.\n;; The process is repeated until at most one stone remains. The function returns the weight of this remaining\n;; stone, or 0 if no stones are left.\n;;\n;; Examples:\n;; >>> last-stone-weight([2 7 4 1 8 1])\n;; 1\n;; >>> last-stone-weight([10])\n;; 10\n\n(define (last-stone-weight stones)", "canonical_solution": "(define (smash largest second-largest rest)\n(if (= largest second-largest)\nrest\n(cons (- largest second-largest) rest)))\n\n(define (iterate stones)\n(cond\n[(null? stones) 0]\n[(null? (cdr stones)) (car stones)]\n[else\n(let* ([sorted-stones (sort stones >)]\n[largest (car sorted-stones)]\n[second-largest (cadr sorted-stones)]\n[rest (cddr sorted-stones)])\n(iterate (smash largest second-largest rest)))]))\n\n(iterate stones))", "test": ";; Test Cases\n(define (check last-stone-weight)\n(define tests\n(list (check-equal? (last-stone-weight (list 2 7 4 1 8 1)) 1)\n(check-equal? (last-stone-weight (list 10)) 10)\n(check-equal? (last-stone-weight (list 8 10 4)) 2)\n(check-equal? (last-stone-weight (list 20 15 10 5)) 0)\n(check-equal? (last-stone-weight (list)) 0)))\n(andmap identity tests))\n\n(check last-stone-weight)", "entry_point": "last-stone-weight", "signature": "(define (last-stone-weight", "docstring": "Function Description:\nGiven a list of stone weights (each weight is a positive integer), this function simulates a process\nwhere in each round, the two heaviest stones are smashed together. The possible outcomes are:\n- If x == y (both stones have the same weight), both stones are completely smashed;\n- If x != y (stones have different weights), the stone with weight x is completely smashed, and\nthe stone with weight y has a new weight of y-x.\nThe process is repeated until at most one stone remains. The function returns the weight of this remaining\nstone, or 0 if no stones are left.\n\nExamples:\n>>> last-stone-weight([2 7 4 1 8 1])\n1\n>>> last-stone-weight([10])\n10\n\n", "instruction": "Write a Racket function `(define (last-stone-weight` to solve the following problem:\nFunction Description:\nGiven a list of stone weights (each weight is a positive integer), this function simulates a process\nwhere in each round, the two heaviest stones are smashed together. The possible outcomes are:\n- If x == y (both stones have the same weight), both stones are completely smashed;\n- If x != y (stones have different weights), the stone with weight x is completely smashed, and\nthe stone with weight y has a new weight of y-x.\nThe process is repeated until at most one stone remains. The function returns the weight of this remaining\nstone, or 0 if no stones are left.\n\nExamples:\n>>> last-stone-weight([2 7 4 1 8 1])\n1\n>>> last-stone-weight([10])\n10\n\n", "level": "hard"}
{"task_id": "Racket/5", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given two integer arrays 'heights' and 'expected', where 'expected' represents the heights\n;; of students in non-decreasing order, and 'heights' represents the current order of student heights,\n;; this function returns the count of indices where heights[i] != expected[i].\n;;\n;; Examples:\n;; >>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n;; 3\n;; >>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n;; 5\n\n(define (height-mismatch-count heights expected)", "canonical_solution": "(define (count-mismatches lst1 lst2)\n(cond\n[(null? lst1) 0]\n[else\n(if (= (car lst1) (car lst2))\n(count-mismatches (cdr lst1) (cdr lst2))\n(+ 1 (count-mismatches (cdr lst1) (cdr lst2))))]))\n(count-mismatches heights expected))", "test": "(define (check height-mismatch-count)\n(define tests\n(list (check-equal? (height-mismatch-count (list 1 1 4 2 1 3) (list 1 1 1 2 3 4)) 3)\n(check-equal? (height-mismatch-count (list 5 1 2 3 4) (list 1 2 3 4 5)) 5)\n(check-equal? (height-mismatch-count (list 1 2 3 4 5) (list 1 2 3 4 5)) 0)\n(check-equal? (height-mismatch-count (list 3 3 3 3 3) (list 3 3 3 3 3)) 0)\n(check-equal? (height-mismatch-count (list 2 1 2 1 2) (list 1 1 2 2 2)) 2)))\n(andmap identity tests))\n\n(check height-mismatch-count)", "entry_point": "height-mismatch-count", "signature": "(define (height-mismatch-count", "docstring": "Function Description:\nGiven two integer arrays 'heights' and 'expected', where 'expected' represents the heights\nof students in non-decreasing order, and 'heights' represents the current order of student heights,\nthis function returns the count of indices where heights[i] != expected[i].\n\nExamples:\n>>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n3\n>>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n5\n\n", "instruction": "Write a Racket function `(define (height-mismatch-count` to solve the following problem:\nFunction Description:\nGiven two integer arrays 'heights' and 'expected', where 'expected' represents the heights\nof students in non-decreasing order, and 'heights' represents the current order of student heights,\nthis function returns the count of indices where heights[i] != expected[i].\n\nExamples:\n>>> height-mismatch-count([1 1 4 2 1 3], [1 1 1 2 3 4])\n3\n>>> height-mismatch-count([5 1 2 3 4], [1 2 3 4 5])\n5\n\n", "level": "easy"}
{"task_id": "Racket/6", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\n;; shifting the remaining elements to the right. The array is modified in place.\n;;\n;; Examples:\n;; >>> duplicate-zeros([1 0 2 3 0 4 5 0])\n;; '(1 0 0 2 3 0 0 4)\n;; >>> duplicate-zeros([1 2 3])\n;; '(1 2 3)\n\n(define (duplicate-zeros arr)", "canonical_solution": "(define (process-list lst processed)\n(cond\n[(null? lst) (reverse processed)]\n[else\n(if (= 0 (car lst))\n(if (null? (cdr lst))\n(process-list '() (cons 0 processed))\n(process-list (cdr lst) (cons 0 (cons 0 processed))))\n(process-list (cdr lst) (cons (car lst) processed)))]))\n(take (process-list arr '()) (length arr)))", "test": ";; Test Cases\n(define (check duplicate-zeros)\n(define tests\n(list (check-equal? (duplicate-zeros (list 1 0 2 3 0 4 5 0)) (list 1 0 0 2 3 0 0 4))\n(check-equal? (duplicate-zeros (list 1 2 3)) (list 1 2 3))\n(check-equal? (duplicate-zeros (list 0 0 0 0 0 0)) (list 0 0 0 0 0 0))\n(check-equal? (duplicate-zeros (list 0 1 7 6 0)) (list 0 0 1 7 6))\n(check-equal? (duplicate-zeros (list 8 4 5 0 0 0 0 7)) (list 8 4 5 0 0 0 0 0))))\n(andmap identity tests))\n\n(check duplicate-zeros)", "entry_point": "duplicate-zeros", "signature": "(define (duplicate-zeros", "docstring": "Function Description:\nGiven a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\nshifting the remaining elements to the right. The array is modified in place.\n\nExamples:\n>>> duplicate-zeros([1 0 2 3 0 4 5 0])\n'(1 0 0 2 3 0 0 4)\n>>> duplicate-zeros([1 2 3])\n'(1 2 3)\n\n", "instruction": "Write a Racket function `(define (duplicate-zeros` to solve the following problem:\nFunction Description:\nGiven a fixed-length integer array 'arr', this function duplicates each occurrence of zero,\nshifting the remaining elements to the right. The array is modified in place.\n\nExamples:\n>>> duplicate-zeros([1 0 2 3 0 4 5 0])\n'(1 0 0 2 3 0 0 4)\n>>> duplicate-zeros([1 2 3])\n'(1 2 3)\n\n", "level": "middle"}
{"task_id": "Racket/7", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of words 'words' and a string 'chars', representing a character set,\n;; this function calculates the sum of the lengths of the words in 'words' that can be\n;; formed using the letters in 'chars'. Each letter in 'chars' can only be used once\n;; per word.\n;;\n;; Examples:\n;; >>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n;; 6 (cat and hat can be formed)\n;; >>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n;; 10 (world and hello can be formed)\n\n(define (sum-of-words-you-know words chars)", "canonical_solution": "(define (char-count str)\n(foldl (lambda (char dict)\n(dict-set dict char (add1 (dict-ref dict char 0))))\n(make-immutable-hash)\n(string->list str)))\n\n(define chars-count (char-count chars))\n\n(define (can-form-word word)\n(let ([word-count (char-count word)])\n(andmap (lambda (char) (<= (dict-ref word-count char 0) (dict-ref chars-count char 0)))\n(string->list word))))\n\n(apply + (map string-length (filter can-form-word words))))", "test": "(define (check sum-of-words-you-know)\n(define tests\n(list (check-equal? (sum-of-words-you-know '(\"cat\" \"bt\" \"hat\" \"tree\") \"atach\") 6)\n(check-equal? (sum-of-words-you-know '(\"hello\" \"world\" \"leetcode\") \"welldonehoneyr\") 10)\n(check-equal? (sum-of-words-you-know '(\"apple\" \"orange\" \"banana\") \"aabbcc\") 0)\n(check-equal? (sum-of-words-you-know '(\"abc\" \"de\" \"fgh\") \"abcdefgh\") 8)\n(check-equal? (sum-of-words-you-know '(\"a\" \"b\" \"c\") \"abc\") 3)))\n(andmap identity tests))\n\n(check sum-of-words-you-know)", "entry_point": "sum-of-words-you-know", "signature": "(define (sum-of-words-you-know", "docstring": "Function Description:\nGiven a list of words 'words' and a string 'chars', representing a character set,\nthis function calculates the sum of the lengths of the words in 'words' that can be\nformed using the letters in 'chars'. Each letter in 'chars' can only be used once\nper word.\n\nExamples:\n>>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n6 (cat and hat can be formed)\n>>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n10 (world and hello can be formed)\n\n", "instruction": "Write a Racket function `(define (sum-of-words-you-know` to solve the following problem:\nFunction Description:\nGiven a list of words 'words' and a string 'chars', representing a character set,\nthis function calculates the sum of the lengths of the words in 'words' that can be\nformed using the letters in 'chars'. Each letter in 'chars' can only be used once\nper word.\n\nExamples:\n>>> sum-of-words-you-know([\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\")\n6 (cat and hat can be formed)\n>>> sum-of-words-you-know([\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\")\n10 (world and hello can be formed)\n\n", "level": "hard"}
{"task_id": "Racket/8", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\n;; distance[i] represents the distance between station i and station (i + 1) % n, this function\n;; returns the shortest distance between a start station and a destination station on the route.\n;; The bus can travel in both clockwise and counterclockwise directions.\n;;\n;; Examples:\n;; >>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n;; 4 (The shortest way from station 0 to 3 is directly 4)\n;; >>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n;; 3 (The shortest way from station 0 to 2 is 1 + 2)\n\n(define (shortest-distance-in-bus-route distance start destination)", "canonical_solution": "(define total-distance (apply + distance))\n(define (slice lst start end)\n(take (drop lst start) (- end start)))\n(define clockwise-distance\n(if (< start destination)\n(apply + (slice distance start destination))\n(apply + (append (slice distance start (length distance))\n(slice distance 0 destination)))))\n(min clockwise-distance (- total-distance clockwise-distance)))", "test": ";; Test Cases\n(define (check shortest-distance-in-bus-route)\n(define tests\n(list (check-equal? (shortest-distance-in-bus-route (list 1 2 3 4) 0 3) 4)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4) 0 2) 3)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4 5) 3 1) 5)\n(check-equal? (shortest-distance-in-bus-route (list 7 10 1 12 11 14 5 0) 7 2) 17)\n(check-equal? (shortest-distance-in-bus-route (list 1 2 3 4 5) 2 2) 0)))\n(andmap identity tests))\n\n(check shortest-distance-in-bus-route)", "entry_point": "shortest-distance-in-bus-route", "signature": "(define (shortest-distance-in-bus-route", "docstring": "Function Description:\nGiven a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\ndistance[i] represents the distance between station i and station (i + 1) % n, this function\nreturns the shortest distance between a start station and a destination station on the route.\nThe bus can travel in both clockwise and counterclockwise directions.\n\nExamples:\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n4 (The shortest way from station 0 to 3 is directly 4)\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n3 (The shortest way from station 0 to 2 is 1 + 2)\n\n", "instruction": "Write a Racket function `(define (shortest-distance-in-bus-route` to solve the following problem:\nFunction Description:\nGiven a circular bus route with 'n' stations numbered from 0 to n - 1, and a list 'distance' where\ndistance[i] represents the distance between station i and station (i + 1) % n, this function\nreturns the shortest distance between a start station and a destination station on the route.\nThe bus can travel in both clockwise and counterclockwise directions.\n\nExamples:\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 3)\n4 (The shortest way from station 0 to 3 is directly 4)\n>>> shortest-distance-in-bus-route([1 2 3 4] 0 2)\n3 (The shortest way from station 0 to 2 is 1 + 2)\n\n", "level": "hard"}
{"task_id": "Racket/9", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array 'arr', this function counts the occurrence of each number in the array.\n;; It returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n;;\n;; Examples:\n;; >>> unique-frequency-count([1 2 2 1 1 3])\n;; #t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n;; >>> unique-frequency-count([1 2 2 3 3 3])\n;; #f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n(define (unique-frequency-count arr)", "canonical_solution": "(define (count-elements lst)\n(foldl (lambda (elem counts)\n(dict-set counts elem (add1 (dict-ref counts elem 0))))\n(make-immutable-hash)\nlst))\n\n(define element-counts (count-elements arr))\n(define frequencies (dict-values element-counts))\n(equal? (length frequencies) (length (remove-duplicates frequencies))))", "test": ";; Test Cases\n(define (check unique-frequency-count)\n(define tests\n(list (check-equal? (unique-frequency-count (list 1 2 2 1 1 3)) #t)\n(check-equal? (unique-frequency-count (list 1 2 2 3 3 3)) #t)\n(check-equal? (unique-frequency-count (list 3 5 7 9 11)) #f)\n(check-equal? (unique-frequency-count (list 4 4 4 4 4)) #t)\n(check-equal? (unique-frequency-count (list 1 2 2 3 3 4 4 4)) #f)))\n(andmap identity tests))\n\n(check unique-frequency-count)", "entry_point": "unique-frequency-count", "signature": "(define (unique-frequency-count", "docstring": "Function Description:\nGiven an integer array 'arr', this function counts the occurrence of each number in the array.\nIt returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n\nExamples:\n>>> unique-frequency-count([1 2 2 1 1 3])\n#t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n>>> unique-frequency-count([1 2 2 3 3 3])\n#f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n", "instruction": "Write a Racket function `(define (unique-frequency-count` to solve the following problem:\nFunction Description:\nGiven an integer array 'arr', this function counts the occurrence of each number in the array.\nIt returns 'true' if each number's occurrence count is unique, otherwise returns 'false'.\n\nExamples:\n>>> unique-frequency-count([1 2 2 1 1 3])\n#t (1 appears 3 times, 2 appears 2 times, and 3 appears 1 time, all unique counts)\n>>> unique-frequency-count([1 2 2 3 3 3])\n#f (1 appears 1 time, 2 appears 2 times, and 3 appears 3 times, counts are not unique)\n\n", "level": "middle"}
{"task_id": "Racket/10", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an array 'position' representing the positions of 'n' chips, this function calculates\n;; the minimum cost to move all chips to the same position. Moving a chip from position[i] to\n;; position[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\n;; costs 1.\n;;\n;; Examples:\n;; >>> min-cost-to-move-chips([1 2 3])\n;; 1 (Move the chip at position 3 to position 1 or 2)\n;; >>> min-cost-to-move-chips([2 2 2 3 3])\n;; 2 (Move two chips at position 3 to position 2)\n\n(define (min-cost-to-move-chips position)", "canonical_solution": "(define (even-odd-counts lst)\n(foldl (lambda (pos counts)\n(if (even? pos)\n(cons (add1 (car counts)) (cdr counts))\n(cons (car counts) (add1 (cdr counts)))))\n'(0 . 0) lst))\n\n(define counts (even-odd-counts position))\n(min (car counts) (cdr counts)))", "test": ";; Test Cases\n(define (check min-cost-to-move-chips)\n(define tests\n(list (check-equal? (min-cost-to-move-chips (list 1 2 3)) 1)\n(check-equal? (min-cost-to-move-chips (list 2 2 2 3 3)) 2)\n(check-equal? (min-cost-to-move-chips (list 1 3 5 7 9)) 0)\n(check-equal? (min-cost-to-move-chips (list 10 3 3 3)) 1)\n(check-equal? (min-cost-to-move-chips (list 6 4 7 8 2)) 1)))\n(andmap identity tests))\n\n(check min-cost-to-move-chips)", "entry_point": "min-cost-to-move-chips", "signature": "(define (min-cost-to-move-chips", "docstring": "Function Description:\nGiven an array 'position' representing the positions of 'n' chips, this function calculates\nthe minimum cost to move all chips to the same position. Moving a chip from position[i] to\nposition[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\ncosts 1.\n\nExamples:\n>>> min-cost-to-move-chips([1 2 3])\n1 (Move the chip at position 3 to position 1 or 2)\n>>> min-cost-to-move-chips([2 2 2 3 3])\n2 (Move two chips at position 3 to position 2)\n\n", "instruction": "Write a Racket function `(define (min-cost-to-move-chips` to solve the following problem:\nFunction Description:\nGiven an array 'position' representing the positions of 'n' chips, this function calculates\nthe minimum cost to move all chips to the same position. Moving a chip from position[i] to\nposition[i] + 2 or position[i] - 2 costs 0, and moving it to position[i] + 1 or position[i] - 1\ncosts 1.\n\nExamples:\n>>> min-cost-to-move-chips([1 2 3])\n1 (Move the chip at position 3 to position 1 or 2)\n>>> min-cost-to-move-chips([2 2 2 3 3])\n2 (Move two chips at position 3 to position 2)\n\n", "level": "easy"}
{"task_id": "Racket/11", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a non-decreasing ordered array of integers, where exactly one integer appears more\n;; than 25% of the time, this function finds and returns that integer.\n;;\n;; Examples:\n;; >>> find-element-over-quarter([1 2 2 3 3 3 3])\n;; 3 (3 appears 4 times which is more than 25% of 7 elements)\n;; >>> find-element-over-quarter([1 1 2 2 3])\n;; 1 (1 appears 2 times which is more than 25% of 5 elements)\n\n(define (find-element-over-quarter arr)", "canonical_solution": "(define quarter-length (/ (length arr) 4))\n\n(define (iter lst count prev-elem)\n(cond\n[(null? lst) prev-elem]\n[else\n(let ([current-elem (car lst)])\n(if (equal? current-elem prev-elem)\n(if (> (add1 count) quarter-length)\ncurrent-elem\n(iter (cdr lst) (add1 count) current-elem))\n(iter (cdr lst) 1 current-elem)))]))\n\n(iter (cdr arr) 1 (car arr)))", "test": ";; Test Cases\n(define (check find-element-over-quarter)\n(define tests\n(list (check-equal? (find-element-over-quarter (list 1 2 2 3 4 5 6)) 2)\n(check-equal? (find-element-over-quarter (list 1 1 2 2 3)) 1)\n(check-equal? (find-element-over-quarter (list 4 4 4 5 6 7 9 10)) 4)\n(check-equal? (find-element-over-quarter (list 1 1 1 1 2 3 4)) 1)\n(check-equal? (find-element-over-quarter (list 7 7 8 9 10 11 12)) 7)))\n(andmap identity tests))\n\n(check find-element-over-quarter)", "entry_point": "find-element-over-quarter", "signature": "(define (find-element-over-quarter", "docstring": "Function Description:\nGiven a non-decreasing ordered array of integers, where exactly one integer appears more\nthan 25% of the time, this function finds and returns that integer.\n\nExamples:\n>>> find-element-over-quarter([1 2 2 3 3 3 3])\n3 (3 appears 4 times which is more than 25% of 7 elements)\n>>> find-element-over-quarter([1 1 2 2 3])\n1 (1 appears 2 times which is more than 25% of 5 elements)\n\n", "instruction": "Write a Racket function `(define (find-element-over-quarter` to solve the following problem:\nFunction Description:\nGiven a non-decreasing ordered array of integers, where exactly one integer appears more\nthan 25% of the time, this function finds and returns that integer.\n\nExamples:\n>>> find-element-over-quarter([1 2 2 3 3 3 3])\n3 (3 appears 4 times which is more than 25% of 7 elements)\n>>> find-element-over-quarter([1 1 2 2 3])\n1 (1 appears 2 times which is more than 25% of 5 elements)\n\n", "level": "middle"}
{"task_id": "Racket/12", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a string, this function extracts all the numbers from the string and returns them as a list.\n;; It considers consecutive digits as a single number.\n;;\n;; Examples:\n;; >>> extract-numbers-from-string(\"abc123def456\")\n;; '(123 456)\n;; >>> extract-numbers-from-string(\"123abc45def\")\n;; '(123 45)\n\n(define (extract-numbers-from-string str)", "canonical_solution": "(define (collect-digits chars)\n(let loop ([chars chars] [current '()] [result '()])\n(cond\n[(null? chars) (if (null? current) result (reverse (cons (list->string (reverse current)) result)))]\n[(char-numeric? (car chars)) (loop (cdr chars) (cons (car chars) current) result)]\n[else (loop (cdr chars) '() (if (null? current) result (reverse (cons (list->string (reverse current)) result))))])))\n(map string->number (collect-digits (string->list str))))", "test": "(define (check extract-numbers-from-string)\n(define tests\n(list (check-equal? (extract-numbers-from-string \"abc123def456\") '(123 456))\n(check-equal? (extract-numbers-from-string \"123abc45def\") '(123 45))\n(check-equal? (extract-numbers-from-string \"no numbers\") '())\n(check-equal? (extract-numbers-from-string \"100 300\") '(100 300))\n(check-equal? (extract-numbers-from-string \"abc123xyz\") '(123))))\n(andmap identity tests))\n\n(check extract-numbers-from-string)", "entry_point": "extract-numbers-from-string", "signature": "(define (extract-numbers-from-string", "docstring": "Function Description:\nGiven a string, this function extracts all the numbers from the string and returns them as a list.\nIt considers consecutive digits as a single number.\n\nExamples:\n>>> extract-numbers-from-string(\"abc123def456\")\n'(123 456)\n>>> extract-numbers-from-string(\"123abc45def\")\n'(123 45)\n\n", "instruction": "Write a Racket function `(define (extract-numbers-from-string` to solve the following problem:\nFunction Description:\nGiven a string, this function extracts all the numbers from the string and returns them as a list.\nIt considers consecutive digits as a single number.\n\nExamples:\n>>> extract-numbers-from-string(\"abc123def456\")\n'(123 456)\n>>> extract-numbers-from-string(\"123abc45def\")\n'(123 45)\n\n", "level": "hard"}
{"task_id": "Racket/13", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of numbers, this function checks if the elements are strictly monotonic.\n;; Strictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n;;\n;; Examples:\n;; >>> is-strictly-monotonic([1 2 3 4 5])\n;; #t (Strictly increasing)\n;; >>> is-strictly-monotonic([5 4 3 2 1])\n;; #t (Strictly decreasing)\n;; >>> is-strictly-monotonic([1 2 2 3 4])\n;; #f (Not strictly monotonic)\n\n(define (is-strictly-monotonic lst)", "canonical_solution": "(define (check-direction lst increasing)\n(cond\n[(or (null? lst) (null? (cdr lst))) #t]\n[else\n(let ([current (car lst)]\n[next (cadr lst)])\n(and (if increasing (< current next) (> current next))\n(check-direction (cdr lst) increasing)))]))\n(or (check-direction lst #t) (check-direction lst #f)))", "test": "(define (check is-strictly-monotonic)\n(define tests\n(list (check-equal? (is-strictly-monotonic (list 1 2 3 4 5)) #t)\n(check-equal? (is-strictly-monotonic (list 5 4 3 2 1)) #t)\n(check-equal? (is-strictly-monotonic (list 1 2 2 3 4)) #f)\n(check-equal? (is-strictly-monotonic (list 1)) #t)\n(check-equal? (is-strictly-monotonic (list 3 2 1 2 3)) #f)))\n(andmap identity tests))\n\n(check is-strictly-monotonic)", "entry_point": "is-strictly-monotonic", "signature": "(define (is-strictly-monotonic", "docstring": "Function Description:\nGiven a list of numbers, this function checks if the elements are strictly monotonic.\nStrictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n\nExamples:\n>>> is-strictly-monotonic([1 2 3 4 5])\n#t (Strictly increasing)\n>>> is-strictly-monotonic([5 4 3 2 1])\n#t (Strictly decreasing)\n>>> is-strictly-monotonic([1 2 2 3 4])\n#f (Not strictly monotonic)\n\n", "instruction": "Write a Racket function `(define (is-strictly-monotonic` to solve the following problem:\nFunction Description:\nGiven a list of numbers, this function checks if the elements are strictly monotonic.\nStrictly monotonic means that the elements are either strictly increasing or strictly decreasing.\n\nExamples:\n>>> is-strictly-monotonic([1 2 3 4 5])\n#t (Strictly increasing)\n>>> is-strictly-monotonic([5 4 3 2 1])\n#t (Strictly decreasing)\n>>> is-strictly-monotonic([1 2 2 3 4])\n#f (Not strictly monotonic)\n\n", "level": "middle"}
{"task_id": "Racket/14", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an integer array 'arr', this function replaces each element with its rank after sorting.\n;; The rank represents the magnitude of an element with the following rules:\n;; - Ranking starts from 1.\n;; - Larger elements have larger ranks. Equal elements have the same rank.\n;; - Each number's rank should be as small as possible.\n;;\n;; Examples:\n;; >>> replace-elements-with-ranks([40, 10, 20, 30])\n;; '(4 1 2 3)\n;; >>> replace-elements-with-ranks([100, 100, 100])\n;; '(1 1 1)\n\n(define (replace-elements-with-ranks arr)", "canonical_solution": "(define sorted-unique (remove-duplicates (sort arr <)))\n(define rank-dict (for/fold ([dict (make-immutable-hash)]) ([elem (in-list sorted-unique)] [i (in-naturals 1)])\n(dict-set dict elem i)))\n(map (lambda (elem) (dict-ref rank-dict elem)) arr))", "test": "(define (check replace-elements-with-ranks)\n(define tests\n(list (check-equal? (replace-elements-with-ranks (list 40 10 20 30)) '(4 1 2 3))\n(check-equal? (replace-elements-with-ranks (list 100 100 100)) '(1 1 1))\n(check-equal? (replace-elements-with-ranks (list 5 5 6 7)) '(1 1 2 3))\n(check-equal? (replace-elements-with-ranks (list 10 20 20 30)) '(1 2 2 3))\n(check-equal? (replace-elements-with-ranks (list 7 5 6 7)) '(3 1 2 3))))\n(andmap identity tests))\n\n(check replace-elements-with-ranks)", "entry_point": "replace-elements-with-ranks", "signature": "(define (replace-elements-with-ranks", "docstring": "Function Description:\nGiven an integer array 'arr', this function replaces each element with its rank after sorting.\nThe rank represents the magnitude of an element with the following rules:\n- Ranking starts from 1.\n- Larger elements have larger ranks. Equal elements have the same rank.\n- Each number's rank should be as small as possible.\n\nExamples:\n>>> replace-elements-with-ranks([40, 10, 20, 30])\n'(4 1 2 3)\n>>> replace-elements-with-ranks([100, 100, 100])\n'(1 1 1)\n\n", "instruction": "Write a Racket function `(define (replace-elements-with-ranks` to solve the following problem:\nFunction Description:\nGiven an integer array 'arr', this function replaces each element with its rank after sorting.\nThe rank represents the magnitude of an element with the following rules:\n- Ranking starts from 1.\n- Larger elements have larger ranks. Equal elements have the same rank.\n- Each number's rank should be as small as possible.\n\nExamples:\n>>> replace-elements-with-ranks([40, 10, 20, 30])\n'(4 1 2 3)\n>>> replace-elements-with-ranks([100, 100, 100])\n'(1 1 1)\n\n", "level": "easy"}
{"task_id": "Racket/15", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list, this function returns a new list with the elements in reverse order.\n;;\n;; Examples:\n;; >>> reverse-list([1 2 3 4 5])\n;; '(5 4 3 2 1)\n;; >>> reverse-list(['a 'b 'c])\n;; '(c b a)\n\n(define (reverse-list lst)", "canonical_solution": "(foldl (lambda (elem acc) (cons elem acc)) '() lst))", "test": ";; Test Cases\n(define (check reverse-list)\n(define tests\n(list (check-equal? (reverse-list (list 1 2 3 4 5)) '(5 4 3 2 1))\n(check-equal? (reverse-list (list 'a 'b 'c)) '(c b a))\n(check-equal? (reverse-list '()) '())\n(check-equal? (reverse-list (list 9)) '(9))\n(check-equal? (reverse-list (list \"hello\" \"world\")) '(\"world\" \"hello\"))))\n(andmap identity tests))\n\n(check reverse-list)", "entry_point": "reverse-list", "signature": "(define (reverse-list", "docstring": "Function Description:\nGiven a list, this function returns a new list with the elements in reverse order.\n\nExamples:\n>>> reverse-list([1 2 3 4 5])\n'(5 4 3 2 1)\n>>> reverse-list(['a 'b 'c])\n'(c b a)\n\n", "instruction": "Write a Racket function `(define (reverse-list` to solve the following problem:\nFunction Description:\nGiven a list, this function returns a new list with the elements in reverse order.\n\nExamples:\n>>> reverse-list([1 2 3 4 5])\n'(5 4 3 2 1)\n>>> reverse-list(['a 'b 'c])\n'(c b a)\n\n", "level": "easy"}
{"task_id": "Racket/16", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given an array 'nums' and a value 'val', this function removes all occurrences of 'val' in-place\n;; and returns the new length of the array after removal.\n;;\n;; Examples:\n;; >>> remove-value-and-return-length([3 2 2 3] 3)\n;; 2 (The array becomes [2 2])\n;; >>> remove-value-and-return-length([0 1 2 2 3 0 4 2] 2)\n;; 5 (The array becomes [0 1 3 0 4])\n\n(define (remove-value-and-return-length nums val)", "canonical_solution": "(define (remove-val lst val)\n(filter (lambda (elem) (not (= elem val))) lst))\n\n(length (remove-val nums val)))", "test": "(define (check remove-value-and-return-length)\n(define tests\n(list (check-equal? (remove-value-and-return-length (list 3 2 2 3) 3) 2)\n(check-equal? (remove-value-and-return-length (list 0 1 2 2 3 0 4 2) 2) 5)\n(check-equal? (remove-value-and-return-length (list 1 2 3 4 5) 6) 5)\n(check-equal? (remove-value-and-return-length (list 1 1 1 1) 1) 0)\n(check-equal? (remove-value-and-return-length (list 5 5 5 2 2) 5) 2)))\n(andmap identity tests))\n\n(check remove-value-and-return-length)", "entry_point": "remove-value-and-return-length", "signature": "(define (remove-value-and-return-length", "docstring": "Function Description:\nGiven an array 'nums' and a value 'val', this function removes all occurrences of 'val' in-place\nand returns the new length of the array after removal.\n\nExamples:\n>>> remove-value-and-return-length([3 2 2 3] 3)\n2 (The array becomes [2 2])\n>>> remove-value-and-return-length([0 1 2 2 3 0 4 2] 2)\n5 (The array becomes [0 1 3 0 4])\n\n", "instruction": "Write a Racket function `(define (remove-value-and-return-length` to solve the following problem:\nFunction Description:\nGiven an array 'nums' and a value 'val', this function removes all occurrences of 'val' in-place\nand returns the new length of the array after removal.\n\nExamples:\n>>> remove-value-and-return-length([3 2 2 3] 3)\n2 (The array becomes [2 2])\n>>> remove-value-and-return-length([0 1 2 2 3 0 4 2] 2)\n5 (The array becomes [0 1 3 0 4])\n\n", "level": "easy"}
{"task_id": "Racket/17", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\n;; in 'nums', or returns the index where it would be if it were inserted in order.\n;;\n;; Examples:\n;; >>> find-or-insert-index([1 3 5 6] 5)\n;; 2 (Target 5 found at index 2)\n;; >>> find-or-insert-index([1 3 5 6] 2)\n;; 1 (Target 2 would be inserted at index 1)\n\n(define (find-or-insert-index nums target)", "canonical_solution": "(define (find-index lst elem index)\n(cond\n[(null? lst) index]\n[(<= elem (car lst)) index]\n[else (find-index (cdr lst) elem (add1 index))]))\n\n(find-index nums target 0))", "test": "(define (check find-or-insert-index)\n(define tests\n(list (check-equal? (find-or-insert-index (list 1 3 5 6) 5) 2)\n(check-equal? (find-or-insert-index (list 1 3 5 6) 2) 1)\n(check-equal? (find-or-insert-index (list 1 3 5 7) 6) 3)\n(check-equal? (find-or-insert-index (list 1 3 4 6 8 10) 5) 3)\n(check-equal? (find-or-insert-index '() 1) 0)))\n(andmap identity tests))\n\n(check find-or-insert-index)", "entry_point": "find-or-insert-index", "signature": "(define (find-or-insert-index", "docstring": "Function Description:\nGiven a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\nin 'nums', or returns the index where it would be if it were inserted in order.\n\nExamples:\n>>> find-or-insert-index([1 3 5 6] 5)\n2 (Target 5 found at index 2)\n>>> find-or-insert-index([1 3 5 6] 2)\n1 (Target 2 would be inserted at index 1)\n\n", "instruction": "Write a Racket function `(define (find-or-insert-index` to solve the following problem:\nFunction Description:\nGiven a sorted array 'nums' and a target value 'target', this function finds the index of 'target'\nin 'nums', or returns the index where it would be if it were inserted in order.\n\nExamples:\n>>> find-or-insert-index([1 3 5 6] 5)\n2 (Target 5 found at index 2)\n>>> find-or-insert-index([1 3 5 6] 2)\n1 (Target 2 would be inserted at index 1)\n\n", "level": "easy"}
{"task_id": "Racket/18", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given two non-decreasing integer arrays 'nums1' and 'nums2', and their respective lengths 'm' and 'n',\n;; this function merges 'nums2' into 'nums1' such that the merged array is in non-decreasing order.\n;;\n;; Examples:\n;; >>> merge-arrays([1 2 3 0 0 0] 3 [2 5 6] 3)\n;; '(1 2 2 3 5 6)\n;; >>> merge-arrays([1] 1 [] 0)\n;; '(1)\n\n(define (merge-arrays nums1 m nums2 n)", "canonical_solution": "(define nums1-trimmed (take nums1 m))\n(define nums2-trimmed (take nums2 n))\n(sort (append nums1-trimmed nums2-trimmed) <))", "test": "(define (check merge-arrays)\n(define tests\n(list (check-equal? (merge-arrays (list 1 2 3 0 0 0) 3 (list 2 5 6) 3) '(1 2 2 3 5 6))\n(check-equal? (merge-arrays (list 1) 1 '() 0) '(1))\n(check-equal? (merge-arrays '() 0 (list 1 2 3) 3) '(1 2 3))\n(check-equal? (merge-arrays (list 4 5 6 0 0 0) 3 (list 1 2 3) 3) '(1 2 3 4 5 6))\n(check-equal? (merge-arrays (list 2 0) 1 (list 1) 1) '(1 2))))\n(andmap identity tests))\n\n(check merge-arrays)", "entry_point": "merge-arrays", "signature": "(define (merge-arrays", "docstring": "Function Description:\nGiven two non-decreasing integer arrays 'nums1' and 'nums2', and their respective lengths 'm' and 'n',\nthis function merges 'nums2' into 'nums1' such that the merged array is in non-decreasing order.\n\nExamples:\n>>> merge-arrays([1 2 3 0 0 0] 3 [2 5 6] 3)\n'(1 2 2 3 5 6)\n>>> merge-arrays([1] 1 [] 0)\n'(1)\n\n", "instruction": "Write a Racket function `(define (merge-arrays` to solve the following problem:\nFunction Description:\nGiven two non-decreasing integer arrays 'nums1' and 'nums2', and their respective lengths 'm' and 'n',\nthis function merges 'nums2' into 'nums1' such that the merged array is in non-decreasing order.\n\nExamples:\n>>> merge-arrays([1 2 3 0 0 0] 3 [2 5 6] 3)\n'(1 2 2 3 5 6)\n>>> merge-arrays([1] 1 [] 0)\n'(1)\n\n", "level": "easy"}
{"task_id": "Racket/19", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a non-empty array, this function returns the third largest number in the array.\n;; If the third largest number does not exist, it returns the largest number in the array.\n;;\n;; Examples:\n;; >>> third-largest-number([2 3 1])\n;; 1 (The third largest number is 1)\n;; >>> third-largest-number([1 2])\n;; 2 (The third largest number does not exist, return the largest number)\n\n(define (third-largest-number nums)", "canonical_solution": "(define sorted-unique (sort (remove-duplicates nums) >))\n(if (>= (length sorted-unique) 3)\n(list-ref sorted-unique 2)\n(car sorted-unique)))", "test": "(define (check third-largest-number)\n(define tests\n(list (check-equal? (third-largest-number (list 2 3 1)) 1)\n(check-equal? (third-largest-number (list 1 2)) 2)\n(check-equal? (third-largest-number (list 5 2 4)) 2)\n(check-equal? (third-largest-number (list 10 10 10)) 10)\n(check-equal? (third-largest-number (list 7 6 5 4)) 5)))\n(andmap identity tests))\n\n(check third-largest-number)", "entry_point": "third-largest-number", "signature": "(define (third-largest-number", "docstring": "Function Description:\nGiven a non-empty array, this function returns the third largest number in the array.\nIf the third largest number does not exist, it returns the largest number in the array.\n\nExamples:\n>>> third-largest-number([2 3 1])\n1 (The third largest number is 1)\n>>> third-largest-number([1 2])\n2 (The third largest number does not exist, return the largest number)\n\n", "instruction": "Write a Racket function `(define (third-largest-number` to solve the following problem:\nFunction Description:\nGiven a non-empty array, this function returns the third largest number in the array.\nIf the third largest number does not exist, it returns the largest number in the array.\n\nExamples:\n>>> third-largest-number([2 3 1])\n1 (The third largest number is 1)\n>>> third-largest-number([1 2])\n2 (The third largest number does not exist, return the largest number)\n\n", "level": "easy"}
{"task_id": "Racket/20", "prompt": "#lang racket\n(require rackunit)\n\n;; Function Description:\n;; Given a list of numbers, this function extracts and returns all the even numbers from the list.\n;;\n;; Examples:\n;; >>> extract-even-numbers([1 2 3 4 5 6])\n;; '(2 4 6)\n;; >>> extract-even-numbers([1 3 5 7])\n;; '()\n\n(define (extract-even-numbers numbers)", "canonical_solution": "(filter even? numbers))", "test": "(define (check extract-even-numbers)\n(define tests\n(list (check-equal? (extract-even-numbers (list 1 2 3 4 5 6)) '(2 4 6))\n(check-equal? (extract-even-numbers (list 1 3 5 7)) '())\n(check-equal? (extract-even-numbers (list 2 4 6 8)) '(2 4 6 8))\n(check-equal? (extract-even-numbers (list 1 1 1 2)) '(2))\n(check-equal? (extract-even-numbers '()) '())))\n(andmap identity tests))\n\n(check extract-even-numbers)", "entry_point": "extract-even-numbers", "signature": "(define (extract-even-numbers", "docstring": "Function Description:\nGiven a list of numbers, this function extracts and returns all the even numbers from the list.\n\nExamples:\n>>> extract-even-numbers([1 2 3 4 5 6])\n'(2 4 6)\n>>> extract-even-numbers([1 3 5 7])\n'()\n\n", "instruction": "Write a Racket function `(define (extract-even-numbers` to solve the following problem:\nFunction Description:\nGiven a list of numbers, this function extracts and returns all the even numbers from the list.\n\nExamples:\n>>> extract-even-numbers([1 2 3 4 5 6])\n'(2 4 6)\n>>> extract-even-numbers([1 3 5 7])\n'()\n\n", "level": "easy"}
{"task_id": "Racket/21", "prompt": "#lang racket\n(require rackunit)\n\n(define (sum-leap-years start-year end-year)\n;; Calculates the sum of all leap years between two given years (exclusive).\n;; Leap years are years divisible by 4, but not by 100 unless also divisible by 400.\n;;\n;; Args:\n;; start-year (integer): The starting year (exclusive).\n;; end-year (integer): The ending year (exclusive).\n;;\n;; Returns:\n;; integer: The sum of all leap years in the given range.\n;;\n;; Examples:\n;; >>> sum-leap-years 2000 2005\n;; 2004\n;; >>> sum-leap-years 1980 1990\n;; 1984 + 1988 = 3972", "canonical_solution": "(define (iter year acc)\n(if (> year end-year)\nacc\n(iter (add1 year)\n(if (is-leap-year year)\n(+ year acc)\nacc))))\n(iter (add1 start-year) 0))\n(define (divisible? n divisor)\n(= (modulo n divisor) 0))\n(define (is-leap-year year)\n(or (and (divisible? year 4)\n(not (divisible? year 100)))\n(divisible? year 400)))", "test": "(define (check sum-leap-years)\n(define tests\n(list (check-equal? (sum-leap-years 2000 2005) 2004)\n(check-equal? (sum-leap-years 1980 1990) 3972)\n(check-equal? (sum-leap-years 1990 2000) 5988)\n(check-equal? (sum-leap-years 1900 2001) 48800)\n(check-equal? (sum-leap-years 2001 2010) 4012)\n(check-equal? (sum-leap-years 1800 1900) 44400)))\n(andmap identity tests))\n\n(check sum-leap-years)", "entry_point": "sum-leap-years", "signature": "(define (sum-leap-years start-year end-year)", "docstring": "Calculates the sum of all leap years between two given years (exclusive).\nLeap years are years divisible by 4, but not by 100 unless also divisible by 400.\n\nArgs:\nstart-year (integer): The starting year (exclusive).\nend-year (integer): The ending year (exclusive).\n\nReturns:\ninteger: The sum of all leap years in the given range.\n\nExamples:\n>>> sum-leap-years 2000 2005\n2004\n>>> sum-leap-years 1980 1990\n1984 + 1988 = 3972", "instruction": "Write a Racket function `(define (sum-leap-years start-year end-year)` to solve the following problem:\nCalculates the sum of all leap years between two given years (exclusive).\nLeap years are years divisible by 4, but not by 100 unless also divisible by 400.\n\nArgs:\nstart-year (integer): The starting year (exclusive).\nend-year (integer): The ending year (exclusive).\n\nReturns:\ninteger: The sum of all leap years in the given range.\n\nExamples:\n>>> sum-leap-years 2000 2005\n2004\n>>> sum-leap-years 1980 1990\n1984 + 1988 = 3972", "level": "middle"}
{"task_id": "Racket/22", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-substring-index haystack needle)\n;; Finds the first index of a substring (needle) within a larger string (haystack).\n;; If the substring is not part of the haystack, returns -1.\n;;\n;; Args:\n;; haystack (string): The string to search within.\n;; needle (string): The substring to find.\n;;\n;; Returns:\n;; integer: The index of the first occurrence of the needle in the haystack or -1 if not found.\n;;\n;; Examples:\n;; >>> find-substring-index \"hello world\" \"world\"\n;; 6\n;; >>> find-substring-index \"racket\" \"et\"\n;; 4\n;; >>> find-substring-index \"programming\" \"fun\"\n;; -1", "canonical_solution": "(let loop ((start 0))\n(cond\n((> (+ start (string-length needle)) (string-length haystack)) -1)\n((string=? (substring haystack start (+ start (string-length needle))) needle) start)\n(else (loop (add1 start))))))", "test": "(define (check find-substring-index)\n(define tests\n(list (check-equal? (find-substring-index \"hello world\" \"world\") 6)\n(check-equal? (find-substring-index \"racket\" \"et\") 4)\n(check-equal? (find-substring-index \"programming\" \"fun\") -1)\n(check-equal? (find-substring-index \"hellohello\" \"lo\") 3)\n(check-equal? (find-substring-index \"racket language\" \"guage\") 10)\n(check-equal? (find-substring-index \"example\" \"exam\") 0)))\n(andmap identity tests))\n\n(check find-substring-index)", "entry_point": "find-substring-index", "signature": "(define (find-substring-index haystack needle)", "docstring": "Finds the first index of a substring (needle) within a larger string (haystack).\nIf the substring is not part of the haystack, returns -1.\n\nArgs:\nhaystack (string): The string to search within.\nneedle (string): The substring to find.\n\nReturns:\ninteger: The index of the first occurrence of the needle in the haystack or -1 if not found.\n\nExamples:\n>>> find-substring-index \"hello world\" \"world\"\n6\n>>> find-substring-index \"racket\" \"et\"\n4\n>>> find-substring-index \"programming\" \"fun\"\n-1", "instruction": "Write a Racket function `(define (find-substring-index haystack needle)` to solve the following problem:\nFinds the first index of a substring (needle) within a larger string (haystack).\nIf the substring is not part of the haystack, returns -1.\n\nArgs:\nhaystack (string): The string to search within.\nneedle (string): The substring to find.\n\nReturns:\ninteger: The index of the first occurrence of the needle in the haystack or -1 if not found.\n\nExamples:\n>>> find-substring-index \"hello world\" \"world\"\n6\n>>> find-substring-index \"racket\" \"et\"\n4\n>>> find-substring-index \"programming\" \"fun\"\n-1", "level": "easy"}
{"task_id": "Racket/23", "prompt": "#lang racket\n(require rackunit)\n\n(define (calculate-R2 R1 S)\n;; Calculates the value of R2 based on the mean (S) and one of the numbers (R1).\n;; The mean is the average of R1 and R2, i.e., S = (R1 + R2) / 2.\n;;\n;; Args:\n;; R1 (integer): One of the numbers.\n;; S (integer): The mean of R1 and R2.\n;;\n;; Returns:\n;; integer: The value of R2.\n;;\n;; Examples:\n;; >>> calculate-R2 10 12\n;; 14\n;; >>> calculate-R2 -5 0\n;; 5\n;; >>> calculate-R2 7 8\n;; 9", "canonical_solution": "(- (* 2 S) R1))", "test": "(define (check calculate-R2)\n(define tests\n(list (check-equal? (calculate-R2 10 12) 14)\n(check-equal? (calculate-R2 -5 0) 5)\n(check-equal? (calculate-R2 7 8) 9)\n(check-equal? (calculate-R2 15 20) 25)\n(check-equal? (calculate-R2 0 -3) -6)\n(check-equal? (calculate-R2 -10 -8) -6)))\n(andmap identity tests))\n\n(check calculate-R2)", "entry_point": "calculate-R2", "signature": "(define (calculate-R2 R1 S)", "docstring": "Calculates the value of R2 based on the mean (S) and one of the numbers (R1).\nThe mean is the average of R1 and R2, i.e., S = (R1 + R2) / 2.\n\nArgs:\nR1 (integer): One of the numbers.\nS (integer): The mean of R1 and R2.\n\nReturns:\ninteger: The value of R2.\n\nExamples:\n>>> calculate-R2 10 12\n14\n>>> calculate-R2 -5 0\n5\n>>> calculate-R2 7 8\n9", "instruction": "Write a Racket function `(define (calculate-R2 R1 S)` to solve the following problem:\nCalculates the value of R2 based on the mean (S) and one of the numbers (R1).\nThe mean is the average of R1 and R2, i.e., S = (R1 + R2) / 2.\n\nArgs:\nR1 (integer): One of the numbers.\nS (integer): The mean of R1 and R2.\n\nReturns:\ninteger: The value of R2.\n\nExamples:\n>>> calculate-R2 10 12\n14\n>>> calculate-R2 -5 0\n5\n>>> calculate-R2 7 8\n9", "level": "easy"}
{"task_id": "Racket/24", "prompt": "#lang racket\n(require rackunit)\n(define (rearrange-numbers numbers order)\n;; Rearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\n;; Each character represents the position of the smallest, middle, and largest number respectively.\n;;\n;; Args:\n;; numbers (list): A list of three integers.\n;; order (string): A string of three characters ('A', 'B', 'C') in any order.\n;;\n;; Returns:\n;; list: The numbers rearranged according to the specified order.\n;;\n;; Examples:\n;; >>> rearrange-numbers (list 8 3 5) \"BCA\"\n;; '(5 8 3)\n;; >>> rearrange-numbers (list 10 20 15) \"CAB\"\n;; '(20 10 15)", "canonical_solution": "(let* ((sorted (sort numbers <))\n(positions (map (lambda (ch) (case ch\n[(#\\A) 0]\n[(#\\B) 1]\n[(#\\C) 2]))\n(string->list order))))\n(map (lambda (pos) (list-ref sorted pos)) positions)))", "test": "(define (check rearrange-numbers)\n(define tests\n(list (check-equal? (rearrange-numbers (list 8 3 5) \"BCA\") '(5 8 3))\n(check-equal? (rearrange-numbers (list 10 20 15) \"CAB\") '(20 10 15))\n(check-equal? (rearrange-numbers (list 7 9 8) \"ACB\") '(7 9 8))\n(check-equal? (rearrange-numbers (list 12 18 14) \"BAC\") '(14 12 18))\n(check-equal? (rearrange-numbers (list 6 2 4) \"CBA\") '(6 4 2))))\n(andmap identity tests))\n\n(check rearrange-numbers)", "entry_point": "rearrange-numbers", "signature": "(define (rearrange-numbers numbers order)", "docstring": "Rearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\nEach character represents the position of the smallest, middle, and largest number respectively.\n\nArgs:\nnumbers (list): A list of three integers.\norder (string): A string of three characters ('A', 'B', 'C') in any order.\n\nReturns:\nlist: The numbers rearranged according to the specified order.\n\nExamples:\n>>> rearrange-numbers (list 8 3 5) \"BCA\"\n'(5 8 3)\n>>> rearrange-numbers (list 10 20 15) \"CAB\"\n'(20 10 15)", "instruction": "Write a Racket function `(define (rearrange-numbers numbers order)` to solve the following problem:\nRearranges a list of three integers in the order specified by a string of characters 'A', 'B', and 'C'.\nEach character represents the position of the smallest, middle, and largest number respectively.\n\nArgs:\nnumbers (list): A list of three integers.\norder (string): A string of three characters ('A', 'B', 'C') in any order.\n\nReturns:\nlist: The numbers rearranged according to the specified order.\n\nExamples:\n>>> rearrange-numbers (list 8 3 5) \"BCA\"\n'(5 8 3)\n>>> rearrange-numbers (list 10 20 15) \"CAB\"\n'(20 10 15)", "level": "easy"}
{"task_id": "Racket/25", "prompt": "#lang racket\n(require rackunit)\n(define (find-aron-position colors)\n;; Determines Aron's position in a queue based on the colors of the shirts worn by people in line.\n;; Groups of people wearing the same color shirt are considered as one entity in the queue.\n;;\n;; Args:\n;; colors (list): A list of strings, each representing the shirt color of a person in line.\n;;\n;; Returns:\n;; integer: The position of Aron in the queue.\n;;\n;; Examples:\n;; >>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n;; 5\n;; >>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n;; 5\n;; >>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n;; 2", "canonical_solution": "(let loop ((remaining colors) (count 0) (last-color #f))\n(cond\n[(null? remaining) (add1 count)]\n[(or (not last-color) (not (string=? (car remaining) last-color)))\n(loop (cdr remaining) (add1 count) (car remaining))]\n[else\n(loop (cdr remaining) count (car remaining))])))", "test": "(define (check find-aron-position)\n(define tests\n(list (check-equal? (find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")) 5)\n(check-equal? (find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")) 5)\n(check-equal? (find-aron-position '(\"Y\" \"Y\" \"Y\")) 2)\n(check-equal? (find-aron-position '(\"B\" \"G\" \"G\" \"R\" \"R\")) 4)\n(check-equal? (find-aron-position '(\"R\" \"R\" \"R\" \"B\" \"B\" \"B\" \"G\" \"G\")) 4)))\n(andmap identity tests))\n\n(check find-aron-position)", "entry_point": "find-aron-position", "signature": "(define (find-aron-position colors)", "docstring": "Determines Aron's position in a queue based on the colors of the shirts worn by people in line.\nGroups of people wearing the same color shirt are considered as one entity in the queue.\n\nArgs:\ncolors (list): A list of strings, each representing the shirt color of a person in line.\n\nReturns:\ninteger: The position of Aron in the queue.\n\nExamples:\n>>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n5\n>>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n5\n>>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n2", "instruction": "Write a Racket function `(define (find-aron-position colors)` to solve the following problem:\nDetermines Aron's position in a queue based on the colors of the shirts worn by people in line.\nGroups of people wearing the same color shirt are considered as one entity in the queue.\n\nArgs:\ncolors (list): A list of strings, each representing the shirt color of a person in line.\n\nReturns:\ninteger: The position of Aron in the queue.\n\nExamples:\n>>> find-aron-position '(\"R\" \"G\" \"B\" \"B\" \"Y\")\n5\n>>> find-aron-position '(\"B\" \"B\" \"R\" \"G\" \"G\" \"Y\")\n5\n>>> find-aron-position '(\"Y\" \"Y\" \"Y\")\n2", "level": "middle"}
{"task_id": "Racket/26", "prompt": "#lang racket\n(require rackunit)\n(define (minimum-queue-length distances)\n;; Calculates the minimum length of a queue to avoid conflicts based on individual personal space requirements.\n;; Each student in the queue has a specific minimum distance that must be maintained from other students.\n;; The function computes the minimum total length of the queue to satisfy these requirements.\n;;\n;; Args:\n;; distances (list): A list of integers where each integer represents the personal space requirement of a student.\n;;\n;; Returns:\n;; integer: The minimum total length of the queue.\n;;\n;; Examples:\n;; >>> minimum-queue-length '(1 2 3)\n;; 6\n;; >>> minimum-queue-length '(2 2 2)\n;; 6\n;; >>> minimum-queue-length '(4 1 3 2)\n;; 10", "canonical_solution": "(if (null? distances)\n0\n(+ (car distances) (minimum-queue-length (cdr distances)))))", "test": "(define (check minimum-queue-length)\n(define tests\n(list (check-equal? (minimum-queue-length '(1 2 3)) 6)\n(check-equal? (minimum-queue-length '(2 2 2)) 6)\n(check-equal? (minimum-queue-length '(4 1 3 2)) 10)\n(check-equal? (minimum-queue-length '(1 3 2 4)) 10)\n(check-equal? (minimum-queue-length '(3 1 2)) 6)))\n(andmap identity tests))\n\n(check minimum-queue-length)", "entry_point": "minimum-queue-length", "signature": "(define (minimum-queue-length distances)", "docstring": "Calculates the minimum length of a queue to avoid conflicts based on individual personal space requirements.\nEach student in the queue has a specific minimum distance that must be maintained from other students.\nThe function computes the minimum total length of the queue to satisfy these requirements.\n\nArgs:\ndistances (list): A list of integers where each integer represents the personal space requirement of a student.\n\nReturns:\ninteger: The minimum total length of the queue.\n\nExamples:\n>>> minimum-queue-length '(1 2 3)\n6\n>>> minimum-queue-length '(2 2 2)\n6\n>>> minimum-queue-length '(4 1 3 2)\n10", "instruction": "Write a Racket function `(define (minimum-queue-length distances)` to solve the following problem:\nCalculates the minimum length of a queue to avoid conflicts based on individual personal space requirements.\nEach student in the queue has a specific minimum distance that must be maintained from other students.\nThe function computes the minimum total length of the queue to satisfy these requirements.\n\nArgs:\ndistances (list): A list of integers where each integer represents the personal space requirement of a student.\n\nReturns:\ninteger: The minimum total length of the queue.\n\nExamples:\n>>> minimum-queue-length '(1 2 3)\n6\n>>> minimum-queue-length '(2 2 2)\n6\n>>> minimum-queue-length '(4 1 3 2)\n10", "level": "easy"}
{"task_id": "Racket/27", "prompt": "#lang racket\n(require rackunit)\n(define (can-fit-sticks-in-boxes sticks boxes)\n;; Determines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\n;; Each box can only contain one stick.\n;;\n;; Args:\n;; sticks (list): A list of integers representing the lengths of the sticks.\n;; boxes (list): A list of integers representing the heights of the boxes.\n;;\n;; Returns:\n;; string: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n;;\n;; Examples:\n;; >>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n;; \"DA\"\n;; >>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n;; \"NE\"\n;; >>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n;; \"NE\"", "canonical_solution": "(define sorted-sticks (sort sticks <))\n(define sorted-boxes (sort boxes <))\n(define (iter sticks boxes)\n(cond\n[(null? sticks) \"DA\"]\n[(null? boxes) \"NE\"]\n[(<= (car sticks) (car boxes))\n(iter (cdr sticks) (cdr boxes))]\n[else \"NE\"]))\n(iter sorted-sticks sorted-boxes))", "test": "(define (check can-fit-sticks-in-boxes)\n(define tests\n(list (check-equal? (can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)) \"DA\")\n(check-equal? (can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)) \"NE\")\n(check-equal? (can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)) \"NE\")\n(check-equal? (can-fit-sticks-in-boxes '(1 1 1) '(2 2 2)) \"DA\")\n(check-equal? (can-fit-sticks-in-boxes '(10 20 30) '(30 20 10)) \"DA\")))\n(andmap identity tests))\n\n(check can-fit-sticks-in-boxes)", "entry_point": "can-fit-sticks-in-boxes", "signature": "(define (can-fit-sticks-in-boxes sticks boxes)", "docstring": "Determines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\nEach box can only contain one stick.\n\nArgs:\nsticks (list): A list of integers representing the lengths of the sticks.\nboxes (list): A list of integers representing the heights of the boxes.\n\nReturns:\nstring: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n\nExamples:\n>>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n\"DA\"\n>>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n\"NE\"\n>>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n\"NE\"", "instruction": "Write a Racket function `(define (can-fit-sticks-in-boxes sticks boxes)` to solve the following problem:\nDetermines if each stick can be fit into a box, where the length of each stick must be less than or equal to the height of the box.\nEach box can only contain one stick.\n\nArgs:\nsticks (list): A list of integers representing the lengths of the sticks.\nboxes (list): A list of integers representing the heights of the boxes.\n\nReturns:\nstring: \"DA\" if all sticks can be fit into the boxes, \"NE\" otherwise.\n\nExamples:\n>>> can-fit-sticks-in-boxes '(5 4 6) '(6 5 7)\n\"DA\"\n>>> can-fit-sticks-in-boxes '(8 6 7) '(5 4 3)\n\"NE\"\n>>> can-fit-sticks-in-boxes '(2 3 4) '(1 5 3)\n\"NE\"", "level": "middle"}
{"task_id": "Racket/28", "prompt": "#lang racket\n(require rackunit)\n(define (determine-winner stone-piles)\n;; Determines the winner of a game played by Alice and Bob with stone piles.\n;; They take turns to remove a stone from any pile where the number of stones is greater than the previous pile.\n;; Alice starts first. The player unable to make a move loses.\n;; The game is played optimally by both players.\n;;\n;; Args:\n;; stone-piles (list): A list of integers representing the number of stones in each pile in ascending order.\n;;\n;; Returns:\n;; string: \"Alice\" if Alice wins, \"Bob\" if Bob wins.\n;;\n;; Examples:\n;; >>> determine-winner '(1)\n;; \"Alice\"\n;; >>> determine-winner '(2 3)\n;; \"Alice\"\n;; >>> determine-winner '(1 2 3)\n;; \"Bob\"", "canonical_solution": "(if (even? (apply + stone-piles))\n\"Bob\"\n\"Alice\"))", "test": "(define (check determine-winner)\n(define tests\n(list (check-equal? (determine-winner '(1)) \"Alice\")\n(check-equal? (determine-winner '(2 3)) \"Alice\")\n(check-equal? (determine-winner '(1 2 3)) \"Bob\")\n(check-equal? (determine-winner '(2)) \"Bob\")\n(check-equal? (determine-winner '(1 2 3 4)) \"Bob\")))\n(andmap identity tests))\n\n(check determine-winner)", "entry_point": "determine-winner", "signature": "(define (determine-winner stone-piles)", "docstring": "Determines the winner of a game played by Alice and Bob with stone piles.\nThey take turns to remove a stone from any pile where the number of stones is greater than the previous pile.\nAlice starts first. The player unable to make a move loses.\nThe game is played optimally by both players.\n\nArgs:\nstone-piles (list): A list of integers representing the number of stones in each pile in ascending order.\n\nReturns:\nstring: \"Alice\" if Alice wins, \"Bob\" if Bob wins.\n\nExamples:\n>>> determine-winner '(1)\n\"Alice\"\n>>> determine-winner '(2 3)\n\"Alice\"\n>>> determine-winner '(1 2 3)\n\"Bob\"", "instruction": "Write a Racket function `(define (determine-winner stone-piles)` to solve the following problem:\nDetermines the winner of a game played by Alice and Bob with stone piles.\nThey take turns to remove a stone from any pile where the number of stones is greater than the previous pile.\nAlice starts first. The player unable to make a move loses.\nThe game is played optimally by both players.\n\nArgs:\nstone-piles (list): A list of integers representing the number of stones in each pile in ascending order.\n\nReturns:\nstring: \"Alice\" if Alice wins, \"Bob\" if Bob wins.\n\nExamples:\n>>> determine-winner '(1)\n\"Alice\"\n>>> determine-winner '(2 3)\n\"Alice\"\n>>> determine-winner '(1 2 3)\n\"Bob\"", "level": "easy"}
{"task_id": "Racket/29", "prompt": "#lang racket\n(require rackunit)\n(define (count-title-characters title)\n;; How many characters are there in the title of this essay? Note: The title may contain uppercase and lowercase English letters, numeric characters, spaces, and line breaks. When counting the number of characters in a title, spaces and line breaks are not counted.\n;; Examples:\n;; >>> count-title-characters \"234\"\n;; 3", "canonical_solution": "  (length (filter (lambda (ch) (and (not (char-whitespace? ch)) (not (char=? ch #\\newline))))\n                  (string->list title))))", "test": "(define (check count-title-characters)\n  (define tests\n    (list (check-equal? (count-title-characters \"234\") 3)\n          (check-equal? (count-title-characters \"Ca 45\") 4)\n          (check-equal? (count-title-characters \"Hello World\") 10)\n          (check-equal? (count-title-characters \"Racket Programming 101\\n\") 20)\n          (check-equal? (count-title-characters \"   \") 0)))\n  (andmap identity tests))\n\n(check count-title-characters)", "entry_point": "count-title-characters", "signature": "(define (count-title-characters title)", "docstring": "How many characters are there in the title of this essay? Note: The title may contain uppercase and lowercase English letters, numeric characters, spaces, and line breaks. When counting the number of characters in a title, spaces and line breaks are not counted.\nExamples:\n>>> count-title-characters \"234\"\n3", "instruction": "Write a Racket function `(define (count-title-characters title)` to solve the following problem:\nHow many characters are there in the title of this essay? Note: The title may contain uppercase and lowercase English letters, numeric characters, spaces, and line breaks. When counting the number of characters in a title, spaces and line breaks are not counted.\nExamples:\n>>> count-title-characters \"234\"\n3", "level": "easy"}
{"task_id": "Racket/30", "prompt": "#lang racket\n(require rackunit)\n(define (sum-arithmetic-series a1 a2 n)\n;; Computes the sum of the first n terms of an arithmetic series.\n;; An arithmetic series is defined where each term after the first is obtained by adding a constant difference to the preceding term.\n;;\n;; Args:\n;; a1 (integer): The first term of the arithmetic series.\n;; a2 (integer): The second term of the arithmetic series.\n;; n (integer): The number of terms in the series to sum.\n;;\n;; Returns:\n;; integer: The sum of the first n terms of the series.\n;;\n;; Examples:\n;; >>> sum-arithmetic-series 1 2 3\n;; 6\n;; >>> sum-arithmetic-series -5 -10 5\n;; -75", "canonical_solution": "(let* ((d (- a2 a1))\n(an (+ a1 (* (- n 1) d))))\n(/ (* n (+ a1 an)) 2)))", "test": "(define (check sum-arithmetic-series)\n(define tests\n(list (check-equal? (sum-arithmetic-series 1 2 3) 6)\n(check-equal? (sum-arithmetic-series -5 -10 5) -75)\n(check-equal? (sum-arithmetic-series 5 7 4) 32)\n(check-equal? (sum-arithmetic-series 3 6 10) 165)\n(check-equal? (sum-arithmetic-series 10 15 7) 175)))\n(andmap identity tests))\n\n(check sum-arithmetic-series)", "entry_point": "sum-arithmetic-series", "signature": "(define (sum-arithmetic-series a1 a2 n)", "docstring": "Computes the sum of the first n terms of an arithmetic series.\nAn arithmetic series is defined where each term after the first is obtained by adding a constant difference to the preceding term.\n\nArgs:\na1 (integer): The first term of the arithmetic series.\na2 (integer): The second term of the arithmetic series.\nn (integer): The number of terms in the series to sum.\n\nReturns:\ninteger: The sum of the first n terms of the series.\n\nExamples:\n>>> sum-arithmetic-series 1 2 3\n6\n>>> sum-arithmetic-series -5 -10 5\n-75", "instruction": "Write a Racket function `(define (sum-arithmetic-series a1 a2 n)` to solve the following problem:\nComputes the sum of the first n terms of an arithmetic series.\nAn arithmetic series is defined where each term after the first is obtained by adding a constant difference to the preceding term.\n\nArgs:\na1 (integer): The first term of the arithmetic series.\na2 (integer): The second term of the arithmetic series.\nn (integer): The number of terms in the series to sum.\n\nReturns:\ninteger: The sum of the first n terms of the series.\n\nExamples:\n>>> sum-arithmetic-series 1 2 3\n6\n>>> sum-arithmetic-series -5 -10 5\n-75", "level": "easy"}
{"task_id": "Racket/31", "prompt": "#lang racket\n(require rackunit)\n(define (count-hehe matrix)\n;; Counts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\n;; The string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n;;\n;; Args:\n;; matrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n;;\n;; Returns:\n;; integer: The number of times \"hehe\" appears in the matrix.\n;;\n;; Examples:\n;; >>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n;; 10\n;; >>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n;; 1", "canonical_solution": "(define (in-bounds? row col)\n(and (>= row 0) (< row (length matrix))\n(>= col 0) (< col (length (first matrix)))))\n(define (check-sequence row col dr dc)\n(and (in-bounds? (+ row (* 3 dr)) (+ col (* 3 dc)))\n(equal? (list-ref (list-ref matrix row) col) \"h\")\n(equal? (list-ref (list-ref matrix (+ row dr)) (+ col dc)) \"e\")\n(equal? (list-ref (list-ref matrix (+ row (* 2 dr))) (+ col (* 2 dc))) \"h\")\n(equal? (list-ref (list-ref matrix (+ row (* 3 dr))) (+ col (* 3 dc))) \"e\")))\n(define (iter row col count)\n(cond\n[(>= row (length matrix)) count]\n[(>= col (length (first matrix))) (iter (+ row 1) 0 count)]\n[else\n(iter row (+ col 1)\n(+ count\n(for/sum ([dr (in-list '(0 1 1 1))]\n[dc (in-list '(1 1 0 -1))])\n(if (and (in-bounds? row col) (check-sequence row col dr dc)) 1 0))))]))\n(iter 0 0 0))", "test": "(define (check count-hehe)\n(define tests\n(list (check-equal? (count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))) 10)\n(check-equal? (count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))) 1)))\n(andmap identity tests))\n\n(check count-hehe)", "entry_point": "count-hehe", "signature": "(define (count-hehe matrix)", "docstring": "Counts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\nThe string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n\nArgs:\nmatrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n\nReturns:\ninteger: The number of times \"hehe\" appears in the matrix.\n\nExamples:\n>>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n10\n>>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n1", "instruction": "Write a Racket function `(define (count-hehe matrix)` to solve the following problem:\nCounts the number of occurrences of the string \"hehe\" in a given 2D matrix of characters.\nThe string \"hehe\" can appear horizontally, vertically, or diagonally in any direction.\n\nArgs:\nmatrix (list of lists): A 2D matrix represented as a list of lists, each sublist representing a row of characters.\n\nReturns:\ninteger: The number of times \"hehe\" appears in the matrix.\n\nExamples:\n>>> count-hehe '((\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"h\" \"e\" \"h\"))\n10\n>>> count-hehe '((\"h\" \"e\" \"l\" \"l\" \"o\") (\"e\" \"h\" \"e\" \"h\" \"e\") (\"h\" \"e\" \"l\" \"l\" \"o\"))\n1", "level": "hard"}
{"task_id": "Racket/32", "prompt": "#lang racket\n(require rackunit)\n(define (count-stairways n)\n;; Calculate the number of different ways to climb a staircase of 'n' steps, \n;; where you can take either one or two steps at a time.\n;; For a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\n;; For a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n;;\n;; Examples:\n;; >>> count-stairways 3\n;; 3\n;; >>> count-stairways 5\n;; 8\n", "canonical_solution": "(cond\n[(<= n 0) 0]\n[(= n 1) 1]\n[(= n 2) 2]\n[else (+ (count-stairways (- n 1)) (count-stairways (- n 2)))]))", "test": "(define (check count-stairways)\n(define tests\n(list (check-equal? (count-stairways 0) 0)\n(check-equal? (count-stairways 1) 1)\n(check-equal? (count-stairways 2) 2)\n(check-equal? (count-stairways 3) 3)\n(check-equal? (count-stairways 4) 5)\n(check-equal? (count-stairways 5) 8)\n(check-equal? (count-stairways 6) 13)))\n(andmap identity tests))\n\n(check count-stairways)", "entry_point": "count-stairways", "signature": "(define (count-stairways n)", "docstring": "Calculate the number of different ways to climb a staircase of 'n' steps, \nwhere you can take either one or two steps at a time.\nFor a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\nFor a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n\nExamples:\n>>> count-stairways 3\n3\n>>> count-stairways 5\n8\n", "instruction": "Write a Racket function `(define (count-stairways n)` to solve the following problem:\nCalculate the number of different ways to climb a staircase of 'n' steps, \nwhere you can take either one or two steps at a time.\nFor a staircase of 3 steps, there are 3 ways: (1,1,1), (1,2), (2,1).\nFor a staircase of 4 steps, there are 5 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2).\n\nExamples:\n>>> count-stairways 3\n3\n>>> count-stairways 5\n8\n", "level": "easy"}
{"task_id": "Racket/33", "prompt": "#lang racket\n(require rackunit)\n(define (sort-votes candidate-count votes)\n;; Sort the votes for student council elections.\n;; Each vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\n;; The function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n;; \n;; Examples:\n;; >>> sort-votes 3 '(3 1 2 3 2)\n;; '(1 2 2 3 3)\n;; >>> sort-votes 4 '(4 4 1 2 3 2 1)\n;; '(1 1 2 2 3 4 4)", "canonical_solution": "(define (count-votes candidate)\n(length (filter (lambda (vote) (= vote candidate)) votes)))\n(flatten (map (lambda (candidate) (make-list (count-votes candidate) candidate))\n(range 1 (add1 candidate-count)))))", "test": "(define (check sort-votes)\n(define tests\n(list (check-equal? (sort-votes 3 '(3 1 2 3 2)) '(1 2 2 3 3))\n(check-equal? (sort-votes 4 '(4 4 1 2 3 2 1)) '(1 1 2 2 3 4 4))\n(check-equal? (sort-votes 5 '(5 3 1 4 2 5 3 2 4)) '(1 2 2 3 3 4 4 5 5))\n(check-equal? (sort-votes 2 '(2 2 1 1 2)) '(1 1 2 2 2))\n(check-equal? (sort-votes 1 '(1 1 1 1 1)) '(1 1 1 1 1))))\n(andmap identity tests))\n\n(check sort-votes)", "entry_point": "sort-votes", "signature": "(define (sort-votes candidate-count votes)", "docstring": "Sort the votes for student council elections.\nEach vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\nThe function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n\nExamples:\n>>> sort-votes 3 '(3 1 2 3 2)\n'(1 2 2 3 3)\n>>> sort-votes 4 '(4 4 1 2 3 2 1)\n'(1 1 2 2 3 4 4)", "instruction": "Write a Racket function `(define (sort-votes candidate-count votes)` to solve the following problem:\nSort the votes for student council elections.\nEach vote is represented by a candidate number. Candidates are numbered from 1 to 'candidate-count'.\nThe function takes the number of candidates and a list of votes, then returns the votes sorted in ascending order.\n\nExamples:\n>>> sort-votes 3 '(3 1 2 3 2)\n'(1 2 2 3 3)\n>>> sort-votes 4 '(4 4 1 2 3 2 1)\n'(1 1 2 2 3 4 4)", "level": "easy"}
{"task_id": "Racket/34", "prompt": "#lang racket\n(require rackunit)\n(define (count-ball-arrangements n r)\n;; This function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\n;; such that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n;;\n;; Examples:\n;; >>> count-ball-arrangements 4 2\n;; 14\n;; >>> count-ball-arrangements 5 3\n;; 150", "canonical_solution": "(* (stirling n r) (factorial r)))\n(define (factorial n)\n(if (= n 0) 1 (* n (factorial (- n 1)))))\n\n(define (stirling n k)\n(if (= k 0) 0\n(if (= k n) 1\n(+ (* k (stirling (- n 1) k)) (stirling (- n 1) (- k 1))))))", "test": "(define (check count-ball-arrangements)\n(define tests\n(list (check-equal? (count-ball-arrangements 3 2) 6)\n(check-equal? (count-ball-arrangements 4 2) 14)\n(check-equal? (count-ball-arrangements 5 3) 150)\n(check-equal? (count-ball-arrangements 6 3) 540)\n(check-equal? (count-ball-arrangements 5 5) 120)))\n(andmap identity tests))\n\n(check count-ball-arrangements)", "entry_point": "count-ball-arrangements", "signature": "(define (count-ball-arrangements n r)", "docstring": "This function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\nsuch that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n\nExamples:\n>>> count-ball-arrangements 4 2\n14\n>>> count-ball-arrangements 5 3\n150", "instruction": "Write a Racket function `(define (count-ball-arrangements n r)` to solve the following problem:\nThis function calculates the number of ways to arrange 'n' distinct balls into 'r' distinct boxes\nsuch that no box is empty. The arrangement is considered different if a ball is placed in a different box.\n\nExamples:\n>>> count-ball-arrangements 4 2\n14\n>>> count-ball-arrangements 5 3\n150", "level": "easy"}
{"task_id": "Racket/35", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-optimal-meeting-place city-data)\n;; This function finds the optimal meeting place for a reunion, given the number of classmates in various cities \n;; along a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \n;; with the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n;;\n;; Examples:\n;; >>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n;; '(\"CityB\" 1200)\n", "canonical_solution": "(define (total-cost city-distance)\n(apply + (map (lambda (city) \n(* (first city) (abs (- city-distance (second city)))))\ncity-data)))\n(define sorted-cities (sort city-data (lambda (a b) (< (second a) (second b)))))\n(define optimal-city \n(argmin (lambda (city) (total-cost (second city))) sorted-cities))\n(list (third optimal-city) (total-cost (second optimal-city))))", "test": "(define (check find-optimal-meeting-place)\n(define tests\n(list (check-equal? (find-optimal-meeting-place '((7 9289 \"Vladivostok\")\n(5 8523 \"Chabarovsk\")\n(3 5184 \"Irkutsk\")\n(8 2213 \"Yalutorovsk\")\n(10 0 \"Moscow\"))) \n'(\"Yalutorovsk\" 112125))\n(check-equal? (find-optimal-meeting-place '((5 300 \"CityA\")\n(3 100 \"CityB\")\n(2 0 \"Moscow\"))) \n'(\"CityB\" 1200))\n(check-equal? (find-optimal-meeting-place '((4 200 \"CityX\")\n(6 400 \"CityY\")\n(1 0 \"Moscow\"))) \n'(\"CityY\" 1200))))\n(andmap identity tests))\n\n(check find-optimal-meeting-place)", "entry_point": "find-optimal-meeting-place", "signature": "(define (find-optimal-meeting-place city-data)", "docstring": "This function finds the optimal meeting place for a reunion, given the number of classmates in various cities \nalong a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \nwith the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n\nExamples:\n>>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n'(\"CityB\" 1200)\n", "instruction": "Write a Racket function `(define (find-optimal-meeting-place city-data)` to solve the following problem:\nThis function finds the optimal meeting place for a reunion, given the number of classmates in various cities \nalong a railway line and the distances of these cities from Moscow. The goal is to minimize the total travel cost, \nwith the cost being the distance traveled by each person. If costs are equal, the city closer to Moscow is preferred.\n\nExamples:\n>>> find-optimal-meeting-place '((5 300 \"CityA\") (3 100 \"CityB\") (2 0 \"Moscow\"))\n'(\"CityB\" 1200)\n", "level": "hard"}
{"task_id": "Racket/36", "prompt": "#lang racket\n(require rackunit)\n\n(define (count-communicating-cows n d cow-positions)\n;; This function calculates the number of pairs of cows that can communicate with each other.\n;; Communication is possible if the cows are within a distance 'd' of each other.\n;; 'n' is the number of cows, 'd' is the maximum distance for communication, \n;; and 'cow-positions' is a list of the positions of the cows.\n;;\n;; Examples:\n;; >>> count-communicating-cows 4 5 '(1 3 6 10)\n;; 4\n;; >>> count-communicating-cows 3 4 '(2 5 9)\n;; 2", "canonical_solution": "(define sorted-positions (sort cow-positions <))\n(define (can-communicate? cow1 cow2)\n(<= (abs (- cow1 cow2)) d))\n(define count 0)\n(for ([i (in-range n)])\n(for ([j (in-range (add1 i) n)])\n(when (can-communicate? (list-ref sorted-positions i) (list-ref sorted-positions j))\n(set! count (add1 count)))))\ncount)", "test": "(define (check count-communicating-cows)\n(define tests\n(list (check-equal? (count-communicating-cows 5 10 '(10 12 16 37 40)) 4)\n(check-equal? (count-communicating-cows 4 5 '(1 3 6 10)) 4)\n(check-equal? (count-communicating-cows 3 4 '(2 5 9)) 2)))\n(andmap identity tests))\n\n(check count-communicating-cows)", "entry_point": "count-communicating-cows", "signature": "(define (count-communicating-cows n d cow-positions)", "docstring": "This function calculates the number of pairs of cows that can communicate with each other.\nCommunication is possible if the cows are within a distance 'd' of each other.\n'n' is the number of cows, 'd' is the maximum distance for communication, \nand 'cow-positions' is a list of the positions of the cows.\n\nExamples:\n>>> count-communicating-cows 4 5 '(1 3 6 10)\n4\n>>> count-communicating-cows 3 4 '(2 5 9)\n2", "instruction": "Write a Racket function `(define (count-communicating-cows n d cow-positions)` to solve the following problem:\nThis function calculates the number of pairs of cows that can communicate with each other.\nCommunication is possible if the cows are within a distance 'd' of each other.\n'n' is the number of cows, 'd' is the maximum distance for communication, \nand 'cow-positions' is a list of the positions of the cows.\n\nExamples:\n>>> count-communicating-cows 4 5 '(1 3 6 10)\n4\n>>> count-communicating-cows 3 4 '(2 5 9)\n2", "level": "middle"}
{"task_id": "Racket/37", "prompt": "#lang racket\n(require rackunit)\n\n(define (find-word-and-count word text)\n;; This function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\n;; The search is case-insensitive and looks for complete word matches only.\n;; If the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n;;\n;; Examples:\n;; >>> find-word-and-count \"To\" \"to be or not to be is a question\"\n;; '(2 0)\n;; >>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n;; -1", "canonical_solution": "(define words (string-split (string-downcase text)))\n(define target (string-downcase word))\n(define (find-index lst item [index 0])\n(cond [(null? lst) -1]\n[(equal? (car lst) item) index]\n[else (find-index (cdr lst) item (add1 index))]))\n(define index (find-index words target))\n(if (= index -1)\n-1\n(list (count (lambda (w) (equal? w target)) words) index)))", "test": "(define (check find-word-and-count)\n(define tests\n(list (check-equal? (find-word-and-count \"To\" \"to be or not to be is a question\") '(2 0))\n(check-equal? (find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\") -1)\n(check-equal? (find-word-and-count \"a\" \"A man a plan a canal Panama\") '(3 0))))\n(andmap identity tests))\n\n(check find-word-and-count)", "entry_point": "find-word-and-count", "signature": "(define (find-word-and-count word text)", "docstring": "This function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\nThe search is case-insensitive and looks for complete word matches only.\nIf the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n\nExamples:\n>>> find-word-and-count \"To\" \"to be or not to be is a question\"\n'(2 0)\n>>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n-1", "instruction": "Write a Racket function `(define (find-word-and-count word text)` to solve the following problem:\nThis function searches for a given word in a text, counting its occurrences and finding the position of its first appearance.\nThe search is case-insensitive and looks for complete word matches only.\nIf the word is not found, the function returns -1. Otherwise, it returns a list containing the count of occurrences and the position of the first occurrence.\n\nExamples:\n>>> find-word-and-count \"To\" \"to be or not to be is a question\"\n'(2 0)\n>>> find-word-and-count \"to\" \"Did the Ottoman Empire lose its power at that time\"\n-1", "level": "hard"}
{"task_id": "Racket/38", "prompt": "#lang racket\n(require rackunit)\n\n(define (count-card-distributions n m card-distribution)\n;; This function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\n;; where each person gets a specific number of cards as per the 'card-distribution' list.\n;; The result is given modulo 10007.\n;;\n;; Examples:\n;; >>> count-card-distributions 5 2 '(3 1)\n;; 20\n;; >>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n;; 8707", "canonical_solution": "(define (iter remaining-cards distribution)\n(if (null? distribution)\n1\n(let* ([cards (car distribution)]\n[ways (nCr remaining-cards cards)])\n(modulo (* ways (iter (- remaining-cards cards) (cdr distribution))) 10007))))\n(iter n card-distribution))\n(define (factorial n)\n(if (<= n 1) 1 (* n (factorial (- n 1)))))\n\n(define (nCr n r)\n(if (> r n) 0\n(modulo (/ (factorial n) (* (factorial r) (factorial (- n r)))) 10007)))", "test": "(define (check count-card-distributions)\n(define tests\n(list (check-equal? (count-card-distributions 5 2 '(3 1)) 20)\n(check-equal? (count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)) 8707)))\n(andmap identity tests))\n\n(check count-card-distributions)", "entry_point": "count-card-distributions", "signature": "(define (count-card-distributions n m card-distribution)", "docstring": "This function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\nwhere each person gets a specific number of cards as per the 'card-distribution' list.\nThe result is given modulo 10007.\n\nExamples:\n>>> count-card-distributions 5 2 '(3 1)\n20\n>>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n8707", "instruction": "Write a Racket function `(define (count-card-distributions n m card-distribution)` to solve the following problem:\nThis function calculates the number of ways to distribute 'n' distinct cards among 'm' people,\nwhere each person gets a specific number of cards as per the 'card-distribution' list.\nThe result is given modulo 10007.\n\nExamples:\n>>> count-card-distributions 5 2 '(3 1)\n20\n>>> count-card-distributions 20 19 '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\n8707", "level": "hard"}
{"task_id": "Racket/39", "prompt": "#lang racket\n(require rackunit)\n\n(define (max-herb-value T M herb-data)\n;; Calculate the maximum total value of herbs that can be collected within a given time constraint.\n;; Each herb has a time requirement and a value.\n;; Args:\n;; T: Total time available for collecting herbs.\n;; M: Number of herbs available.\n;; herb-data: List of pairs, each containing time to collect a herb and its value.\n;; Returns:\n;; Maximum total value of herbs that can be collected within the time constraint.\n;; Example:\n;; (max-herb-value 10 2 '((5 10) (4 7)))\n;; ; Returns 17\n;; (max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n;; ; Returns 17", "canonical_solution": "(define dp (make-vector (add1 T) 0))\n(for ([i (in-range M)])\n(for ([j (in-range (- T 1) -1 -1)])\n(define herb (list-ref herb-data i))\n(define t (car herb))\n(define v (cadr herb))\n(when (<= t (+ j 1))\n(let ((new-index (- (+ j 1) t)))\n(when (and (>= new-index 0) (< new-index T))\n(vector-set! dp (+ j 1) (max (vector-ref dp (+ j 1)) (+ (vector-ref dp new-index) v))))))))\n(vector-ref dp T))", "test": "(define (test-max-herb-value)\n(define tests\n(list (check-equal? (max-herb-value 10 2 '((5 10) (4 7))) 17)\n(check-equal? (max-herb-value 10 3 '((3 6) (4 7) (2 4))) 17)\n(check-equal? (max-herb-value 15 4 '((3 8) (5 15) (6 10) (7 6))) 33)\n(check-equal? (max-herb-value 5 2 '((2 3) (3 4))) 7)\n(check-equal? (max-herb-value 7 3 '((1 2) (2 5) (3 7))) 14)))\n(andmap identity tests))\n\n(test-max-herb-value)", "entry_point": "max-herb-value", "signature": "(define (max-herb-value T M herb-data)", "docstring": "Calculate the maximum total value of herbs that can be collected within a given time constraint.\nEach herb has a time requirement and a value.\nArgs:\nT: Total time available for collecting herbs.\nM: Number of herbs available.\nherb-data: List of pairs, each containing time to collect a herb and its value.\nReturns:\nMaximum total value of herbs that can be collected within the time constraint.\nExample:\n(max-herb-value 10 2 '((5 10) (4 7)))\n; Returns 17\n(max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n; Returns 17", "instruction": "Write a Racket function `(define (max-herb-value T M herb-data)` to solve the following problem:\nCalculate the maximum total value of herbs that can be collected within a given time constraint.\nEach herb has a time requirement and a value.\nArgs:\nT: Total time available for collecting herbs.\nM: Number of herbs available.\nherb-data: List of pairs, each containing time to collect a herb and its value.\nReturns:\nMaximum total value of herbs that can be collected within the time constraint.\nExample:\n(max-herb-value 10 2 '((5 10) (4 7)))\n; Returns 17\n(max-herb-value 10 3 '((3 6) (4 7) (2 4)))\n; Returns 17", "level": "hard"}
{"task_id": "Racket/40", "prompt": "#lang racket\n(require rackunit)\n\n(define (remove-duplicates-and-sort numbers)\n;; Function: remove-duplicates-and-sort\n;;\n;; Description: \n;; This function takes a list of integers and performs two main tasks:\n;; 1. Removes any duplicate numbers.\n;; 2. Sorts the remaining numbers in ascending order.\n;;\n;; Args:\n;; numbers: A list of integers.\n;;\n;; Returns:\n;; A list of integers that are unique and sorted in ascending order.\n;;\n;; Examples:\n;; (remove-duplicates-and-sort '(3 1 4 1 5 9 2 6 5 3 5)) => '(1 2 3 4 5 6 9)\n;; (remove-duplicates-and-sort '(10 20 20 30 40 50)) => '(10 20 30 40 50)\n;; (remove-duplicates-and-sort '(5 4 3 2 1)) => '(1 2 3 4 5)", "canonical_solution": "(sort (set->list (list->set numbers)) <))", "test": "(define (test-remove-duplicates-and-sort)\n(define tests\n(list\n(check-equal? (remove-duplicates-and-sort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 2 3 4 5 6 9))\n(check-equal? (remove-duplicates-and-sort '(10 20 20 30 40 50)) '(10 20 30 40 50))\n(check-equal? (remove-duplicates-and-sort '(5 4 3 2 1)) '(1 2 3 4 5))\n(check-equal? (remove-duplicates-and-sort '(7 7 7 7 7 7 7)) '(7))\n(check-equal? (remove-duplicates-and-sort '()) '())))\n(andmap identity tests))\n\n(test-remove-duplicates-and-sort)", "entry_point": "remove-duplicates-and-sort", "signature": "(define (remove-duplicates-and-sort numbers)", "docstring": "Function: remove-duplicates-and-sort\n\nDescription: \nThis function takes a list of integers and performs two main tasks:\n1. Removes any duplicate numbers.\n2. Sorts the remaining numbers in ascending order.\n\nArgs:\nnumbers: A list of integers.\n\nReturns:\nA list of integers that are unique and sorted in ascending order.\n\nExamples:\n(remove-duplicates-and-sort '(3 1 4 1 5 9 2 6 5 3 5)) => '(1 2 3 4 5 6 9)\n(remove-duplicates-and-sort '(10 20 20 30 40 50)) => '(10 20 30 40 50)\n(remove-duplicates-and-sort '(5 4 3 2 1)) => '(1 2 3 4 5)", "instruction": "Write a Racket function `(define (remove-duplicates-and-sort numbers)` to solve the following problem:\nFunction: remove-duplicates-and-sort\n\nDescription: \nThis function takes a list of integers and performs two main tasks:\n1. Removes any duplicate numbers.\n2. Sorts the remaining numbers in ascending order.\n\nArgs:\nnumbers: A list of integers.\n\nReturns:\nA list of integers that are unique and sorted in ascending order.\n\nExamples:\n(remove-duplicates-and-sort '(3 1 4 1 5 9 2 6 5 3 5)) => '(1 2 3 4 5 6 9)\n(remove-duplicates-and-sort '(10 20 20 30 40 50)) => '(10 20 30 40 50)\n(remove-duplicates-and-sort '(5 4 3 2 1)) => '(1 2 3 4 5)", "level": "easy"}
{"task_id": "Racket/41", "prompt": "#lang racket\n(require rackunit)\n(define (calculate-expression a b c)\n;; Calculates the value of the expression (a+b) * c for given integers a, b, and c.\n;; The function takes three integers, a, b, and c, and returns the result of (a+b) * c.\n;; Args:\n;;   a: An integer where -10^4 < a < 10^4.\n;;   b: An integer where -10^4 < b < 10^4.\n;;   c: An integer where -10^4 < c < 10^4.\n;; Returns:\n;;   The result of the expression (a+b) * c as an integer.\n;;\n;; Examples:\n;; >>> (calculate-expression 1 2 3)\n;; 9\n;; >>> (calculate-expression -1 -1 2)\n;; -4\n;; >>> (calculate-expression 0 0 5)\n;; 0", "canonical_solution": "(* (+ a b) c))", "test": "(define (check calculate-expression)\n  (define tests\n    (list (check-equal? (calculate-expression 2 3 5) 25)\n          (check-equal? (calculate-expression -2 3 -5) -5)\n          (check-equal? (calculate-expression 0 100 0) 0)\n          (check-equal? (calculate-expression 100 -50 2) 100)\n          (check-equal? (calculate-expression -1 -1 1) -2)\n          (check-equal? (calculate-expression 1000 2000 3) 9000)\n          (check-equal? (calculate-expression -1000 500 2) -1000)))\n  (andmap identity tests))\n\n(check calculate-expression)", "entry_point": "calculate-expression", "signature": "(define (calculate-expression a b c)", "docstring": " Calculates the value of the expression (a+b) * c for given integers a, b, and c.\n The function takes three integers, a, b, and c, and returns the result of (a+b) * c.\n Args:\n a: An integer where -10^4 < a < 10^4.\n b: An integer where -10^4 < b < 10^4.\n c: An integer where -10^4 < c < 10^4.\n Returns:\n The result of the expression (a+b) * c as an integer.\n\n Examples:\n >>> (calculate-expression 1 2 3)\n 9\n >>> (calculate-expression -1 -1 2)\n -4\n >>> (calculate-expression 0 0 5)\n 0", "instruction": "Write a Racket function `(define (calculate-expression a b c)` to solve the following problem: Calculates the value of the expression (a+b) * c for given integers a, b, and c.\n The function takes three integers, a, b, and c, and returns the result of (a+b) * c.\n Args:\n a: An integer where -10^4 < a < 10^4.\n b: An integer where -10^4 < b < 10^4.\n c: An integer where -10^4 < c < 10^4.\n Returns:\n The result of the expression (a+b) * c as an integer.\n\n Examples:\n >>> (calculate-expression 1 2 3)\n 9\n >>> (calculate-expression -1 -1 2)\n -4\n >>> (calculate-expression 0 0 5)\n 0", "level": "easy"}
{"task_id": "Racket/42", "prompt": "#lang racket\n(require rackunit)\n(define (char-to-ascii char)\n;; Converts a given character (excluding space) to its ASCII code.\n;; The character is guaranteed to be a visible character (not a space).\n;; Args:\n;;   char: A character for which the ASCII code will be returned.\n;; Returns:\n;;   The ASCII code of the given character as an integer.\n;;\n;; Examples:\n;; >>> (char-to-ascii #\\A)\n;; 65\n;; >>> (char-to-ascii #\\a)\n;; 97\n;; >>> (char-to-ascii #\\0)\n;; 48", "canonical_solution": "  (char->integer char))", "test": "(define (check char-to-ascii)\n  (define tests\n    (list (check-equal? (char-to-ascii #\\A) 65)\n          (check-equal? (char-to-ascii #\\b) 98)\n          (check-equal? (char-to-ascii #\\1) 49)\n          (check-equal? (char-to-ascii #\\Z) 90)\n          (check-equal? (char-to-ascii #\\z) 122)\n          (check-equal? (char-to-ascii #\\!) 33)\n          (check-equal? (char-to-ascii #\\$) 36)))\n  (andmap identity tests))\n\n(check char-to-ascii)", "entry_point": "char-to-ascii", "signature": "(define (char-to-ascii char)", "docstring": " Converts a given character (excluding space) to its ASCII code.\n The character is guaranteed to be a visible character (not a space).\n Args:\n char: A character for which the ASCII code will be returned.\n Returns:\n The ASCII code of the given character as an integer.\n\n Examples:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\a)\n 97\n >>> (char-to-ascii #\\0)\n 48", "instruction": "Write a Racket function `(define (char-to-ascii char)` to solve the following problem: Converts a given character (excluding space) to its ASCII code.\n The character is guaranteed to be a visible character (not a space).\n Args:\n char: A character for which the ASCII code will be returned.\n Returns:\n The ASCII code of the given character as an integer.\n\n Examples:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\a)\n 97\n >>> (char-to-ascii #\\0)\n 48", "level": "easy"}
{"task_id": "Racket/43", "prompt": "#lang racket\n(require rackunit)\n(define (ascii-to-char ascii-code)\n;; Converts an ASCII code to its corresponding character.\n;; The ASCII code is guaranteed to be within the range of visible characters (greater than 0 and less than 128).\n;; Args:\n;;   ascii-code: An integer representing the ASCII code of the character.\n;; Returns:\n;;   The character corresponding to the given ASCII code.\n;;\n;; Examples:\n;; >>> (ascii-to-char 65)\n;; \"A\"\n;; >>> (ascii-to-char 97)\n;; \"a\"\n;; >>> (ascii-to-char 48)\n;; \"0\"", "canonical_solution": "  (integer->char ascii-code))", "test": "(define (check ascii-to-char)\n  (define tests\n    (list (check-equal? (ascii-to-char 65) #\\A)\n          (check-equal? (ascii-to-char 98) #\\b)\n          (check-equal? (ascii-to-char 49) #\\1)\n          (check-equal? (ascii-to-char 32) #\\space)\n          (check-equal? (ascii-to-char 90) #\\Z)\n          (check-equal? (ascii-to-char 122) #\\z)\n          (check-equal? (ascii-to-char 58) #\\:)))\n  (andmap identity tests))\n\n(check ascii-to-char)", "entry_point": "ascii-to-char", "signature": "(define (ascii-to-char ascii-code)", "docstring": " Converts an ASCII code to its corresponding character.\n The ASCII code is guaranteed to be within the range of visible characters (greater than 0 and less than 128).\n Args:\n ascii-code: An integer representing the ASCII code of the character.\n Returns:\n The character corresponding to the given ASCII code.\n\n Examples:\n >>> (ascii-to-char 65)\n \"A\"\n >>> (ascii-to-char 97)\n \"a\"\n >>> (ascii-to-char 48)\n \"0\"", "instruction": "Write a Racket function `(define (ascii-to-char ascii-code)` to solve the following problem: Converts an ASCII code to its corresponding character.\n The ASCII code is guaranteed to be within the range of visible characters (greater than 0 and less than 128).\n Args:\n ascii-code: An integer representing the ASCII code of the character.\n Returns:\n The character corresponding to the given ASCII code.\n\n Examples:\n >>> (ascii-to-char 65)\n \"A\"\n >>> (ascii-to-char 97)\n \"a\"\n >>> (ascii-to-char 48)\n \"0\"", "level": "easy"}
{"task_id": "Racket/44", "prompt": "#lang racket\n(require rackunit)\n(define (int-bool-int-conversion x)\n;; Converts an integer to a boolean and then back to an integer.\n;; In Racket, any non-zero integer is true (represented by #t), and 0 is false (#f).\n;; When converting back to an integer, true becomes 1, and false becomes 0.\n;; Args:\n;;   x: An integer, the initial value for conversion.\n;; Returns:\n;;   An integer, the result after converting to boolean and back to integer.\n;;\n;; Examples:\n;; >>> (int-bool-int-conversion 3)\n;; 1\n;; >>> (int-bool-int-conversion 0)\n;; 0\n;; >>> (int-bool-int-conversion -5)\n;; 1", "canonical_solution": "  (if (= x 0)\n      0\n      1))", "test": "(define (check int-bool-int-conversion)\n  (define tests\n    (list (check-equal? (int-bool-int-conversion 100) 1)\n          (check-equal? (int-bool-int-conversion -1) 1)\n          (check-equal? (int-bool-int-conversion 0) 0)\n          (check-equal? (int-bool-int-conversion 1) 1)\n          (check-equal? (int-bool-int-conversion -100) 1)\n          (check-equal? (int-bool-int-conversion 9999) 1)\n          (check-equal? (int-bool-int-conversion -9999) 1)))\n  (andmap identity tests))\n\n(check int-bool-int-conversion)", "entry_point": "int-bool-int-conversion", "signature": "(define (int-bool-int-conversion x)", "docstring": " Converts an integer to a boolean and then back to an integer.\n In Racket, any non-zero integer is true (represented by #t), and 0 is false (#f).\n When converting back to an integer, true becomes 1, and false becomes 0.\n Args:\n x: An integer, the initial value for conversion.\n Returns:\n An integer, the result after converting to boolean and back to integer.\n\n Examples:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1", "instruction": "Write a Racket function `(define (int-bool-int-conversion x)` to solve the following problem: Converts an integer to a boolean and then back to an integer.\n In Racket, any non-zero integer is true (represented by #t), and 0 is false (#f).\n When converting back to an integer, true becomes 1, and false becomes 0.\n Args:\n x: An integer, the initial value for conversion.\n Returns:\n An integer, the result after converting to boolean and back to integer.\n\n Examples:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1", "level": "easy"}
{"task_id": "Racket/45", "prompt": "#lang racket\n(require rackunit)\n(define (reverse-three-digit n)\n;; Reverses a three-digit number and outputs the reversed number. The input is guaranteed to be a three-digit integer.\n;; Args:\n;;   n: A three-digit integer.\n;; Returns:\n;;   The reversed integer as output, preserving leading zeros in the return value as an integer.\n;;\n;; Examples:\n;; >>> (reverse-three-digit 123)\n;; 321\n;; >>> (reverse-three-digit 908)\n;; 809\n;; >>> (reverse-three-digit 100)\n;; 1 ;; Note: In Racket, leading zeros are not represented in integers.", "canonical_solution": "  (let* ((digits (number->string n))\n         (reversed-string (list->string (reverse (string->list digits)))))\n    (string->number reversed-string)))", "test": "(define (check reverse-three-digit)\n  (define tests\n    (list (check-equal? (reverse-three-digit 456) 654)\n          (check-equal? (reverse-three-digit 700) 7)\n          (check-equal? (reverse-three-digit 890) 98) ;; Adjusted for Racket's handling of numbers\n          (check-equal? (reverse-three-digit 123) 321)\n          (check-equal? (reverse-three-digit 250) 52)\n          (check-equal? (reverse-three-digit 505) 505)\n          (check-equal? (reverse-three-digit 999) 999)))\n  (andmap identity tests))\n\n(check reverse-three-digit)", "entry_point": "reverse-three-digit", "signature": "(define (reverse-three-digit n)", "docstring": " Reverses a three-digit number and outputs the reversed number. The input is guaranteed to be a three-digit integer.\n Args:\n n: A three-digit integer.\n Returns:\n The reversed integer as output, preserving leading zeros in the return value as an integer.\n\n Examples:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 908)\n 809\n >>> (reverse-three-digit 100)\n 1Note: In Racket, leading zeros are not represented in integers.", "instruction": "Write a Racket function `(define (reverse-three-digit n)` to solve the following problem: Reverses a three-digit number and outputs the reversed number. The input is guaranteed to be a three-digit integer.\n Args:\n n: A three-digit integer.\n Returns:\n The reversed integer as output, preserving leading zeros in the return value as an integer.\n\n Examples:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 908)\n 809\n >>> (reverse-three-digit 100)\n 1Note: In Racket, leading zeros are not represented in integers.", "level": "easy"}
{"task_id": "Racket/46", "prompt": "#lang racket\n(require rackunit)\n(define (nth-term a1 a2 n)\n;; Calculates the nth term of an arithmetic sequence given its first two terms, a1 and a2, and the term number n.\n;; Args:\n;;   a1: The first term of the arithmetic sequence, an integer between -100 and 100.\n;;   a2: The second term of the arithmetic sequence, an integer between -100 and 100.\n;;   n: The term number, a positive integer less than or equal to 1000.\n;; Returns:\n;;   The nth term of the arithmetic sequence as an integer.\n;;\n;; Examples:\n;; >>> (nth-term 2 5 3)\n;; 8\n;; >>> (nth-term -1 2 10)\n;; 17", "canonical_solution": "  (+ a1 (* (- a2 a1) (- n 1))))", "test": "(define (check nth-term)\n  (define tests\n    (list (check-equal? (nth-term 0 3 4) 9)\n          (check-equal? (nth-term 5 7 10) 23)\n          (check-equal? (nth-term 1 1 100) 1)\n          (check-equal? (nth-term 10 13 5) 22)\n          (check-equal? (nth-term 100 50 3) 0)))\n  (andmap identity tests))\n\n(check nth-term)", "entry_point": "nth-term ", "signature": "(define (nth-term a1 a2 n)", "docstring": " Calculates the nth term of an arithmetic sequence given its first two terms, a1 and a2, and the term number n.\n Args:\n a1: The first term of the arithmetic sequence, an integer between -100 and 100.\n a2: The second term of the arithmetic sequence, an integer between -100 and 100.\n n: The term number, a positive integer less than or equal to 1000.\n Returns:\n The nth term of the arithmetic sequence as an integer.\n\n Examples:\n >>> (nth-term 2 5 3)\n 8\n >>> (nth-term -1 2 10)\n 17", "instruction": "Write a Racket function `(define (nth-term a1 a2 n)` to solve the following problem: Calculates the nth term of an arithmetic sequence given its first two terms, a1 and a2, and the term number n.\n Args:\n a1: The first term of the arithmetic sequence, an integer between -100 and 100.\n a2: The second term of the arithmetic sequence, an integer between -100 and 100.\n n: The term number, a positive integer less than or equal to 1000.\n Returns:\n The nth term of the arithmetic sequence as an integer.\n\n Examples:\n >>> (nth-term 2 5 3)\n 8\n >>> (nth-term -1 2 10)\n 17", "level": "easy"}
{"task_id": "Racket/47", "prompt": "#lang racket\n(require rackunit)\n(define (multiply-a-b a b)\n;; Computes the product of two positive integers A and B, considering the appropriate data type for the range.\n;; Args:\n;;   a: A positive integer, where 1 <= a <= 50000.\n;;   b: A positive integer, where 1 <= b <= 50000.\n;; Returns:\n;;   The product of A and B as an integer.\n;;\n;; Examples:\n;; >>> (multiply-a-b 2 3)\n;; 6\n;; >>> (multiply-a-b 10 20)\n;; 200\n;; >>> (multiply-a-b 50000 1)\n;; 50000", "canonical_solution": " (* a b))", "test": "(define (check multiply-a-b)\n  (define tests\n    (list (check-equal? (multiply-a-b 5 6) 30)\n          (check-equal? (multiply-a-b 100 200) 20000)\n          (check-equal? (multiply-a-b 1 50000) 50000)\n          (check-equal? (multiply-a-b 250 100) 25000)\n          (check-equal? (multiply-a-b 123 456) 56088)\n          (check-equal? (multiply-a-b 50000 50000) 2500000000)\n          (check-equal? (multiply-a-b 49999 2) 99998)))\n  (andmap identity tests))\n\n(check multiply-a-b)", "entry_point": "multiply-a-b", "signature": "(define (multiply-a-b a b)", "docstring": " Computes the product of two positive integers A and B, considering the appropriate data type for the range.\n Args:\n a: A positive integer, where 1 <= a <= 50000.\n b: A positive integer, where 1 <= b <= 50000.\n Returns:\n The product of A and B as an integer.\n\n Examples:\n >>> (multiply-a-b 2 3)\n 6\n >>> (multiply-a-b 10 20)\n 200\n >>> (multiply-a-b 50000 1)\n 50000", "instruction": "Write a Racket function `(define (multiply-a-b a b)` to solve the following problem: Computes the product of two positive integers A and B, considering the appropriate data type for the range.\n Args:\n a: A positive integer, where 1 <= a <= 50000.\n b: A positive integer, where 1 <= b <= 50000.\n Returns:\n The product of A and B as an integer.\n\n Examples:\n >>> (multiply-a-b 2 3)\n 6\n >>> (multiply-a-b 10 20)\n 200\n >>> (multiply-a-b 50000 1)\n 50000", "level": "easy"}
{"task_id": "Racket/48", "prompt": "#lang racket\n(require rackunit)\n(define (power-of-two n)\n;; Calculates 2 raised to the power of n, where n is a non-negative integer less than 31.\n;; Args:\n;;   n: A non-negative integer, where 0 <= n < 31.\n;; Returns:\n;;   The result of 2^n as an integer.\n;;\n;; Examples:\n;; >>> (power-of-two 4)\n;; 16\n;; >>> (power-of-two 0)\n;; 1\n;; >>> (power-of-two 10)\n;; 1024", "canonical_solution": "  (expt 2 n))", "test": "(define (check power-of-two)\n  (define tests\n    (list (check-equal? (power-of-two 5) 32)\n          (check-equal? (power-of-two 0) 1)\n          (check-equal? (power-of-two 15) 32768)\n          (check-equal? (power-of-two 10) 1024)\n          (check-equal? (power-of-two 20) 1048576)\n          (check-equal? (power-of-two 8) 256)\n          (check-equal? (power-of-two 1) 2)))\n  (andmap identity tests))\n\n(check power-of-two)", "entry_point": "power-of-two", "signature": "(define (power-of-two n)", "docstring": " Calculates 2 raised to the power of n, where n is a non-negative integer less than 31.\n Args:\n n: A non-negative integer, where 0 <= n < 31.\n Returns:\n The result of 2^n as an integer.\n\n Examples:\n >>> (power-of-two 4)\n 16\n >>> (power-of-two 0)\n 1\n >>> (power-of-two 10)\n 1024", "instruction": "Write a Racket function `(define (power-of-two n)` to solve the following problem: Calculates 2 raised to the power of n, where n is a non-negative integer less than 31.\n Args:\n n: A non-negative integer, where 0 <= n < 31.\n Returns:\n The result of 2^n as an integer.\n\n Examples:\n >>> (power-of-two 4)\n 16\n >>> (power-of-two 0)\n 1\n >>> (power-of-two 10)\n 1024", "level": "easy"}
{"task_id": "Racket/49", "prompt": "#lang racket\n(require rackunit)\n(define (sign-of-n n)\n;; Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n;; Args:\n;;   n: An integer, where -10^9 <= n <= 10^9.\n;; Returns:\n;;   A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n;;\n;; Examples:\n;; >>> (sign-of-n -1)\n;; \"negative\"\n;; >>> (sign-of-n 1)\n;; \"positive\"\n;; >>> (sign-of-n 0)\n;; \"zero\"", "canonical_solution": "  (cond\n    [(> n 0) \"positive\"]\n    [(< n 0) \"negative\"]\n    [else \"zero\"]))", "test": "(define (check sign-of-n)\n  (define tests\n    (list (check-equal? (sign-of-n -100) \"negative\")\n          (check-equal? (sign-of-n 100) \"positive\")\n          (check-equal? (sign-of-n 0) \"zero\")\n          (check-equal? (sign-of-n -999999999) \"negative\")\n          (check-equal? (sign-of-n 999999999) \"positive\")\n          (check-equal? (sign-of-n -1) \"negative\")\n          (check-equal? (sign-of-n 1) \"positive\")))\n  (andmap identity tests))\n\n(check sign-of-n)", "entry_point": "sign-of-n", "signature": "(define (sign-of-n n)", "docstring": " Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n Args:\n n: An integer, where -10^9 <= n <= 10^9.\n Returns:\n A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n\n Examples:\n >>> (sign-of-n -1)\n \"negative\"\n >>> (sign-of-n 1)\n \"positive\"\n >>> (sign-of-n 0)\n \"zero\"", "instruction": "Write a Racket function `(define (sign-of-n n)` to solve the following problem: Determines if the integer `n` is positive, negative, or zero and returns a string accordingly.\n Args:\n n: An integer, where -10^9 <= n <= 10^9.\n Returns:\n A string that is either \"positive\", \"negative\", or \"zero\" based on the value of `n`.\n\n Examples:\n >>> (sign-of-n -1)\n \"negative\"\n >>> (sign-of-n 1)\n \"positive\"\n >>> (sign-of-n 0)\n \"zero\"", "level": "easy"}
{"task_id": "Racket/50", "prompt": "#lang racket\n(require rackunit)\n(define (absolute-value n)\n;; Computes the absolute value of an integer `n`, where the absolute value does not exceed 10000.\n;; Args:\n;;   n: An integer, the absolute value of which is to be computed.\n;; Returns:\n;;   The absolute value of `n`.\n;;\n;; Examples:\n;; >>> (absolute-value -5)\n;; 5\n;; >>> (absolute-value 3)\n;; 3\n;; >>> (absolute-value 0)\n;; 0", "canonical_solution": "  (if (< n 0)\n      (- n)\n      n))", "test": "(define (check absolute-value)\n  (define tests\n    (list (check-equal? (absolute-value -100) 100)\n          (check-equal? (absolute-value 100) 100)\n          (check-equal? (absolute-value 0) 0)\n          (check-equal? (absolute-value -9999) 9999)\n          (check-equal? (absolute-value 9999) 9999)\n          (check-equal? (absolute-value -1) 1)\n          (check-equal? (absolute-value 1) 1)))\n  (andmap identity tests))\n\n(check absolute-value)", "entry_point": "absolute-value", "signature": "(define (absolute-value n)", "docstring": " Computes the absolute value of an integer `n`, where the absolute value does not exceed 10000.\n Args:\n n: An integer, the absolute value of which is to be computed.\n Returns:\n The absolute value of `n`.\n\n Examples:\n >>> (absolute-value -5)\n 5\n >>> (absolute-value 3)\n 3\n >>> (absolute-value 0)\n 0", "instruction": "Write a Racket function `(define (absolute-value n)` to solve the following problem: Computes the absolute value of an integer `n`, where the absolute value does not exceed 10000.\n Args:\n n: An integer, the absolute value of which is to be computed.\n Returns:\n The absolute value of `n`.\n\n Examples:\n >>> (absolute-value -5)\n 5\n >>> (absolute-value 3)\n 3\n >>> (absolute-value 0)\n 0", "level": "easy"}
