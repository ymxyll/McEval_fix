{"task_id": "Dart/0", "prompt": "/* Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n*/\nbool hasCloseElements(List<double> numbers, double threshold)", "canonical_solution": "{\n  for (int i = 0; i < numbers.length; i++) {\n    for (int j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        double distance = (numbers[i] - numbers[j]).abs();\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "test": "void main() {\n  check(hasCloseElements);\n}\n\nvoid check(bool Function(List<double>, double) hasCloseElements) {\n  assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true);\n  assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false);\n  assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true);\n  assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false);\n  assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true);\n  assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true);\n  assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false);\n}", "entry_point": "hasCloseElements", "signature": "bool hasCloseElements(List<double> numbers, double threshold)", "docstring": " Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n", "instruction": "Write a dart function 'bool hasCloseElements(List<double> numbers, double threshold)' to solve the following problem:\n Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n", "level": "easy"}
{"task_id": "Dart/1", "prompt": "int horseControl(int dx, int dy, int hx, int hy) \n/*The function horseControl takes four integer arguments: dx, dy, hx, and hy. \nThe dx and dy parameters define the dimensions of a rectangular grid, while \nhx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid. \nThe function calculates the number of ways to travel from the top-left corner of the grid \nto the bottom-right corner by only moving right or down, without passing through any of the \ncells that the horse controls.\n\nIn chess, a knight can move in an L-shape: two cells in one direction and then one cell \nperpendicular to that direction. This function first marks all the cells within the grid that \nthe horse controls, including the cell where the horse is located. Then, using dynamic programming, \nit calculates the total number of paths to each cell, accumulating the count from the top and \nleft neighboring cells, but skipping any cells that are blocked by the horse's control.\n\nexample:\n>>> horseControl(6,6,3,3)\n6\n*/", "canonical_solution": "{\n  List<List<int>> dp = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => 0));\n  List<List<bool>> horseBlock = List.generate(dx + 1, (_) => List.generate(dy + 1, (_) => false));\n\n  // Mark the positions that the horse controls\n  List<List<int>> moves = [\n    [2, 1], [1, 2], [-1, 2], [-2, 1],\n    [-2, -1], [-1, -2], [1, -2], [2, -1]\n  ];\n\n  horseBlock[hx][hy] = true; // Horse's current position\n  for (List<int> move in moves) {\n    int nx = hx + move[0];\n    int ny = hy + move[1];\n    if (nx >= 0 && nx <= dx && ny >= 0 && ny <= dy) {\n      horseBlock[nx][ny] = true; // Horse's control positions\n    }\n  }\n\n  // Initialize the dp table\n  dp[0][0] = 1;\n  for (int i = 0; i <= dx; i++) {\n    for (int j = 0; j <= dy; j++) {\n      if (horseBlock[i][j]) {\n        continue; // Skip the position if it's controlled by the horse\n      }\n      // Calculate the number of paths from the top and left cells\n      if (i > 0) dp[i][j] += dp[i - 1][j];\n      if (j > 0) dp[i][j] += dp[i][j - 1];\n    }\n  }\n  return dp[dx][dy];\n}", "test": "void main() {\n  // Test case 1: Start and horse positions are the same\n  assert(horseControl(1, 1, 0, 0) == 2, 'Test case 1 failed');\n\n  // Test case 2: Horse controls some of the paths\n  assert(horseControl(2, 2, 1, 1) == 2, 'Test case 2 failed');\n\n  // Test case 3: No horse control over the board\n  assert(horseControl(5, 5, 5, 5) == 0, 'Test case 3 failed');\n\n  // Additional test cases...\n\n  print('All test cases passed!');\n}", "entry_point": "horseControl", "signature": "int horseControl(int dx, int dy, int hx, int hy)", "docstring": "The function horseControl takes four integer arguments: dx, dy, hx, and hy. \nThe dx and dy parameters define the dimensions of a rectangular grid, while \nhx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid. \nThe function calculates the number of ways to travel from the top-left corner of the grid \nto the bottom-right corner by only moving right or down, without passing through any of the \ncells that the horse controls.\n\nIn chess, a knight can move in an L-shape: two cells in one direction and then one cell \nperpendicular to that direction. This function first marks all the cells within the grid that \nthe horse controls, including the cell where the horse is located. Then, using dynamic programming, \nit calculates the total number of paths to each cell, accumulating the count from the top and \nleft neighboring cells, but skipping any cells that are blocked by the horse's control.\n\nexample:\n>>> horseControl(6,6,3,3)\n6\n", "instruction": "Write a dart function 'int horseControl(int dx, int dy, int hx, int hy)' to solve the following problem:\nThe function horseControl takes four integer arguments: dx, dy, hx, and hy. \nThe dx and dy parameters define the dimensions of a rectangular grid, while \nhx and hy represent the coordinates of a horse (similar to a knight in chess) on this grid. \nThe function calculates the number of ways to travel from the top-left corner of the grid \nto the bottom-right corner by only moving right or down, without passing through any of the \ncells that the horse controls.\n\nIn chess, a knight can move in an L-shape: two cells in one direction and then one cell \nperpendicular to that direction. This function first marks all the cells within the grid that \nthe horse controls, including the cell where the horse is located. Then, using dynamic programming, \nit calculates the total number of paths to each cell, accumulating the count from the top and \nleft neighboring cells, but skipping any cells that are blocked by the horse's control.\n\nexample:\n>>> horseControl(6,6,3,3)\n6\n", "level": "hard"}
{"task_id": "Dart/2", "prompt": "int findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)\n/*Finds the index of the topmost carpet that covers a given point.\n\nTakes a list of carpets, where each carpet is represented by a list of four integers\n[a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\nand k (height). The function also takes a point represented by a list of two integers [x, y],\nwhich define the coordinates of the point.\n\nThe carpets are layered in the order they appear in the list, with the first carpet at the bottom.\nThe function iterates through the carpets from the topmost to the bottommost. It returns the\n1-based index of the first carpet that covers the point. If no carpet covers the point, the function\nreturns -1.\n\nArgs:\n  carpets (List<List<int>>): The list of carpets information.\n  point (List<int>): The coordinates of the point to check.\n\nReturns:\n  int: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n\nExample:\n  findTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n\n  findTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n*/", "canonical_solution": " {\n  int x = point[0];\n  int y = point[1];\n  int result = -1;\n\n  // Iterate through the carpets from top to bottom.\n  for (int i = carpets.length - 1; i >= 0; i--) {\n    // Extract carpet's information.\n    List<int> carpet = carpets[i];\n    int a = carpet[0];\n    int b = carpet[1];\n    int g = carpet[2];\n    int k = carpet[3];\n\n    // Check if the point is within the current carpet.\n    if (x >= a && x <= a + g && y >= b && y <= b + k) {\n      result = i + 1; // Carpet numbers are 1-indexed.\n      break; // Stop searching as we found the topmost carpet.\n    }\n  }\n  return result;\n}", "test": "void testFindTopmostCarpetIndex() {\n  // TestCase 1: Point lies on the second carpet which is on top of the first one\n  List<List<int>> carpets1 = [\n    [0, 0, 4, 4], // Carpet 1 (bottom)\n    [1, 1, 3, 3], // Carpet 2 (top)\n  ];\n  List<int> point1 = [2, 2];\n  assert(findTopmostCarpetIndex(carpets1, point1) == 2, 'Test case 1 failed');\n\n  // TestCase 2: Point lies outside any carpet\n  List<List<int>> carpets2 = [\n    [0, 0, 4, 4],\n    [5, 5, 2, 2],\n  ];\n  List<int> point2 = [6, 6];\n  assert(findTopmostCarpetIndex(carpets2, point2) == 2, 'Test case 2 failed');\n\n  // TestCase 3: Point lies on the only carpet\n  List<List<int>> carpets3 = [\n    [0, 0, 5, 5], // Only one carpet\n  ];\n  List<int> point3 = [3, 3];\n  assert(findTopmostCarpetIndex(carpets3, point3) == 1, 'Test case 3 failed');\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  // Call the test function to run the test cases\n  testFindTopmostCarpetIndex();\n}", "entry_point": "findTopmostCarpetIndex", "signature": "int findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)", "docstring": "Finds the index of the topmost carpet that covers a given point.\n\nTakes a list of carpets, where each carpet is represented by a list of four integers\n[a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\nand k (height). The function also takes a point represented by a list of two integers [x, y],\nwhich define the coordinates of the point.\n\nThe carpets are layered in the order they appear in the list, with the first carpet at the bottom.\nThe function iterates through the carpets from the topmost to the bottommost. It returns the\n1-based index of the first carpet that covers the point. If no carpet covers the point, the function\nreturns -1.\n\nArgs:\n  carpets (List<List<int>>): The list of carpets information.\n  point (List<int>): The coordinates of the point to check.\n\nReturns:\n  int: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n\nExample:\n  findTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n\n  findTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n", "instruction": "Write a dart function 'int findTopmostCarpetIndex(List<List<int>> carpets, List<int> point)' to solve the following problem:\nFinds the index of the topmost carpet that covers a given point.\n\nTakes a list of carpets, where each carpet is represented by a list of four integers\n[a, b, g, k], which define a carpet's bottom-left corner (a, b) and its dimensions g (width)\nand k (height). The function also takes a point represented by a list of two integers [x, y],\nwhich define the coordinates of the point.\n\nThe carpets are layered in the order they appear in the list, with the first carpet at the bottom.\nThe function iterates through the carpets from the topmost to the bottommost. It returns the\n1-based index of the first carpet that covers the point. If no carpet covers the point, the function\nreturns -1.\n\nArgs:\n  carpets (List<List<int>>): The list of carpets information.\n  point (List<int>): The coordinates of the point to check.\n\nReturns:\n  int: The 1-based index of the topmost carpet covering the point, or -1 if the point is not covered.\n\nExample:\n  findTopmostCarpetIndex([[0, 0, 4, 4], [1, 1, 3, 3]], [2, 2]); // Returns 2\n\n  findTopmostCarpetIndex([[0, 0, 4, 4], [5, 5, 2, 2]], [6, 6]); // Returns -1\n", "level": "middle"}
{"task_id": "Dart/3", "prompt": "import 'dart:io';\nint maxSumInGrid(List<List<int>> grid, int N)\n/*Calculates the maximum sum of numbers that can be picked on a grid by two paths.\n\nThis function takes a square grid of integers and the size of the grid (N),\nand computes the maximum sum of numbers that can be collected by two paths\nstarting from the top-left corner and ending at the bottom-right corner.\nEach path can only move right or down, and no two paths can overlap.\n\nArgs:\n  grid (List<List<int>>): A 2D list of integers representing the grid.\n  N (int): The size of the dimensions of the square grid.\n\nReturns:\n  int: The maximum sum of numbers picked by the two paths.\n\nExample:\n  maxSumInGrid([\n    [0, 0, 0, 0],\n    [0, 4, 0, 0],\n    [0, 0, 2, 0],\n    [1, 0, 0, 0]\n  ], 4);\n  return 7\n*/", "canonical_solution": " {\n  // Initialize a 3-dimensional array dp to store the maximum sum for each state (i, j, k).\n  List<List<List<int>>> dp = List.generate(\n    2 * N,\n    (i) => List.generate(N, (j) => List.generate(N, (k) => 0)),\n  );\n\n  // Populate the dp array with the input numbers\n  for (var i = 0; i < N; ++i) {\n    for (var j = 0; j < N; ++j) {\n      for (var k = 0; k < N; ++k) {\n        var l = i + j - k; // The position of P2 on the y-axis\n        if (l < 0 || l >= N) continue; // Skip invalid positions\n        var value = grid[i][j];\n        if (i != k) value += grid[k][l]; // If not on the same column, add P2's value\n        var maxPrev = 0;\n        if (i > 0) maxPrev = max(maxPrev, dp[i - 1][j][k]); // P1 left\n        if (j > 0) maxPrev = max(maxPrev, dp[i][j - 1][k]); // P1 up\n        if (k > 0) maxPrev = max(maxPrev, dp[i][j][k - 1]); // P2 left\n        if (l > 0) maxPrev = max(maxPrev, dp[i][j][k]); // P2 up\n        dp[i][j][k] = maxPrev + value;\n      }\n    }\n  }\n  // The answer is the value in dp[N-1][N-1][N-1]\n  return dp[N - 1][N - 1][N - 1];\n}\n\nint max(int a, int b) => a > b ? a : b;", "test": "void testMaxSumInGrid() {\n  // TestCase Structure\n  List<Map<String, dynamic>> testCases = [\n    {\n      'grid': [\n        [0, 0, 0, 0],\n        [0, 4, 0, 0],\n        [0, 0, 2, 0],\n        [1, 0, 0, 0]\n      ],\n      'N': 4,\n      'expected': 16\n    },\n    {\n      'grid': [\n        [0, 0, 13, 0],\n        [0, 0, 0, 6],\n        [0, 7, 0, 0],\n        [0, 0, 0, 0]\n      ],\n      'N': 4,\n      'expected': 58\n    },\n    // Add more test cases here\n  ];\n\n  for (var testCase in testCases) {\n    int result = maxSumInGrid(testCase['grid'], testCase['N']);\n    assert(result == testCase['expected'], \"Test case failed: Expected ${testCase['expected']}, got $result\");\n    print('Test case passed: Expected ${testCase['expected']}, got $result');\n  }\n}\n\nvoid main() {\n  testMaxSumInGrid();\n  // You can also handle the interactive part here, if necessary.\n}", "entry_point": "maxSumInGrid", "signature": "int maxSumInGrid(List<List<int>> grid, int N)", "docstring": "Calculates the maximum sum of numbers that can be picked on a grid by two paths.\n\nThis function takes a square grid of integers and the size of the grid (N),\nand computes the maximum sum of numbers that can be collected by two paths\nstarting from the top-left corner and ending at the bottom-right corner.\nEach path can only move right or down, and no two paths can overlap.\n\nArgs:\n  grid (List<List<int>>): A 2D list of integers representing the grid.\n  N (int): The size of the dimensions of the square grid.\n\nReturns:\n  int: The maximum sum of numbers picked by the two paths.\n\nExample:\n  maxSumInGrid([\n    [0, 0, 0, 0],\n    [0, 4, 0, 0],\n    [0, 0, 2, 0],\n    [1, 0, 0, 0]\n  ], 4);\n  return 7\n", "instruction": "Write a dart function 'int maxSumInGrid(List<List<int>> grid, int N)' to solve the following problem:\nCalculates the maximum sum of numbers that can be picked on a grid by two paths.\n\nThis function takes a square grid of integers and the size of the grid (N),\nand computes the maximum sum of numbers that can be collected by two paths\nstarting from the top-left corner and ending at the bottom-right corner.\nEach path can only move right or down, and no two paths can overlap.\n\nArgs:\n  grid (List<List<int>>): A 2D list of integers representing the grid.\n  N (int): The size of the dimensions of the square grid.\n\nReturns:\n  int: The maximum sum of numbers picked by the two paths.\n\nExample:\n  maxSumInGrid([\n    [0, 0, 0, 0],\n    [0, 4, 0, 0],\n    [0, 0, 2, 0],\n    [1, 0, 0, 0]\n  ], 4);\n  return 7\n", "level": "hard"}
{"task_id": "Dart/4", "prompt": "List<List<int>> generatePermutations(List<int> list)\n/*Generates all possible permutations of a given list of integers.\n\nThis recursive function takes a list of integers as input and returns\na list of lists, where each inner list represents a unique permutation\nof the input list. The function works by iterating over each element in\nthe list, removing it, and generating all permutations of the remaining\nelements. Each of these permutations has the removed element prepended\nto it, thereby creating a new permutation that includes the removed element.\nThe base case of the recursion is when the list contains only one element,\nin which case, the list itself is the only permutation.\n\nArgs:\n  list (List<int>): The list of integers to permute.\n\nReturns:\n  List<List<int>>: A list containing all permutations of the input list.\n\nExamples:\n  generatePermutations([1]) returns [[1]]\n  generatePermutations([1, 2]) returns [[1, 2], [2, 1]]\n*/", "canonical_solution": " {\n  if (list.length == 1) {\n    return [list];\n  }\n\n  List<List<int>> perms = [];\n  for (int i = 0; i < list.length; i++) {\n    int current = list[i];\n    List<int> remaining = List.from(list)..removeAt(i);\n    List<List<int>> remainingPerms = generatePermutations(remaining);\n\n    for (var perm in remainingPerms) {\n      perms.add([current] + perm);\n    }\n  }\n  return perms;\n}", "test": "void testGeneratePermutations() {\n  // Test case 1\n  List<int> list1 = [1];\n  List<List<int>> expectedPerms1 = [\n    [1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list1), expectedPerms1));\n\n  // Test case 2\n  List<int> list2 = [1, 2];\n  List<List<int>> expectedPerms2 = [\n    [1, 2],\n    [2, 1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list2), expectedPerms2));\n\n  // Test case 3\n  List<int> list3 = [1, 2, 3];\n  List<List<int>> expectedPerms3 = [\n    [1, 2, 3],\n    [1, 3, 2],\n    [2, 1, 3],\n    [2, 3, 1],\n    [3, 1, 2],\n    [3, 2, 1]\n  ];\n  assert(ListEquality().equals(generatePermutations(list3), expectedPerms3));\n\n  print(\"All test cases passed!\");\n}\n\n// Equality for nested lists\nclass ListEquality {\n  bool equals(List<List<int>> list1, List<List<int>> list2) {\n    if (list1.length != list2.length) return false;\n    for (int i = 0; i < list1.length; i++) {\n      if (!_listEquals(list1[i], list2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  bool _listEquals(List<int> list1, List<int> list2) {\n    if (list1.length != list2.length) return false;\n    for (int i = 0; i < list1.length; i++) {\n      if (list1[i] != list2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nvoid main() {\n  testGeneratePermutations();\n}", "entry_point": "generatePermutations", "signature": "List<List<int>> generatePermutations(List<int> list)", "docstring": "Generates all possible permutations of a given list of integers.\n\nThis recursive function takes a list of integers as input and returns\na list of lists, where each inner list represents a unique permutation\nof the input list. The function works by iterating over each element in\nthe list, removing it, and generating all permutations of the remaining\nelements. Each of these permutations has the removed element prepended\nto it, thereby creating a new permutation that includes the removed element.\nThe base case of the recursion is when the list contains only one element,\nin which case, the list itself is the only permutation.\n\nArgs:\n  list (List<int>): The list of integers to permute.\n\nReturns:\n  List<List<int>>: A list containing all permutations of the input list.\n\nExamples:\n  generatePermutations([1]) returns [[1]]\n  generatePermutations([1, 2]) returns [[1, 2], [2, 1]]\n", "instruction": "Write a dart function 'List<List<int>> generatePermutations(List<int> list)' to solve the following problem:\nGenerates all possible permutations of a given list of integers.\n\nThis recursive function takes a list of integers as input and returns\na list of lists, where each inner list represents a unique permutation\nof the input list. The function works by iterating over each element in\nthe list, removing it, and generating all permutations of the remaining\nelements. Each of these permutations has the removed element prepended\nto it, thereby creating a new permutation that includes the removed element.\nThe base case of the recursion is when the list contains only one element,\nin which case, the list itself is the only permutation.\n\nArgs:\n  list (List<int>): The list of integers to permute.\n\nReturns:\n  List<List<int>>: A list containing all permutations of the input list.\n\nExamples:\n  generatePermutations([1]) returns [[1]]\n  generatePermutations([1, 2]) returns [[1, 2], [2, 1]]\n", "level": "easy"}
{"task_id": "Dart/5", "prompt": "import 'dart:io';\nimport 'dart:math';\nBigInt sumOfFactorials(int n)\n/*Calculates the sum of factorials of all integers from 1 to n.\n\nThis function computes the factorial of each integer from 1 up to and\nincluding n using the `factorial` function, then sums these factorials to\nobtain the final result. The function uses `BigInt` to handle very large\nnumbers that may arise from factorial calculations.\n\nArgs:\n  n (int): The upper bound of the range for which to calculate the sum\n           of factorials. The value of n should be a non-negative integer.\n\nReturns:\n  BigInt: The sum of factorials of all integers from 1 to n.\n\nExamples:\n  sumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\n  sumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\n*/", "canonical_solution": "{\n  BigInt sum = BigInt.zero;\n  for (int i = 1; i <= n; i++) {\n    sum += factorial(i);\n  }\n  return sum;\n}\n\nBigInt factorial(int n) {\n  BigInt result = BigInt.one;\n  for (int i = 1; i <= n; i++) {\n    result *= BigInt.from(i);\n  }\n  return result;\n}", "test": "void testSumOfFactorials() {\n  // Test case 1: Sum of factorials up to 1\n  assert(sumOfFactorials(1) == BigInt.from(1), \"Sum of factorials up to 1 should be 1\");\n\n  // Test case 2: Sum of factorials up to 3\n  assert(sumOfFactorials(3) == BigInt.from(9), \"Sum of factorials up to 3 should be 9\");\n\n  // Test case 3: Sum of factorials up to 4\n  BigInt expectedSumOfFactorials4 = BigInt.from(1) + BigInt.from(2) + BigInt.from(6) + BigInt.from(24);\n  assert(sumOfFactorials(4) == expectedSumOfFactorials4, \"Sum of factorials up to 4 should be 33\");\n\n  print(\"All sum of factorials test cases passed!\");\n}\n\nvoid main() {\n  testSumOfFactorials();\n}", "entry_point": "sumOfFactorials", "signature": "BigInt sumOfFactorials(int n)", "docstring": "Calculates the sum of factorials of all integers from 1 to n.\n\nThis function computes the factorial of each integer from 1 up to and\nincluding n using the `factorial` function, then sums these factorials to\nobtain the final result. The function uses `BigInt` to handle very large\nnumbers that may arise from factorial calculations.\n\nArgs:\n  n (int): The upper bound of the range for which to calculate the sum\n           of factorials. The value of n should be a non-negative integer.\n\nReturns:\n  BigInt: The sum of factorials of all integers from 1 to n.\n\nExamples:\n  sumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\n  sumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\n", "instruction": "Write a dart function 'BigInt sumOfFactorials(int n)' to solve the following problem:\nCalculates the sum of factorials of all integers from 1 to n.\n\nThis function computes the factorial of each integer from 1 up to and\nincluding n using the `factorial` function, then sums these factorials to\nobtain the final result. The function uses `BigInt` to handle very large\nnumbers that may arise from factorial calculations.\n\nArgs:\n  n (int): The upper bound of the range for which to calculate the sum\n           of factorials. The value of n should be a non-negative integer.\n\nReturns:\n  BigInt: The sum of factorials of all integers from 1 to n.\n\nExamples:\n  sumOfFactorials(1) returns BigInt.from(1) (since 1! = 1)\n  sumOfFactorials(3) returns BigInt.from(9) (since 1! + 2! + 3! = 1 + 2 + 6 = 9)\n", "level": "easy"}
{"task_id": "Dart/6", "prompt": "String concatenateLargestNumber(List<int> numbers)\n/*Creates the largest possible number by concatenating the given list of integers.\n\nThe function sorts the list of integers in such a way that when they are\nconcatenated in this order, the resulting string represents the largest\npossible number. It uses a custom comparator for sorting that compares\nconcatenated pairs of numbers in reverse order to ensure the correct\nplacement for the largest concatenated result.\n\nArgs:\n  numbers (List<int>): A list of non-negative integers to be concatenated.\n\nReturns:\n  String: A string representing the largest number formed by the\n          concatenation of the provided integers.\n\nExamples:\n  concatenateLargestNumber([10, 2]) returns \"210\"\n  concatenateLargestNumber([42]) returns \"42\"\n*/", "canonical_solution": "{\n  // Custom comparator to decide which concatenation leads to a larger number\n  numbers.sort((a, b) {\n    String ab = '$a$b';\n    String ba = '$b$a';\n    return -ab.compareTo(ba); // Descending order\n  });\n  // Concatenate the numbers in the sorted order to form the largest number\n  return numbers.join('');\n}", "test": "void testConcatenateLargestNumber() {\n  // Test case 1: Simple case\n  assert(concatenateLargestNumber([10, 2]) == \"210\", \"Test Case 1 Failed: [10, 2] should concatenate to '210'\");\n\n  // Test case 2: Case with same starting digits\n  assert(concatenateLargestNumber([3, 30, 34, 5, 9]) == \"9534330\", \"Test Case 2 Failed: [3, 30, 34, 5, 9] should concatenate to '9534330'\");\n\n  // Test case 3: Case with zeros\n  assert(concatenateLargestNumber([0, 0, 0, 1]) == \"1000\", \"Test Case 3 Failed: [0, 0, 0, 1] should concatenate to '1000'\");\n\n  // Test case 4: All zeros\n  assert(concatenateLargestNumber([0, 0, 0, 0]) == \"0000\", \"Test Case 4 Failed: [0, 0, 0, 0] should concatenate to '0'\");\n\n  // Test case 5: Single number\n  assert(concatenateLargestNumber([42]) == \"42\", \"Test Case 5 Failed: [42] should concatenate to '42'\");\n\n  print(\"All concatenateLargestNumber test cases passed!\");\n}\n\nvoid main() {\n  testConcatenateLargestNumber();\n}", "entry_point": "concatenateLargestNumber", "signature": "String concatenateLargestNumber(List<int> numbers)", "docstring": "Creates the largest possible number by concatenating the given list of integers.\n\nThe function sorts the list of integers in such a way that when they are\nconcatenated in this order, the resulting string represents the largest\npossible number. It uses a custom comparator for sorting that compares\nconcatenated pairs of numbers in reverse order to ensure the correct\nplacement for the largest concatenated result.\n\nArgs:\n  numbers (List<int>): A list of non-negative integers to be concatenated.\n\nReturns:\n  String: A string representing the largest number formed by the\n          concatenation of the provided integers.\n\nExamples:\n  concatenateLargestNumber([10, 2]) returns \"210\"\n  concatenateLargestNumber([42]) returns \"42\"\n", "instruction": "Write a dart function 'String concatenateLargestNumber(List<int> numbers)' to solve the following problem:\nCreates the largest possible number by concatenating the given list of integers.\n\nThe function sorts the list of integers in such a way that when they are\nconcatenated in this order, the resulting string represents the largest\npossible number. It uses a custom comparator for sorting that compares\nconcatenated pairs of numbers in reverse order to ensure the correct\nplacement for the largest concatenated result.\n\nArgs:\n  numbers (List<int>): A list of non-negative integers to be concatenated.\n\nReturns:\n  String: A string representing the largest number formed by the\n          concatenation of the provided integers.\n\nExamples:\n  concatenateLargestNumber([10, 2]) returns \"210\"\n  concatenateLargestNumber([42]) returns \"42\"\n", "level": "easy"}
{"task_id": "Dart/7", "prompt": "String getCantorNumber(int n)\n/*Finds the N-th term in the Cantor enumeration of the rational numbers.\n\nThe Cantor enumeration is a sequence that lists all positive rational\nnumbers (fractions) uniquely. The enumeration is based on traversing the\ninfinite matrix of numerators/denominators diagonally. This function\ncalculates the numerator and denominator of the N-th term in this sequence.\n\nArgs:\n  n (int): The position in the sequence for which to calculate the\n           numerator and denominator.\n\nReturns:\n  String: A string representation of the fraction at the N-th position\n          in the form \"numerator/denominator\".\n\nExamples:\n  getCantorNumber(1) returns \"1/1\"\n  getCantorNumber(6) returns \"1/3\"\n*/", "canonical_solution": "{\n  // Determine the sum of the numerator and denominator for the N-th position\n  int sum = 0;\n  int count = 0;\n  while (count < n) {\n    sum++;\n    count += sum;\n  }\n\n  // Calculate the difference to backtrack to the start of the diagonal\n  int diff = count - n;\n\n  // Determine the numerator and denominator based on the diagonal's direction\n  int numerator, denominator;\n  if (sum % 2 == 0) {\n    // Even sum indicates a diagonal going down (numerator increases)\n    numerator = sum - diff;\n    denominator = 1 + diff;\n  } else {\n    // Odd sum indicates a diagonal going up (denominator increases)\n    numerator = 1 + diff;\n    denominator = sum - diff;\n  }\n  return \"$numerator/$denominator\";\n}", "test": "void testGetCantorNumber() {\n  // Test case 1: First term (N=1)\n  assert(getCantorNumber(1) == \"1/1\", \"Test Case 1 Failed: N=1 should result in '1/1'\");\n\n  // Test case 2: Fifth term (N=5)\n  assert(getCantorNumber(5) == \"2/2\", \"Test Case 2 Failed: N=5 should result in '2/2'\");\n\n  // Test case 3: Tenth term (N=10)\n  assert(getCantorNumber(10) == \"4/1\", \"Test Case 3 Failed: N=10 should result in '1/4'\");\n\n  print(\"All getCantorNumber test cases passed!\");\n}\n\nvoid main() {\n  testGetCantorNumber();\n}", "entry_point": "getCantorNumber", "signature": "String getCantorNumber(int n)", "docstring": "Finds the N-th term in the Cantor enumeration of the rational numbers.\n\nThe Cantor enumeration is a sequence that lists all positive rational\nnumbers (fractions) uniquely. The enumeration is based on traversing the\ninfinite matrix of numerators/denominators diagonally. This function\ncalculates the numerator and denominator of the N-th term in this sequence.\n\nArgs:\n  n (int): The position in the sequence for which to calculate the\n           numerator and denominator.\n\nReturns:\n  String: A string representation of the fraction at the N-th position\n          in the form \"numerator/denominator\".\n\nExamples:\n  getCantorNumber(1) returns \"1/1\"\n  getCantorNumber(6) returns \"1/3\"\n", "instruction": "Write a dart function 'String getCantorNumber(int n)' to solve the following problem:\nFinds the N-th term in the Cantor enumeration of the rational numbers.\n\nThe Cantor enumeration is a sequence that lists all positive rational\nnumbers (fractions) uniquely. The enumeration is based on traversing the\ninfinite matrix of numerators/denominators diagonally. This function\ncalculates the numerator and denominator of the N-th term in this sequence.\n\nArgs:\n  n (int): The position in the sequence for which to calculate the\n           numerator and denominator.\n\nReturns:\n  String: A string representation of the fraction at the N-th position\n          in the form \"numerator/denominator\".\n\nExamples:\n  getCantorNumber(1) returns \"1/1\"\n  getCantorNumber(6) returns \"1/3\"\n", "level": "middle"}
{"task_id": "Dart/8", "prompt": "String convertToNegativeBase(int n, int base) \n/*Converts an integer to its representation in a given negative base.\n\nThis function takes an integer `n` and a negative integer `base` and\nreturns a string representing the number `n` in the specified negative\nbase system. The conversion is done using the standard negative base\nconversion algorithm, which handles remainders and the division process\ndifferently than in positive base systems due to the nature of negative\nbases.\n\nArgs:\n  n (int): The integer to be converted.\n  base (int): The negative base to which the integer `n` will be converted.\n              The base must be a negative integer (e.g., -2, -3, etc.).\n\nReturns:\n  String: A string representing the integer `n` in the negative base system.\n\nExamples:\n  convertToNegativeBase(10, -2) returns \"11010\"\n  convertToNegativeBase(4, -3) returns \"102\"\n*/", "canonical_solution": "{\n  if (n == 0) return \"0\";\n\n  String result = \"\";\n  while (n != 0) {\n    int remainder = n % base;\n    n ~/= base;\n    if (remainder < 0) {\n      remainder += (-base);\n      n += 1;\n    }\n    result = _digitToChar(remainder) + result;\n  }\n  return result;\n}\n\nString _digitToChar(int digit) {\n  if (digit < 10) {\n    return digit.toString();\n  }\n  return String.fromCharCode('A'.codeUnitAt(0) + digit - 10);\n}", "test": "void testConvertToNegativeBase() {\n  // Test case 1: Conversion of 10 to base -2\n  assert(convertToNegativeBase(10, -2) == \"1010\", \"Test Case 1 Failed: 10 in base -2 should be '11010'\");\n\n  // Test case 2: Conversion of -15 to base -2\n  assert(convertToNegativeBase(-15, -2) == \"1111\", \"Test Case 2 Failed: -15 in base -2 should be '110001'\");\n\n  // Test case 3: Conversion of 4 to base -3\n  assert(convertToNegativeBase(4, -3) == \"21\", \"Test Case 3 Failed: 4 in base -3 should be '102'\");\n\n  print(\"All convertToNegativeBase test cases passed!\");\n}\n\nvoid main() {\n  testConvertToNegativeBase();\n}", "entry_point": "convertToNegativeBase", "signature": "String convertToNegativeBase(int n, int base)", "docstring": "Converts an integer to its representation in a given negative base.\n\nThis function takes an integer `n` and a negative integer `base` and\nreturns a string representing the number `n` in the specified negative\nbase system. The conversion is done using the standard negative base\nconversion algorithm, which handles remainders and the division process\ndifferently than in positive base systems due to the nature of negative\nbases.\n\nArgs:\n  n (int): The integer to be converted.\n  base (int): The negative base to which the integer `n` will be converted.\n              The base must be a negative integer (e.g., -2, -3, etc.).\n\nReturns:\n  String: A string representing the integer `n` in the negative base system.\n\nExamples:\n  convertToNegativeBase(10, -2) returns \"11010\"\n  convertToNegativeBase(4, -3) returns \"102\"\n", "instruction": "Write a dart function 'String convertToNegativeBase(int n, int base)' to solve the following problem:\nConverts an integer to its representation in a given negative base.\n\nThis function takes an integer `n` and a negative integer `base` and\nreturns a string representing the number `n` in the specified negative\nbase system. The conversion is done using the standard negative base\nconversion algorithm, which handles remainders and the division process\ndifferently than in positive base systems due to the nature of negative\nbases.\n\nArgs:\n  n (int): The integer to be converted.\n  base (int): The negative base to which the integer `n` will be converted.\n              The base must be a negative integer (e.g., -2, -3, etc.).\n\nReturns:\n  String: A string representing the integer `n` in the negative base system.\n\nExamples:\n  convertToNegativeBase(10, -2) returns \"11010\"\n  convertToNegativeBase(4, -3) returns \"102\"\n", "level": "easy"}
{"task_id": "Dart/9", "prompt": "int maxProduct(String numbers, int n, int k)\n/*Calculates the maximum product by inserting `k` multiplication signs into\nthe given string of digits `numbers`.\n\nThis function utilizes dynamic programming to find the maximum product that\ncan be obtained by inserting `k` multiplication signs (`*`) into the string\n`numbers`, which is composed of `n` digits. The algorithm computes this by\nbreaking down the problem into subproblems and storing intermediate results\nin a two-dimensional list `dp`, where dp[i][j] represents the maximum\nproduct obtainable from the first `i` digits with `j` multiplication signs.\n\nArgs:\n  numbers (String): The string of digits to insert multiplication signs into.\n  n (int): The number of digits in the `numbers` string.\n  k (int): The number of multiplication signs to insert.\n\nReturns:\n  int: The maximum product that can be achieved by inserting `k`\n       multiplication signs into the string `numbers`.\n\nExamples:\n  maxProduct(\"123\", 3, 1) returns 46\n  maxProduct(\"1234\", 4, 2) returns 120\n*/", "canonical_solution": "{\n  List<List<int>> dp = List.generate(n + 1, (i) => List.generate(k + 1, (j) => 0));\n\n  // Convert the number string into an array of digits for easy access\n  List<int> digits = numbers.split('').map((c) => int.parse(c)).toList();\n\n  // Initialize the DP table for the case when we have 0 multiplication signs\n  for (int i = 1; i <= n; i++) {\n    dp[i][0] = dp[i - 1][0] * 10 + digits[i - 1];\n  }\n\n  // Fill the DP table\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= k && j < i; j++) {\n      for (int m = j; m < i; m++) {\n        int currentProduct = dp[m][j - 1] * (dp[i][0] ~/ dp[m][0]);\n        dp[i][j] = max(dp[i][j], currentProduct);\n      }\n    }\n  }\n  // The answer will be the maximum product when using k multiplication signs\n  return dp[n][k];\n}\n\nint max(int a, int b) => a > b ? a : b;", "test": "void testMaxProduct() {\n  // Test case 1\n  assert(maxProduct(\"123\", 3, 1) == 123, \"Test Case 1 Failed: The maximum product from '123' with 1 multiplication sign should be 23 (1 * 23).\");\n\n  // Test case 2\n  assert(maxProduct(\"1234\", 4, 1) == 1234, \"Test Case 2 Failed: The maximum product from '1234' with 1 multiplication sign should be 234 (1 * 234).\");\n\n  // Test case 3\n  assert(maxProduct(\"1234\", 4, 2) == 1230, \"Test Case 3 Failed: The maximum product from '1234' with 2 multiplication signs should be 48 (1 * 2 * 34).\");\n\n  print(\"All maxProduct test cases passed!\");\n}\n\nvoid main() {\n  testMaxProduct();\n}", "entry_point": "maxProduct", "signature": "int maxProduct(String numbers, int n, int k)", "docstring": "Calculates the maximum product by inserting `k` multiplication signs into\nthe given string of digits `numbers`.\n\nThis function utilizes dynamic programming to find the maximum product that\ncan be obtained by inserting `k` multiplication signs (`*`) into the string\n`numbers`, which is composed of `n` digits. The algorithm computes this by\nbreaking down the problem into subproblems and storing intermediate results\nin a two-dimensional list `dp`, where dp[i][j] represents the maximum\nproduct obtainable from the first `i` digits with `j` multiplication signs.\n\nArgs:\n  numbers (String): The string of digits to insert multiplication signs into.\n  n (int): The number of digits in the `numbers` string.\n  k (int): The number of multiplication signs to insert.\n\nReturns:\n  int: The maximum product that can be achieved by inserting `k`\n       multiplication signs into the string `numbers`.\n\nExamples:\n  maxProduct(\"123\", 3, 1) returns 46\n  maxProduct(\"1234\", 4, 2) returns 120\n", "instruction": "Write a dart function 'int maxProduct(String numbers, int n, int k)' to solve the following problem:\nCalculates the maximum product by inserting `k` multiplication signs into\nthe given string of digits `numbers`.\n\nThis function utilizes dynamic programming to find the maximum product that\ncan be obtained by inserting `k` multiplication signs (`*`) into the string\n`numbers`, which is composed of `n` digits. The algorithm computes this by\nbreaking down the problem into subproblems and storing intermediate results\nin a two-dimensional list `dp`, where dp[i][j] represents the maximum\nproduct obtainable from the first `i` digits with `j` multiplication signs.\n\nArgs:\n  numbers (String): The string of digits to insert multiplication signs into.\n  n (int): The number of digits in the `numbers` string.\n  k (int): The number of multiplication signs to insert.\n\nReturns:\n  int: The maximum product that can be achieved by inserting `k`\n       multiplication signs into the string `numbers`.\n\nExamples:\n  maxProduct(\"123\", 3, 1) returns 46\n  maxProduct(\"1234\", 4, 2) returns 120\n", "level": "hard"}
{"task_id": "Dart/10", "prompt": "int calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)\n/*Calculates the scholarship amount a student is eligible to receive based on\nacademic performance, leadership, geographic background, and research contributions.\n\nThe scholarship is calculated by considering the student's final exam score,\nclass score, whether they are a student cadre (a leadership position),\nwhether they come from a western region, and the number of papers they have\npublished. Different conditions contribute varying amounts to the total scholarship.\n\nArgs:\n  name (String): The name of the student (not used in the calculation).\n  finalScore (int): The student's final exam score.\n  classScore (int): The student's class score.\n  isCadre (bool): Indicates if the student is a student cadre (true/false).\n  isWestern (bool): Indicates if the student is from a western region (true/false).\n  papers (int): The number of papers the student has published.\n\nReturns:\n  int: The total amount of scholarship money the student is eligible to receive.\n\nExamples:\n  calculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\n  calculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\n*/", "canonical_solution": "{\n\n    int scholarship = 0;\n    if (finalScore > 80 && papers >= 1) scholarship += 8000;\n    if (finalScore > 85 && classScore > 80) scholarship += 4000;\n    if (finalScore > 90) scholarship += 2000;\n    if (isWestern && finalScore > 85) scholarship += 1000;\n    if (isCadre && classScore > 80) scholarship += 850;\n    return scholarship;\n}", "test": "void testCalculateScholarship() {\n  // Test case 1: Student with high final score, class score, and has papers, but is not a cadre or from the western region\n  assert(calculateScholarship(\"Alice\", 90, 85, false, false, 2) == 12000,\n    \"Test Case 1 Failed: Alice should receive a scholarship of 14000.\");\n\n  // Test case 2: Student with high final score, class score, is a cadre, and from the western region, but does not have papers\n  assert(calculateScholarship(\"Bob\", 86, 82, true, true, 0) == 5850,\n    \"Test Case 2 Failed: Bob should receive a scholarship of 5850.\");\n\n  // Test case 3: Student with average scores, not a cadre, not from the western region, and no papers\n  assert(calculateScholarship(\"Charlie\", 75, 75, false, false, 0) == 0,\n    \"Test Case 3 Failed: Charlie should not receive any scholarship.\");\n\n  print(\"All calculateScholarship test cases passed!\");\n}\n\nvoid main() {\n  testCalculateScholarship();\n}", "entry_point": "calculateScholarship", "signature": "int calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)", "docstring": "Calculates the scholarship amount a student is eligible to receive based on\nacademic performance, leadership, geographic background, and research contributions.\n\nThe scholarship is calculated by considering the student's final exam score,\nclass score, whether they are a student cadre (a leadership position),\nwhether they come from a western region, and the number of papers they have\npublished. Different conditions contribute varying amounts to the total scholarship.\n\nArgs:\n  name (String): The name of the student (not used in the calculation).\n  finalScore (int): The student's final exam score.\n  classScore (int): The student's class score.\n  isCadre (bool): Indicates if the student is a student cadre (true/false).\n  isWestern (bool): Indicates if the student is from a western region (true/false).\n  papers (int): The number of papers the student has published.\n\nReturns:\n  int: The total amount of scholarship money the student is eligible to receive.\n\nExamples:\n  calculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\n  calculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\n", "instruction": "Write a dart function 'int calculateScholarship(  String name, int finalScore, int classScore, bool isCadre, bool isWestern, int papers)' to solve the following problem:\nCalculates the scholarship amount a student is eligible to receive based on\nacademic performance, leadership, geographic background, and research contributions.\n\nThe scholarship is calculated by considering the student's final exam score,\nclass score, whether they are a student cadre (a leadership position),\nwhether they come from a western region, and the number of papers they have\npublished. Different conditions contribute varying amounts to the total scholarship.\n\nArgs:\n  name (String): The name of the student (not used in the calculation).\n  finalScore (int): The student's final exam score.\n  classScore (int): The student's class score.\n  isCadre (bool): Indicates if the student is a student cadre (true/false).\n  isWestern (bool): Indicates if the student is from a western region (true/false).\n  papers (int): The number of papers the student has published.\n\nReturns:\n  int: The total amount of scholarship money the student is eligible to receive.\n\nExamples:\n  calculateScholarship(\"Alice\", 90, 85, false, false, 2) returns 14000\n  calculateScholarship(\"Charlie\", 75, 75, false, false, 0) returns 0\n", "level": "easy"}
{"task_id": "Dart/11", "prompt": "String validateISBN(String isbn)\n/*Validates an ISBN-10 number and returns either 'Right' if the ISBN is valid\nor the corrected ISBN with the proper check digit if it is not.\n\nThe function takes a String [isbn] which is an ISBN-10 number that may\ninclude hyphens. It removes any hyphens and then calculates the checksum \nbased on the first 9 digits. The checksum is used to determine the correct\ncheck digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n\nArguments:\n  isbn - A String containing the ISBN-10 number to be validated.\n\nReturns:\n  A String 'Right' if the ISBN is valid, or a String containing the\n  corrected ISBN if the original ISBN has an incorrect check digit.\n\nExamples:\n  validateISBN(\"0-306-40615-2\") returns 'Right' \n  validateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\"\n*/", "canonical_solution": "{\n  // Remove the hyphens and keep only the digits and 'X' if present\n  String cleanISBN = isbn.replaceAll('-', '');\n\n  // Calculate the check sum\n  int checkSum = 0;\n  for (int i = 0; i < 9; i++) {\n    checkSum += int.parse(cleanISBN[i]) * (i + 1);\n  }\n\n  // Compute the check digit\n  String checkDigit = (checkSum % 11).toString();\n  checkDigit = checkDigit == '10' ? 'X' : checkDigit;\n\n  // Check if the last digit of the ISBN is equal to the calculated check digit\n  if (cleanISBN[9] == checkDigit) {\n    return 'Right';\n  } else {\n    // If the check digit is incorrect, replace it with the correct one and return the full ISBN\n    return isbn.substring(0, 12) + checkDigit;\n  }\n}", "test": "void testValidateISBN() {\n  // Test case 1: A valid ISBN-10\n  assert(validateISBN(\"0-306-40615-2\") == 'Right');\n\n  // Test case 2: An invalid ISBN-10 with an incorrect check digit\n  assert(validateISBN(\"0-306-40615-0\") == \"0-306-40615-2\");\n\n  // Test case 3: A valid ISBN-10 with 'X' as the check digit\n  assert(validateISBN(\"0-19-852663-6\") == 'Right');\n\n  // All tests passed if no assertion error is thrown\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testValidateISBN();\n}", "entry_point": "validateISBN", "signature": "String validateISBN(String isbn)", "docstring": "Validates an ISBN-10 number and returns either 'Right' if the ISBN is valid\nor the corrected ISBN with the proper check digit if it is not.\n\nThe function takes a String [isbn] which is an ISBN-10 number that may\ninclude hyphens. It removes any hyphens and then calculates the checksum \nbased on the first 9 digits. The checksum is used to determine the correct\ncheck digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n\nArguments:\n  isbn - A String containing the ISBN-10 number to be validated.\n\nReturns:\n  A String 'Right' if the ISBN is valid, or a String containing the\n  corrected ISBN if the original ISBN has an incorrect check digit.\n\nExamples:\n  validateISBN(\"0-306-40615-2\") returns 'Right' \n  validateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\"\n", "instruction": "Write a dart function 'String validateISBN(String isbn)' to solve the following problem:\nValidates an ISBN-10 number and returns either 'Right' if the ISBN is valid\nor the corrected ISBN with the proper check digit if it is not.\n\nThe function takes a String [isbn] which is an ISBN-10 number that may\ninclude hyphens. It removes any hyphens and then calculates the checksum \nbased on the first 9 digits. The checksum is used to determine the correct\ncheck digit, which can be a number from 0 to 9, or 'X' if the checksum is 10.\n\nArguments:\n  isbn - A String containing the ISBN-10 number to be validated.\n\nReturns:\n  A String 'Right' if the ISBN is valid, or a String containing the\n  corrected ISBN if the original ISBN has an incorrect check digit.\n\nExamples:\n  validateISBN(\"0-306-40615-2\") returns 'Right' \n  validateISBN(\"0-306-40615-0\") returns \"0-306-40615-2\"\n", "level": "middle"}
{"task_id": "Dart/12", "prompt": "List<int> findCorridors(List<int> counts, int limit) \n/*Finds and returns a list of indices corresponding to the highest values in the\n`counts` list, up to the specified `limit`. The resulting list of indices is\nsorted in ascending order.\n\nThe function first generates a list of indices (1-based) up to the specified\n`limit`. Then it sorts these indices based on the corresponding values in the\n`counts` list, in descending order. After sorting, it takes the indices that\ncorrespond to the `limit` highest values and returns them sorted in ascending\norder. If the `limit` is greater than the number of elements in `counts`, the\nfunction will return indices up to the number of elements in `counts`.\n\nArguments:\n  counts (List<int>): A list containing integer values to be ranked.\n  limit (int): The maximum number of top values to return.\n\nReturns:\n  List<int>: A list containing the indices (1-based) of the top `limit` values\n  from `counts`, sorted in ascending order.\n\nExamples:\n  findCorridors([10, 20, 30, 40, 50], 3) return [3, 4, 5]\n*/", "canonical_solution": "{\n  List<int> corridors = [];\n  for (int i = 0; i < limit; i++) {\n    corridors.add(i + 1);\n  }\n\n  // Ensure we do not try to sort based on indices that don't exist in 'counts'\n  int countsLimit = counts.length < limit ? counts.length : limit;\n\n  corridors.sort((a, b) {\n    // Adjusting indices for zero-based indexing in the 'counts' list\n    int adjustedA = a - 1;\n    int adjustedB = b - 1;\n\n    // Prevent out-of-range access\n    if (adjustedA >= countsLimit) return 1;\n    if (adjustedB >= countsLimit) return -1;\n\n    return counts[adjustedB].compareTo(counts[adjustedA]);\n  });\n  // Take only the number of corridors that exists in the 'counts' list and sort them\n  return corridors.take(countsLimit).toList()..sort();\n}", "test": "void testFindCorridors() {\n  // Test case 1: General case with distinct counts\n  List<int> counts1 = [10, 20, 30, 40, 50];\n  int limit1 = 3;\n  List<int> expected1 = [1, 2, 3]; // Indices of the top 3 counts in ascending order\n  assert(findCorridors(counts1, limit1).toString() == expected1.toString());\n\n  // Test case 2: Case with some equal counts\n  List<int> counts2 = [50, 20, 50, 40, 10];\n  int limit2 = 4;\n  List<int> expected2 = [1, 2, 3, 4]; // Indices of the top 4 counts in ascending order\n  assert(findCorridors(counts2, limit2).toString() == expected2.toString());\n\n  // Test case 3: Case where limit exceeds the number of elements\n  List<int> counts3 = [5, 15, 25];\n  int limit3 = 5;\n  List<int> expected3 = [1, 2, 3]; // All indices in ascending order since limit exceeds the list size\n  assert(findCorridors(counts3, limit3).toString() == expected3.toString());\n\n  // All tests passed if no assertion error is thrown\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testFindCorridors();\n}", "entry_point": "findCorridors", "signature": "List<int> findCorridors(List<int> counts, int limit)", "docstring": "Finds and returns a list of indices corresponding to the highest values in the\n`counts` list, up to the specified `limit`. The resulting list of indices is\nsorted in ascending order.\n\nThe function first generates a list of indices (1-based) up to the specified\n`limit`. Then it sorts these indices based on the corresponding values in the\n`counts` list, in descending order. After sorting, it takes the indices that\ncorrespond to the `limit` highest values and returns them sorted in ascending\norder. If the `limit` is greater than the number of elements in `counts`, the\nfunction will return indices up to the number of elements in `counts`.\n\nArguments:\n  counts (List<int>): A list containing integer values to be ranked.\n  limit (int): The maximum number of top values to return.\n\nReturns:\n  List<int>: A list containing the indices (1-based) of the top `limit` values\n  from `counts`, sorted in ascending order.\n\nExamples:\n  findCorridors([10, 20, 30, 40, 50], 3) return [3, 4, 5]\n", "instruction": "Write a dart function 'List<int> findCorridors(List<int> counts, int limit)' to solve the following problem:\nFinds and returns a list of indices corresponding to the highest values in the\n`counts` list, up to the specified `limit`. The resulting list of indices is\nsorted in ascending order.\n\nThe function first generates a list of indices (1-based) up to the specified\n`limit`. Then it sorts these indices based on the corresponding values in the\n`counts` list, in descending order. After sorting, it takes the indices that\ncorrespond to the `limit` highest values and returns them sorted in ascending\norder. If the `limit` is greater than the number of elements in `counts`, the\nfunction will return indices up to the number of elements in `counts`.\n\nArguments:\n  counts (List<int>): A list containing integer values to be ranked.\n  limit (int): The maximum number of top values to return.\n\nReturns:\n  List<int>: A list containing the indices (1-based) of the top `limit` values\n  from `counts`, sorted in ascending order.\n\nExamples:\n  findCorridors([10, 20, 30, 40, 50], 3) return [3, 4, 5]\n", "level": "middle"}
{"task_id": "Dart/13", "prompt": "int passBallGame(int n, int m)\n/*Calculates the number of ways a ball can be passed among `n` students `m` times,\nsuch that the ball ends up with student 1 after the last pass.\n\nThis function uses dynamic programming to solve the problem, where `dp[i][j]`\nrepresents the number of ways to pass the ball `i` times and end up with student `j`.\nThe function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\nintermediate results. The base case is set where no passes are made and the ball starts\nwith student 1. The function then iterates over the number of passes and students to fill\nthe `dp` table with the count of pass sequences for each scenario. The final result is the\nnumber of ways to pass the ball `m` times and return it to student 1.\n\nArguments:\n  n (int): The total number of students among whom the ball is being passed.\n  m (int): The total number of passes to be made.\n\nReturns:\n  int: The number of distinct ways to pass the ball `m` times such that it\n  ends up with student 1.\n\nExamples:\n  passBallGame(3, 1) returns 0\n  passBallGame(5, 0) returns 1\n*/", "canonical_solution": "{\n  List<List<int>> dp = List.generate(m + 1, (_) => List.filled(n + 1, 0));\n  dp[0][1] = 1; // Starting with student 1, 0 passes.\n\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n      dp[i][j] = dp[i - 1][(j - 2 + n) % n + 1] + dp[i - 1][j % n + 1];\n    }\n  }\n  return dp[m][1]; // Number of ways ball can be passed m times and end up with student 1.\n}", "test": "void testPassBallGame() {\n  // Test case 1: Small number of students and passes\n  assert(passBallGame(3, 1) == 0, 'Test Case 1 Failed'); // There are two ways to pass the ball once among 3 students and end with student 1.\n\n  // Test case 2: A scenario where no passes are made\n  assert(passBallGame(5, 0) == 1, 'Test Case 2 Failed'); // There is only one way (no passes) to end up with student 1 when no passes are made.\n\n  // Test case 3: A larger number of students and passes\n  assert(passBallGame(4, 2) == 2, 'Test Case 3 Failed'); // There are two ways to pass the ball twice among 4 students and end with student 1.\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testPassBallGame();\n}", "entry_point": "passBallGame", "signature": "int passBallGame(int n, int m)", "docstring": "Calculates the number of ways a ball can be passed among `n` students `m` times,\nsuch that the ball ends up with student 1 after the last pass.\n\nThis function uses dynamic programming to solve the problem, where `dp[i][j]`\nrepresents the number of ways to pass the ball `i` times and end up with student `j`.\nThe function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\nintermediate results. The base case is set where no passes are made and the ball starts\nwith student 1. The function then iterates over the number of passes and students to fill\nthe `dp` table with the count of pass sequences for each scenario. The final result is the\nnumber of ways to pass the ball `m` times and return it to student 1.\n\nArguments:\n  n (int): The total number of students among whom the ball is being passed.\n  m (int): The total number of passes to be made.\n\nReturns:\n  int: The number of distinct ways to pass the ball `m` times such that it\n  ends up with student 1.\n\nExamples:\n  passBallGame(3, 1) returns 0\n  passBallGame(5, 0) returns 1\n", "instruction": "Write a dart function 'int passBallGame(int n, int m)' to solve the following problem:\nCalculates the number of ways a ball can be passed among `n` students `m` times,\nsuch that the ball ends up with student 1 after the last pass.\n\nThis function uses dynamic programming to solve the problem, where `dp[i][j]`\nrepresents the number of ways to pass the ball `i` times and end up with student `j`.\nThe function initializes a 2D list `dp` with dimensions `(m + 1) x (n + 1)` to store\nintermediate results. The base case is set where no passes are made and the ball starts\nwith student 1. The function then iterates over the number of passes and students to fill\nthe `dp` table with the count of pass sequences for each scenario. The final result is the\nnumber of ways to pass the ball `m` times and return it to student 1.\n\nArguments:\n  n (int): The total number of students among whom the ball is being passed.\n  m (int): The total number of passes to be made.\n\nReturns:\n  int: The number of distinct ways to pass the ball `m` times such that it\n  ends up with student 1.\n\nExamples:\n  passBallGame(3, 1) returns 0\n  passBallGame(5, 0) returns 1\n", "level": "easy"}
{"task_id": "Dart/14", "prompt": "List<int> removeDuplicatesAndSort(List<int> numbers)\n/*Removes duplicates from a list of integers and returns a sorted list of the unique numbers.\n\nThis function first converts the input list to a set to remove any duplicate values.\nSince a set inherently contains only unique elements, this step ensures that all duplicates\nare eliminated. The set is then converted back to a list, and this list is sorted in ascending\norder before being returned.\n\nArguments:\n  numbers (List<int>): The list of integers to be processed, which may contain duplicates.\n\nReturns:\n  List<int>: A list of unique integers sorted in ascending order.\n\nExamples:\n    removeDuplicatesAndSort([4, 1, 2, 4, 3, 2])\n    return [1, 2, 3, 4].\n    removeDuplicatesAndSort([1, 2, 2, 3])\n    return [1, 2, 3].\n*/", "canonical_solution": "{\n  Set<int> uniqueNumbers = numbers.toSet(); // Remove duplicates\n  List<int> sortedNumbers = uniqueNumbers.toList()..sort(); // Convert to list and sort\n  return sortedNumbers;\n}", "test": "void testRemoveDuplicatesAndSort() {\n  // Test case 1: A list with duplicates that needs sorting\n  assert(\n    removeDuplicatesAndSort([4, 1, 2, 4, 3, 2]).toString() == [1, 2, 3, 4].toString(),\n    'Test Case 1 Failed: Expected [1, 2, 3, 4], got ${removeDuplicatesAndSort([4, 1, 2, 4, 3, 2])}'\n  );\n\n  // Test case 2: A list with no duplicates, only needs sorting\n  assert(\n    removeDuplicatesAndSort([5, 3, 4, 1, 2]).toString() == [1, 2, 3, 4, 5].toString(),\n    'Test Case 2 Failed: Expected [1, 2, 3, 4, 5], got ${removeDuplicatesAndSort([5, 3, 4, 1, 2])}'\n  );\n\n  // Test case 3: A list that is already sorted and has duplicates\n  assert(\n    removeDuplicatesAndSort([1, 2, 2, 3]).toString() == [1, 2, 3].toString(),\n    'Test Case 3 Failed: Expected [1, 2, 3], got ${removeDuplicatesAndSort([1, 2, 2, 3])}'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testRemoveDuplicatesAndSort();\n}", "entry_point": "removeDuplicatesAndSort", "signature": "List<int> removeDuplicatesAndSort(List<int> numbers)", "docstring": "Removes duplicates from a list of integers and returns a sorted list of the unique numbers.\n\nThis function first converts the input list to a set to remove any duplicate values.\nSince a set inherently contains only unique elements, this step ensures that all duplicates\nare eliminated. The set is then converted back to a list, and this list is sorted in ascending\norder before being returned.\n\nArguments:\n  numbers (List<int>): The list of integers to be processed, which may contain duplicates.\n\nReturns:\n  List<int>: A list of unique integers sorted in ascending order.\n\nExamples:\n    removeDuplicatesAndSort([4, 1, 2, 4, 3, 2])\n    return [1, 2, 3, 4].\n    removeDuplicatesAndSort([1, 2, 2, 3])\n    return [1, 2, 3].\n", "instruction": "Write a dart function 'List<int> removeDuplicatesAndSort(List<int> numbers)' to solve the following problem:\nRemoves duplicates from a list of integers and returns a sorted list of the unique numbers.\n\nThis function first converts the input list to a set to remove any duplicate values.\nSince a set inherently contains only unique elements, this step ensures that all duplicates\nare eliminated. The set is then converted back to a list, and this list is sorted in ascending\norder before being returned.\n\nArguments:\n  numbers (List<int>): The list of integers to be processed, which may contain duplicates.\n\nReturns:\n  List<int>: A list of unique integers sorted in ascending order.\n\nExamples:\n    removeDuplicatesAndSort([4, 1, 2, 4, 3, 2])\n    return [1, 2, 3, 4].\n    removeDuplicatesAndSort([1, 2, 2, 3])\n    return [1, 2, 3].\n", "level": "easy"}
{"task_id": "Dart/15", "prompt": "import 'dart:math';\n\nint getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)\n/*Calculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n\nThis function uses a dynamic programming approach to determine the maximum value that can be achieved\nwithin the constraints of the total money available to spend. Each item's value is determined by its\nprice multiplied by its importance. The function iterates over the list of items, updating the maximum\nvalue obtainable at each price point up to the total money available.\n\nArguments:\n  totalMoney (int): The total amount of money available to spend on items.\n  numItems (int): The number of different items available for purchase.\n  prices (List<int>): A list containing the price of each item.\n  importance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n\nReturns:\n  int: The maximum value obtainable with the given total money and items.\n\nExamples:\n    getMaxValue(50, 2, [20, 30], [5, 10])\n    returns 400\n*/", "canonical_solution": "{\n  List<int> dp = List.filled(totalMoney + 1, 0);\n\n  for (int i = 0; i < numItems; i++) {\n    for (int j = totalMoney; j >= prices[i]; j--) {\n      dp[j] = max(dp[j], dp[j - prices[i]] + prices[i] * importance[i]);\n    }\n  }\n\n  return dp[totalMoney];\n}", "test": "void testGetMaxValue() {\n  // Test case 1: Basic scenario with two items\n  assert(\n    getMaxValue(50, 2, [20, 30], [5, 10]) == 400,\n    'Test Case 1 Failed: Expected maximum value to be 60, got ${getMaxValue(50, 2, [20, 30], [5, 10])}'\n  );\n\n  // Test case 2: Scenario where the total money can't buy the most valuable item\n  assert(\n    getMaxValue(10, 3, [5, 10, 15], [3, 6, 9]) == 60,\n    'Test Case 2 Failed: Expected maximum value to be 6, got ${getMaxValue(10, 3, [5, 10, 15], [3, 6, 9])}'\n  );\n\n  // Test case 3: Multiple items can be bought within the total money\n  assert(\n    getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2]) == 140,\n    'Test Case 3 Failed: Expected maximum value to be 100, got ${getMaxValue(100, 4, [50, 25, 10, 20], [1, 2, 3, 2])}'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testGetMaxValue();\n}", "entry_point": "getMaxValue", "signature": "int getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)", "docstring": "Calculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n\nThis function uses a dynamic programming approach to determine the maximum value that can be achieved\nwithin the constraints of the total money available to spend. Each item's value is determined by its\nprice multiplied by its importance. The function iterates over the list of items, updating the maximum\nvalue obtainable at each price point up to the total money available.\n\nArguments:\n  totalMoney (int): The total amount of money available to spend on items.\n  numItems (int): The number of different items available for purchase.\n  prices (List<int>): A list containing the price of each item.\n  importance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n\nReturns:\n  int: The maximum value obtainable with the given total money and items.\n\nExamples:\n    getMaxValue(50, 2, [20, 30], [5, 10])\n    returns 400\n", "instruction": "Write a dart function 'int getMaxValue(int totalMoney, int numItems, List<int> prices, List<int> importance)' to solve the following problem:\nCalculates the maximum value one can obtain with a given amount of money and a list of items with associated prices and importance.\n\nThis function uses a dynamic programming approach to determine the maximum value that can be achieved\nwithin the constraints of the total money available to spend. Each item's value is determined by its\nprice multiplied by its importance. The function iterates over the list of items, updating the maximum\nvalue obtainable at each price point up to the total money available.\n\nArguments:\n  totalMoney (int): The total amount of money available to spend on items.\n  numItems (int): The number of different items available for purchase.\n  prices (List<int>): A list containing the price of each item.\n  importance (List<int>): A list containing the importance of each item, corresponding to the prices list.\n\nReturns:\n  int: The maximum value obtainable with the given total money and items.\n\nExamples:\n    getMaxValue(50, 2, [20, 30], [5, 10])\n    returns 400\n", "level": "easy"}
{"task_id": "Dart/16", "prompt": "import 'dart:math';\n\nint maxEnergy(List<int> beads)\n/*Calculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n\nThis function simulates the energy released when breaking a circular necklace of beads into individual parts.\nThe energy obtained from breaking the necklace at a certain point is the product of the values of the beads\nat the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\nthat maximizes the total energy released.\n\nArguments:\n  beads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n\nReturns:\n  int: The maximum energy obtainable by breaking the necklace.\n\nExamples:\n  maxEnergy([1, 2, 3])\n  Returns: 6\n*/", "canonical_solution": " {\n  int n = beads.length;\n  // Extend the beads list to simulate a circular necklace\n  List<int> extendedBeads = List.from(beads)..addAll(beads);\n  // Initialize a 2D array for dynamic programming\n  List<List<int>> dp = List.generate(2 * n, (i) => List.filled(2 * n, 0));\n\n  // Bottom-up dynamic programming approach\n  for (int len = 2; len <= n; ++len) { // length of the chain to multiply\n    for (int i = 0; i < 2 * n - len + 1; ++i) { // start of the chain\n      int j = i + len - 1; // end of the chain\n      for (int k = i + 1; k < j; ++k) { // split point of the chain\n        int energy = extendedBeads[i] * extendedBeads[k] * extendedBeads[j];\n        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + energy);\n      }\n    }\n  }\n\n  // Find the maximum energy that can be obtained\n  int maxEnergy = 0;\n  for (int i = 0; i < n; ++i) {\n    maxEnergy = max(maxEnergy, dp[i][i + n - 1]);\n  }\n\n  return maxEnergy;\n}", "test": "void testMaxEnergy() {\n  // Test case 1: Simple case with three beads\n  assert(\n    maxEnergy([1, 2, 3]) == 6,\n    'Test Case 1 Failed: Expected maximum energy to be 12, got ${maxEnergy([1, 2, 3])}'\n  );\n\n  // Test case 2: Another simple case with four beads\n  assert(\n    maxEnergy([4, 3, 2, 1]) == 32,\n    'Test Case 2 Failed: Expected maximum energy to be 48, got ${maxEnergy([4, 3, 2, 1])}'\n  );\n\n  // Test case 3: Case with more beads\n  assert(\n    maxEnergy([1, 3, 5, 8]) == 144,\n    'Test Case 3 Failed: Expected maximum energy to be 152, got ${maxEnergy([1, 3, 5, 8])}'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testMaxEnergy();\n}", "entry_point": "maxEnergy", "signature": "int maxEnergy(List<int> beads)", "docstring": "Calculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n\nThis function simulates the energy released when breaking a circular necklace of beads into individual parts.\nThe energy obtained from breaking the necklace at a certain point is the product of the values of the beads\nat the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\nthat maximizes the total energy released.\n\nArguments:\n  beads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n\nReturns:\n  int: The maximum energy obtainable by breaking the necklace.\n\nExamples:\n  maxEnergy([1, 2, 3])\n  Returns: 6\n", "instruction": "Write a dart function 'int maxEnergy(List<int> beads)' to solve the following problem:\nCalculates the maximum energy that can be obtained by breaking a circular necklace of beads.\n\nThis function simulates the energy released when breaking a circular necklace of beads into individual parts.\nThe energy obtained from breaking the necklace at a certain point is the product of the values of the beads\nat the breaking points. The function uses a dynamic programming approach to find the sequence of breaks\nthat maximizes the total energy released.\n\nArguments:\n  beads (List<int>): A list of integers representing the value of each bead in the circular necklace.\n\nReturns:\n  int: The maximum energy obtainable by breaking the necklace.\n\nExamples:\n  maxEnergy([1, 2, 3])\n  Returns: 6\n", "level": "hard"}
{"task_id": "Dart/17", "prompt": "String formatPolynomial(List<int> coefficients)\n/*Formats a list of coefficients into a string representation of a polynomial.\n\nThis function takes a list of integer coefficients and returns a string that represents\nthe corresponding polynomial. Coefficients are listed in descending order of their degree.\nZero coefficients are skipped, and the powers of 'x' are included only where necessary.\nThe output polynomial does not contain unnecessary plus or minus signs and avoids using\nthe coefficient '1' where it is implied, except for the constant term.\n\nArguments:\n  coefficients (List<int>): A list of integer coefficients for the polynomial.\n\nReturns:\n  String: A string representation of the polynomial.\n\nExamples:\n  formatPolynomial([1, 0, -4, 3])\n  return 'x^3 - 4x + 3'\n*/", "canonical_solution": "{\n  StringBuffer polynomial = StringBuffer();\n  int degree = coefficients.length - 1;\n\n  for (int i = 0; i < coefficients.length; i++) {\n    int coeff = coefficients[i];\n    if (coeff == 0) continue; // Skip zero coefficients\n\n    int exp = degree - i; // Exponent for the current term\n    String term = \"\";\n\n    if (coeff > 0 && polynomial.isNotEmpty) {\n      term += \"+\"; // Add + sign for positive coefficients (except for the first term)\n    }\n\n    if (coeff < 0) {\n      term += \"-\"; // Add - sign for negative coefficients\n      coeff = -coeff; // Convert to positive for display\n    }\n\n    // Append the coefficient if it's not 1 or if it's the constant term (exp == 0)\n    if (coeff != 1 || exp == 0) {\n      term += coeff.toString();\n    }\n\n    if (exp > 0) {\n      term += \"x\"; // Append the variable x\n    }\n\n    if (exp > 1) {\n      term += \"^$exp\"; // Append the exponent if greater than 1\n    }\n\n    polynomial.write(term); // Add the term to the polynomial\n  }\n\n  return polynomial.toString();\n}", "test": "void testFormatPolynomial() {\n  // Test case 1: Polynomial with positive and negative coefficients, and zero coefficients\n  assert(\n    formatPolynomial([3, -2, 0, 1]) == \"3x^3-2x^2+1\",\n    'Test Case 1 Failed: Expected polynomial string to be \"3x^3-2x^2+x\", got \"${formatPolynomial([3, -2, 0, 1])}\"'\n  );\n\n  // Test case 2: Polynomial with all positive coefficients\n  assert(\n    formatPolynomial([1, 2, 3]) == \"x^2+2x+3\",\n    'Test Case 2 Failed: Expected polynomial string to be \"x^2+2x+3\", got \"${formatPolynomial([1, 2, 3])}\"'\n  );\n\n  // Test case 3: Polynomial with a single constant term\n  assert(\n    formatPolynomial([5]) == \"5\",\n    'Test Case 3 Failed: Expected polynomial string to be \"5\", got \"${formatPolynomial([5])}\"'\n  );\n\n  // Additional test cases can be added here as needed.\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testFormatPolynomial();\n}", "entry_point": "formatPolynomial", "signature": "String formatPolynomial(List<int> coefficients)", "docstring": "Formats a list of coefficients into a string representation of a polynomial.\n\nThis function takes a list of integer coefficients and returns a string that represents\nthe corresponding polynomial. Coefficients are listed in descending order of their degree.\nZero coefficients are skipped, and the powers of 'x' are included only where necessary.\nThe output polynomial does not contain unnecessary plus or minus signs and avoids using\nthe coefficient '1' where it is implied, except for the constant term.\n\nArguments:\n  coefficients (List<int>): A list of integer coefficients for the polynomial.\n\nReturns:\n  String: A string representation of the polynomial.\n\nExamples:\n  formatPolynomial([1, 0, -4, 3])\n  return 'x^3 - 4x + 3'\n", "instruction": "Write a dart function 'String formatPolynomial(List<int> coefficients)' to solve the following problem:\nFormats a list of coefficients into a string representation of a polynomial.\n\nThis function takes a list of integer coefficients and returns a string that represents\nthe corresponding polynomial. Coefficients are listed in descending order of their degree.\nZero coefficients are skipped, and the powers of 'x' are included only where necessary.\nThe output polynomial does not contain unnecessary plus or minus signs and avoids using\nthe coefficient '1' where it is implied, except for the constant term.\n\nArguments:\n  coefficients (List<int>): A list of integer coefficients for the polynomial.\n\nReturns:\n  String: A string representation of the polynomial.\n\nExamples:\n  formatPolynomial([1, 0, -4, 3])\n  return 'x^3 - 4x + 3'\n", "level": "hard"}
{"task_id": "Dart/18", "prompt": "List<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)\n/**\nSorts and filters a list of applicants based on their scores and an interview cutoff line.\n\nThe function accepts a list of applicant records, where each record is a list containing\ntwo integers: the applicant's number and their examination score. The function sorts the \napplicants primarily by score in descending order and secondarily by applicant number in \nascending order. It then filters the applicants to include only those whose scores meet \nor exceed the score of the applicant at the interview cutoff line, which is determined \nas the score of the applicant ranked at position `m* 1.5` (floored). The final list\ncontains all applicants who have made it past the cutoff line.\n\n@param applicants A list of lists where each inner list contains two integers representing\n                  an applicant's number and score, respectively.\n@param m          An integer representing the number of positions available for interview.\n\n@return A list of applicants who have scores greater than or equal to the interview line score.\n\nExample cases:\nsortAndFilterApplicants([[1, 90], [2, 85], [3, 80]],2) \nreturn [[1, 90], [2, 85], [3, 80]]\n*/", "canonical_solution": "{\n  // Sort the applicants based on score and then by applicant number\n  applicants.sort((a, b) => b[1] != a[1] ? b[1].compareTo(a[1]) : a[0].compareTo(b[0]));\n  int interviewLineIndex = (m * 1.5).floor() - 1;\n  int interviewLineScore = applicants[interviewLineIndex][1];\n  // Find all applicants who have a score >= interview line score\n  return applicants.where((applicant) => applicant[1] >= interviewLineScore).toList();\n}", "test": "void testSortAndFilterApplicants() {\n  // Test case 1: Basic test with already sorted applicants\n  List<List<int>> applicants1 = [\n    [1, 90],\n    [2, 85],\n    [3, 80],\n  ];\n  List<List<int>> expected1 = [[1, 90], [2, 85], [3, 80]];\n  assert(sortAndFilterApplicants(applicants1, 2).toString() == expected1.toString());\n\n  // Test case 2: Test with unsorted applicants and a cutoff that excludes some applicants\n  List<List<int>> applicants2 = [\n    [3, 70],\n    [1, 95],\n    [2, 90],\n  ];\n  List<List<int>> expected2 = [[1, 95]];\n  assert(sortAndFilterApplicants(applicants2, 1).toString() == expected2.toString());\n\n  // Test case 3: Test with a tie on scores\n  List<List<int>> applicants3 = [\n    [5, 85],\n    [2, 85],\n    [1, 90],\n    [3, 80],\n    [4, 85],\n  ];\n  List<List<int>> expected3 = [\n    [1, 90],\n    [2, 85],\n    [4, 85],\n    [5, 85],\n  ];\n  assert(sortAndFilterApplicants(applicants3, 2).toString() == expected3.toString());\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testSortAndFilterApplicants();\n}", "entry_point": "sortAndFilterApplicants", "signature": "List<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)", "docstring": "*\nSorts and filters a list of applicants based on their scores and an interview cutoff line.\n\nThe function accepts a list of applicant records, where each record is a list containing\ntwo integers: the applicant's number and their examination score. The function sorts the \napplicants primarily by score in descending order and secondarily by applicant number in \nascending order. It then filters the applicants to include only those whose scores meet \nor exceed the score of the applicant at the interview cutoff line, which is determined \nas the score of the applicant ranked at position `m* 1.5` (floored). The final list\ncontains all applicants who have made it past the cutoff line.\n\n@param applicants A list of lists where each inner list contains two integers representing\n                  an applicant's number and score, respectively.\n@param m          An integer representing the number of positions available for interview.\n\n@return A list of applicants who have scores greater than or equal to the interview line score.\n\nExample cases:\nsortAndFilterApplicants([[1, 90], [2, 85], [3, 80]],2) \nreturn [[1, 90], [2, 85], [3, 80]]\n", "instruction": "Write a dart function 'List<List<int>> sortAndFilterApplicants(List<List<int>> applicants, int m)' to solve the following problem:\n*\nSorts and filters a list of applicants based on their scores and an interview cutoff line.\n\nThe function accepts a list of applicant records, where each record is a list containing\ntwo integers: the applicant's number and their examination score. The function sorts the \napplicants primarily by score in descending order and secondarily by applicant number in \nascending order. It then filters the applicants to include only those whose scores meet \nor exceed the score of the applicant at the interview cutoff line, which is determined \nas the score of the applicant ranked at position `m* 1.5` (floored). The final list\ncontains all applicants who have made it past the cutoff line.\n\n@param applicants A list of lists where each inner list contains two integers representing\n                  an applicant's number and score, respectively.\n@param m          An integer representing the number of positions available for interview.\n\n@return A list of applicants who have scores greater than or equal to the interview line score.\n\nExample cases:\nsortAndFilterApplicants([[1, 90], [2, 85], [3, 80]],2) \nreturn [[1, 90], [2, 85], [3, 80]]\n", "level": "easy"}
{"task_id": "Dart/20", "prompt": "import 'dart:math';\nint findLargerPrimeFactor(int n)\n/*Finds the larger prime factor of a given integer.\n\nThis function takes an integer `n` and returns its larger prime factor.\nIt starts by checking from the smallest prime number, 2, and continues\nup to the square root of `n`. If a factor is found, it returns the\ncomplementary factor, which is guaranteed to be larger. If `n` is prime\nor 1, it returns `n` itself.\n\nArgs:\n  int n: The integer to find the larger prime factor of.\n\nReturns:\n  The larger prime factor of `n` if it exists, otherwise `n` itself.\n\nExamples:\n  findLargerPrimeFactor(1) returns 1\n  findLargerPrimeFactor(15) returns 5\n*/", "canonical_solution": "{\n  // Handle the edge case if n is 1\n  if (n == 1) return 1;\n\n  // Start checking for factors from 2 upwards\n  for (int i = 2; i <= sqrt(n); i++) {\n    // If i is a factor of n, it means n / i is the other factor\n    if (n % i == 0) {\n      // Since n is a product of two primes, the larger factor is n / i\n      return n ~/ i;\n    }\n  }\n\n  // If no factors are found, n itself is a prime number\n  return n;\n}", "test": "void main() {\n  testFindLargerPrimeFactor();\n}\n\nvoid testFindLargerPrimeFactor() {\n  // Test case 1: Testing with a composite number which is a product of two primes\n  assert(findLargerPrimeFactor(14) == 7, 'Test case 1 failed');\n\n  // Test case 2: Testing with a prime number (should return the number itself)\n  assert(findLargerPrimeFactor(13) == 13, 'Test case 2 failed');\n\n  // Test case 3: Testing with a composite number with a non-prime factor\n  assert(findLargerPrimeFactor(49) == 7, 'Test case 3 failed');\n\n  // Add more cases if needed\n  // ...\n\n  print('All test cases passed!');\n}", "entry_point": "findLargerPrimeFactor", "signature": "int findLargerPrimeFactor(int n)", "docstring": "Finds the larger prime factor of a given integer.\n\nThis function takes an integer `n` and returns its larger prime factor.\nIt starts by checking from the smallest prime number, 2, and continues\nup to the square root of `n`. If a factor is found, it returns the\ncomplementary factor, which is guaranteed to be larger. If `n` is prime\nor 1, it returns `n` itself.\n\nArgs:\n  int n: The integer to find the larger prime factor of.\n\nReturns:\n  The larger prime factor of `n` if it exists, otherwise `n` itself.\n\nExamples:\n  findLargerPrimeFactor(1) returns 1\n  findLargerPrimeFactor(15) returns 5\n", "instruction": "Write a dart function 'int findLargerPrimeFactor(int n)' to solve the following problem:\nFinds the larger prime factor of a given integer.\n\nThis function takes an integer `n` and returns its larger prime factor.\nIt starts by checking from the smallest prime number, 2, and continues\nup to the square root of `n`. If a factor is found, it returns the\ncomplementary factor, which is guaranteed to be larger. If `n` is prime\nor 1, it returns `n` itself.\n\nArgs:\n  int n: The integer to find the larger prime factor of.\n\nReturns:\n  The larger prime factor of `n` if it exists, otherwise `n` itself.\n\nExamples:\n  findLargerPrimeFactor(1) returns 1\n  findLargerPrimeFactor(15) returns 5\n", "level": "easy"}
{"task_id": "Dart/21", "prompt": "int smallestNForSumExceeds(int k)\n/*\nGiven that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+\u2026+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\nNow, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\nexample\nsmallestNForSumExceeds(1) => 2\n*/", "canonical_solution": "{\n    double sum = 0.0;\n    int n = 0;\n\n    while (sum <= k) {\n        n++;\n        sum += 1 / n;\n    }\n\n    return n;\n}", "test": "void main() {\n  check(smallestNForSumExceeds);\n}\n\nvoid check(int Function(int) smallestNForSumExceeds) {\n  assert(smallestNForSumExceeds(1) == 2);\n  assert(smallestNForSumExceeds(2) == 4);\n  assert(smallestNForSumExceeds(0) == 1);\n}", "entry_point": "smallestNForSumExceeds", "signature": "int smallestNForSumExceeds(int k)", "docstring": "\nGiven that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+\u2026+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\nNow, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\nexample\nsmallestNForSumExceeds(1) => 2\n", "instruction": "Write a dart function 'int smallestNForSumExceeds(int k)' to solve the following problem:\n\nGiven that: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+\u2026+\\dfrac{1}{n}$. It is evident that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\nNow, given an integer $k$, the task is to calculate the smallest $n$ such that $S_n>k$.\nexample\nsmallestNForSumExceeds(1) => 2\n", "level": "easy"}
{"task_id": "Dart/22", "prompt": "int countPrimeSumCombinations(List<int> numbers, int n, int k)\n/*Problem Description\n\nGiven are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n$3+7+12=22$\n$3+7+19=29$\n$7+12+19=38$\n$3+12+19=34$\nThe task is to compute the number of combinations for which the sum is a prime number.\nFor the example given, there is only one combination where the sum is prime: $3+7+19=29$.\nexample\ncountPrimeSumCombination([3,7,12,19],4,3) = 1\n*/", "canonical_solution": "{\n  int count = 0;\n  // \u4f7f\u7528\u9012\u5f52\u7684\u65b9\u6cd5\u751f\u6210\u6240\u6709\u53ef\u80fd\u7684\u7ec4\u5408\n  void _combine(List<int> selected, int start) {\n    if (selected.length == k) {\n      // \u5982\u679c\u9009\u5b9a\u7684\u6570\u8fbe\u5230k\u4e2a\uff0c\u68c0\u67e5\u548c\u662f\u5426\u4e3a\u7d20\u6570\n      int sum = selected.reduce((value, element) => value + element);\n      if (isPrime(sum)) {\n        count++;\n      }\n      return;\n    }\n    for (int i = start; i < numbers.length; i++) {\n      _combine([...selected, numbers[i]], i + 1);\n    }\n  }\n\n  _combine([], 0);\n  return count;\n}\n\n// \u68c0\u67e5\u4e00\u4e2a\u6570\u662f\u5426\u662f\u7d20\u6570\nbool isPrime(int n) {\n  if (n < 2) return false;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}", "test": "void main() {\n  // \u6d4b\u8bd5\u7528\u4f8b1\n  {\n    List<int> numbers = [3, 7, 12, 19];\n    int n = 4;\n    int k = 3;\n    int expected = 1;\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '\u6d4b\u8bd5\u7528\u4f8b1\u5931\u8d25: \u9884\u671f$expected, \u5b9e\u9645$result');\n  }\n\n  // \u6d4b\u8bd5\u7528\u4f8b2\n  {\n    List<int> numbers = [2, 3, 5, 7];\n    int n = 4;\n    int k = 2;\n    int expected = 2; // 2+3=5, 5+7=12(\u4e0d\u662f\u7d20\u6570)\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '\u6d4b\u8bd5\u7528\u4f8b2\u5931\u8d25: \u9884\u671f$expected, \u5b9e\u9645$result');\n  }\n\n  // \u6d4b\u8bd5\u7528\u4f8b3\n  {\n    List<int> numbers = [1, 3, 6, 8, 10];\n    int n = 5;\n    int k = 3;\n    int expected = 4; // \u6ca1\u6709\u7ec4\u5408\u7684\u548c\u662f\u7d20\u6570\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '\u6d4b\u8bd5\u7528\u4f8b3\u5931\u8d25: \u9884\u671f$expected, \u5b9e\u9645$result');\n  }\n\n  // \u6d4b\u8bd5\u7528\u4f8b4\n  {\n    List<int> numbers = [11, 13, 17, 19, 23];\n    int n = 5;\n    int k = 4;\n    int expected = 0; // \u6240\u6709\u53ef\u80fd\u7684\u7ec4\u5408\u548c\u90fd\u662f\u7d20\u6570\n    int result = countPrimeSumCombinations(numbers, n, k);\n    assert(result == expected, '\u6d4b\u8bd5\u7528\u4f8b4\u5931\u8d25: \u9884\u671f$expected, \u5b9e\u9645$result');\n  }\n\n  print('\u6240\u6709\u6d4b\u8bd5\u7528\u4f8b\u90fd\u901a\u8fc7\u4e86!');\n}", "entry_point": "countPrimeSumCombinations", "signature": "int countPrimeSumCombinations(List<int> numbers, int n, int k)", "docstring": "Problem Description\n\nGiven are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n$3+7+12=22$\n$3+7+19=29$\n$7+12+19=38$\n$3+12+19=34$\nThe task is to compute the number of combinations for which the sum is a prime number.\nFor the example given, there is only one combination where the sum is prime: $3+7+19=29$.\nexample\ncountPrimeSumCombination([3,7,12,19],4,3) = 1\n", "instruction": "Write a dart function 'int countPrimeSumCombinations(List<int> numbers, int n, int k)' to solve the following problem:\nProblem Description\n\nGiven are $n$ integers $x_1,x_2,\\cdots,x_n$, along with one integer $k$ where $k<n$. By selecting any $k$ integers from these $n$ integers and summing them, a series of sums can be obtained. For instance, when $n=4$, $k=3$, and the four integers are $3,7,12,19$, the complete set of combinations and their sums are as follows:\n$3+7+12=22$\n$3+7+19=29$\n$7+12+19=38$\n$3+12+19=34$\nThe task is to compute the number of combinations for which the sum is a prime number.\nFor the example given, there is only one combination where the sum is prime: $3+7+19=29$.\nexample\ncountPrimeSumCombination([3,7,12,19],4,3) = 1\n", "level": "middle"}
{"task_id": "Dart/23", "prompt": "int countSequences(int n)\n/*Problem Description\nYY contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n\nCurrently, two operations can be performed:\n\n1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n\nUsing these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n\nYour program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n\nexample\ncountSequences(3) = 5\n*/", "canonical_solution": "{\n  // Base case\n  if (n == 0 || n == 1) return 1;\n\n  int result = 0;\n\n  // Applying the formula for Catalan Numbers:\n  // C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n  for (int i = 0; i < n; i++) {\n    result += countSequences(i) * countSequences(n - 1 - i);\n  }\n\n  return result;\n}", "test": "void testCountSequences() {\n  // Test case 1: n = 3\n  assert(countSequences(3) == 5, 'Test case 1 failed');\n\n  // Test case 2: n = 4\n  assert(countSequences(4) == 14, 'Test case 2 failed');\n\n  // Test case 3: n = 5\n  assert(countSequences(5) == 42, 'Test case 3 failed');\n\n  print('All test cases passed!');\n}\n\nvoid main() {\n  testCountSequences();\n}", "entry_point": "countSequences", "signature": "int countSequences(int n)", "docstring": "Problem Description\nYY contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n\nCurrently, two operations can be performed:\n\n1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n\nUsing these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n\nYour program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n\nexample\ncountSequences(3) = 5\n", "instruction": "Write a dart function 'int countSequences(int n)' to solve the following problem:\nProblem Description\nYY contemplates the following scenario: a sequence of operation numbers, $1,2,\\ldots ,n$ (as illustrated for the case of 1 to 3), where the depth of stack A exceeds $n$.\n\nCurrently, two operations can be performed:\n\n1. Move a number from the head of the operation number sequence to the head of the stack (corresponding to the stack's push operation).\n2. Move a number from the head of the stack to the tail of the output sequence (corresponding to the stack's pop operation).\n\nUsing these two operations, a series of output sequences can be generated from an operation number sequence, as shown below for generating the sequence `2 3 1` from `1 2 3`.\n\nYour program is tasked with calculating and outputting the total number of possible output sequences derived from the operation number sequence $1,2,\\ldots,n$.\n\nexample\ncountSequences(3) = 5\n", "level": "easy"}
{"task_id": "Dart/24", "prompt": "int countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)\n/*Problem Description\n\nIn the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n\nThe task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n\ncountApplesTaoTaoCanPick([100, 200, 150, 140, 129, 134, 167, 198, 200, 111],110) returns 5\n*/", "canonical_solution": "{\n  // TaoTao can use a 30 cm stool to reach higher\n  int stoolHeight = 30;\n\n  // Calculating the total height TaoTao can reach with the stool\n  int totalReachWithStool = maxReach + stoolHeight;\n\n  // Initializing a counter for the apples TaoTao can pick\n  int applesPicked = 0;\n\n  // Iterating through the list of apple heights\n  for (int height in appleHeights) {\n    // If TaoTao can reach the apple with or without the stool, increment the counter\n    if (height <= totalReachWithStool) {\n      applesPicked++;\n    }\n  }\n\n  // Returning the number of apples TaoTao can pick\n  return applesPicked;\n}", "test": "void testCountApplesTaoTaoCanPick() {\n  // Test case 1\n  List<int> appleHeights1 = [100, 200, 150, 140, 129, 134, 167, 198, 200, 111];\n  int maxReach1 = 110;\n  int expectedApples1 = 5;\n  assert(countApplesTaoTaoCanPick(appleHeights1, maxReach1) == expectedApples1);\n\n  // Test case 2\n  List<int> appleHeights2 = [120, 130, 140, 150, 160, 170, 180, 190, 200, 210];\n  int maxReach2 = 120;\n  int expectedApples2 = 4;\n  assert(countApplesTaoTaoCanPick(appleHeights2, maxReach2) == expectedApples2);\n\n  // Test case 3\n  List<int> appleHeights3 = [101, 102, 103, 104, 105, 106, 107, 108, 109, 110];\n  int maxReach3 = 100;\n  int expectedApples3 = 10;\n  assert(countApplesTaoTaoCanPick(appleHeights3, maxReach3) == expectedApples3);\n\n  // If the program reaches this point without any assertion error, print success message\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  // Running the test function\n  testCountApplesTaoTaoCanPick();\n}", "entry_point": "countApplesTaoTaoCanPick", "signature": "int countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)", "docstring": "Problem Description\n\nIn the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n\nThe task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n\ncountApplesTaoTaoCanPick([100, 200, 150, 140, 129, 134, 167, 198, 200, 111],110) returns 5\n", "instruction": "Write a dart function 'int countApplesTaoTaoCanPick(List<int> appleHeights, int maxReach)' to solve the following problem:\nProblem Description\n\nIn the courtyard of TaoTao's residence stands an apple tree that bears 10 apples each autumn. Upon the maturation of these apples, TaoTao sets out to pick the apples. TaoTao possesses a stool measuring 30 centimeters in height, which she resorts to standing on whenever the apples are beyond her direct reach.\n\nThe task is to compute the number of apples TaoTao can successfully pick, given the heights of 10 apples from the ground, alongside the maximum height TaoTao can reach with her arm fully extended. It is assumed that any apple that TaoTao touches will fall.\n\ncountApplesTaoTaoCanPick([100, 200, 150, 140, 129, 134, 167, 198, 200, 111],110) returns 5\n", "level": "middle"}
{"task_id": "Dart/25", "prompt": "int countRemainingTrees(int roadLength, List<List<int>> regions)\n/*Problem Description\nAdjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\nSome sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n\nInput Format\nThe first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\nThe following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n\nOutput Format\nOutput a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n\nSample \ncountRemainingTrees(500,[[150, 300], [301, 450]]) => 200\n*/", "canonical_solution": "{\n  // Initialize a list to keep track of the trees; true means the tree is still there\n  List<bool> trees = List.filled(roadLength + 1, true);\n\n  // Iterate through each region and mark the trees in that region as removed\n  for (var region in regions) {\n    for (int i = region[0]; i <= region[1]; i++) {\n      trees[i] = false; // Tree is removed\n    }\n  }\n\n  // Count the remaining trees\n  int remaining = trees.where((tree) => tree).length;\n  print(remaining);\n  return remaining;\n}", "test": "void testCountRemainingTrees() {\n  // Test case 1: Non-overlapping regions\n  int roadLength1 = 500;\n  List<List<int>> regions1 = [\n    [150, 300],\n    [301, 450]\n  ];\n  int expectedRemaining1 = 200; // Trees from 0-149, 451-500\n  assert(countRemainingTrees(roadLength1, regions1) == expectedRemaining1);\n\n  // Test case 2: Partially overlapping regions\n  int roadLength2 = 500;\n  List<List<int>> regions2 = [\n    [100, 200],\n    [150, 300],\n    [470, 471]\n  ];\n  int expectedRemaining2 = 298; // Trees from 0-99, 301-469, 472-500\n  assert(countRemainingTrees(roadLength2, regions2) == expectedRemaining2);\n\n  // Test case 3: All trees are removed\n  int roadLength3 = 10;\n  List<List<int>> regions3 = [\n    [0, 10]\n  ];\n  int expectedRemaining3 = 0; // All trees are removed\n  assert(countRemainingTrees(roadLength3, regions3) == expectedRemaining3);\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testCountRemainingTrees();\n}", "entry_point": "countRemainingTrees", "signature": "int countRemainingTrees(int roadLength, List<List<int>> regions)", "docstring": "Problem Description\nAdjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\nSome sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n\nInput Format\nThe first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\nThe following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n\nOutput Format\nOutput a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n\nSample \ncountRemainingTrees(500,[[150, 300], [301, 450]]) => 200\n", "instruction": "Write a dart function 'int countRemainingTrees(int roadLength, List<List<int>> regions)' to solve the following problem:\nProblem Description\nAdjacent to a school's main gate, there is a road of length $l$ meters, lined with a sequence of trees. The spacing between each pair of adjacent trees is 1 meter. The road can be conceptualized as a numerical axis, with one end at the position 0 on the axis and the other end at position $l$; a tree is planted at every integer point on this axis, i.e., at $0,1,2,\\dots,l$.\nSome sections of this road are designated for subway construction. These sections are defined by their starting and ending points on the numerical axis. It is known that the coordinates of any section's starting and ending points are integers, and there may be overlaps between sections. The current task involves removing the trees within these sections, including the trees located at the endpoints of each section. Your objective is to calculate the number of trees remaining on the road after these trees have been removed.\n\nInput Format\nThe first line contains two integers, representing respectively the length of the road $l$ and the number of sections $m$.\nThe following $m$ lines each contain two integers $u, v$, representing the coordinates of a section's starting and ending points.\n\nOutput Format\nOutput a single integer on one line, representing the number of trees remaining on the road after the specified trees have been removed.\n\nSample \ncountRemainingTrees(500,[[150, 300], [301, 450]]) => 200\n", "level": "middle"}
{"task_id": "Dart/26", "prompt": "int getMaxValue(int T, int M, List<List<int>> herbs)\n\n/*\nbinbin is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes binbin to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\nIf you were binbin, could you complete this task?\n\nInput Format\n\nThe first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n\nThe next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n\nOutput Format\n\nOutput the maximum total value of the herbs that can be collected within the allotted time.\n\nexample\ngetMaxValue(70, 3, [[71, 100], [69, 1], [1, 2]]) => 3\n\n*/", "canonical_solution": "{\n  List<int> dp = List.filled(T + 1, 0); // dp[i] represents the maximum value within time i\n\n  for (int i = 0; i < M; i++) {\n    int time = herbs[i][0];\n    int value = herbs[i][1];\n    for (int j = T; j >= time; j--) {\n      dp[j] = dp[j].compareTo(dp[j - time] + value) > 0 ? dp[j] : dp[j - time] + value;\n    }\n  }\n\n  return dp[T];\n}", "test": "void testGetMaxValue() {\n  // Test Case 1: Provided example\n  assert(getMaxValue(70, 3, [\n    [71, 100],\n    [69, 1],\n    [1, 2]\n  ]) == 3);\n\n  // Test Case 2: Multiple herbs can be collected, no single herb takes all time\n  assert(getMaxValue(10, 4, [\n    [1, 10],\n    [2, 15],\n    [3, 20],\n    [4, 30]\n  ]) == 75); // Best option: collect all herbs\n\n  // Test Case 3: Only one herb can be collected due to time constraint\n  assert(getMaxValue(5, 3, [\n    [5, 50],\n    [4, 40],\n    [3, 30]\n  ]) == 50); // Best option: collect the herb worth 50\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testGetMaxValue();\n}", "entry_point": "getMaxValue", "signature": "int getMaxValue(int T, int M, List<List<int>> herbs)", "docstring": "\nbinbin is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes binbin to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\nIf you were binbin, could you complete this task?\n\nInput Format\n\nThe first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n\nThe next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n\nOutput Format\n\nOutput the maximum total value of the herbs that can be collected within the allotted time.\n\nexample\ngetMaxValue(70, 3, [[71, 100], [69, 1], [1, 2]]) => 3\n\n", "instruction": "Write a dart function 'int getMaxValue(int T, int M, List<List<int>> herbs)' to solve the following problem:\n\nbinbin is a child of exceptional talent, aspiring to become the world's greatest physician. To achieve this, he wishes to apprentice himself to the most prestigious physician nearby. To assess his potential, the physician presents him with a challenging task. He takes binbin to a cave filled with various herbs and says, \"Child, this cave contains several different herbs, each requiring some time to collect and each possessing its own value. I will give you a certain amount of time, within which you may collect some herbs. If you are a clever child, you should be able to maximize the total value of the herbs you collect.\"\nIf you were binbin, could you complete this task?\n\nInput Format\n\nThe first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le  M \\le 100$), separated by a space, where $T$ represents the total time available for collecting herbs, and $M$ represents the number of herbs in the cave.\n\nThe next $M$ lines each include two integers between $1$ and $100$ (inclusive), representing the time required to collect a particular herb and the value of that herb, respectively.\n\nOutput Format\n\nOutput the maximum total value of the herbs that can be collected within the allotted time.\n\nexample\ngetMaxValue(70, 3, [[71, 100], [69, 1], [1, 2]]) => 3\n\n", "level": "easy"}
{"task_id": "Dart/27", "prompt": "int minRemainingSpace(int V, List<int> volumes)\n/*There is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n\nNow, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n\nInput Format\n\nThe first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n\nOutput Format\n\n- A single line containing one integer, indicating the minimum remaining space in the box.\n\nexample\nminRemainingSpace(30,[10,14,20]) => 0\n*/", "canonical_solution": "{\n  List<int> dp = List.filled(V + 1, V);\n  dp[0] = 0;\n  for (int i = 0; i < volumes.length; i++) {\n    for (int j = V; j >= volumes[i]; j--) {\n      dp[j] = dp[j] < dp[j - volumes[i]] + volumes[i] ? dp[j] : dp[j - volumes[i]] + volumes[i];\n    }\n  }\n  print(V - dp[V]);\n  return V - dp[V];\n}", "test": "void testMinRemainingSpace() {\n  assert(minRemainingSpace(24, [8, 3, 12, 7, 9, 7]) == 0);\n  assert(minRemainingSpace(10, [5, 3, 2, 4]) == 0);\n  assert(minRemainingSpace(30, [10, 14, 20]) == 0);\n\n  print(\"All test cases passed successfully.\");\n}\n\nvoid main() {\n  testMinRemainingSpace();\n}", "entry_point": "minRemainingSpace", "signature": "int minRemainingSpace(int V, List<int> volumes)", "docstring": "There is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n\nNow, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n\nInput Format\n\nThe first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n\nOutput Format\n\n- A single line containing one integer, indicating the minimum remaining space in the box.\n\nexample\nminRemainingSpace(30,[10,14,20]) => 0\n", "instruction": "Write a dart function 'int minRemainingSpace(int V, List<int> volumes)' to solve the following problem:\nThere is a box with a capacity of $V$, and there are $n$ items, each with a volume.\n\nNow, from these $n$ items, any number of items can be selected for packing into the box (including the option of not selecting any), with the objective of minimizing the remaining space in the box. Output this minimum value.\n\nInput Format\n\nThe first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe following $n$ lines each contain a positive integer, indicating the volume of the $i^{th}$ item.\n\nOutput Format\n\n- A single line containing one integer, indicating the minimum remaining space in the box.\n\nexample\nminRemainingSpace(30,[10,14,20]) => 0\n", "level": "easy"}
{"task_id": "Dart/28", "prompt": "String decipher(String encryptedMessage, String originalMessage, String toTranslate)\n/*The countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n\n1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n\nFor instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n\nNow, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n\n1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n\nInput Format\n\nThere are three lines in total, each being a string of length between $1$ and $100$.\nThe first line is an encrypted message obtained by C;\nThe second line is the original message corresponding to the encrypted message in the first line;\nThe third line is the encrypted message that the command headquarters of R asks C to translate.\n\nOutput Format\n\nA single line.\nIf decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\nOtherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n\nexample\ndecipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"QWERTY\")  return \"ABCDEF\"\n*/", "canonical_solution": "{\n  Map<String, String> codeMap = {};\n  Set<String> used = Set();\n  for (int i = 0; i < encryptedMessage.length; i++) {\n    String encryptedChar = encryptedMessage[i];\n    String originalChar = originalMessage[i];\n    if (codeMap.containsKey(encryptedChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    if (used.contains(originalChar) && codeMap[encryptedChar] != originalChar) {\n      return 'Failed';\n    }\n    codeMap[encryptedChar] = originalChar;\n    used.add(originalChar);\n  }\n  if (used.length < 26) {\n    return 'Failed';\n  }\n  String result = '';\n  for (int i = 0; i < toTranslate.length; i++) {\n    String charToTranslate = toTranslate[i];\n    if (!codeMap.containsKey(charToTranslate)) {\n      return 'Failed';\n    }\n    result += codeMap[charToTranslate]!;\n  }\n  print(result);\n  return result;\n}", "test": "void testDecipher() {\n    // Test case with all letters mapped to themselves except the given ones are translated\n  assert(decipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"QWERTY\") == \"ABCDEF\");\n  assert(decipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"HELLO\") == \"NCKKI\");\n  assert(decipher(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\");\n}\n\nvoid main() {\n  testDecipher();\n}", "entry_point": "decipher", "signature": "String decipher(String encryptedMessage, String originalMessage, String toTranslate)", "docstring": "The countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n\n1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n\nFor instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n\nNow, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n\n1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n\nInput Format\n\nThere are three lines in total, each being a string of length between $1$ and $100$.\nThe first line is an encrypted message obtained by C;\nThe second line is the original message corresponding to the encrypted message in the first line;\nThe third line is the encrypted message that the command headquarters of R asks C to translate.\n\nOutput Format\n\nA single line.\nIf decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\nOtherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n\nexample\ndecipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"QWERTY\")  return \"ABCDEF\"\n", "instruction": "Write a dart function 'String decipher(String encryptedMessage, String originalMessage, String toTranslate)' to solve the following problem:\nThe countries of R and S are embroiled in war, with both sides dispatching spies to infiltrate the other, lying in wait for the opportunity to act. After enduring numerous hardships, spy C from R, who had been lurking in S, finally deciphered the encoding rules of S's military cipher:\n\n1. The original messages intended for internal transmission within the military of S are encrypted before being sent over the network. Both the content of the original messages and the encrypted output consist solely of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (excluding spaces and other characters);\n2. S has designated a specific cipher letter for each letter. The encryption process involves replacing every letter in the original message with its corresponding cipher letter;\n3. Each letter corresponds to one unique cipher letter, and different letters correspond to different cipher letters. The cipher letter can be the same as the original letter.\n\nFor instance, if $\\tt A$'s cipher letter is designated as $\\tt A$, and $\\tt B$'s as $\\tt C$ (other letters and ciphers omitted), then the original message $\\tt ABA$ is encrypted to $\\tt ACA$.\n\nNow, spy C has obtained one encrypted message sent over the network of S and its corresponding original message through an inside source. C hopes to use this information to crack S's military cipher. C's decryption process is as follows: scanning the original message, for the letter $x$ (representing any uppercase letter) in the original message, find its corresponding uppercase letter $y$ in the encrypted message, and consider $y$ as the cipher letter for $x$. This process continues until it stops at one of the following situations:\n\n1. All information has been scanned, and all 26 letters from $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the original message and have been assigned corresponding cipher letters;\n2. All information has been scanned, but it is found that some letter(s) did not appear in the original message;\n3. During scanning, it is discovered that the information in hand contains obvious contradictions or errors (violating the encoding rules of S's cipher).\n\nInput Format\n\nThere are three lines in total, each being a string of length between $1$ and $100$.\nThe first line is an encrypted message obtained by C;\nThe second line is the original message corresponding to the encrypted message in the first line;\nThe third line is the encrypted message that the command headquarters of R asks C to translate.\n\nOutput Format\n\nA single line.\nIf decryption stops due to situations $2$ or $3$, output $\\tt Failed$;\nOtherwise, output the original message obtained by translating the encrypted message in the telegram using the deciphered cipher.\n\nexample\ndecipher(\"QWERTYUIOPLKJHGFDSAZXCVBNM\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"QWERTY\")  return \"ABCDEF\"\n", "level": "hard"}
{"task_id": "Dart/29", "prompt": "int countArrangements(int n, int m, List<int> a)\n/*Upon the grand opening of xl's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, xl has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\nThe task is to compute the total number of distinct flower arranging schemes.\n\nInput Format\nThe first line contains two positive integers $n$ and $m$, separated by a space.\nThe second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n\nOutput Format\nOutput a single integer, representing the number of schemes. \n\nexample\ncountArrangements(1,2,[2]) => 2\n*/", "canonical_solution": "{\n  const int mod = 1000007;\n  List<List<int>> dp = List.generate(n + 1, (_) => List.generate(m + 1, (_) => 0));\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= m; j++) {\n      for (int k = 0; k <= a[i - 1] && k <= j; k++) {\n        dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod;\n      }\n    }\n  }\n  return dp[n][m];\n}", "test": "void testCountWays() {\n  // Test case 1: Simple case\n  assert(countArrangements(1, 2, [2]) == 1);\n\n  // Test case 2: Two types, more combinations\n  assert(countArrangements(2, 2, [1, 1]) == 1);\n\n  // Test case 3: More complicated case\n  assert(countArrangements(3, 3, [1, 2, 3]) == 6);\n}\n\nvoid main() {\n  testCountWays();\n}", "entry_point": "countArrangements", "signature": "int countArrangements(int n, int m, List<int> a)", "docstring": "Upon the grand opening of xl's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, xl has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\nThe task is to compute the total number of distinct flower arranging schemes.\n\nInput Format\nThe first line contains two positive integers $n$ and $m$, separated by a space.\nThe second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n\nOutput Format\nOutput a single integer, representing the number of schemes. \n\nexample\ncountArrangements(1,2,[2]) => 2\n", "instruction": "Write a dart function 'int countArrangements(int n, int m, List<int> a)' to solve the following problem:\nUpon the grand opening of xl's flower shop, aiming to attract customers, he plans to arrange a row of flowers, totaling $m$ pots, at the entrance of his shop. Through surveying customer preferences, xl has identified the $n$ most favored types of flowers by customers, numbered from $1$ to $n$. To display a greater variety of flowers at the entrance, it is stipulated that the $i$-th type of flower cannot exceed $a_i$ pots, and when arranging, the same type of flower should be placed together, with different types of flowers arranged in ascending order of their numbers.\nThe task is to compute the total number of distinct flower arranging schemes.\n\nInput Format\nThe first line contains two positive integers $n$ and $m$, separated by a space.\nThe second line contains $n$ integers, separated by spaces, sequentially representing $a_1, a_2, \\cdots, a_n$.\n\nOutput Format\nOutput a single integer, representing the number of schemes. \n\nexample\ncountArrangements(1,2,[2]) => 2\n", "level": "easy"}
{"task_id": "Dart/30", "prompt": "int modInverse(int a, int b)\n/*\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\nInput Format\nA single line containing two integers $a, b$, separated by a space.\n\nOutput Format\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\nexample\nmodInverse(3, 10) => 7\n*/", "canonical_solution": "{\n  int b0 = b, t, q;\n  int x0 = 0, x1 = 1;\n  if (b == 1) return 1;\n  while (a > 1) {\n    q = a ~/ b;\n    t = b;\n    b = a % b;\n    a = t;\n    t = x0;\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n  if (x1 < 0) x1 += b0;\n  return x1;\n}", "test": "void testModInverse() {\n  assert(modInverse(3, 10) == 7);\n  assert(modInverse(25, 28) == 9);\n  assert(modInverse(4, 7) == 2);\n}\n\nvoid main() {\n  testModInverse();\n}", "entry_point": "modInverse", "signature": "int modInverse(int a, int b)", "docstring": "\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\nInput Format\nA single line containing two integers $a, b$, separated by a space.\n\nOutput Format\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\nexample\nmodInverse(3, 10) => 7\n", "instruction": "Write a dart function 'int modInverse(int a, int b)' to solve the following problem:\n\nDetermine the smallest positive integer solution for the congruence equation $ax \\equiv 1 \\pmod{b}$ with respect to $x$.\n\nInput Format\nA single line containing two integers $a, b$, separated by a space.\n\nOutput Format\nA single integer $x_0$, representing the smallest positive integer solution. It is guaranteed that a solution exists.\n\nexample\nmodInverse(3, 10) => 7\n", "level": "easy"}
{"task_id": "Dart/31", "prompt": "int findMostUnhappyDay(List<List<int>> schedule)\n/**\nxx has entered junior high school. Her mother believes that xx should be more dedicated to her studies; therefore, aside from attending school, xx is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if xx's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming xx's discontent arises from no other cause and does not carry over to the next day, please help check xx's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time xx spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\nexample\nfindMostUnhappyDay([[5, 3],[6, 2],[7, 2],[5, 3],[5, 4],[0, 4], [0, 6]]) => 3\n*/", "canonical_solution": "{\n  int mostUnhappyDay = 0;\n  int maxUnhappiness = 0;\n  for (int i = 0; i < 7; i++) {\n    int schoolTime = schedule[i][0], extraClassTime = schedule[i][1];\n    int totalStudyTime = schoolTime + extraClassTime;\n    if (totalStudyTime > 8 && totalStudyTime > maxUnhappiness) {\n      maxUnhappiness = totalStudyTime;\n      mostUnhappyDay = i + 1; // Adjusting index to match days (1-7)\n    }\n  }\n  return mostUnhappyDay;\n}", "test": "void testFindMostUnhappyDay() {\n  // Test case 1\n  assert(findMostUnhappyDay([\n    [5, 3],\n    [6, 2],\n    [7, 2],\n    [5, 3],\n    [5, 4],\n    [0, 4],\n    [0, 6]\n  ]) == 3);\n\n  // Test case 2\n  assert(findMostUnhappyDay([\n    [2, 3],\n    [1, 2],\n    [2, 2],\n    [3, 5],\n    [6, 2],\n    [5, 3],\n    [4, 4]\n  ]) == 0);\n\n  // Test case 3\n  assert(findMostUnhappyDay([\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1, 7],\n    [8, 1]\n  ]) == 7);\n}\n\nvoid main() {\n  testFindMostUnhappyDay();\n}", "entry_point": "findMostUnhappyDay", "signature": "int findMostUnhappyDay(List<List<int>> schedule)", "docstring": "*\nxx has entered junior high school. Her mother believes that xx should be more dedicated to her studies; therefore, aside from attending school, xx is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if xx's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming xx's discontent arises from no other cause and does not carry over to the next day, please help check xx's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time xx spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\nexample\nfindMostUnhappyDay([[5, 3],[6, 2],[7, 2],[5, 3],[5, 4],[0, 4], [0, 6]]) => 3\n", "instruction": "Write a dart function 'int findMostUnhappyDay(List<List<int>> schedule)' to solve the following problem:\n*\nxx has entered junior high school. Her mother believes that xx should be more dedicated to her studies; therefore, aside from attending school, xx is also enrolled in various subject review classes by her mother. Moreover, her mother sends her to learn recitation, dance, and piano every week. However, if xx's daily class duration exceeds eight hours, she becomes unhappy, and the longer the duration, the more her discontent grows. Assuming xx's discontent arises from no other cause and does not carry over to the next day, please help check xx's schedule for the coming week to determine whether she will be unhappy; if so, identify the day she will be most discontent.\n\n## Input Format\n\nThe input consists of $7$ lines of data, representing the schedule from Monday to Sunday. Each line includes two non-negative integers less than $10$, separated by a space, representing the time xx spends in school and the time arranged by her mother for classes, respectively.\n\n## Output Format\n\nA single digit. Output $0$ if she will not be discontent; otherwise, output the day of the week she will be most discontent (with $1, 2, 3, 4, 5, 6, 7$ representing Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If the degree of discontent is equivalent on two or more days, output the earliest day.\n\nexample\nfindMostUnhappyDay([[5, 3],[6, 2],[7, 2],[5, 3],[5, 4],[0, 4], [0, 6]]) => 3\n", "level": "easy"}
{"task_id": "Dart/32", "prompt": "List<int> calculateNewDigits(int N, int M, List<int> digits)\n/**\nA Martian demonstrated their counting technique using a human hand. If the five fingers\u2014thumb, index finger, middle finger, ring finger, and little finger\u2014are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\nA Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\nThere are three lines in total.  \nThe first line contains a positive integer $N$, indicating the number of Martian fingers \nThe second line contains a positive integer $M$, representing the small integer to be added \nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\nexample:\ncalculateNewDigits(3, 123, [1, 2, 3]).join() => '246'\n*/", "canonical_solution": " {\n  int originalNumber = digits.reduce((a, b) => a * 10 + b);\n  int newNumber = originalNumber + M;\n  List<int> newDigits = [];\n\n  while (newNumber > 0) {\n    newDigits.insert(0, newNumber % 10);\n    newNumber ~/= 10;\n  }\n\n  return newDigits;\n}", "test": "void testCalculateNewDigits() {\n  assert(calculateNewDigits(3, 123, [1, 2, 3]).join() == '246');\n  assert(calculateNewDigits(4, 0, [1, 0, 0, 0]).join() == '1000');\n  assert(calculateNewDigits(2, 99, [3, 1]).join() == '130');\n\n  print('All tests passed!');\n}\n\n\nvoid main() {\n  testCalculateNewDigits();\n}", "entry_point": "calculateNewDigits", "signature": "List<int> calculateNewDigits(int N, int M, List<int> digits)", "docstring": "*\nA Martian demonstrated their counting technique using a human hand. If the five fingers\u2014thumb, index finger, middle finger, ring finger, and little finger\u2014are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\nA Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\nThere are three lines in total.  \nThe first line contains a positive integer $N$, indicating the number of Martian fingers \nThe second line contains a positive integer $M$, representing the small integer to be added \nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\nexample:\ncalculateNewDigits(3, 123, [1, 2, 3]).join() => '246'\n", "instruction": "Write a dart function 'List<int> calculateNewDigits(int N, int M, List<int> digits)' to solve the following problem:\n*\nA Martian demonstrated their counting technique using a human hand. If the five fingers\u2014thumb, index finger, middle finger, ring finger, and little finger\u2014are numbered $1,2,3,4$, and $5$ respectively, they form the $5$-digit number $12345$ when arranged in the typical order. Swapping the positions of the ring and little fingers results in the $5$-digit number $12354$. Completely reversing the order of the five fingers yields $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest, representing $2$; $54321$ is the largest, representing $120$. The following table displays the $6$ possible $3$-digit numbers that can be formed with just $3$ fingers and the numerals they represent:\n\n| Ternary Number | Represented Digit |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\nA Martian will show you their fingers, and the scientists will inform you of the small number to be added. Your task is to add the number represented by the Martian's fingers to the number given by the scientists and rearrange the Martian fingers according to the sum. The input data guarantees that the result will not exceed the range representable by Martian fingers.\n\n## Input Format\nThere are three lines in total.  \nThe first line contains a positive integer $N$, indicating the number of Martian fingers \nThe second line contains a positive integer $M$, representing the small integer to be added \nThe next line is a permutation of the integers from $1$ to $N$, separated by spaces, indicating the order of the Martian fingers.\n\n## Output Format\n$N$ integers, representing the rearranged order of Martian fingers after the change. Each pair of adjacent numbers is separated by a space, with no superfluous spaces allowed.\n\nexample:\ncalculateNewDigits(3, 123, [1, 2, 3]).join() => '246'\n", "level": "easy"}
{"task_id": "Dart/33", "prompt": "int calculateSavings(List<int> budgets)\n/*\nBB has always managed her pocket money by herself. At the beginning of each month, her mother gives BB 300 yuan, from which BB budgets her monthly expenses and consistently matches her actual expenses with her budget.\nTo teach BB how to save money, her mother proposed that BB could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to BB with an additional 20% interest. Therefore, BB devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\nBB realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money BB has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, BB will have to economize and cut back on her budget for that month.\nNow, according to BB's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money BB will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, representing BB's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money BB will have at the end of 2004.\n\n## example\ncalculateSavings([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]) => -7\n*/", "canonical_solution": "{\n  int savings = 0;\n  int balance = 0;\n  for (int month = 1; month <= budgets.length; month++) {\n    int budget = budgets[month - 1];\n    balance += 300 - budget;\n    if (balance < 0) {\n      return -month;\n    }\n    savings += (balance ~/ 100) * 100;\n    balance %= 100;\n  }\n  return (savings * 1.2).toInt() + balance;\n}", "test": "void main() {\n  assert(calculateSavings([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]) == -7);\n  assert(calculateSavings([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]) == 1580);\n  assert(calculateSavings([300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]) == 0);\n}", "entry_point": "calculateSavings", "signature": "int calculateSavings(List<int> budgets)", "docstring": "\nBB has always managed her pocket money by herself. At the beginning of each month, her mother gives BB 300 yuan, from which BB budgets her monthly expenses and consistently matches her actual expenses with her budget.\nTo teach BB how to save money, her mother proposed that BB could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to BB with an additional 20% interest. Therefore, BB devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\nBB realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money BB has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, BB will have to economize and cut back on her budget for that month.\nNow, according to BB's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money BB will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, representing BB's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money BB will have at the end of 2004.\n\n## example\ncalculateSavings([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]) => -7\n", "instruction": "Write a dart function 'int calculateSavings(List<int> budgets)' to solve the following problem:\n\nBB has always managed her pocket money by herself. At the beginning of each month, her mother gives BB 300 yuan, from which BB budgets her monthly expenses and consistently matches her actual expenses with her budget.\nTo teach BB how to save money, her mother proposed that BB could deposit any whole hundreds of yuan with her at any time, and at the end of the year, she would return the money to BB with an additional 20% interest. Therefore, BB devised a savings plan: at the beginning of each month, after receiving her pocket money from her mother, if she anticipates having more than 100 yuan or exactly 100 yuan left at the end of the month, she would deposit the whole hundreds with her mother and keep the remainder with herself.\nBB realized that the main risk of this savings plan is that the money deposited with her mother cannot be withdrawn before the end of the year. It is possible that at the beginning of some month, the money BB has plus the money given by her mother for that month is not enough for the month's budget. If this situation arises, BB will have to economize and cut back on her budget for that month.\nNow, according to BB's budget from January to December 2004, determine whether this situation will occur. If not, calculate how much money BB will have at the end of 2004 after her mother returns her savings with an additional 20% interest.\n\n## Input Format\n\n12 lines of data, representing BB's budget from January to December.\n\n## Output Format\n\nA single integer. If there is a month during the implementation of the savings plan where the money is insufficient, output -X, where X indicates the first month when this situation occurs; otherwise, output how much money BB will have at the end of 2004.\n\n## example\ncalculateSavings([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]) => -7\n", "level": "easy"}
{"task_id": "Dart/34", "prompt": "int minEnergy(List<int> weights)\n/*\nWithin an orchard, BB has harvested all the fruits and sorted them into different piles according to their varieties. BB has decided to merge all the fruits into a single pile.\n\nEach merge allows BB to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by BB in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nAssuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes BB's energy expenditure and output this minimum value.\nue.\n\n## Input Format\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample\nminEnergy([1, 2, 9]) => 15\n*/", "canonical_solution": "{\n  int energy = 0;\n  weights.sort();\n  while (weights.length > 1) {\n    int first = weights.removeAt(0);\n    int second = weights.removeAt(0);\n    int mergedWeight = first + second;\n    energy += mergedWeight;\n    weights.add(mergedWeight);\n    weights.sort();\n  }\n  return energy;\n}", "test": "void testMinEnergy() {\n  assert(minEnergy([1, 2, 9]) == 15);\n  assert(minEnergy([1, 2, 3, 4]) == 19);\n  assert(minEnergy([10]) == 0);\n}\n\nvoid main() {\n  testMinEnergy();\n}", "entry_point": "minEnergy", "signature": "int minEnergy(List<int> weights)", "docstring": "\nWithin an orchard, BB has harvested all the fruits and sorted them into different piles according to their varieties. BB has decided to merge all the fruits into a single pile.\n\nEach merge allows BB to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by BB in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nAssuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes BB's energy expenditure and output this minimum value.\nue.\n\n## Input Format\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample\nminEnergy([1, 2, 9]) => 15\n", "instruction": "Write a dart function 'int minEnergy(List<int> weights)' to solve the following problem:\n\nWithin an orchard, BB has harvested all the fruits and sorted them into different piles according to their varieties. BB has decided to merge all the fruits into a single pile.\n\nEach merge allows BB to combine two piles of fruits together, with the expenditure of physical energy equivalent to the sum of the weights of the two piles. It is evident that after $n-1$ merges, there will remain only one pile. The total amount of energy expended by BB in merging the fruits is equal to the sum of the energy consumed in each merge.\n\nAssuming that each fruit weighs $1$ and knowing the number of fruit varieties and the quantity of each variety, your task is to devise a merging strategy that minimizes BB's energy expenditure and output this minimum value.\nue.\n\n## Input Format\nThe second line contains $n$ integers, separated by spaces, where the $i$-th integer $a_i$ represents the quantity of the $i$-th variety of fruit.\n\n## Output Format\n\nA single integer, which is the minimum value of the energy expenditure. The input data guarantees that this value is less than $2^{31}$.\n\n## Sample\nminEnergy([1, 2, 9]) => 15\n", "level": "easy"}
{"task_id": "Dart/35", "prompt": "List<List<int>> choirFormation(List<List<int>> grades)\n/*\nSort students based on their total scores from three subjects (Chinese, Mathematics, and English). \nIf students have the same total score, sort by their Chinese grade. If they also have the same Chinese grade, \nsort by their student number. Return the top 5 students' numbers and their total scores.\n\n## Input Format\n\nThe input is a list of lists where each sublist contains three integers representing the grades for Chinese, Mathematics, and English.\n\n## Output Format\n\nThe output is a list of 5 sublists, each containing two integers: the student number (1-based) and the total score.\n\n## Example\n\n>>> choirFormation([[90,67,80],[87,66,91],[78,89,91],[88,99,77],[67,89,64],[78,89,98]]) => [[6,265],[4,264],[3,258],[2,244],[1,237]]\n*/", "canonical_solution": "{\n  List<List<int>> students = [];\n  for (int i = 0; i < grades.length; i++) {\n    int totalScore = grades[i][0] + grades[i][1] + grades[i][2];\n    students.add([i + 1, totalScore, grades[i][0]]); // Student number, total score, Chinese grade\n  }\n\n  students.sort((a, b) {\n    if (b[1] != a[1]) {\n      return b[1] - a[1]; // Sort by total score in descending order\n    } else if (b[2] != a[2]) {\n      return b[2] - a[2]; // Sort by Chinese grade in descending order\n    } else {\n      return a[0] - b[0]; // Sort by student number in ascending order\n    }\n  });\n\n  return students.take(5).map((student) => [student[0], student[1]]).toList();\n}", "test": "void main() {\n  testChoirFormation();\n}\n\nvoid testChoirFormation() {\n  assert(\n    choirFormation([\n      [90,67,80], \n      [87,66,91], \n      [78,89,91], \n      [88,99,77], \n      [67,89,64], \n      [78,89,98]\n    ]).toString() == \n    [[6,265],[4,264],[3,258],[2,244],[1,237]].toString()\n  );\n\n  assert(\n    choirFormation([\n      [70, 60, 80], \n      [80, 70, 60], \n      [60, 70, 80], \n      [70, 80, 90], \n      [50, 50, 50], \n      [100, 100, 100]\n    ]).toString() == \n    [[6, 300], [4, 240], [2, 210], [1, 210], [3, 210]].toString()\n  );\n\n  assert(\n    choirFormation([\n      [80, 80, 80], \n      [80, 80, 80], \n      [80, 80, 80], \n      [80, 80, 80], \n      [80, 80, 80], \n      [80, 80, 80]\n    ]).toString() == \n    [[1, 240], [2, 240], [3, 240], [4, 240], [5, 240]].toString()\n  );\n}", "entry_point": "choirFormation", "signature": "List<List<int>> choirFormation(List<List<int>> grades)", "docstring": "\nSort students based on their total scores from three subjects (Chinese, Mathematics, and English). \nIf students have the same total score, sort by their Chinese grade. If they also have the same Chinese grade, \nsort by their student number. Return the top 5 students' numbers and their total scores.\n\n## Input Format\n\nThe input is a list of lists where each sublist contains three integers representing the grades for Chinese, Mathematics, and English.\n\n## Output Format\n\nThe output is a list of 5 sublists, each containing two integers: the student number (1-based) and the total score.\n\n## Example\n\n>>> choirFormation([[90,67,80],[87,66,91],[78,89,91],[88,99,77],[67,89,64],[78,89,98]]) => [[6,265],[4,264],[3,258],[2,244],[1,237]]\n", "instruction": "Write a dart function 'List<List<int>> choirFormation(List<List<int>> grades)' to solve the following problem:\n\nSort students based on their total scores from three subjects (Chinese, Mathematics, and English). \nIf students have the same total score, sort by their Chinese grade. If they also have the same Chinese grade, \nsort by their student number. Return the top 5 students' numbers and their total scores.\n\n## Input Format\n\nThe input is a list of lists where each sublist contains three integers representing the grades for Chinese, Mathematics, and English.\n\n## Output Format\n\nThe output is a list of 5 sublists, each containing two integers: the student number (1-based) and the total score.\n\n## Example\n\n>>> choirFormation([[90,67,80],[87,66,91],[78,89,91],[88,99,77],[67,89,64],[78,89,98]]) => [[6,265],[4,264],[3,258],[2,244],[1,237]]\n", "level": "middle"}
{"task_id": "Dart/36", "prompt": "int minimumGroups(List<int> gifts, int limit)\n/*\nthe school's student council has assigned BB the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, BB must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, BB hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+1$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nLines $2$ to $n+1$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\nminimumGroups([90, 20, 20, 30, 50, 60, 70, 80, 90], 100) => 6\n*/", "canonical_solution": " {\n  gifts.sort();\n  int i = 0, j = gifts.length - 1, groups = 0;\n  while (i <= j) {\n    if (gifts[i] + gifts[j] <= limit) i++;\n    j--;\n    groups++;\n  }\n  return groups;\n}", "test": "void testMinimumGroups() {\n  assert(minimumGroups([90, 20, 20, 30, 50, 60, 70, 80, 90], 100) == 6);\n  assert(minimumGroups([10, 20, 30, 40, 50, 60, 70, 80, 90], 150) == 5);\n  assert(minimumGroups([30, 30, 50, 60, 70], 100) == 3);\n}\n\nvoid main() {\n  testMinimumGroups();\n}", "entry_point": "minimumGroups", "signature": "int minimumGroups(List<int> gifts, int limit)", "docstring": "\nthe school's student council has assigned BB the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, BB must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, BB hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+1$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nLines $2$ to $n+1$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\nminimumGroups([90, 20, 20, 30, 50, 60, 70, 80, 90], 100) => 6\n", "instruction": "Write a dart function 'int minimumGroups(List<int> gifts, int limit)' to solve the following problem:\n\nthe school's student council has assigned BB the task of distributing souvenirs for the New Year's Eve party. To ensure that the value of souvenirs received by the students attending the party is relatively balanced, BB must group the purchased souvenirs by price. However, each group can contain at most two souvenirs, and the total price of the souvenirs in each group must not exceed a given integer. To guarantee that all souvenirs are distributed in the shortest possible time, BB hopes to minimize the number of groups.\n\nYour task is to write a program that finds the least number of groups among all possible grouping schemes and outputs this minimum number.\n\n## Input Format\n\nThere are $n+1$ lines in total:\n\nThe first line includes an integer $w$, which is the upper limit for the total price of souvenirs in each group.\n\nLines $2$ to $n+1$ each contain a positive integer $P_i$ representing the price of the corresponding souvenir.\n\n## Output Format\n\nA single integer, which is the minimum number of groups.\n\n## Sample #1\n\nminimumGroups([90, 20, 20, 30, 50, 60, 70, 80, 90], 100) => 6\n", "level": "easy"}
{"task_id": "Dart/37", "prompt": "int hanoiTwinTowers(int n)\n/*\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\nhanoiTwinTowers(1) => 2\n*/", "canonical_solution": "{\n  List<int> dp = List<int>.filled(n + 1, 0);\n  dp[1] = 2;\n  for (int i = 2; i <= n; i++) {\n    dp[i] = 3 * dp[i - 1] + 2;\n  }\n  return dp[n];\n}", "test": "void testHanoiTwinTowers() {\n  assert(hanoiTwinTowers(1) == 2);\n  assert(hanoiTwinTowers(2) == 8);\n  assert(hanoiTwinTowers(3) == 26);\n}\n\nvoid main() {\n  testHanoiTwinTowers();\n}", "entry_point": "hanoiTwinTowers", "signature": "int hanoiTwinTowers(int n)", "docstring": "\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\nhanoiTwinTowers(1) => 2\n", "instruction": "Write a dart function 'int hanoiTwinTowers(int n)' to solve the following problem:\n\nGiven three sufficiently long thin rods named A, B, and C, there are $2n$ circular discs with holes in the middle placed on rod A. There are $n$ distinct sizes, with two identical discs for each size; note that these two discs are indistinguishable from each other\n\nThe task is to transfer these discs to rod C, with the possibility of temporarily storing them on rod B during the process. The requirements are as follows:\n\n1. Only one disc can be moved at a time;\n2. The discs on rods A, B, and C must always maintain an order with smaller discs on top of larger ones.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the above task for $2n$ discs. For the given input $n$, output $A_n$.\n\n## Input Format\n\nA positive integer $n$, indicating there are $2n$ circular discs placed on rod A.\n\n## Output Format\n\nA positive integer, which is the minimum number of moves required to complete the task $A_n$.\n\n## Sample #1\nhanoiTwinTowers(1) => 2\n", "level": "easy"}
{"task_id": "Dart/38", "prompt": "String expandString(String input, int p1, int p2, int p3)\n/*\nWe provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\nexpandString(\"abcs-w1234-9s-4zz\", 1, 2, 1) => \"abcsttuuvvw1234556677889s-4zz\"\n*/", "canonical_solution": "{\n  // Helper function to expand a given range.\n  String expandRange(String start, String end, int p1, int p2, int p3) {\n    if (start.codeUnitAt(0) + 1 == end.codeUnitAt(0)) {\n      return \"$start$end\"; // Directly return if end is successor of start.\n    }\n\n    List<int> range = [];\n    for (int i = start.codeUnitAt(0) + 1; i < end.codeUnitAt(0); i++) {\n      for (int j = 0; j < p2; j++) { // Repeat according to p2.\n        range.add(i);\n      }\n    }\n\n    if (p3 == 2) {\n      range = range.reversed.toList(); // Reverse if p3 is 2.\n    }\n\n    return String.fromCharCodes(range.map((i) {\n      if (p1 == 3) return 42; // Return '*' for p1 = 3.\n      if (p1 == 2 && i >= 97 && i <= 122) return i - 32; // Uppercase for letters if p1 = 2.\n      return i; // Default behavior.\n    }));\n  }\n\n  RegExp exp = RegExp(r'([a-z0-9])-([a-z0-9])');\n  return input.replaceAllMapped(exp, (Match m) {\n    String start = m.group(1)!;\n    String end = m.group(2)!;\n\n    // Check if the end character is strictly greater than the start character.\n    if (start.codeUnitAt(0) < end.codeUnitAt(0)) {\n      return start + expandRange(start, end, p1, p2, p3) + end;\n    } else {\n      return m.group(0)!; // Return original if not in correct order.\n    }\n  });\n}", "test": "void main() {\n  // Test case 1: Normal case\n  assert(expandString('abcs-w1234-9s-4zz', 1, 2, 1) == 'abcsttuuvvw1234556677889s-4zz');\n\n  // Test case 2: With numbers, order preserved\n  assert(expandString('3-6', 1, 1, 1) == '3456');\n\n  // Test case 3: Mixed characters, inverse order with stars\n  assert(expandString('a-d-d', 2, 3, 2) == 'aCCCBBBd-d');\n}", "entry_point": "expandString", "signature": "String expandString(String input, int p1, int p2, int p3)", "docstring": "\nWe provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\nexpandString(\"abcs-w1234-9s-4zz\", 1, 2, 1) => \"abcsttuuvvw1234556677889s-4zz\"\n", "instruction": "Write a dart function 'String expandString(String input, int p1, int p2, int p3)' to solve the following problem:\n\nWe provided an example of string expansion: if the input string contains substrings such as `d-h` or `4-8`, we treat it as a kind of abbreviation. During output, continuous increasing letters or number strings replace the dash, i.e., the above two substrings are output respectively as `defgh` and `45678`. In this question, we make the string expansion more flexible by adding some parameter settings. The specific agreements are as follows:\n\n(1) The need for string expansion arises in the following scenario: in the input string, a dash `-` appears, with both sides of the dash being either lowercase letters or numbers, and according to the ASCII code order, the character to the right of the dash is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: Expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In these two cases, the filling method for number substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a number substring, it is filled with asterisks `*` equal in number to the letters that need to be filled.\n\n(3) Parameter $p_2$: The repetition count of the fill character. $p_2=k$ means that the same character should be filled continuously $k$ times. For example, when $p_2=3$, the substring `d-h` should be expanded to `deeefffgggh`. The characters on both sides of the dash remain unchanged.\n\n(4) Parameter $p_3$: Whether to reverse the order: $p_3=1$ means to maintain the original order, $p_3=2$ means to use reverse order output, noting that the characters on both ends of the dash are still not included. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should be expanded to `dggffeeh`.\n\n(5) If the character to the right of the dash is exactly the successor of the character on the left, only the dash in the middle is removed, for example: `d-e` should be output as `de`, `3-4` should be output as `34`. If the character to the right of the dash is less than or equal to the character on the left according to the ASCII code sequence, the dash in the middle should be retained during output, for example: `d-d` should be output as `d-d`, `3-1` should be output as `3-1`.\n\n## Input Format\n\nThere are two lines in total.\n\nThe 1st line contains 3 positive integers separated by spaces, representing parameters $p_1,p_2,p_3$ in sequence.\n\nThe 2nd line is a string composed only of numbers, lowercase letters, and the dash `-`. There is no space at the beginning or at the end of the line.\n\n## Output Format\n\nThere is a single line for output, which is the string after expansion.\n\n## Sample #1\nexpandString(\"abcs-w1234-9s-4zz\", 1, 2, 1) => \"abcsttuuvvw1234556677889s-4zz\"\n", "level": "hard"}
{"task_id": "Dart/39", "prompt": "int swapHighLowBits(int n)\n/*\nGiven a non-negative integer less than $2^{32}$, this number can be represented by a 32-bit binary number (if less than 32 bits, zeros are added to make up the difference). We refer to the first 16 bits of this binary number as the \"high bits\" and the last 16 bits as the \"low bits.\" By swapping the high and low bits, we can obtain a new number. The task is to determine what this new number is in decimal representation.\n\n## Input Format\n\nA non-negative integer less than $2^{32}$.\n\n## Output Format\n\nOutput the new number.\n\n## Sample Case #1\nswapHighLowBits(1314520) => 249036820\n*/", "canonical_solution": "{\n  return ((n & 0xFFFF) << 16) | ((n & 0xFFFF0000) >> 16);\n}", "test": "void testSwapHighLowBits() {\n  assert(swapHighLowBits(1314520) == 249036820);\n  assert(swapHighLowBits(0xFFFFFFFF) == 0xFFFFFFFF);\n  assert(swapHighLowBits(0) == 0);\n}\n\nvoid main() {\n  testSwapHighLowBits();\n}", "entry_point": "swapHighLowBits", "signature": "int swapHighLowBits(int n)", "docstring": "\nGiven a non-negative integer less than $2^{32}$, this number can be represented by a 32-bit binary number (if less than 32 bits, zeros are added to make up the difference). We refer to the first 16 bits of this binary number as the \"high bits\" and the last 16 bits as the \"low bits.\" By swapping the high and low bits, we can obtain a new number. The task is to determine what this new number is in decimal representation.\n\n## Input Format\n\nA non-negative integer less than $2^{32}$.\n\n## Output Format\n\nOutput the new number.\n\n## Sample Case #1\nswapHighLowBits(1314520) => 249036820\n", "instruction": "Write a dart function 'int swapHighLowBits(int n)' to solve the following problem:\n\nGiven a non-negative integer less than $2^{32}$, this number can be represented by a 32-bit binary number (if less than 32 bits, zeros are added to make up the difference). We refer to the first 16 bits of this binary number as the \"high bits\" and the last 16 bits as the \"low bits.\" By swapping the high and low bits, we can obtain a new number. The task is to determine what this new number is in decimal representation.\n\n## Input Format\n\nA non-negative integer less than $2^{32}$.\n\n## Output Format\n\nOutput the new number.\n\n## Sample Case #1\nswapHighLowBits(1314520) => 249036820\n", "level": "easy"}
{"task_id": "Dart/40", "prompt": "int countPairsWithDifference(List<int> numbers, int difference)\n/*\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nnumbers: a list of integers $A_1, A_2, \\ldots, A_N$\ndifference: an integer $C$ \n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\ncountPairsWithDifference([1, 1, 2, 3], 1) => 3\n*/", "canonical_solution": "{\n  Map<int, int> countMap = {};\n  int pairCount = 0;\n\n  for (int number in numbers) {\n    pairCount += countMap[number - difference] ?? 0;\n    countMap[number] = (countMap[number] ?? 0) + 1;\n  }\n  return pairCount;\n}", "test": "void main() {\n  testCountPairsWithDifference();\n}\n\nvoid testCountPairsWithDifference() {\n  assert(countPairsWithDifference([1, 1, 2, 3], 1) == 3);\n  assert(countPairsWithDifference([5, 4, 3, 2, 1], 1) == 0);\n  assert(countPairsWithDifference([10, 2, 9, 4, 8, 3, 7], 5) == 1);\n}", "entry_point": "countPairsWithDifference", "signature": "int countPairsWithDifference(List<int> numbers, int difference)", "docstring": "\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nnumbers: a list of integers $A_1, A_2, \\ldots, A_N$\ndifference: an integer $C$ \n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\ncountPairsWithDifference([1, 1, 2, 3], 1) => 3\n", "instruction": "Write a dart function 'int countPairsWithDifference(List<int> numbers, int difference)' to solve the following problem:\n\nGiven a sequence of positive integers and a positive integer $C$, the task is to calculate the number of pairs that satisfy the equation $A - B = C$ (pairs with identical numbers at different positions are considered distinct).\n\n## Input Format\n\nnumbers: a list of integers $A_1, A_2, \\ldots, A_N$\ndifference: an integer $C$ \n\n## Output Format\n\nA single line indicating the number of pairs within the given sequence of positive integers that satisfy $A - B = C$.\n\n## Sample #1\ncountPairsWithDifference([1, 1, 2, 3], 1) => 3\n", "level": "easy"}
{"task_id": "Dart/41", "prompt": "int minimumUntidiness(List<Book> books, int k)\n\n/*\nBB possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading BB to initially arrange the books in ascending order by height. However, BB discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\nbooks: A list of $n$ books, where each book is represented as a tuple $(h, w)$, where $h$ is the height and $w$ is the width.\nk: An integer representing the number of books to remove.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\nmimimumUntidiness([(1, 2), (2, 4), (3, 1), (5, 3)], 1) => 3\n*/", "canonical_solution": "{\n  books.sort((a, b) => a.height.compareTo(b.height));\n  List<int> prefixSum = List.generate(books.length + 1, (_) => 0);\n\n  for (int i = 1; i < prefixSum.length; i++) {\n    prefixSum[i] = prefixSum[i - 1] + books[i - 1].width;\n  }\n\n  List<List<int>> dp = List.generate(books.length + 1, (_) => List.generate(k + 1, (_) => 0));\n\n  for (int i = 1; i <= books.length; i++) {\n    for (int j = 1; j <= k; j++) {\n      if (j > i) {\n        dp[i][j] = dp[i][j - 1];\n      } else {\n        dp[i][j] = dp[i - 1][j];\n        for (int p = 0; p < i; p++) {\n          dp[i][j] = min(dp[i][j], dp[p][j - 1] + prefixSum[i] - prefixSum[p + 1] - books[p].width);\n        }\n      }\n    }\n  }\n  print(dp[books.length][k]);\n  return dp[books.length][k];\n}\n\nint min(int a, int b) => a < b ? a : b;\n\nclass Book {\n  final int height;\n  final int width;\n  Book(this.height, this.width);\n}", "test": "void main() {\n  testMinimumUntidiness();\n}\n\nvoid testMinimumUntidiness() {\n  assert(minimumUntidiness([\n    Book(1, 2),\n    Book(2, 4),\n    Book(3, 1),\n    Book(5, 3)\n  ], 1) == -4);\n\n  assert(minimumUntidiness([\n    Book(4, 5),\n    Book(1, 2),\n    Book(3, 2),\n    Book(2, 1)\n  ], 2) == -7);\n\n  assert(minimumUntidiness([\n    Book(1, 10),\n    Book(2, 3),\n    Book(3, 7),\n    Book(4, 1),\n    Book(5, 5)\n  ], 3) == -22);\n}", "entry_point": "minimumUntidiness", "signature": "int minimumUntidiness(List<Book> books, int k)", "docstring": "\nBB possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading BB to initially arrange the books in ascending order by height. However, BB discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\nbooks: A list of $n$ books, where each book is represented as a tuple $(h, w)$, where $h$ is the height and $w$ is the width.\nk: An integer representing the number of books to remove.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\nmimimumUntidiness([(1, 2), (2, 4), (3, 1), (5, 3)], 1) => 3\n", "instruction": "Write a dart function 'int minimumUntidiness(List<Book> books, int k)' to solve the following problem:\n\nBB possesses an extensive collection of books and a bookshelf on which he desires to place them. The bookshelf can accommodate the entire collection, leading BB to initially arrange the books in ascending order by height. However, BB discerns that, due to the varying widths of many books, the arrangement still appears untidy. Consequently, he decides to remove $k$ books to potentially achieve a neater appearance.\n\nThe untidiness of the bookshelf is defined as follows: it is the sum of the absolute differences in width between every pair of adjacent books. Consider a set of $4$ books:\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\nUpon arranging the books tidily, the sequence is:\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\nHere, the untidiness is calculated as $2+3+2=7$.\n\nGiven that each book has a unique height, you are tasked with determining the minimum untidiness achievable upon the removal of $k$ books.\n\n## Input Format\nbooks: A list of $n$ books, where each book is represented as a tuple $(h, w)$, where $h$ is the height and $w$ is the width.\nk: An integer representing the number of books to remove.\n\n## Output Format\n\nA single integer on one line, representing the minimum untidiness of the bookshelf.\n\n## Sample #1\nmimimumUntidiness([(1, 2), (2, 4), (3, 1), (5, 3)], 1) => 3\n", "level": "hard"}
{"task_id": "Dart/42", "prompt": "List<String> sortStudentsByBirthday(List<List<String>> inputList)\n/*\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\ninputList is a list of lists, where each inner list contains the name of a student and their birthday in the format of [name, year, month, day].\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\nsortStudentsByBirthday([[\"Yangchu\", \"1992\", \"4\", \"23\"], [\"Qiujingya\", \"1993\", \"10\", \"13\"], [\"Luowen\", \"1991\", \"8\", \"1\"]])\nreturns [\"Luowen\", \"Yangchu\", \"Qiujingya\"]\n*/", "canonical_solution": "{\n  List<Student> students = inputList.map((data) {\n    String name = data[0];\n    int year = int.parse(data[1]);\n    int month = int.parse(data[2]);\n    int day = int.parse(data[3]);\n    return Student(name, DateTime(year, month, day));\n  }).toList();\n\n  students.sort((a, b) {\n    int comp = b.birthday.compareTo(a.birthday);\n    if (comp == 0) return inputList.indexOf([a.name, '${a.birthday.year}', '${a.birthday.month}', '${a.birthday.day}']).compareTo(inputList.indexOf([b.name, '${b.birthday.year}', '${b.birthday.month}', '${b.birthday.day}']));\n    return comp;\n  });\n  return students.map((student) => student.name).toList();\n}\n\nclass Student {\n  String name;\n  DateTime birthday;\n  Student(this.name, this.birthday);\n}", "test": "void main() {\n  testSortStudentsByBirthday();\n}\n\nvoid testSortStudentsByBirthday() {\n  assert(sortStudentsByBirthday([\n    [\"Alice\", \"1990\", \"5\", \"12\"],\n    [\"Bob\", \"1989\", \"1\", \"15\"],\n    [\"Charlie\", \"1990\", \"5\", \"12\"],\n  ]).join(',') == \"Alice,Charlie,Bob\");\n\n  assert(sortStudentsByBirthday([\n    [\"David\", \"1991\", \"3\", \"11\"],\n    [\"Eve\", \"1992\", \"7\", \"30\"],\n    [\"Frank\", \"1991\", \"3\", \"11\"],\n  ]).join(',') == \"Eve,David,Frank\");\n\n  assert(sortStudentsByBirthday([\n    [\"George\", \"1990\", \"4\", \"22\"],\n    [\"Hannah\", \"1992\", \"10\", \"13\"],\n    [\"Ian\", \"1991\", \"8\", \"1\"],\n  ]).join(',') == \"Hannah,Ian,George\");\n}", "entry_point": "sortStudentsByBirthday", "signature": "List<String> sortStudentsByBirthday(List<List<String>> inputList)", "docstring": "\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\ninputList is a list of lists, where each inner list contains the name of a student and their birthday in the format of [name, year, month, day].\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\nsortStudentsByBirthday([[\"Yangchu\", \"1992\", \"4\", \"23\"], [\"Qiujingya\", \"1993\", \"10\", \"13\"], [\"Luowen\", \"1991\", \"8\", \"1\"]])\nreturns [\"Luowen\", \"Yangchu\", \"Qiujingya\"]\n", "instruction": "Write a dart function 'List<String> sortStudentsByBirthday(List<List<String>> inputList)' to solve the following problem:\n\nCJF wishes to survey the birthdays of each student in the school's OI (Olympiad in Informatics) group and sort them in descending order by age. However, CJF is currently overwhelmed with homework and lacks the time, thus your assistance is requested for the sorting task.\n\n## Input Format\n\ninputList is a list of lists, where each inner list contains the name of a student and their birthday in the format of [name, year, month, day].\n\n## Output Format\n\nThe output should consist of $n$ lines,\n\nrepresenting the names of the $n$ students sorted from the oldest to the youngest birthday. (If two students share the same birthday, the one whose information was entered later should be output first.)\n\n## Sample #1\nsortStudentsByBirthday([[\"Yangchu\", \"1992\", \"4\", \"23\"], [\"Qiujingya\", \"1993\", \"10\", \"13\"], [\"Luowen\", \"1991\", \"8\", \"1\"]])\nreturns [\"Luowen\", \"Yangchu\", \"Qiujingya\"]\n", "level": "hard"}
{"task_id": "Dart/43", "prompt": "String removeKDigits(String num, int k)\n\n/*\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nnum: a string representing the high-precision positive integer $N$.\nk: an integer representing the number of digits to be removed.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\nremoveKDigits(\"175438\", 4) => 13\n*/", "canonical_solution": "{\n  List<int> stack = [];\n  for (int i = 0; i < num.length; i++) {\n    int current = num.codeUnitAt(i) - '0'.codeUnitAt(0);\n    while (stack.isNotEmpty && stack.last > current && k > 0) {\n      stack.removeLast();\n      k--;\n    }\n    if (stack.isNotEmpty || current != 0) {\n      stack.add(current);\n    }\n  }\n\n  while (k > 0 && stack.isNotEmpty) {\n    stack.removeLast();\n    k--;\n  }\n\n  if (stack.isEmpty) {\n    return \"0\";\n  }\n\n  return stack.join();\n}", "test": "void main() {\n  testRemoveKDigits();\n}\n\nvoid testRemoveKDigits() {\n  assert(removeKDigits(\"175438\", 4) == \"13\");\n  assert(removeKDigits(\"10200\", 1) == \"200\");\n  assert(removeKDigits(\"1432219\", 3) == \"1219\");\n}", "entry_point": "removeKDigits", "signature": "String removeKDigits(String num, int k)", "docstring": "\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nnum: a string representing the high-precision positive integer $N$.\nk: an integer representing the number of digits to be removed.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\nremoveKDigits(\"175438\", 4) => 13\n", "instruction": "Write a dart function 'String removeKDigits(String num, int k)' to solve the following problem:\n\nThrough keyboard input, a high-precision positive integer $N$ (no more than $250$ digits) is entered. By removing any $k$ digits from it, the remaining digits will form a new non-negative integer, preserving the original left-to-right order. The task is to develop a program, given $N$ and $k$, that finds a strategy to ensure the newly formed number is the smallest possible.\n\n## Input Format\n\nnum: a string representing the high-precision positive integer $N$.\nk: an integer representing the number of digits to be removed.\n\n## Output Format\n\nOutput one integer, the smallest possible number remaining after deletion.\n\n## Sample #1\nremoveKDigits(\"175438\", 4) => 13\n", "level": "easy"}
{"task_id": "Dart/44", "prompt": "import 'dart:math';\n\nint minimumTransfers(int n, List<int> groups, int L, int R)\n\n/*\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nn: the number of groups of students\ngroups: an array of $n$ integers, where the $i$-th integer represents the initial number of students in the $i$-th group\nL: the lower bound for the number of students per group\nR: the upper bound for the number of students per group\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\nminimumTransfers(2, [10, 20], 10, 15) => 5\n */", "canonical_solution": "{\n  int totalStudents = groups.reduce((a, b) => a + b);\n  if (totalStudents < n * L || totalStudents > n * R) return -1;\n\n  int transfers = 0;\n  List<int> surplus = groups.where((g) => g > R).toList();\n  List<int> deficit = groups.where((g) => g < L).toList();\n\n  while (surplus.isNotEmpty && deficit.isNotEmpty) {\n    int transfer = min(surplus.last - R, L - deficit.first);\n    surplus[surplus.length - 1] -= transfer;\n    deficit[0] += transfer;\n    transfers += transfer;\n    if (surplus.last <= R) surplus.removeLast();\n    if (deficit.first >= L) deficit.removeAt(0);\n  }\n  return transfers;\n}", "test": "void testMinimumTransfers() {\n  assert(minimumTransfers(2, [10, 20], 10, 15) == 0);\n  assert(minimumTransfers(3, [8, 16, 8], 9, 12) == 2);\n  assert(minimumTransfers(4, [10, 10, 10, 10], 5, 15) == 0);\n}\n\nvoid main() {\n  testMinimumTransfers();\n}", "entry_point": "minimumTransfers", "signature": "int minimumTransfers(int n, List<int> groups, int L, int R)", "docstring": "\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nn: the number of groups of students\ngroups: an array of $n$ integers, where the $i$-th integer represents the initial number of students in the $i$-th group\nL: the lower bound for the number of students per group\nR: the upper bound for the number of students per group\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\nminimumTransfers(2, [10, 20], 10, 15) => 5\n ", "instruction": "Write a dart function 'int minimumTransfers(int n, List<int> groups, int L, int R)' to solve the following problem:\n\nThere are $n$ groups of students, with the initial number of students in each group provided. Additionally, the upper bound $R$ and the lower bound $L$ for the number of students per group are given, with the constraint that $L \\le R$. At each step, you may select a student from one group and reassign them to another group. The question is: what is the minimum number of steps required to ensure that the number of students in each of the $N$ groups falls within the interval $[L,R]$?\n\n## Input Format\n\nn: the number of groups of students\ngroups: an array of $n$ integers, where the $i$-th integer represents the initial number of students in the $i$-th group\nL: the lower bound for the number of students per group\nR: the upper bound for the number of students per group\n\n## Output Format\n\nA single number, representing the minimum number of exchanges required. If the conditions of the problem cannot be met, output $-1$.\n\n## Sample Case #1\nminimumTransfers(2, [10, 20], 10, 15) => 5\n ", "level": "middle"}
{"task_id": "Dart/45", "prompt": "int findEarliestTime(int N, int M, List<Road> roads)\n/*\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\nfindEarliestTime(4, 4, [\n  Road(1, 2, 6),\n  Road(1, 3, 4),\n  Road(1, 4, 5),\n  Road(4, 2, 3),\n]) => 5\n*/", "canonical_solution": "{\n  roads.sort((a, b) => a.repairTime.compareTo(b.repairTime));\n  List<int> parent = List.generate(N + 1, (index) => index);\n\n  int find(int v) {\n    return v == parent[v] ? v : parent[v] = find(parent[v]);\n  }\n\n  void union(int a, int b) {\n    parent[find(a)] = find(b);\n  }\n\n  int maxTime = 0;\n  int components = N;\n\n  for (Road road in roads) {\n    if (find(road.village1) != find(road.village2)) {\n      union(road.village1, road.village2);\n      maxTime = road.repairTime;\n      components--;\n    }\n    if (components == 1) break;\n  }\n\n  return components == 1 ? maxTime : -1;\n}", "test": "class Road {\n  int village1;\n  int village2;\n  int repairTime;\n\n  Road(this.village1, this.village2, this.repairTime);\n\n  @override\n  String toString() => 'Road(village1: $village1, village2: $village2, repairTime: $repairTime)';\n}\n\nvoid testFindEarliestTime() {\n  assert(findEarliestTime(4, 4, [\n    Road(1, 2, 6),\n    Road(1, 3, 4),\n    Road(1, 4, 5),\n    Road(4, 2, 3)\n  ]) == 5);\n\n  assert(findEarliestTime(3, 3, [\n    Road(1, 2, 2),\n    Road(2, 3, 5),\n    Road(1, 3, 1)\n  ]) == 2);\n\n  assert(findEarliestTime(5, 3, [\n    Road(1, 2, 3),\n    Road(2, 3, 4),\n    Road(4, 5, 5)\n  ]) == -1);\n}\n\nvoid main() {\n  testFindEarliestTime();\n}", "entry_point": "findEarliestTime", "signature": "int findEarliestTime(int N, int M, List<Road> roads)", "docstring": "\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\nfindEarliestTime(4, 4, [\n  Road(1, 2, 6),\n  Road(1, 3, 4),\n  Road(1, 4, 5),\n  Road(4, 2, 3),\n]) => 5\n", "instruction": "Write a dart function 'int findEarliestTime(int N, int M, List<Road> roads)' to solve the following problem:\n\nFollowing an earthquake in Region A, the highways connecting all the villages were damaged and became impassable. The government has dispatched crews to repair these highways.\nGiven the number of villages $N$ in Region A and the number of highways $M$, which are bidirectional, you are provided with information about which two villages each highway connects, and the time it will take to repair each highway. The question is: at the earliest, when will any two villages be accessible by car? That is, when will there be at least one repaired road between every pair of villages (where a road may consist of multiple highways)?\n\n## Input Format\n\nThe first line contains two positive integers $N, M$.\n\nThe following $M$ lines, each containing three positive integers $x, y, t$, inform you that the highway connects villages $x$ and $y$, and can be repaired by time $t$.\n\n## Output Format\n\nIf after repairing all highways there still exist two villages that cannot be accessed by car, output $-1$. Otherwise, output the earliest time at which any two villages can be accessed by car.\n\n## Sample Case #1\nfindEarliestTime(4, 4, [\n  Road(1, 2, 6),\n  Road(1, 3, 4),\n  Road(1, 4, 5),\n  Road(4, 2, 3),\n]) => 5\n", "level": "middle"}
{"task_id": "Dart/46", "prompt": "import 'dart:math';\n\nint calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)\n/*\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. \n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks.There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\ntasks: A list of $n$ tasks, each represented by a list of integers, where the first integer is the task number, the second integer is the time required to complete the task, and the remaining integers are the prerequisite tasks that must be completed beforehand, ending with the digit $0$.\n\ntimeToComplete: A list of $n$ integers, where the $i$-th integer is the time required to complete the $i$-th task.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\ncalculateMinimumTime([[1, 5, 0], [2, 2, 1, 0], [3, 3, 2, 0], [4, 6, 1, 0], [5, 1, 2, 4, 0], [6, 8, 2, 4, 0], [7, 4, 3, 5, 6, 0]]) => 23\n*/", "canonical_solution": "{\n  int n = tasks.length;\n  List<int> maxPreTaskTime = List.filled(n, 0);\n\n  for (int i = 0; i < n; i++) {\n    for (int preTask in tasks[i]) {\n      maxPreTaskTime[i] = max(maxPreTaskTime[i], maxPreTaskTime[preTask] + timeToComplete[preTask]);\n    }\n  }\n\n  int totalTime = 0;\n  for (int i = 0; i < n; i++) {\n    totalTime = max(totalTime, maxPreTaskTime[i] + timeToComplete[i]);\n  }\n\n  return totalTime;\n}", "test": "void testCalculateMinimumTime() {\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [1],\n    [0],\n    [1, 3],\n    [1, 3],\n    [2, 4, 5]\n  ],\n  [5, 2, 3, 6, 1, 8, 4]) == 23);\n\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [1],\n    [1, 2]\n  ],\n  [4, 3, 2, 5]) == 14);\n\n  assert(calculateMinimumTime([\n    [],\n    [0],\n    [0],\n    [0],\n    [1, 2, 3]\n  ],\n  [1, 2, 3, 4, 5]) == 10);\n}\n\nvoid main() {\n  testCalculateMinimumTime();\n}", "entry_point": "calculateMinimumTime", "signature": "int calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)", "docstring": "\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. \n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks.There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\ntasks: A list of $n$ tasks, each represented by a list of integers, where the first integer is the task number, the second integer is the time required to complete the task, and the remaining integers are the prerequisite tasks that must be completed beforehand, ending with the digit $0$.\n\ntimeToComplete: A list of $n$ integers, where the $i$-th integer is the time required to complete the $i$-th task.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\ncalculateMinimumTime([[1, 5, 0], [2, 2, 1, 0], [3, 3, 2, 0], [4, 6, 1, 0], [5, 1, 2, 4, 0], [6, 8, 2, 4, 0], [7, 4, 3, 5, 6, 0]]) => 23\n", "instruction": "Write a dart function 'int calculateMinimumTime(List<List<int>> tasks, List<int> timeToComplete)' to solve the following problem:\n\nPrior to milking the dairy cows on John's farm, there are numerous miscellaneous tasks that need to be completed, each requiring a certain amount of time for execution. \n\nNaturally, some tasks can only be initiated upon the completion of other specific tasks.There is at least one task that does not require any preparatory work, which can be the first task to be tackled, designated as task $1$.\n\nJohn possesses a list of $n$ miscellaneous tasks that require completion, and this list is structured in a particular order, with the preparatory work for task $k\\ (k>1)$ only possibly being among tasks $1$ to $k-1$.\n\nWrite a program to sequentially read in the description of each task. Compute the shortest time required to complete all tasks. It is understood that tasks unrelated to one another can be executed concurrently, and it can be assumed that John's farm is sufficiently staffed to simultaneously accomplish any number of tasks.\n\n## Input Format\n\ntasks: A list of $n$ tasks, each represented by a list of integers, where the first integer is the task number, the second integer is the time required to complete the task, and the remaining integers are the prerequisite tasks that must be completed beforehand, ending with the digit $0$.\n\ntimeToComplete: A list of $n$ integers, where the $i$-th integer is the time required to complete the $i$-th task.\n\n## Output Format\n\nA single integer representing the shortest time required to complete all miscellaneous tasks.\n\n## Sample Case #1\ncalculateMinimumTime([[1, 5, 0], [2, 2, 1, 0], [3, 3, 2, 0], [4, 6, 1, 0], [5, 1, 2, 4, 0], [6, 8, 2, 4, 0], [7, 4, 3, 5, 6, 0]]) => 23\n", "level": "easy"}
{"task_id": "Dart/47", "prompt": "import 'dart:math';\n\nint longestBalancedSubsequence(List<int> students)\n/*\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nstudents: an array of integers representing the heights of the students in the school. The length of the array is between 1 and 10^5. Each element of the array is an integer between 0 and 1.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\nlongestBalancedSubsequence([0, 1, 0, 0, 0, 1, 1, 0, 0]) => 6\n*/", "canonical_solution": "{\n  int n = students.length;\n  Map<int, int> firstOccurrence = {0: -1};\n  int maxLength = 0;\n  int balance = 0;\n\n  for (int i = 0; i < n; i++) {\n    balance += students[i] == 0 ? -1 : 1;\n    if (firstOccurrence.containsKey(balance)) {\n      maxLength = max(maxLength, i - firstOccurrence[balance]!);\n    } else {\n      firstOccurrence[balance] = i;\n    }\n  }\n\n  return maxLength;\n}", "test": "void testLongestBalancedSubsequence() {\n  assert(longestBalancedSubsequence([0, 1, 0, 0, 0, 1, 1, 0, 0]) == 6);\n  assert(longestBalancedSubsequence([1, 1, 0, 0, 0, 1, 0, 1, 1]) == 8);\n  assert(longestBalancedSubsequence([0, 1, 1, 0, 1, 1, 0, 0]) == 8);\n}\n\nvoid main() {\n  testLongestBalancedSubsequence();\n}", "entry_point": "longestBalancedSubsequence", "signature": "int longestBalancedSubsequence(List<int> students)", "docstring": "\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nstudents: an array of integers representing the heights of the students in the school. The length of the array is between 1 and 10^5. Each element of the array is an integer between 0 and 1.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\nlongestBalancedSubsequence([0, 1, 0, 0, 0, 1, 1, 0, 0]) => 6\n", "instruction": "Write a dart function 'int longestBalancedSubsequence(List<int> students)' to solve the following problem:\n\nAs Halloween approaches, `XXX` plans to organize a large-scale \"Perfect Pairing\" event at his school. For the participants of this event, `XXX` has a unique method of selection. He wishes to choose individuals in equal numbers of males and females whose heights are closely matched. The mechanism for this selection is straightforward: he has all the school's students line up by height and then selects a continuous group from this line such that the number of males and females is equal. To ensure the event is lively, it goes without saying that `XXX` prefers to select as many individuals as possible. Please write a program to inform him of the maximum number of individuals he can select.\n\n## Input Format\n\nstudents: an array of integers representing the heights of the students in the school. The length of the array is between 1 and 10^5. Each element of the array is an integer between 0 and 1.\n\n## Output Format\n\nOutput a non-negative integer. This number represents the length of the longest subinterval with an equal number of males and females in the input data.\n\nIf there are no subintervals with an equal number of males and females, please output $0$.\n\n## Sample Case #1\nlongestBalancedSubsequence([0, 1, 0, 0, 0, 1, 1, 0, 0]) => 6\n", "level": "easy"}
{"task_id": "Dart/48", "prompt": "import 'dart:math';\n\nint maxSubarraySum(List<int> a)\n/*\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\na: a list of integers, $a_1, a_2, \\ldots, a_n$\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\nmaxSubarraySum([2, -4, 3, -1, 2, -4, 3]) => 4\n*/", "canonical_solution": "{\n  int maxSum = a[0], currentSum = a[0];\n  for (int i = 1; i < a.length; i++) {\n    currentSum = currentSum > 0 ? currentSum + a[i] : a[i];\n    maxSum = max(maxSum, currentSum);\n  }\n  return maxSum;\n}", "test": "void testMaxSubarraySum() {\n  assert(maxSubarraySum([2, -4, 3, -1, 2, -4, 3]) == 4);\n  assert(maxSubarraySum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7);\n  assert(maxSubarraySum([-1, -2, -3, -4]) == -1);\n}\n\nvoid main() {\n  testMaxSubarraySum();\n}", "entry_point": "maxSubarraySum", "signature": "int maxSubarraySum(List<int> a)", "docstring": "\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\na: a list of integers, $a_1, a_2, \\ldots, a_n$\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\nmaxSubarraySum([2, -4, 3, -1, 2, -4, 3]) => 4\n", "instruction": "Write a dart function 'int maxSubarraySum(List<int> a)' to solve the following problem:\n\nGiven a sequence of length $n$, denoted as $a$, find a continuous and non-empty segment that yields the maximum sum.\n\n## Input Format\na: a list of integers, $a_1, a_2, \\ldots, a_n$\n\n## Output Format\n\nOutput a single line with one integer representing the solution.\n\n## Sample Case #1\nmaxSubarraySum([2, -4, 3, -1, 2, -4, 3]) => 4\n", "level": "easy"}
{"task_id": "Dart/49", "prompt": "int minimumSwaps(List<int> train)\n/*\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\ntrain: A list of integers representing the initial order of the carriages.\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\nminimumSwaps([4, 3, 2, 1]) => 6\n\n*/", "canonical_solution": "{\n  int count = 0;\n  for (int i = 0; i < train.length; i++) {\n    while (train[i] != i + 1) {\n      int temp = train[i];\n      train[i] = train[temp - 1];\n      train[temp - 1] = temp;\n      count++;\n    }\n  }\n  return count;\n}", "test": "void testMinimumSwaps() {\n  assert(minimumSwaps([4, 3, 2, 1]) == 2);\n  assert(minimumSwaps([1, 3, 5, 2, 4, 6]) == 3);\n  assert(minimumSwaps([1, 5, 4, 3, 2]) == 2);\n}\n\nvoid main() {\n  testMinimumSwaps();\n}", "entry_point": "minimumSwaps", "signature": "int minimumSwaps(List<int> train)", "docstring": "\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\ntrain: A list of integers representing the initial order of the carriages.\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\nminimumSwaps([4, 3, 2, 1]) => 6\n\n", "instruction": "Write a dart function 'int minimumSwaps(List<int> train)' to solve the following problem:\n\nAdjacent to an old-fashioned train station lies a bridge with a deck capable of horizontally rotating around the central pier of the river. A worker at the station discovered that the bridge could accommodate a maximum of two carriages. By rotating the bridge 180 degrees, the positions of two adjacent carriages could be interchanged, thus allowing for the reordering of the carriages' sequence. Consequently, he took on the responsibility of using the bridge to organize the incoming carriages in ascending order based on their carriage numbers. Following his retirement, the train station decided to automate this task. A crucial part of this automation involves developing a program that takes the initial order of the carriages and calculates the minimum number of steps required to sort them.\n\n## Input Format\n\ntrain: A list of integers representing the initial order of the carriages.\n\n## Output Format\n\nA single integer indicating the minimum number of rotations required.\n\n## Sample Case #1\nminimumSwaps([4, 3, 2, 1]) => 6\n\n", "level": "easy"}
{"task_id": "Dart/50", "prompt": "int countExcellentSplits(String s)\n/*\nGiven a string, determine the number of substrings with excellent decomposition. A decomposition is considered excellent if it can be written in the form \"AABB\", where \"A\" and \"B\" are non-empty substrings.\n\ncountExcellentSplits(\"abcdabc\")\n0\ncountExcellentSplits(\"aaabaaa\")\n2\n*/", "canonical_solution": "{\nint count = 0;\n  int n = s.length;\n\n  // Helper function to count excellent splits in a given substring\n  bool isExcellentSplit(String sub) {\n    int len = sub.length;\n    for (int i = 1; i <= len/2; i++) {\n      String A = sub.substring(0, i);\n      String A1 = sub.substring(i,2*i);\n      String remaining = sub.substring(2*i);\n      for (int j = 1; j <= remaining.length / 2; j++) {\n        String B = remaining.substring(0, j);\n        String B2 = remaining.substring(j);\n        if (B == B2 && A == A1) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // Iterate over all substrings of s\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 4; j <= n; j++) {\n      String sub = s.substring(i, j);\n      if (isExcellentSplit(sub)) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}", "test": "void main() {\n  check(countExcellentSplits);\n}\n\nvoid check(int Function(String) countExcellentSplits) {\n  assert(countExcellentSplits(\"abcdabc\") == 0);\n  assert(countExcellentSplits(\"aabbbb\") == 3);\n  assert(countExcellentSplits(\"cccccc\") == 4);\n}", "entry_point": "countExcellentSplits", "signature": "int countExcellentSplits(String s)", "docstring": "\nGiven a string, determine the number of substrings with excellent decomposition. A decomposition is considered excellent if it can be written in the form \"AABB\", where \"A\" and \"B\" are non-empty substrings.\n\ncountExcellentSplits(\"abcdabc\")\n0\ncountExcellentSplits(\"aaabaaa\")\n2\n", "instruction": "Write a dart function 'int countExcellentSplits(String s)' to solve the following problem:\n\nGiven a string, determine the number of substrings with excellent decomposition. A decomposition is considered excellent if it can be written in the form \"AABB\", where \"A\" and \"B\" are non-empty substrings.\n\ncountExcellentSplits(\"abcdabc\")\n0\ncountExcellentSplits(\"aaabaaa\")\n2\n", "level": "hard"}
{"task_id": "Dart/51", "prompt": "int findOriginalStickLength(int n, List<int> lengths)\n/*\nBB had some sticks of the same length, which he cut into smaller pieces such that no piece was longer than 50 units.\nNow he wants to reassemble the sticks to their original lengths but has forgotten the number of original sticks and their lengths.\nGiven the lengths of the smaller pieces, determine the smallest possible original length of the sticks.\nArgs:\nn (int): The number of small stick pieces.\nlengths (List<int>): The lengths of the small stick pieces.\nReturns:\nint: The smallest possible original length of the sticks.\nExample:\nfindOriginalStickLength(9, [5, 2, 1, 5, 2, 1, 5, 2, 1])\n6\n*/", "canonical_solution": "{\n  int totalLength = lengths.reduce((a, b) => a + b);\n  int maxLength = lengths.reduce((a, b) => a > b ? a : b);\n  for (int i = maxLength; i <= totalLength; i++) {\n    if (totalLength % i == 0) {\n      List<int> used = List.filled(n, 0);\n      if (canFormOriginal(lengths, used, 0, i)) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\nbool canFormOriginal(List<int> lengths, List<int> used, int index, int targetLength) {\n  if (index == lengths.length) {\n    return true;\n  }\n  for (int i = 0; i < used.length; i++) {\n    if (used[i] + lengths[index] <= targetLength) {\n      used[i] += lengths[index];\n      if (canFormOriginal(lengths, used, index + 1, targetLength)) {\n        return true;\n      }\n      used[i] -= lengths[index];\n    }\n    if (used[i] == 0) {\n      break;\n    }\n  }\n  return false;\n}", "test": "void main() {\ncheck(findOriginalStickLength);\n}\n\nvoid check(int Function(int, List<int>) findOriginalStickLength) {\nassert(findOriginalStickLength(9, [5, 2, 1, 5, 2, 1, 5, 2, 1]) == 6);\nassert(findOriginalStickLength(4, [10, 10, 10, 10]) == 10);\nassert(findOriginalStickLength(6, [15, 15, 15, 15, 30, 30]) == 30);\n}", "entry_point": "findOriginalStickLength", "signature": "int findOriginalStickLength(int n, List<int> lengths)", "docstring": "\nBB had some sticks of the same length, which he cut into smaller pieces such that no piece was longer than 50 units.\nNow he wants to reassemble the sticks to their original lengths but has forgotten the number of original sticks and their lengths.\nGiven the lengths of the smaller pieces, determine the smallest possible original length of the sticks.\nArgs:\nn (int): The number of small stick pieces.\nlengths (List<int>): The lengths of the small stick pieces.\nReturns:\nint: The smallest possible original length of the sticks.\nExample:\nfindOriginalStickLength(9, [5, 2, 1, 5, 2, 1, 5, 2, 1])\n6\n", "instruction": "Write a dart function 'int findOriginalStickLength(int n, List<int> lengths)' to solve the following problem:\n\nBB had some sticks of the same length, which he cut into smaller pieces such that no piece was longer than 50 units.\nNow he wants to reassemble the sticks to their original lengths but has forgotten the number of original sticks and their lengths.\nGiven the lengths of the smaller pieces, determine the smallest possible original length of the sticks.\nArgs:\nn (int): The number of small stick pieces.\nlengths (List<int>): The lengths of the small stick pieces.\nReturns:\nint: The smallest possible original length of the sticks.\nExample:\nfindOriginalStickLength(9, [5, 2, 1, 5, 2, 1, 5, 2, 1])\n6\n", "level": "hard"}
