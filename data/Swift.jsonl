{"task_id": "Swift/1", "prompt": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/", "canonical_solution": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}", "test": "func check(_ hasCloseElements: ([Double], Double) -> Bool) {\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\nassert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\n}\n\ncheck(hasCloseElements)", "entry_point": "hasCloseElements", "signature": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {", "docstring": "\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "instruction": "Write a Swift function `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` to solve the following problem:\n\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n", "level": "easy"}
{"task_id": "Swift/2", "prompt": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/", "canonical_solution": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}", "test": "func checkFirstPalindrome(_ firstPalindrome: ([String]) -> String) {\nassert(firstPalindrome([\"apple\", \"banana\", \"civic\"]) == \"civic\", \"Test failed: Expected 'civic'\")\nassert(firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"]) == \"ada\", \"Test failed: Expected 'ada'\")\nassert(firstPalindrome([\"hello\", \"world\"]) == \"\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"radar\", \"rotor\", \"level\"]) == \"radar\", \"Test failed: Expected 'radar'\")\nassert(firstPalindrome([\"not\", \"a\", \"single\", \"palindrome\"]) == \"a\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"A\", \"B\", \"C\", \"D\"]) == \"A\", \"Test failed: Expected 'A'\")\nassert(firstPalindrome([\"noon\", \"evening\", \"morning\"]) == \"noon\", \"Test failed: Expected 'noon'\")\n}\n\n\ncheckFirstPalindrome(firstPalindrome)", "entry_point": "firstPalindrome", "signature": "func firstPalindrome(_ words: [String]) -> String {", "docstring": "\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n", "instruction": "Write a Swift function `func firstPalindrome(_ words: [String]) -> String {` to solve the following problem:\n\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n", "level": "easy"}
{"task_id": "Swift/3", "prompt": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/", "canonical_solution": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}", "test": "func checkMaxWordCount(_ maxWordCount: ([String]) -> Int) {\nassert(maxWordCount([\"Hello world\", \"Swift is amazing\"]) == 3)\nassert(maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"]) == 5)\nassert(maxWordCount([\"single\"]) == 1)\nassert(maxWordCount([\"\", \"one two\", \"one two three\"]) == 3)\nassert(maxWordCount([\"This is a test sentence\", \"This is another\"]) == 5)\nassert(maxWordCount([\"Sentence with five words\", \"Shorter one\"]) == 4)\n}\n\ncheckMaxWordCount(maxWordCount)", "entry_point": "maxWordCount", "signature": "func maxWordCount(_ sentences: [String]) -> Int {", "docstring": "\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n", "instruction": "Write a Swift function `func maxWordCount(_ sentences: [String]) -> Int {` to solve the following problem:\n\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n", "level": "easy"}
{"task_id": "Swift/4", "prompt": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/", "canonical_solution": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}", "test": "func checkIsValidMatrix(_ isValidMatrix: ([[Int]]) -> Bool) {\nassert(isValidMatrix([[1,2,3],[3,1,2],[2,3,1]]) == true)\nassert(isValidMatrix([[1,2,3],[3,2,1],[1,2,3]]) == false)\nassert(isValidMatrix([[1]]) == true)\nassert(isValidMatrix([[1,2],[2,1]]) == true)\nassert(isValidMatrix([[1,2],[1,2]]) == false)\nassert(isValidMatrix([[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]) == true)\nassert(isValidMatrix([[4,3,2,1],[3,2,1,4],[2,1,4,3],[1,4,3,2]]) == true)\nassert(isValidMatrix([[1,2,3],[3,1,2],[3,2,1]]) == false)\n}\n\ncheckIsValidMatrix(isValidMatrix)", "entry_point": "isValidMatrix", "signature": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {", "docstring": "\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n", "instruction": "Write a Swift function `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` to solve the following problem:\n\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n", "level": "middle"}
{"task_id": "Swift/5", "prompt": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n*/", "canonical_solution": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}", "test": "func checkMinCostToBuyCandies(_ minCostToBuyCandies: ([Int]) -> Int) {\nassert(minCostToBuyCandies([1, 2, 3, 4]) == 8)\nassert(minCostToBuyCandies([1, 2]) == 3)\nassert(minCostToBuyCandies([1, 6, 3, 5, 2, 4]) == 16)\nassert(minCostToBuyCandies([5, 5, 5, 5, 5, 5]) == 20)\nassert(minCostToBuyCandies([7, 1, 2, 9, 6, 4]) == 22)\nassert(minCostToBuyCandies([1]) == 1)\nassert(minCostToBuyCandies([]) == 0)\n}\n\ncheckMinCostToBuyCandies(minCostToBuyCandies)", "entry_point": "minCostToBuyCandies", "signature": "func minCostToBuyCandies(_ costs: [Int]) -> Int {", "docstring": "\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n", "instruction": "Write a Swift function `func minCostToBuyCandies(_ costs: [Int]) -> Int {` to solve the following problem:\n\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n", "level": "easy"}
{"task_id": "Swift/6", "prompt": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n*/", "canonical_solution": "guard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}", "test": "func checkCountElementsWithStrictBounds(_ countElementsWithStrictBounds: ([Int]) -> Int) {\nassert(countElementsWithStrictBounds([2, 1, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 2, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 1, 1]) == 0)\nassert(countElementsWithStrictBounds([3, 3, 5, 2, 2, 7, 4]) == 4)\nassert(countElementsWithStrictBounds([10, 5, 9, 1, 7, 6, 8]) == 5)\nassert(countElementsWithStrictBounds([-2, -1, 0, 1, 2]) == 3)\nassert(countElementsWithStrictBounds([]) == 0)\n}\n\ncheckCountElementsWithStrictBounds(countElementsWithStrictBounds)", "entry_point": "countElementsWithStrictBounds", "signature": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {", "docstring": "\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n", "instruction": "Write a Swift function `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` to solve the following problem:\n\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n", "level": "easy"}
{"task_id": "Swift/7", "prompt": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n*/", "canonical_solution": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}", "test": "func checkFindFinalValue(_ findFinalValue: ([Int], Int) -> Int) {\nassert(findFinalValue([5, 3, 6, 1, 12], 3) == 24)\nassert(findFinalValue([2, 7, 9], 4) == 4)\nassert(findFinalValue([1, 2, 4, 8, 16], 1) == 32)\nassert(findFinalValue([10, 20, 30, 40], 10) == 80)\nassert(findFinalValue([5, 10, 20, 40], 2) == 2)\nassert(findFinalValue([], 1) == 1)\nassert(findFinalValue([100, 200, 300], 100) == 400)\n}\n\ncheckFindFinalValue(findFinalValue)", "entry_point": "findFinalValue", "signature": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {", "docstring": "\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n", "instruction": "Write a Swift function `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` to solve the following problem:\n\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n", "level": "easy"}
{"task_id": "Swift/8", "prompt": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/", "canonical_solution": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}", "test": "func checkReorderArray(_ reorderArray: ([Int]) -> [Int]) {\nassert(reorderArray([4, 1, 2, 3]) == [2, 3, 4, 1])\nassert(reorderArray([6, 5, 4, 3, 2, 1]) == [2, 5, 4, 3, 6, 1])\nassert(reorderArray([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2])\nassert(reorderArray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1])\nassert(reorderArray([1]) == [1])\nassert(reorderArray([1, 2]) == [1, 2])\nassert(reorderArray([]) == [])\n}\n\ncheckReorderArray(reorderArray)", "entry_point": "reorderArray", "signature": "func reorderArray(_ nums: [Int]) -> [Int] {", "docstring": "\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n", "instruction": "Write a Swift function `func reorderArray(_ nums: [Int]) -> [Int] {` to solve the following problem:\n\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n", "level": "middle"}
{"task_id": "Swift/9", "prompt": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n*/", "canonical_solution": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}", "test": "func checkCountDivisiblePairs(_ countDivisiblePairs: ([Int], Int) -> Int) {\nassert(countDivisiblePairs([1, 2, 3, 1, 2, 3], 3) == 1)\nassert(countDivisiblePairs([1, 1, 1, 1], 1) == 6)\nassert(countDivisiblePairs([1, 2, 3, 4, 5, 6], 7) == 0)\nassert(countDivisiblePairs([1, 2, 2, 1, 2], 2) == 4)\nassert(countDivisiblePairs([4, 4, 4, 4], 4) == 3)\nassert(countDivisiblePairs([], 5) == 0)\nassert(countDivisiblePairs([2, 2, 2, 2, 2], 3) == 7 )\n}\n\ncheckCountDivisiblePairs(countDivisiblePairs)", "entry_point": "countDivisiblePairs", "signature": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {", "docstring": "\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n", "instruction": "Write a Swift function `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` to solve the following problem:\n\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n", "level": "easy"}
{"task_id": "Swift/10", "prompt": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n*/", "canonical_solution": "return words.filter { $0.hasPrefix(pref) }.count\n}", "test": "func checkCountPrefixStrings(_ countPrefixStrings: ([String], String) -> Int) {\nassert(countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\") == 3)\nassert(countPrefixStrings([\"hello\", \"world\"], \"he\") == 1)\nassert(countPrefixStrings([\"python\", \"php\", \"perl\", \"java\"], \"p\") == 3)\nassert(countPrefixStrings([\"swift\", \"scala\"], \"s\") == 2)\nassert(countPrefixStrings([\"go\", \"rust\", \"ruby\"], \"c\") == 0)\nassert(countPrefixStrings([], \"test\") == 0)\nassert(countPrefixStrings([\"prefix\", \"preference\", \"preliminary\"], \"pre\") == 3)\n}\n\ncheckCountPrefixStrings(countPrefixStrings)", "entry_point": "countPrefixStrings", "signature": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {", "docstring": "\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n", "instruction": "Write a Swift function `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` to solve the following problem:\n\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n", "level": "easy"}
{"task_id": "Swift/11", "prompt": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n*/", "canonical_solution": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}", "test": "func checkRemoveAnagramWords(_ removeAnagramWords: ([String]) -> [String]) {\nassert(removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) == [\"ab\", \"cd\", \"e\"])\nassert(removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) == [\"abc\"])\nassert(removeAnagramWords([\"word\", \"drow\", \"hello\", \"world\"]) == [\"word\", \"hello\",\"world\"])\nassert(removeAnagramWords([\"a\", \"b\", \"c\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(removeAnagramWords([\"zzz\", \"zzz\", \"zzz\"]) == [\"zzz\"])\nassert(removeAnagramWords([\"abcd\", \"dbca\", \"dcba\"]) == [\"abcd\"])\n}\n\ncheckRemoveAnagramWords(removeAnagramWords)", "entry_point": "removeAnagramWords", "signature": "func removeAnagramWords(_ words: [String]) -> [String] {", "docstring": "\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n", "instruction": "Write a Swift function `func removeAnagramWords(_ words: [String]) -> [String] {` to solve the following problem:\n\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n", "level": "middle"}
{"task_id": "Swift/12", "prompt": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n*/", "canonical_solution": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}", "test": "func checkMostFrequentTargetAfterKey(_ mostFrequentTargetAfterKey: ([Int], Int) -> Int) {\nassert(mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1) == 2)\nassert(mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1) == 1)\nassert(mostFrequentTargetAfterKey([1, 2, 3, 1, 2, 3, 1, 2], 2) == 3)\nassert(mostFrequentTargetAfterKey([7, 7, 7, 8, 8, 9, 7, 9, 9], 7) == 7)\nassert(mostFrequentTargetAfterKey([1], 1) == 1)\nassert(mostFrequentTargetAfterKey([2, 2, 2, 2, 2, 3], 2) == 2)\n}\n\ncheckMostFrequentTargetAfterKey(mostFrequentTargetAfterKey)", "entry_point": "mostFrequentTargetAfterKey", "signature": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {", "docstring": "\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n", "instruction": "Write a Swift function `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` to solve the following problem:\n\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n", "level": "hard"}
{"task_id": "Swift/13", "prompt": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n*/", "canonical_solution": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}", "test": "func checkKCloseNeighbors(_ kCloseNeighbors: ([Int], Int, Int) -> [Int]) {\nassert(kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2) == [0, 1, 2, 3, 4, 5, 6])\nassert(kCloseNeighbors([1, 2, 3, 4, 5], 3, 1) == [1, 2, 3])\nassert(kCloseNeighbors([1, 1, 1, 1, 1], 1, 0) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([5, 4, 3, 2, 1], 3, 2) == [0,1, 2, 3, 4])\nassert(kCloseNeighbors([7, 7, 7, 7, 7], 7, 3) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([], 1, 1) == [])\nassert(kCloseNeighbors([1, 2, 3, 4, 5, 6], 4, 1) == [2, 3, 4])\n}\n\ncheckKCloseNeighbors(kCloseNeighbors)", "entry_point": "kCloseNeighbors", "signature": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {", "docstring": "\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n", "instruction": "Write a Swift function `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` to solve the following problem:\n\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n", "level": "middle"}
{"task_id": "Swift/14", "prompt": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n*/", "canonical_solution": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}", "test": "func checkCanFormPairs(_ canFormPairs: ([Int]) -> Bool) {\nassert(canFormPairs([1, 2, 2, 1]) == true)\nassert(canFormPairs([1, 2, 3, 4, 5, 6]) == false)\nassert(canFormPairs([3, 3, 3, 3, 3, 3]) == true)\nassert(canFormPairs([0, 0]) == true)\nassert(canFormPairs([1, 1, 2, 2, 2, 2, 3, 3]) == true)\nassert(canFormPairs([1, 2, 3, 4, 4, 3, 2, 1, 5]) == false)\nassert(canFormPairs([]) == true)\n}\n\ncheckCanFormPairs(canFormPairs)", "entry_point": "canFormPairs", "signature": "func canFormPairs(_ nums: [Int]) -> Bool {", "docstring": "\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n", "instruction": "Write a Swift function `func canFormPairs(_ nums: [Int]) -> Bool {` to solve the following problem:\n\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n", "level": "easy"}
{"task_id": "Swift/15", "prompt": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n*/", "canonical_solution": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}", "test": "func checkFindUniqueElements(_ findUniqueElements: ([Int], [Int]) -> [[Int]]) {\nassert(findUniqueElements([1, 2, 3], [2, 3, 4]) == [[1], [4]])\nassert(findUniqueElements( [1, 1, 2, 3], [3, 4, 4, 5]) == [[1, 2], [4, 5]])\nassert(findUniqueElements( [1, 2, 2], [1, 1, 1]) == [[2], []])\nassert(findUniqueElements( [], [1, 2, 3]) == [[], [1, 2, 3]])\nassert(findUniqueElements( [4, 5, 6], [4, 5, 6]) == [[], []])\nassert(findUniqueElements( [10], [10, 20]) == [[], [20]])\n}\n\ncheckFindUniqueElements(findUniqueElements)", "entry_point": "findUniqueElements", "signature": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {", "docstring": "\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n", "instruction": "Write a Swift function `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` to solve the following problem:\n\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n", "level": "easy"}
{"task_id": "Swift/16", "prompt": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n*/", "canonical_solution": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}", "test": "func checkClosestToZero(_ closestToZero: ([Int]) -> Int) {\nassert(closestToZero([2, -1, 1]) == 1)\nassert(closestToZero([-3, -2, -1]) == -1)\nassert(closestToZero([0, 10, 20]) == 0)\nassert(closestToZero([5, 6, 7]) == 5)\nassert(closestToZero([-5, 5]) == 5)\nassert(closestToZero([-10, -5, 0, 5, 10]) == 0)\nassert(closestToZero([]) == 0)\n}\n\ncheckClosestToZero(closestToZero)", "entry_point": "closestToZero", "signature": "func closestToZero(_ nums: [Int]) -> Int {", "docstring": "\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n", "instruction": "Write a Swift function `func closestToZero(_ nums: [Int]) -> Int {` to solve the following problem:\n\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n", "level": "easy"}
{"task_id": "Swift/17", "prompt": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n*/", "canonical_solution": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}", "test": "func checkCommonElementsInAllArrays(_ commonElementsInAllArrays: ([[Int]]) -> [Int]) {\nassert(commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == [3])\nassert(commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]]) == [2])\nassert(commonElementsInAllArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [])\nassert(commonElementsInAllArrays([[10, 20], [20, 30], [20, 40]]) == [20])\nassert(commonElementsInAllArrays([[1]]) == [1])\nassert(commonElementsInAllArrays([]) == [])\nassert(commonElementsInAllArrays([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == [4])\n}\n\ncheckCommonElementsInAllArrays(commonElementsInAllArrays)", "entry_point": "commonElementsInAllArrays", "signature": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {", "docstring": "\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n", "instruction": "Write a Swift function `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` to solve the following problem:\n\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n", "level": "easy"}
{"task_id": "Swift/18", "prompt": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n*/", "canonical_solution": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}", "test": "func checkPerformAlgorithmOnNums(_ performAlgorithmOnNums: ([Int]) -> Int) {\nassert(performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8]) == 1)\nassert(performAlgorithmOnNums([10, 100, 30, 20]) == 10)\nassert(performAlgorithmOnNums([2, 4]) == 2)\nassert(performAlgorithmOnNums([7]) == 7)\n}\n\ncheckPerformAlgorithmOnNums(performAlgorithmOnNums)", "entry_point": "performAlgorithmOnNums", "signature": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {", "docstring": "\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n", "instruction": "Write a Swift function `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` to solve the following problem:\n\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n", "level": "middle"}
{"task_id": "Swift/19", "prompt": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n*/", "canonical_solution": "return words.filter { s.hasPrefix($0) }.count\n}", "test": "func checkCountPrefixes(_ countPrefixes: ([String], String) -> Int) {\nassert(countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\") == 2)\nassert(countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\") == 2)\nassert(countPrefixes([\"app\", \"apple\", \"apricot\", \"ap\"], \"apple\") == 3)\nassert(countPrefixes([\"blue\", \"blues\", \"blueberry\"], \"blue\") == 1)\nassert(countPrefixes([\"no\", \"match\"], \"yes\") == 0)\nassert(countPrefixes([], \"empty\") == 0)\nassert(countPrefixes([\"full\", \"fullest\", \"ful\"], \"fullest\") == 3)\n}\n\ncheckCountPrefixes(countPrefixes)", "entry_point": "countPrefixes", "signature": "func countPrefixes(_ words: [String], _ s: String) -> Int {", "docstring": "\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n", "instruction": "Write a Swift function `func countPrefixes(_ words: [String], _ s: String) -> Int {` to solve the following problem:\n\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n", "level": "easy"}
{"task_id": "Swift/20", "prompt": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/", "canonical_solution": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}", "test": "func checkTwoSum(_ twoSum: ([Int], Int) -> [Int]) {\nassert(twoSum([2, 7, 11, 15], 9) == [0, 1])\nassert(twoSum([3, 2, 4], 6) == [1, 2])\nassert(twoSum([3, 3], 6) == [0, 1])\nassert(twoSum([1, 5, 4, 7], 8) == [0, 3])\nassert(twoSum([1, 2, 3, 4], 7) == [2, 3])\nassert(twoSum([4, 4], 8) == [0, 1])\nassert(twoSum([-1, -2, -3, -4, -5], -8) == [2, 4])\n}\n\ncheckTwoSum(twoSum)", "entry_point": "twoSum", "signature": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {", "docstring": "\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n", "instruction": "Write a Swift function `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` to solve the following problem:\n\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n", "level": "easy"}
{"task_id": "Swift/21", "prompt": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/", "canonical_solution": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}", "test": "func check(_ findFourthVertex: ((Int, Int), (Int, Int), (Int, Int)) -> (Int, Int)) {\nassert(findFourthVertex((5, 5), (5, 7), (7, 5)) == (7, 7))\nassert(findFourthVertex((2, 3), (2, 5), (4, 5)) == (4, 3))\nassert(findFourthVertex((10, 10), (10, 20), (20, 10)) == (20, 20))\nassert(findFourthVertex((15, 15), (10, 15), (10, 10)) == (15, 10))\nassert(findFourthVertex((3, 4), (5, 4), (3, 2)) == (5, 2))\nassert(findFourthVertex((8, 9), (8, 12), (11, 12)) == (11, 9))\n}\n\ncheck(findFourthVertex)", "entry_point": "findFourthVertex", "signature": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {", "docstring": "\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n", "instruction": "Write a Swift function `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` to solve the following problem:\n\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n", "level": "hard"}
{"task_id": "Swift/22", "prompt": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n*/", "canonical_solution": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}", "test": "func testAdjustChessPieces() {\nassert(adjustChessPieces([1, 1, 2, 2, 2, 8]) == [0, 0, 0, 0, 0, 0], \"Test Case 1 Failed\")\nassert(adjustChessPieces([0, 2, 1, 2, 2, 5]) == [1, -1, 1, 0, 0, 3], \"Test Case 2 Failed\")\nassert(adjustChessPieces([1, 0, 2, 1, 3, 8]) == [0, 1, 0, 1, -1, 0], \"Test Case 3 Failed\")\nassert(adjustChessPieces([0, 1, 0, 0, 0, 0]) == [1, 0, 2, 2, 2, 8], \"Test Case 4 Failed\")\nassert(adjustChessPieces([2, 2, 3, 3, 3, 10]) == [-1, -1, -1, -1, -1, -2], \"Test Case 5 Failed\")\n}\n\ntestAdjustChessPieces()", "entry_point": "adjustChessPieces", "signature": "func adjustChessPieces(_ counts: [Int]) -> [Int] {", "docstring": "\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n", "instruction": "Write a Swift function `func adjustChessPieces(_ counts: [Int]) -> [Int] {` to solve the following problem:\n\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n", "level": "middle"}
{"task_id": "Swift/23", "prompt": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/", "canonical_solution": "if n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}", "test": "func testMaxChessboardSlices() {\nassert(maxChessboardSlices(0) == 1)\nassert(maxChessboardSlices(2) == 4)\nassert(maxChessboardSlices(4) == 9)\nassert(maxChessboardSlices(5) == 12)\nassert(maxChessboardSlices(6) == 16)\nassert(maxChessboardSlices(7) == 20)\n}\n\ntestMaxChessboardSlices()", "entry_point": "maxChessboardSlices", "signature": "func maxChessboardSlices(_ n: Int) -> Int {", "docstring": "\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n", "instruction": "Write a Swift function `func maxChessboardSlices(_ n: Int) -> Int {` to solve the following problem:\n\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n", "level": "easy"}
{"task_id": "Swift/24", "prompt": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/", "canonical_solution": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}", "test": "func testFindSmallestWordInMatrix() {\nassert(findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]]) == \"abc\")\nassert(findSmallestWordInMatrix([[\"a\", \"#\", \"c\"], [\"#\", \"d\", \"e\"], [\"f\", \"g\", \"#\"]]) == \"ce\")\nassert(findSmallestWordInMatrix([[\"#\", \"a\", \"#\"], [\"#\", \"b\", \"c\"], [\"#\", \"#\", \"d\"]]) == \"ab\")\nassert(findSmallestWordInMatrix([[\"m\", \"n\", \"o\"], [\"#\", \"#\", \"#\"], [\"p\", \"q\", \"r\"]]) == \"mno\")\nassert(findSmallestWordInMatrix([[\"x\", \"y\", \"#\"], [\"#\", \"z\", \"a\"], [\"b\", \"c\", \"d\"]]) == \"ad\")\n}\n\ntestFindSmallestWordInMatrix()", "entry_point": "findSmallestWordInMatrix", "signature": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {", "docstring": "\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n", "instruction": "Write a Swift function `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` to solve the following problem:\n\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n", "level": "hard"}
{"task_id": "Swift/25", "prompt": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n*/", "canonical_solution": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}", "test": "func testFindMissingNumber() {\nassert(findMissingNumber(in: [3, 7, 5]) == 1 || findMissingNumber(in: [3, 7, 5]) == 9)\nassert(findMissingNumber(in: [20, 14, 8]) == 26 || findMissingNumber(in: [20, 14, 8]) == 2)\nassert(findMissingNumber(in: [12, 6, 18]) == 0 || findMissingNumber(in: [12, 6, 18]) == 24)\nassert(findMissingNumber(in: [-4, 0, -8]) == -12 || findMissingNumber(in: [-4, 0, -8]) == 4)\nassert(findMissingNumber(in: [15, 5, 10]) == 0 || findMissingNumber(in: [15, 5, 10]) == 20)\n}\n\ntestFindMissingNumber()", "entry_point": "findMissingNumber", "signature": "func findMissingNumber(in numbers: [Int]) -> Int {", "docstring": "\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n", "instruction": "Write a Swift function `func findMissingNumber(in numbers: [Int]) -> Int {` to solve the following problem:\n\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n", "level": "hard"}
{"task_id": "Swift/26", "prompt": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/", "canonical_solution": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}", "test": "func testCountUnfairReminders() {\nassert(countUnfairReminders([\"mirko\", \"stanko\", \"stanko\", \"stanko\"]) == 1)\nassert(countUnfairReminders([\"a\", \"b\", \"b\", \"a\", \"a\", \"a\", \"c\", \"a\", \"b\", \"b\", \"c\", \"b\"]) == 0)\nassert(countUnfairReminders([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 10)\nassert(countUnfairReminders([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\"]) == 0)\nprint(\"All test cases pass.\")\n}\n\ntestCountUnfairReminders()", "entry_point": "countUnfairReminders", "signature": "func countUnfairReminders(_ children: [String]) -> Int {", "docstring": "\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n", "instruction": "Write a Swift function `func countUnfairReminders(_ children: [String]) -> Int {` to solve the following problem:\n\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n", "level": "middle"}
{"task_id": "Swift/27", "prompt": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/", "canonical_solution": "let eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}", "test": "func check(_ remainingApples: (Int, Int, Int) -> Int) {\nassert(remainingApples(50, 10, 200) == 30)\nassert(remainingApples(100, 5, 1000) == 0)\nassert(remainingApples(75, 15, 300) == 55)\nassert(remainingApples(20, 20, 400) == 0)\nassert(remainingApples(30, 10, 300) == 0)\nassert(remainingApples(40, 15, 600) == 0)\nassert(remainingApples(60, 10, 600) == 0)\n}\n\ncheck(remainingApples)", "entry_point": "remainingApples", "signature": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {", "docstring": "\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n", "instruction": "Write a Swift function `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` to solve the following problem:\n\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n", "level": "easy"}
{"task_id": "Swift/28", "prompt": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/", "canonical_solution": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}", "test": "func testCheckLikes(_ checkLikes: (Int) -> (Int, Int, Int, Int)) {\nassert(checkLikes(12) == (0, 1, 1, 0))\nassert(checkLikes(5) == (0, 1, 1, 0))\nassert(checkLikes(6) == (1, 1, 0, 0))\nassert(checkLikes(3) == (0, 0, 0, 1))\nassert(checkLikes(13) == (0, 0, 0, 1))\nassert(checkLikes(4) == (0, 1, 1, 0))\nassert(checkLikes(11) == (0, 1, 1, 0))\nassert(checkLikes(7) == (0, 1, 1, 0))\nassert(checkLikes(2) == (0, 1, 1, 0))\n}\n\ntestCheckLikes(checkLikes)", "entry_point": "checkLikes", "signature": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {", "docstring": "\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n", "instruction": "Write a Swift function `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` to solve the following problem:\n\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n", "level": "hard"}
{"task_id": "Swift/29", "prompt": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/", "canonical_solution": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}", "test": "func check(_ isLeapYear: (Int) -> Int) {\nassert(isLeapYear(1926) == 0)\nassert(isLeapYear(1900) == 0)\nassert(isLeapYear(2000) == 1)\nassert(isLeapYear(1996) == 1)\nassert(isLeapYear(2020) == 1)\nassert(isLeapYear(2021) == 0)\nassert(isLeapYear(2022) == 0)\nassert(isLeapYear(2023) == 0)\nassert(isLeapYear(2024) == 1)\n}\n\ncheck(isLeapYear)", "entry_point": "isLeapYear", "signature": "func isLeapYear(_ year: Int) -> Int {", "docstring": "\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n", "instruction": "Write a Swift function `func isLeapYear(_ year: Int) -> Int {` to solve the following problem:\n\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n", "level": "easy"}
{"task_id": "Swift/30", "prompt": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/", "canonical_solution": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}", "test": "func testDaysInMonth() {\n// Non-leap years\nassert(daysInMonth(1926, 8) == 31)\nassert(daysInMonth(1999, 12) == 31)\n\n// Leap years\nassert(daysInMonth(2000, 2) == 29)\nassert(daysInMonth(2020, 2) == 29)\n\n// Months with 30 days\nassert(daysInMonth(2022, 4) == 30)\nassert(daysInMonth(2022, 6) == 30)\n\n// Months with 31 days\nassert(daysInMonth(2022, 1) == 31)\nassert(daysInMonth(2022, 3) == 31)\n}\n\ntestDaysInMonth()", "entry_point": "daysInMonth", "signature": "func daysInMonth(_ year: Int, _ month: Int) -> Int {", "docstring": "\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n", "instruction": "Write a Swift function `func daysInMonth(_ year: Int, _ month: Int) -> Int {` to solve the following problem:\n\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n", "level": "easy"}
{"task_id": "Swift/31", "prompt": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/", "canonical_solution": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}", "test": "func check(_ minimumSwapsToOrder: ([Int]) -> Int) {\nassert(minimumSwapsToOrder([2, 3, 1]) == 2)\nassert(minimumSwapsToOrder([1, 4, 3, 2]) == 3)\nassert(minimumSwapsToOrder([5, 4, 3, 2, 1]) == 10)\nassert(minimumSwapsToOrder([1, 2, 3, 4, 5]) == 0)\nassert(minimumSwapsToOrder([3, 1, 2]) == 2)\nassert(minimumSwapsToOrder([4, 5, 1, 3, 2]) == 7)\nassert(minimumSwapsToOrder([1]) == 0)\n}\n\ncheck(minimumSwapsToOrder)", "entry_point": "minimumSwapsToOrder", "signature": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {", "docstring": "\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n", "instruction": "Write a Swift function `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` to solve the following problem:\n\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n", "level": "middle"}
{"task_id": "Swift/32", "prompt": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/", "canonical_solution": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}", "test": "func testIsLuckyWord() {\nassert(isLuckyWord(\"hello\") == (false, 0))\nassert(isLuckyWord(\"swift\") == (false, 0))\nassert(isLuckyWord(\"programming\") == (false, 0))\nassert(isLuckyWord(\"apple\") == (false, 0))\nassert(isLuckyWord(\"banana\") == (true, 2))\nassert(isLuckyWord(\"challenge\") == (false, 0))\nassert(isLuckyWord(\"developer\") == (true, 2))\n}\n\ntestIsLuckyWord()", "entry_point": "isLuckyWord", "signature": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {", "docstring": "\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n", "instruction": "Write a Swift function `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` to solve the following problem:\n\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n", "level": "hard"}
{"task_id": "Swift/33", "prompt": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n*/", "canonical_solution": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}", "test": "func check(_ maxSubArraySum: ([Int]) -> Int) {\nassert(maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9)\nassert(maxSubArraySum([-2, -3, -1]) == -1)\nassert(maxSubArraySum([5, -3, 5]) == 7)\nassert(maxSubArraySum([-1, -2, -3, -4]) == -1)\nassert(maxSubArraySum([2, 3, -2, 5, -3]) == 8)\nassert(maxSubArraySum([10, -11, 12]) == 12)\nassert(maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6)\n}\n\ncheck(maxSubArraySum)", "entry_point": "maxSubArraySum", "signature": "func maxSubArraySum(_ nums: [Int]) -> Int {", "docstring": "\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n", "instruction": "Write a Swift function `func maxSubArraySum(_ nums: [Int]) -> Int {` to solve the following problem:\n\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n", "level": "easy"}
{"task_id": "Swift/34", "prompt": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/", "canonical_solution": "let decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}", "test": "func check(_ convertNumber: (Int, String, Int) -> String) {\nassert(convertNumber(10, \"255\", 2) == \"11111111\")\nassert(convertNumber(2, \"1010\", 10) == \"10\")\nassert(convertNumber(8, \"175\", 16) == \"7D\")\nassert(convertNumber(16, \"1A\", 10) == \"26\")\nassert(convertNumber(2, \"1111\", 16) == \"F\")\nassert(convertNumber(16, \"FF\", 8) == \"377\")\nassert(convertNumber(10, \"1000\", 16) == \"3E8\")\n}\n\ncheck(convertNumber)", "entry_point": "convertNumber", "signature": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {", "docstring": "\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n", "instruction": "Write a Swift function `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` to solve the following problem:\n\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n", "level": "easy"}
{"task_id": "Swift/35", "prompt": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/", "canonical_solution": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}", "test": "func testKthUniqueSmallestNumber() {\nassert(kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2) == \"3\")\nassert(kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4) == \"4\")\nassert(kthUniqueSmallestNumber([10, 20, 30], 4) == \"NO RESULT\")\nassert(kthUniqueSmallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == \"7\")\nassert(kthUniqueSmallestNumber([12, 15, 12, 18, 20, 22, 15, 18], 3) == \"18\")\nassert(kthUniqueSmallestNumber([3, 3, 3, 3, 3], 1) == \"3\")\nassert(kthUniqueSmallestNumber([40, 30, 20, 10], 2) == \"20\")\n}\n\ntestKthUniqueSmallestNumber()", "entry_point": "kthUniqueSmallestNumber", "signature": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {", "docstring": "\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n", "instruction": "Write a Swift function `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` to solve the following problem:\n\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n", "level": "easy"}
{"task_id": "Swift/36", "prompt": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/", "canonical_solution": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}", "test": "func check(_ findShortestDistanceAmongPoints: ([(Double, Double)]) -> Double) {\nassert(findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]) == 1.0000)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)]) == 1.4142)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (5.0, 5.0), (1.0, 6.0), (2.0, 1.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(2.0, 3.0), (4.0, 4.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(1.5, 1.5), (3.5, 3.5), (5.5, 5.5)]) == 2.8284)\n}\n\ncheck(findShortestDistanceAmongPoints)", "entry_point": "findShortestDistanceAmongPoints", "signature": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {", "docstring": "\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n", "instruction": "Write a Swift function `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` to solve the following problem:\n\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n", "level": "hard"}
{"task_id": "Swift/37", "prompt": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/", "canonical_solution": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}", "test": "func check(_ countMealCombinations: ([Int], Int) -> Int) {\nassert(countMealCombinations([1, 2, 3], 4) == 1)\nassert(countMealCombinations([1, 1, 3, 4, 5], 5) == 4)\nassert(countMealCombinations([2, 2, 2, 2], 8) == 1)\nassert(countMealCombinations([1, 1, 1, 1, 1], 3) == 10)\nassert(countMealCombinations([5, 5, 5, 5, 5], 10) == 10)\nassert(countMealCombinations([10, 15, 20], 25) == 1)\nassert(countMealCombinations([1, 3, 4, 6], 9) == 1)\n}\n\ncheck(countMealCombinations)", "entry_point": "countMealCombinations", "signature": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {", "docstring": "\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n", "instruction": "Write a Swift function `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` to solve the following problem:\n\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n", "level": "easy"}
{"task_id": "Swift/38", "prompt": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/", "canonical_solution": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}", "test": "func check(_ latestDepartureTime: (Int, Int) -> String) {\nassert(latestDepartureTime(100, 10) == \"07:40\")\nassert(latestDepartureTime(50, 25) == \"07:48\")\nassert(latestDepartureTime(120, 60) == \"07:48\")\nassert(latestDepartureTime(80, 20) == \"07:46\")\nassert(latestDepartureTime(200, 40) == \"07:45\")\nassert(latestDepartureTime(90, 30) == \"07:47\")\n}\n\ncheck(latestDepartureTime)", "entry_point": "latestDepartureTime", "signature": "func latestDepartureTime(distance: Int, speed: Int) -> String {", "docstring": "\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n", "instruction": "Write a Swift function `func latestDepartureTime(distance: Int, speed: Int) -> String {` to solve the following problem:\n\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n", "level": "hard"}
{"task_id": "Swift/39", "prompt": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/", "canonical_solution": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}", "test": "func testCalculateFinalScore() {\nassert(calculateFinalScore([10.0, 8.5, 9.0, 9.5, 10.0]) == 9.50)\nassert(calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5]) == 7.00)\nassert(calculateFinalScore([5.0, 5.5, 6.0, 5.5, 5.0]) == 5.33)\nassert(calculateFinalScore([]) == 0.0)\n}\n\ntestCalculateFinalScore()", "entry_point": "calculateFinalScore", "signature": "func calculateFinalScore(_ scores: [Double]) -> Double {", "docstring": "\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n", "instruction": "Write a Swift function `func calculateFinalScore(_ scores: [Double]) -> Double {` to solve the following problem:\n\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n", "level": "middle"}
{"task_id": "Swift/40", "prompt": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/", "canonical_solution": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}", "test": "func testMinimumTasteDifference() {\nassert(minimumTasteDifference([(3, 10)]) == 7)\nassert(minimumTasteDifference([(3, 8), (5, 8)]) == 1)\nassert(minimumTasteDifference([(1, 2), (2, 3), (3, 4)]) == 1)\nassert(minimumTasteDifference([(2, 4), (3, 6)]) == 2)\nassert(minimumTasteDifference([(1, 3), (2, 5), (4, 1)]) == 0)\n}\n\ntestMinimumTasteDifference()", "entry_point": "minimumTasteDifference", "signature": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {", "docstring": "\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n", "instruction": "Write a Swift function `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` to solve the following problem:\n\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n", "level": "hard"}
{"task_id": "Swift/41", "prompt": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calculates the product of the sum of the first two integers and the third integer.\n\n    This function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n    - Parameters:\n        - a: The first integer.\n        - b: The second integer.\n        - c: The third integer.\n\n    - Returns: An integer that is the product of (a+b) and c.\n\n    ### Example:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n    */", "canonical_solution": "    return (a + b) * c\n}", "test": "func testCalculateProductOfSumAndValue() {\n    assert(calculateProductOfSumAndValue(1, 2, 3) == 9, \"Test Case 1 Failed\")\n    assert(calculateProductOfSumAndValue(-1, 2, 3) == 3, \"Test Case 2 Failed\")\n    assert(calculateProductOfSumAndValue(-1, -2, -3) == 9, \"Test Case 3 Failed\")\n    assert(calculateProductOfSumAndValue(0, 0, 1) == 0, \"Test Case 4 Failed\")\n    assert(calculateProductOfSumAndValue(10, 20, 30) == 900, \"Test Case 5 Failed\")\n    assert(calculateProductOfSumAndValue(-5, 5, 0) == 0, \"Test Case 6 Failed\")\n    assert(calculateProductOfSumAndValue(100, 200, -1) == -300, \"Test Case 7 Failed\")\n}\n\ntestCalculateProductOfSumAndValue()", "entry_point": "calculateProductOfSumAndValue", "signature": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {", "docstring": "\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n", "instruction": "Write a Swift function `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` to solve the following problem:\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n", "level": "easy"}
{"task_id": "Swift/42", "prompt": "func asciiCode(of character: Character) -> Int {\n    /**\n    Returns the ASCII code of the given character.\n\n    This function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n    - Parameter character: A `Character` value representing a visible character (excluding space).\n\n    - Returns: An `Int` representing the ASCII code of the given character.\n\n    ### Example:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */", "canonical_solution": "    return Int(character.asciiValue!)\n}", "test": "func testAsciiCode() {\n    assert(asciiCode(of: \"A\") == 65, \"Test Case 1 Failed\")\n    assert(asciiCode(of: \"a\") == 97, \"Test Case 2 Failed\")\n    assert(asciiCode(of: \"0\") == 48, \"Test Case 3 Failed\")\n    assert(asciiCode(of: \"#\") == 35, \"Test Case 4 Failed\")\n    assert(asciiCode(of: \"Z\") == 90, \"Test Case 5 Failed\")\n    assert(asciiCode(of: \"z\") == 122, \"Test Case 6 Failed\")\n}\n\ntestAsciiCode()", "entry_point": "asciiCode", "signature": "func asciiCode(of character: Character) -> Int {", "docstring": "\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n", "instruction": "Write a Swift function `func asciiCode(of character: Character) -> Int {` to solve the following problem:\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n", "level": "easy"}
{"task_id": "Swift/43", "prompt": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Returns the character corresponding to the given ASCII code.\n\n    This function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n    - Parameter code: An `Int` value representing the ASCII code.\n\n    - Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n    ### Example:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */", "canonical_solution": "    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}", "test": "func testCharacterForAsciiCode() {\n    assert(characterForAsciiCode(65) == \"A\", \"Test Case 1 Failed\")\n    assert(characterForAsciiCode(97) == \"a\", \"Test Case 2 Failed\")\n    assert(characterForAsciiCode(48) == \"0\", \"Test Case 3 Failed\")\n    assert(characterForAsciiCode(35) == \"#\", \"Test Case 4 Failed\")\n    assert(characterForAsciiCode(90) == \"Z\", \"Test Case 5 Failed\")\n    assert(characterForAsciiCode(122) == \"z\", \"Test Case 6 Failed\")\n}\n\ntestCharacterForAsciiCode()", "entry_point": "characterForAsciiCode", "signature": "func characterForAsciiCode(_ code: Int) -> Character? {", "docstring": "\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n", "instruction": "Write a Swift function `func characterForAsciiCode(_ code: Int) -> Character? {` to solve the following problem:\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n", "level": "easy"}
{"task_id": "Swift/44", "prompt": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Converts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n    - Parameters:\n        - value: An integer value to be converted to boolean and back to integer.\n\n    - Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n    ### Example:\n    - `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n    - `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n    - `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n    */", "canonical_solution": "    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}", "test": "func testConvertIntToBoolToInt() {\n    assert(convertIntToBoolToInt(5) == 1, \"Conversion of 5 should return 1.\")\n    assert(convertIntToBoolToInt(0) == 0, \"Conversion of 0 should return 0.\")\n    assert(convertIntToBoolToInt(-10) == 1, \"Conversion of -10 should return 1.\")\n    assert(convertIntToBoolToInt(1) == 1, \"Conversion of 1 should return 1.\")\n    assert(convertIntToBoolToInt(-1) == 1, \"Conversion of -1 should return 1.\")\n    assert(convertIntToBoolToInt(100) == 1, \"Conversion of 100 should return 1.\")\n    assert(convertIntToBoolToInt(-100) == 1, \"Conversion of -100 should return 1.\")\n}\n\n// Call the test function to verify the functionality\ntestConvertIntToBoolToInt()", "entry_point": "convertIntToBoolToInt", "signature": "func convertIntToBoolToInt(_ value: Int) -> Int {", "docstring": "\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n", "instruction": "Write a Swift function `func convertIntToBoolToInt(_ value: Int) -> Int {` to solve the following problem:\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n", "level": "easy"}
{"task_id": "Swift/45", "prompt": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Reverses a three-digit number and returns the result.\n\n    - Parameters:\n        - number: A three-digit integer to be reversed.\n\n    - Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n    ### Examples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Note: The function assumes the input is always a three-digit number.\n    */", "canonical_solution": "    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}", "test": "func testReverseThreeDigitNumber() {\n    assert(reverseThreeDigitNumber(123) == 321, \"Reverse of 123 should be 321.\")\n    assert(reverseThreeDigitNumber(456) == 654, \"Reverse of 456 should be 654.\")\n    assert(reverseThreeDigitNumber(789) == 987, \"Reverse of 789 should be 987.\")\n    assert(reverseThreeDigitNumber(100) == 1, \"Reverse of 100 should be 1.\")\n    assert(reverseThreeDigitNumber(905) == 509, \"Reverse of 905 should be 509.\")\n    assert(reverseThreeDigitNumber(999) == 999, \"Reverse of 999 should be 999.\")\n    assert(reverseThreeDigitNumber(210) == 12, \"Reverse of 210 should be 12.\")\n}\n\n// Call the test function to verify the functionality\ntestReverseThreeDigitNumber()", "entry_point": "reverseThreeDigitNumber", "signature": "func reverseThreeDigitNumber(_ number: Int) -> Int {", "docstring": "\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n", "instruction": "Write a Swift function `func reverseThreeDigitNumber(_ number: Int) -> Int {` to solve the following problem:\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n", "level": "middle"}
{"task_id": "Swift/46", "prompt": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calculates the nth term of an arithmetic sequence given its first two terms.\n\n    - Parameters:\n        - a1: The first term of the arithmetic sequence.\n        - a2: The second term of the arithmetic sequence.\n        - n: The position of the term in the sequence to be found (1-based index).\n\n    - Returns: The nth term of the arithmetic sequence.\n\n    ### Example:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\n    Note: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */", "canonical_solution": "    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}", "test": "func testArithmeticSequenceLastTerm() {\n    assert(arithmeticSequenceLastTerm(1, 4, 100) == 298, \"The 100th term should be 298.\")\n    assert(arithmeticSequenceLastTerm(5, 9, 20) == 81, \"The 20th term should be 77.\")\n    assert(arithmeticSequenceLastTerm(-3, 1, 10) == 33, \"The 10th term should be 33.\")\n    assert(arithmeticSequenceLastTerm(0, 2, 50) == 98, \"The 50th term should be 98.\")\n    assert(arithmeticSequenceLastTerm(-100, -97, 1000) == 2897, \"The 1000th term should be 2897.\")\n    assert(arithmeticSequenceLastTerm(2, 5, 3) == 8, \"The 3rd term should be 8.\")\n}\n\n// Call the test function to verify the functionality\ntestArithmeticSequenceLastTerm()", "entry_point": "arithmeticSequenceLastTerm", "signature": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {", "docstring": "\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n", "instruction": "Write a Swift function `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` to solve the following problem:\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n", "level": "easy"}
{"task_id": "Swift/47", "prompt": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calculates the product of two positive integers.\n\n    - Parameters:\n        - a: The first positive integer.\n        - b: The second positive integer.\n        - Both `a` and `b` should be in the range of 1 to 50,000.\n\n    - Returns: The product of `a` and `b` as an integer.\n\n    ### Example:\n    - `multiply(3, 4)` returns `12`.\n    - `multiply(10, 5)` returns `50`.\n    - `multiply(36, 18)` returns `648`.\n\n    Note: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n    */", "canonical_solution": "    return a * b\n}", "test": "func testMultiply() {\n    assert(multiply(3, 4) == 12, \"Product of 3 and 4 should be 12.\")\n    assert(multiply(10, 5) == 50, \"Product of 10 and 5 should be 50.\")\n    assert(multiply(36, 18) == 648, \"Product of 36 and 18 should be 648.\")\n    assert(multiply(1, 50000) == 50000, \"Product of 1 and 50000 should be 50000.\")\n    assert(multiply(123, 456) == 56088, \"Product of 123 and 456 should be 56088.\")\n    assert(multiply(500, 100) == 50000, \"Product of 500 and 100 should be 50000.\")\n}\n\n// Call the test function to verify the functionality\ntestMultiply()", "entry_point": "multiply", "signature": "func multiply(_ a: Int, _ b: Int) -> Int {", "docstring": "\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n", "instruction": "Write a Swift function `func multiply(_ a: Int, _ b: Int) -> Int {` to solve the following problem:\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n", "level": "easy"}
{"task_id": "Swift/48", "prompt": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calculates the power of 2 for a given non-negative integer.\n\n    - Parameters:\n        - n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n    - Returns: The result of 2 raised to the power of `n`.\n\n    ### Example:\n    - `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n    - `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n    - `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\n    Note: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n    */", "canonical_solution": "    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}", "test": "func testPowerOfTwo() {\n    assert(powerOfTwo(3) == 8, \"2^3 should be 8.\")\n    assert(powerOfTwo(5) == 32, \"2^5 should be 32.\")\n    assert(powerOfTwo(10) == 1024, \"2^10 should be 1024.\")\n    assert(powerOfTwo(0) == 1, \"2^0 should be 1.\")\n    assert(powerOfTwo(15) == 32768, \"2^15 should be 32768.\")\n    assert(powerOfTwo(30) == 1073741824, \"2^30 should be 1073741824.\")\n}\n\n// Call the test function to verify the functionality\ntestPowerOfTwo()", "entry_point": "powerOfTwo", "signature": "func powerOfTwo(_ n: Int) -> Int {", "docstring": "\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n", "instruction": "Write a Swift function `func powerOfTwo(_ n: Int) -> Int {` to solve the following problem:\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n", "level": "easy"}
{"task_id": "Swift/49", "prompt": "func determineSign(_ n: Int) -> String {\n    /**\n    Determines if a given integer is positive, zero, or negative.\n\n    - Parameters:\n        - n: An integer value that can range from -10^9 to 10^9.\n\n    - Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n    ### Example:\n    - `determineSign(3)` returns `\"positive\"`.\n    - `determineSign(0)` returns `\"zero\"`.\n    - `determineSign(-5)` returns `\"negative\"`.\n\n    Note: This function accurately classifies any integer within the specified range into one of the three categories.\n    */", "canonical_solution": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}", "test": "func testDetermineSign() {\n    assert(determineSign(3) == \"positive\", \"3 should be positive.\")\n    assert(determineSign(0) == \"zero\", \"0 should be zero.\")\n    assert(determineSign(-5) == \"negative\", \"-5 should be negative.\")\n    assert(determineSign(1000000000) == \"positive\", \"1000000000 should be positive.\")\n    assert(determineSign(-1000000000) == \"negative\", \"-1000000000 should be negative.\")\n    assert(determineSign(1) == \"positive\", \"1 should be positive.\")\n}\n\n// Call the test function to verify the functionality\ntestDetermineSign()", "entry_point": "determineSign", "signature": "func determineSign(_ n: Int) -> String {", "docstring": "\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n", "instruction": "Write a Swift function `func determineSign(_ n: Int) -> String {` to solve the following problem:\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n", "level": "easy"}
{"task_id": "Swift/50", "prompt": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calculates and returns the absolute value of a given integer.\n\n    - Parameters:\n        - n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n    - Returns: The absolute value of `n`.\n\n    ### Example:\n    - `absoluteValue(-3)` returns `3`.\n    - `absoluteValue(5)` returns `5`.\n    - `absoluteValue(0)` returns `0`.\n    - `absoluteValue(-10000)` returns `10000`.\n\n    Note: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n    */", "canonical_solution": "    return abs(n)\n}", "test": "func testAbsoluteValue() {\n    assert(absoluteValue(-3) == 3, \"-3's absolute value should be 3.\")\n    assert(absoluteValue(5) == 5, \"5's absolute value should be 5.\")\n    assert(absoluteValue(0) == 0, \"0's absolute value should be 0.\")\n    assert(absoluteValue(-10000) == 10000, \"-10000's absolute value should be 10000.\")\n    assert(absoluteValue(10000) == 10000, \"10000's absolute value should be 10000.\")\n    assert(absoluteValue(-1) == 1, \"-1's absolute value should be 1.\")\n}\n\n// Call the test function to verify the functionality\ntestAbsoluteValue()", "entry_point": "absoluteValue", "signature": "func absoluteValue(_ n: Int) -> Int {", "docstring": "\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n", "instruction": "Write a Swift function `func absoluteValue(_ n: Int) -> Int {` to solve the following problem:\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n", "level": "easy"}
