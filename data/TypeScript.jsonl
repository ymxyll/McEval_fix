{"task_id": "TypeScript/1", "prompt": "\n// return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string", "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}", "test": "(() => {\n    console.assert(hello_mmcodeeval() === \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n})();", "entry_point": "hello_mmcodeeval", "signature": "function hello_mmcodeeval(): string", "docstring": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "instruction": "Write a TypeScript function `function hello_mmcodeeval(): string` to solve the following problem:\nreturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "level": "easy"}
{"task_id": "TypeScript/2", "prompt": "\n/**\n * Calculate the area of a triangle given its three sides.\n * \n * @param a - Length of side 'a'.\n * @param b - Length of side 'b'.\n * @param c - Length of side 'c'.\n * @returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n *          Otherwise, return \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number", "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        const s: number = (a + b + c) / 2.0;\n        return parseFloat(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}", "test": "(() => {\n    let area: number;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculateTriangleArea(3, 5, 4);\n    console.assert(Math.abs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should return \"-1\"\n    area = calculateTriangleArea(1, 1, 4);\n    console.assert(area === -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculateTriangleArea(7, 24, 25);\n    console.assert(Math.abs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculateTriangleArea(10.5, 6.2, 7.3);\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    console.assert(Math.abs(area - 22.15) < 1e-2);\n\n    // console.log(\"All tests passed successfully.\");\n})();", "entry_point": "calculateTriangleArea", "signature": "function calculateTriangleArea(a: number, b: number, c: number): number", "docstring": "Calculate the area of a triangle given its three sides.\n\n@param a - Length of side 'a'.\n@param b - Length of side 'b'.\n@param c - Length of side 'c'.\n@returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n         Otherwise, return \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6", "instruction": "Write a TypeScript function `function calculateTriangleArea(a: number, b: number, c: number): number` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\n@param a - Length of side 'a'.\n@param b - Length of side 'b'.\n@param c - Length of side 'c'.\n@returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n         Otherwise, return \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6", "level": "easy"}
{"task_id": "TypeScript/3", "prompt": "\n/**\n * Calculate the value of the function for a given input.\n * \n * Parameters:\n * - x (number): Input value for the function.\n * \n * Returns:\n * - string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n * \n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Example usage:\n * calculateFunctionValue(40); // Returns \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string", "canonical_solution": "{\n    let y: number;\n\n    if (0 <= x && x < 10) {\n        y = Math.cos(x + 3.0);\n        return y.toFixed(5);\n    } else if (10 <= x && x < 20) {\n        y = Math.cos(x + 7.5);\n        return (y * y).toFixed(5);\n    } else if (20 <= x && x < 30) {\n        y = Math.cos(x + 4.0);\n        return Math.pow(y, 4).toFixed(5);\n    } else {\n        return \"Not define\";\n    }\n}", "test": "function testCalculateFunctionValue(): void {\n    console.assert(calculateFunctionValue(40) === \"Not define\", \"Test failed: x = 40 should be 'Not define'\");\n    console.assert(calculateFunctionValue(5) === \"-0.14550\", \"Test failed: x = 5 should be '-0.14550'\");\n    console.assert(calculateFunctionValue(15) === \"0.76266\", \"Test failed: x = 15 should be '0.76266'\");\n    console.assert(calculateFunctionValue(25) === \"0.31314\", \"Test failed: x = 25 should be '0.31314'\");\n    console.assert(calculateFunctionValue(-1) === \"Not define\", \"Test failed: x = -1 should be 'Not define'\");\n}\n\ntestCalculateFunctionValue();", "entry_point": "calculateFunctionValue", "signature": "function calculateFunctionValue(x: number): string", "docstring": "Calculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\n  Otherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample usage:\ncalculateFunctionValue(40); // Returns \"Not define\"\n", "instruction": "Write a TypeScript function `function calculateFunctionValue(x: number): string` to solve the following problem:\nCalculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\n  Otherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample usage:\ncalculateFunctionValue(40); // Returns \"Not define\"\n", "level": "middle"}
{"task_id": "TypeScript/4", "prompt": "\n/**\n * Find the maximum and minimum of three distinct integers.\n *\n * @param a - The first integer.\n * @param b - The second integer.\n * @param c - The third integer.\n * @returns A tuple containing the maximum and minimum values respectively.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]", "canonical_solution": "{\n    let max: number;\n    let min: number;\n\n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = b < c ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = a < c ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return [max, min];\n}", "test": "(() => {\n    let max: number, min: number, result: [number, number];\n\n    result = findMaxMin(1, 2, 3);\n    [max, min] = result;\n    console.assert(max === 3 && min === 1, 'Test failed for input (1, 2, 3)');\n\n    // Additional tests\n    result = findMaxMin(5, 3, 4);\n    [max, min] = result;\n    console.assert(max === 5 && min === 3, 'Test failed for input (5, 3, 4)');\n\n    result = findMaxMin(10, -2, 7);\n    [max, min] = result;\n    console.assert(max === 10 && min === -2, 'Test failed for input (10, -2, 7)');\n\n    result = findMaxMin(-1, -3, -2);\n    [max, min] = result;\n    console.assert(max === -1 && min === -3, 'Test failed for input (-1, -3, -2)');\n})();", "entry_point": "findMaxMin", "signature": "function findMaxMin(a: number, b: number, c: number): [number, number]", "docstring": "Find the maximum and minimum of three distinct integers.\n\n@param a - The first integer.\n@param b - The second integer.\n@param c - The third integer.\n@returns A tuple containing the maximum and minimum values respectively.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);", "instruction": "Write a TypeScript function `function findMaxMin(a: number, b: number, c: number): [number, number]` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\n@param a - The first integer.\n@param b - The second integer.\n@param c - The third integer.\n@returns A tuple containing the maximum and minimum values respectively.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);", "level": "middle"}
{"task_id": "TypeScript/5", "prompt": "\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * @param xa - x-coordinate of point A\n * @param ya - y-coordinate of point A\n * @param xb - x-coordinate of point B\n * @param yb - y-coordinate of point B\n * @returns The distance between points A and B\n * \n * Example:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number", "canonical_solution": "{\n    return Math.sqrt((xa - xb) ** 2 + (ya - yb) ** 2);\n}", "test": "const testCalculateDistance = (): void => {\n    console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6);\n    console.assert(Math.abs(calculateDistance(0, 0, 0, 0) - 0) < 1e-6);\n    console.assert(Math.abs(calculateDistance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    console.assert(Math.abs(calculateDistance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    // console.log(\"All test cases passed!\");\n};\n\ntestCalculateDistance();", "entry_point": "calculateDistance", "signature": "function calculateDistance(xa: number, ya: number, xb: number, yb: number): number", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\n@param xa - x-coordinate of point A\n@param ya - y-coordinate of point A\n@param xb - x-coordinate of point B\n@param yb - y-coordinate of point B\n@returns The distance between points A and B\n\nExample:\ncalculateDistance(0, 0, 3, 4) === 5", "instruction": "Write a TypeScript function `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\n@param xa - x-coordinate of point A\n@param ya - y-coordinate of point A\n@param xb - x-coordinate of point B\n@param yb - y-coordinate of point B\n@returns The distance between points A and B\n\nExample:\ncalculateDistance(0, 0, 3, 4) === 5", "level": "easy"}
{"task_id": "TypeScript/6", "prompt": "\n/**\n * Finds the factorial of N and applies modulo 10007 to the result.\n *\n * Parameters:\n * - N (number): A non-negative integer (N <= 10000).\n *\n * Returns:\n * - number: The factorial of N modulo 10007.\n *\n * Examples:\n * processRequest(1) // returns 1\n * processRequest(2) // returns 2\n * processRequest(10) // returns 6266\n */\nfunction processRequest(n: number): number", "canonical_solution": "{\n    let a: number[] = Array(10001).fill(0);\n    a[0] = 1;\n    a[1] = 1;\n    for (let i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}", "test": "const testProcessRequest = () => {\n    console.assert(processRequest(0) === 1, \"processRequest(0) should return 1\"); // Added test for boundary condition\n    console.assert(processRequest(1) === 1, \"processRequest(1) should return 1\");\n    console.assert(processRequest(2) === 2, \"processRequest(2) should return 2\");\n    console.assert(processRequest(3) === 6, \"processRequest(3) should return 6\");\n    console.assert(processRequest(4) === 24, \"processRequest(4) should return 24\");\n    console.assert(processRequest(10) === 6266, \"processRequest(10) should return 6266\"); // 10! % 10007 = 3628800 % 10007 = 6266\n    console.assert(processRequest(10000) === 6991, \"processRequest(10000) should return 6991\"); // Added a test for upper boundary condition\n};\n\ntestProcessRequest();", "entry_point": "processRequest", "signature": "function processRequest(n: number): number", "docstring": "Finds the factorial of N and applies modulo 10007 to the result.\n\nParameters:\n- N (number): A non-negative integer (N <= 10000).\n\nReturns:\n- number: The factorial of N modulo 10007.\n\nExamples:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266", "instruction": "Write a TypeScript function `function processRequest(n: number): number` to solve the following problem:\nFinds the factorial of N and applies modulo 10007 to the result.\n\nParameters:\n- N (number): A non-negative integer (N <= 10000).\n\nReturns:\n- number: The factorial of N modulo 10007.\n\nExamples:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266", "level": "easy"}
{"task_id": "TypeScript/7", "prompt": "\n/**\n * Calculate the area of a triangle given its base and height.\n * \n * @param base The base length of the triangle.\n * @param height The height of the triangle.\n * \n * @returns The calculated area of the triangle, rounded to one decimal place.\n * \n * Examples:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number", "canonical_solution": "{\n    return (base * height) / 2.0;\n}", "test": "const testCalculateTriangleArea = () => {\n    // The equivalent of C's assertion with a floating-point comparison in TypeScript.\n    const assertCloseTo = (value: number, expected: number, tolerance: number = 1e-6) => {\n        console.assert(Math.abs(value - expected) < tolerance);\n    };\n\n    assertCloseTo(calculateTriangleArea(1, 2), 1.0);\n    assertCloseTo(calculateTriangleArea(3, 4), 6.0);\n    assertCloseTo(calculateTriangleArea(5, 8), 20.0);\n    assertCloseTo(calculateTriangleArea(7, 3), 10.5);\n    assertCloseTo(calculateTriangleArea(10, 10), 50.0);\n\n    // Uncomment to log the outcome to the console.\n    // console.log(\"All tests passed.\");\n};\n\ntestCalculateTriangleArea();", "entry_point": "calculateTriangleArea", "signature": "function calculateTriangleArea(base: number, height: number): number", "docstring": "Calculate the area of a triangle given its base and height.\n\n@param base The base length of the triangle.\n@param height The height of the triangle.\n\n@returns The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0\n", "instruction": "Write a TypeScript function `function calculateTriangleArea(base: number, height: number): number` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n\n@param base The base length of the triangle.\n@param height The height of the triangle.\n\n@returns The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0\n", "level": "easy"}
{"task_id": "TypeScript/8", "prompt": "\n/**\n * Calculate the Hamming distance between two integers in binary representation.\n * Parameters:\n * - x (number): The first positive integer (x <= 1,000,000,000).\n * - y (number): The second positive integer (y <= 1,000,000,000).\n * Returns:\n * - number: The Hamming distance between x and y, i.e., the number of bits\n *           that need to be flipped to transform x into y in binary.\n * Example usage:\n *   hamming_distance(1, 2); // returns 2\n *   hamming_distance(4, 7); // returns 2\n */\nfunction hamming_distance(x: number, y: number): number", "canonical_solution": "{\n    let distance = 0;\n    let xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n\n    // Count the number of bits set in xor_result\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>>= 1;\n    }\n\n    return distance;\n}", "test": "(() => {\n    console.assert(hamming_distance(1, 2) === 2, '01 and 10 have 2 different bits');\n    console.assert(hamming_distance(4, 7) === 2, '100 and 111 have 2 different bits');\n    console.assert(hamming_distance(25, 30) === 3, '11001 and 11110 have 3 different bits');\n    console.assert(hamming_distance(0, 0) === 0, 'Same numbers have 0 different bits');\n    console.assert(hamming_distance(0xFFFFFFF, 0) === 28, 'Max unsigned int and 0 have 28 different bits');\n\n    // If no assertion fails, log success message to the console\n    // console.log(\"All tests passed!\");\n})();", "entry_point": "hamming_distance", "signature": "function hamming_distance(x: number, y: number): number", "docstring": "Calculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): The first positive integer (x <= 1,000,000,000).\n- y (number): The second positive integer (y <= 1,000,000,000).\nReturns:\n- number: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\nExample usage:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2", "instruction": "Write a TypeScript function `function hamming_distance(x: number, y: number): number` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): The first positive integer (x <= 1,000,000,000).\n- y (number): The second positive integer (y <= 1,000,000,000).\nReturns:\n- number: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\nExample usage:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2", "level": "easy"}
{"task_id": "TypeScript/9", "prompt": "\n/**\n * Counts the number of odd integers in a given list of numbers.\n * \n * @param count - The count of numbers to evaluate.\n * @param numbers - A list of integers to be checked for oddness.\n * @returns The count of odd numbers in the input list.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number", "canonical_solution": "{\n    let ans = 0;\n    numbers.slice(0, count).forEach(num => {\n        if (num % 2 === 1)\n            ans++;\n    });\n    return ans;\n}", "test": "const testCountOddNumbers = (): void => {\n    console.assert(countOddNumbers(5, [1, 4, 3, 2, 5]) === 3, \"Test 1 failed\");\n    console.assert(countOddNumbers(4, [2, 2, 0, 0]) === 0, \"Test 2 failed\");\n    console.assert(countOddNumbers(6, [7, 7, 8, 1, 9, 10]) === 4, \"Test 3 failed\");\n    // console.log(\"All tests passed!\");\n};\n\ntestCountOddNumbers();", "entry_point": "countOddNumbers", "signature": "function countOddNumbers(count: number, numbers: number[]): number", "docstring": "Counts the number of odd integers in a given list of numbers.\n\n@param count - The count of numbers to evaluate.\n@param numbers - A list of integers to be checked for oddness.\n@returns The count of odd numbers in the input list.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```", "instruction": "Write a TypeScript function `function countOddNumbers(count: number, numbers: number[]): number` to solve the following problem:\nCounts the number of odd integers in a given list of numbers.\n\n@param count - The count of numbers to evaluate.\n@param numbers - A list of integers to be checked for oddness.\n@returns The count of odd numbers in the input list.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```", "level": "easy"}
{"task_id": "TypeScript/10", "prompt": "\n/**\n * Calculate the sum of even numbers in a given list.\n * \n * @param numbers An array of integers.\n * @param size The size of the array.\n * @returns The sum of even numbers in the input array.\n * \n * Examples:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Returns 4\n * calculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number", "canonical_solution": "{\n    let sum = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            sum += numbers[i];\n        }\n    }\n    return sum;\n}", "test": "(() => {\n    console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6, \"Test 1 failed\");\n    console.assert(calculateEvenSum([2, 2, 0, 0], 4) === 4, \"Test 2 failed\");\n    console.assert(calculateEvenSum([7, 11, 19], 3) === 0, \"Test 3 failed - no even numbers\");\n    console.assert(calculateEvenSum([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20), \"Test 4 failed - all even numbers\");\n    // console.log(\"All tests passed successfully.\");\n})();", "entry_point": "calculateEvenSum", "signature": "function calculateEvenSum(numbers: number[], size: number): number", "docstring": "Calculate the sum of even numbers in a given list.\n\n@param numbers An array of integers.\n@param size The size of the array.\n@returns The sum of even numbers in the input array.\n\nExamples:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)", "instruction": "Write a TypeScript function `function calculateEvenSum(numbers: number[], size: number): number` to solve the following problem:\nCalculate the sum of even numbers in a given list.\n\n@param numbers An array of integers.\n@param size The size of the array.\n@returns The sum of even numbers in the input array.\n\nExamples:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)", "level": "easy"}
{"task_id": "TypeScript/11", "prompt": "\n/**\n * Determine if two closed intervals intersect.\n * Args:\n *    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n *    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: true if the intervals intersect, false otherwise.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean", "canonical_solution": "{\n    return (c <= a && b <= d) ||\n           (a <= c && c <= b && b <= d) ||\n           (a <= c && d <= b) ||\n           (c <= a && a <= d && d <= b);\n}", "test": "(() => {\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === false);\n    // Additional test cases\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === true);\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === true);\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === false);\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === true);\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === false);\n})();", "entry_point": "areIntervalsIntersecting", "signature": "function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean", "docstring": "Determine if two closed intervals intersect.\nArgs:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\n    boolean: true if the intervals intersect, false otherwise.", "instruction": "Write a TypeScript function `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` to solve the following problem:\nDetermine if two closed intervals intersect.\nArgs:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\n    boolean: true if the intervals intersect, false otherwise.", "level": "easy"}
{"task_id": "TypeScript/12", "prompt": "\n/**\n * You are given three digits a, b, c. Two of them are equal, but the third one\n * is different from the other two. Find the value that occurs exactly once.\n * \n * Examples:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number", "canonical_solution": "{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}", "test": "(() => {\n    console.assert(extraNumber(2, 7, 2) === 7, \"Test 1 failed\");\n    console.assert(extraNumber(3, 2, 2) === 3, \"Test 2 failed\");\n    console.assert(extraNumber(5, 5, 1) === 1, \"Test 3 failed\");\n    console.assert(extraNumber(500000000, 3, 500000000) === 3, \"Test 4 failed\");\n    console.assert(extraNumber(500000000, 500000000, 3) === 3, \"Test 5 failed\");\n\n    // console.log(\"All tests passed!\");\n})();", "entry_point": "extraNumber", "signature": "function extraNumber(a: number, b: number, c: number): number", "docstring": "You are given three digits a, b, c. Two of them are equal, but the third one\nis different from the other two. Find the value that occurs exactly once.\n\nExamples:\nextraNumber(0, 0, 1) // returns 1\n", "instruction": "Write a TypeScript function `function extraNumber(a: number, b: number, c: number): number` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one\nis different from the other two. Find the value that occurs exactly once.\n\nExamples:\nextraNumber(0, 0, 1) // returns 1\n", "level": "easy"}
{"task_id": "TypeScript/13", "prompt": "\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n * @param score1 - The score for the first subject.\n * @param score2 - The score for the second subject.\n * @param score3 - The score for the third subject.\n * @param score4 - The score for the fourth subject.\n * @param score5 - The score for the fifth subject.\n * @returns The total score obtained by summing up the scores in all subjects.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number", "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "test": "const testCalculateTotalScore = (): void => {\n    console.assert(calculateTotalScore(100, 100, 100, 100, 100) === 500);\n    console.assert(calculateTotalScore(0, 0, 0, 0, 0) === 0);\n    console.assert(calculateTotalScore(20, 30, 40, 10, 50) === 150);\n    console.assert(calculateTotalScore(23, 45, 67, 89, 12) === 236);\n    console.assert(calculateTotalScore(5, 5, 5, 5, 5) === 25);\n};\n\ntestCalculateTotalScore();", "entry_point": "calculateTotalScore", "signature": "function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number", "docstring": "Calculate the total score for a student based on the scores in different subjects.\n@param score1 - The score for the first subject.\n@param score2 - The score for the second subject.\n@param score3 - The score for the third subject.\n@param score4 - The score for the fourth subject.\n@param score5 - The score for the fifth subject.\n@returns The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500", "instruction": "Write a TypeScript function `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n@param score1 - The score for the first subject.\n@param score2 - The score for the second subject.\n@param score3 - The score for the third subject.\n@param score4 - The score for the fourth subject.\n@param score5 - The score for the fifth subject.\n@returns The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500", "level": "easy"}
{"task_id": "TypeScript/14", "prompt": "\n/**\n * Decode a series of numbers to reveal the pattern and understand the actual values\n * each digit represents.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Parameters:\n * - dataStr: A string representing a series of numbers. Length does not exceed 100.\n *\n * Returns:\n * number: The result of each data string corresponding to the right-hand side of the equation.\n *\n * Example usage:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number", "canonical_solution": "{\n    const a: number[] = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans: number = 0;\n    \n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[parseInt(dataStr[i])];\n    }\n    \n    return ans;\n}", "test": "const testDecodeNumbers = (): void => {\n    console.assert(decodeNumbers(\"0000\") === 4);\n    console.assert(decodeNumbers(\"8888\") === 8);\n    console.assert(decodeNumbers(\"1234\") === 1);\n    console.assert(decodeNumbers(\"5678\") === 3);\n    console.assert(decodeNumbers(\"9012\") === 2);\n    console.assert(decodeNumbers(\"1357\") === 0);\n    console.assert(decodeNumbers(\"2468\") === 4);\n\n    // Additional test samples\n    console.assert(decodeNumbers(\"9999\") === 4);\n    console.assert(decodeNumbers(\"1111\") === 0);\n    console.assert(decodeNumbers(\"2222\") === 0);\n    console.assert(decodeNumbers(\"3333\") === 0);\n    console.assert(decodeNumbers(\"4444\") === 4);\n    console.assert(decodeNumbers(\"5555\") === 0);\n    console.assert(decodeNumbers(\"6666\") === 4);\n    console.assert(decodeNumbers(\"7777\") === 0);\n    console.assert(decodeNumbers(\"0001\") === 3);\n    console.assert(decodeNumbers(\"2301\") === 1);\n};\n\ntestDecodeNumbers();", "entry_point": "decodeNumbers", "signature": "function decodeNumbers(dataStr: string): number", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values\n each digit represents.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parameters:\n - dataStr: A string representing a series of numbers. Length does not exceed 100.\n\n Returns:\n number: The result of each data string corresponding to the right-hand side of the equation.\n\n Example usage:\n console.assert(decodeNumbers(\"0000\") === 4);", "instruction": "Write a TypeScript function `function decodeNumbers(dataStr: string): number` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values\n each digit represents.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parameters:\n - dataStr: A string representing a series of numbers. Length does not exceed 100.\n\n Returns:\n number: The result of each data string corresponding to the right-hand side of the equation.\n\n Example usage:\n console.assert(decodeNumbers(\"0000\") === 4);", "level": "easy"}
{"task_id": "TypeScript/15", "prompt": "\n/**\n * Counts the number of different coloring methods for `n` squares with `m` colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * Args:\n * - n (number): The number of squares.\n * - m (number): The number of colors.\n * \n * Returns:\n * - number: The count of different coloring methods satisfying the specified conditions.\n *           The result is modulo 1000003.\n * \n * Example calls:\n * ```\n * countColoringMethods(1, 1) // returns 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {", "canonical_solution": "const MOD = 1000003;\n    let f: number[] = new Array(n + 1); // Array to store results\n\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD + (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n\n    return f[n];\n}", "test": "function runTests() {\n    console.assert(countColoringMethods(1, 1) === 1);\n    console.assert(countColoringMethods(2, 2) === 2);\n    console.assert(countColoringMethods(3, 3) === 6);\n    console.assert(countColoringMethods(4, 2) === 2);\n    // The expected result for this case is not provided in the C code, but it is required to pass the test\n    console.assert(countColoringMethods(1000, 10) === 566585); \n\n    // Additional test cases.\n    console.assert(countColoringMethods(2, 3) === 6);\n    console.assert(countColoringMethods(1000, 1000) === 67911);\n    console.assert(countColoringMethods(999, 66) === 501817);\n    console.assert(countColoringMethods(5, 3) === 30); // Example of an expected output\n\n}\n\nrunTests();", "entry_point": "countColoringMethods", "signature": "function countColoringMethods(n: number, m: number): number", "docstring": "Counts the number of different coloring methods for `n` squares with `m` colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (number): The number of squares.\n- m (number): The number of colors.\n\nReturns:\n- number: The count of different coloring methods satisfying the specified conditions.\nThe result is modulo 1000003.\n\nExample calls:\ncountColoringMethods(1, 1) // returns 1\n", "instruction": "Write a TypeScript function `function countColoringMethods(n: number, m: number): number` to solve the following problem:\nCounts the number of different coloring methods for `n` squares with `m` colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (number): The number of squares.\n- m (number): The number of colors.\n\nReturns:\n- number: The count of different coloring methods satisfying the specified conditions.\nThe result is modulo 1000003.\n\nExample calls:\ncountColoringMethods(1, 1) // returns 1\n", "level": "middle"}
{"task_id": "TypeScript/16", "prompt": "\n/**\n * Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n * \n * @param n - The number of coin tosses.\n * @returns The count of valid sequences.\n * \n * Examples:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number", "canonical_solution": "{\n    let a: number[][] = Array.from({ length: n + 1 }, () => Array(2).fill(0));\n    a[1][0] = a[1][1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}", "test": "const testCountValidCoinTossSequences = (): void => {\n    console.assert(countValidCoinTossSequences(1) === 2);\n    console.assert(countValidCoinTossSequences(2) === 3);\n    console.assert(countValidCoinTossSequences(3) === 5);\n    console.assert(countValidCoinTossSequences(4) === 8); // Additional test\n    console.assert(countValidCoinTossSequences(5) === 13); // Additional test\n    // Feel free to add more tests here\n    console.assert(countValidCoinTossSequences(40) === 267914296); // Additional test\n    console.assert(countValidCoinTossSequences(39) === 165580141);\n    console.assert(countValidCoinTossSequences(38) === 102334155);\n    // Uncomment the next line to log a message on successful test pass\n    // console.log(\"All tests passed!\");\n};\n\ntestCountValidCoinTossSequences();", "entry_point": "countValidCoinTossSequences", "signature": "function countValidCoinTossSequences(n: number): number", "docstring": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - The number of coin tosses.\n@returns The count of valid sequences.\n\nExamples:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3\n", "instruction": "Write a TypeScript function `function countValidCoinTossSequences(n: number): number` to solve the following problem:\nCounts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - The number of coin tosses.\n@returns The count of valid sequences.\n\nExamples:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3\n", "level": "easy"}
{"task_id": "TypeScript/17", "prompt": "\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n *\n * Parameters:\n * - n (number): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n *\n * Returns:\n * - number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n *\n * Examples:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number", "canonical_solution": "{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1) {\n            ans++;\n        } else {\n            if (ans > max) {\n                max = ans;\n            }\n            ans = 0;\n        }\n        n >>>= 1; // In TypeScript, >>> is used for unsigned right shift\n    }\n    if (ans > max) {\n        max = ans;\n    }\n    return max;\n}", "test": "const testFindLongestConsecutiveOnesLength = (): void => {\n    console.assert(findLongestConsecutiveOnesLength(7) === 3, \"Failed on input 7\");\n    console.assert(findLongestConsecutiveOnesLength(13) === 2, \"Failed on input 13\");\n    console.assert(findLongestConsecutiveOnesLength(12345) === 3, \"Failed on input 12345\");\n    console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4, \"Failed on input 0b11011101111\");\n    console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32, \"Failed on input 0xFFFFFFFF\");\n    console.assert(findLongestConsecutiveOnesLength(0) === 0, \"Failed on input 0\");\n\n    // console.log(\"All tests passed!\");\n};\n\ntestFindLongestConsecutiveOnesLength();", "entry_point": "findLongestConsecutiveOnesLength", "signature": "function findLongestConsecutiveOnesLength(n: number): number", "docstring": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\n- number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0\n", "instruction": "Write a TypeScript function `function findLongestConsecutiveOnesLength(n: number): number` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 \u2264 n \u2264 2^64 - 1).\n\nReturns:\n- number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0\n", "level": "middle"}
{"task_id": "TypeScript/18", "prompt": "\n/**\n * Creates an ID by combining two words in a specific manner.\n * Parameters:\n * - word1 (string): The first word to be used in the ID.\n * - word2 (string): The second word to be used in the ID.\n * Returns:\n *  string: A unique ID formed by reversing every other character of the second\n *          word and combining it with the first word.\n * e.g.:\n *      createId('fish', 'cat')  // returns 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string", "canonical_solution": "{\n    let result: string[] = [];\n    let j: number = 0;\n    let k: number = word2.length - 1;\n\n    for (let i = 0; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            // Take character from word1\n            result.push(word1[j++]);\n        } else {\n            // Take character from word2 in reverse\n            result.push(word2[k--]);\n        }\n    }\n    return result.join('');\n}", "test": "const testCreateId = (): void => {\n    let id: string;\n\n    id = createId(\"fish\", \"cat\");\n    console.assert(id === \"ftiasch\", `Test failed: Expected ftiasch, got ${id}`);\n  \n    id = createId(\"icpc\", \"acm\");\n    console.assert(id === \"imccpac\", `Test failed: Expected imccpac, got ${id}`);\n  \n    id = createId(\"oo\", \"w\");\n    console.assert(id === \"owo\", `Test failed: Expected owo, got ${id}`);\n  \n    id = createId(\"hello\", \"world\");\n    console.assert(id === \"hdellrloow\", `Test failed: Expected hdellrloow, got ${id}`);\n  \n    id = createId(\"abc\", \"def\");\n    console.assert(id === \"afbecd\", `Test failed: Expected afbecd, got ${id}`);\n  \n    id = createId(\"buaanb\", \"nbbuaa\");\n    console.assert(id === \"bauaauabnbbn\", `Test failed: Expected bauaauabnbbn, got ${id}`);\n    \n    id = createId(\"xtuisgood\", \"ilovextu\");\n    console.assert(id === \"xuttuxiesvgooloid\", `Test failed: Expected xuttuxiesvgooloid, got ${id}`);\n};\n\ntestCreateId();", "entry_point": "createId", "signature": "function createId(word1: string, word2: string): string", "docstring": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\n string: A unique ID formed by reversing every other character of the second\n         word and combining it with the first word.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'\n", "instruction": "Write a TypeScript function `function createId(word1: string, word2: string): string` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\n string: A unique ID formed by reversing every other character of the second\n         word and combining it with the first word.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'\n", "level": "middle"}
{"task_id": "TypeScript/19", "prompt": "\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number", "canonical_solution": "{\n    let factorial = 1.0;\n    let i: number;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}", "test": "(() => {\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2);\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3);\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0);\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675);\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4);\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1);\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156);\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1);\n    // Add more test cases if necessary\n})();", "entry_point": "countPermutationsOfBinaryString", "signature": "function countPermutationsOfBinaryString(n: number, m: number): number", "docstring": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.", "instruction": "Write a TypeScript function `function countPermutationsOfBinaryString(n: number, m: number): number` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.", "level": "hard"}
{"task_id": "TypeScript/20", "prompt": "\n/**\n * Answer a series of questions by providing choices A, B, C, or D for each question.\n * Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n * Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n * Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n * Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n * \n * You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nfunction answerQuestions(): string", "canonical_solution": "{\n    return \"DDDBA\";\n}", "test": "function testAnswerQuestions(): void {\n    const expectedAnswers = \"DDDBA\";\n    console.assert(answerQuestions() === expectedAnswers, `Expected answers string '${expectedAnswers}' does not match the result.`);\n}\n\ntestAnswerQuestions();", "entry_point": "answerQuestions", "signature": "function answerQuestions(): string", "docstring": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "instruction": "Write a TypeScript function `function answerQuestions(): string` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "level": "easy"}
{"task_id": "TypeScript/21", "prompt": "\n/**\n * Determines if it is possible to assemble wooden squares from a number of buckets\n * into a single larger square. Each bucket contains a set number of squares,\n * with each square having a side length of 1.\n * \n * @param length - The number of buckets.\n * @param squares - An array where each element represents the number of squares in a bucket.\n * @returns A boolean indicating whether it is possible to form a larger square.\n *\n * Examples:\n *   IsSquare(1, [9]) returns true.\n *   IsSquare(2, [14, 2]) returns true.\n *   IsSquare(2, [7, 7]) returns false.\n */\nfunction isSquare(length: number, squares: number[]): boolean", "canonical_solution": "{\n    let sum: number = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Sum the squares\n    }\n    let root: number = Math.floor(Math.sqrt(sum));\n    return root * root === sum; // Check if sum is a perfect square\n}", "test": "const testIsSquare = (): void => {\n    console.assert(isSquare(1, [9]) === true, \"Test 1 failed\");\n    console.assert(isSquare(2, [14, 2]) === true, \"Test 2 failed\");\n    console.assert(isSquare(2, [7, 7]) === false, \"Test 3 failed\");\n    console.assert(isSquare(7, [1, 2, 3, 4, 5, 6, 7]) === false, \"Test 4 failed\");\n    console.assert(isSquare(6, [1, 3, 5, 7, 9, 11]) === true, \"Test 5 failed\");\n    console.assert(isSquare(4, [2, 2, 2, 2]) === false, \"Test 6 failed\");\n    \n    // Additional test cases\n    console.assert(isSquare(3, [4, 5, 6]) === false, \"Additional Test 1 failed\");\n    console.assert(isSquare(4, [16, 9, 4, 1]) === false, \"Additional Test 2 failed\");\n    console.assert(isSquare(5, [1, 1, 1, 1, 1]) === false, \"Additional Test 3 failed\");\n    console.assert(isSquare(2, [25, 25]) === false, \"Additional Test 4 failed\");\n    console.assert(isSquare(3, [10, 10, 5]) === true, \"Additional Test 5 failed\");\n    \n    // console.info(\"All tests passed!\");\n};\n\ntestIsSquare();", "entry_point": "isSquare", "signature": "function isSquare(length: number, squares: number[]): boolean", "docstring": "Determines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nParameters:\n- length - The number of buckets.\n- squares - An array where each element represents the number of squares in a bucket.\n\nReturns A boolean indicating whether it is possible to form a larger square.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.", "instruction": "Write a TypeScript function `function isSquare(length: number, squares: number[]): boolean` to solve the following problem:\nDetermines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nParameters:\n- length - The number of buckets.\n- squares - An array where each element represents the number of squares in a bucket.\n\nReturns A boolean indicating whether it is possible to form a larger square.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.", "level": "easy"}
{"task_id": "TypeScript/22", "prompt": "\n/**\n * Given integers c and d, where a + b = c and a * b = d, find and return the\n * possible value of a (a <= b). If there are multiple pairs, output the pair with\n * the smallest a.\n * \n * @param c - The sum of a and b.\n * @param d - The product of a and b.\n * @returns A possible value of a or -1 if valid values do not exist.\n *\n * Examples:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number", "canonical_solution": "{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "test": "const testFindIntegers = () => {\n    console.assert(findIntegers(5, 6) === 2, 'Test 1 failed');\n    console.assert(findIntegers(6, 9) === 3, 'Test 2 failed');\n    console.assert(findIntegers(7, 12) === 3, 'Test 3 failed');\n    console.assert(findIntegers(7, 11) === -1, 'Test 4 failed');\n    console.assert(findIntegers(9, 8) === 1, 'Test 5 failed');\n    console.assert(findIntegers(10, 25) === 5, 'Test 6 failed');\n    console.assert(findIntegers(10000, 8765) === -1, 'Test 7 failed');\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestFindIntegers();", "entry_point": "findIntegers", "signature": "function findIntegers(c: number, d: number): number", "docstring": "Given integers c and d, where a + b = c and a * b = d, find and return the\npossible value of a (a <= b). If there are multiple pairs, output the pair with\nthe smallest a.\n\n@param c - The sum of a and b.\n@param d - The product of a and b.\n@returns A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2", "instruction": "Write a TypeScript function `function findIntegers(c: number, d: number): number` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the\npossible value of a (a <= b). If there are multiple pairs, output the pair with\nthe smallest a.\n\n@param c - The sum of a and b.\n@param d - The product of a and b.\n@returns A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2", "level": "easy"}
{"task_id": "TypeScript/23", "prompt": "\n/**\n * Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n * \n * @param edges An array of integers representing the lengths of the edges.\n * @returns The count of distinct acute-angled triangles that can be formed.\n * \n * Examples:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number", "canonical_solution": "{\n    // Sort the edges in non-decreasing order\n    edges.sort((a, b) => a - b);\n\n    let sum = 0;\n    for (let i = 0; i < edges.length - 2; i++) {\n        for (let j = i + 1; j < edges.length - 1; j++) {\n            for (let k = j + 1; k < edges.length; k++) {\n                let x = edges[i], y = edges[j], z = edges[k];\n                // Check if the edges form an acute-angled triangle\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    return sum;\n}", "test": "(() => {\n    // Test function using console.assert for validation\n    console.assert(countAcuteTriangles([1, 1, 1, 1]) === 4, \"Test 1 Failed\");\n    console.assert(countAcuteTriangles([1, 2, 3]) === 0, \"Test 2 Failed\");\n    // Additional tests to ensure correctness\n    console.assert(countAcuteTriangles([3, 4, 5, 7, 10]) === 0, \"Test 3 Failed\");\n    console.assert(countAcuteTriangles([6, 8, 10, 5, 5, 5]) === 4, \"Test 4 Failed\");\n    // console.log(\"All tests passed!\");\n})();", "entry_point": "countAcuteTriangles", "signature": "function countAcuteTriangles(edges: number[]): number", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges An array of integers representing the lengths of the edges.\n@returns The count of distinct acute-angled triangles that can be formed.\n\nExamples:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4", "instruction": "Write a TypeScript function `function countAcuteTriangles(edges: number[]): number` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges An array of integers representing the lengths of the edges.\n@returns The count of distinct acute-angled triangles that can be formed.\n\nExamples:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4", "level": "hard"}
{"task_id": "TypeScript/24", "prompt": "\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * @param integer_value The input integer.\n * @param char_value The input character.\n * @returns A string containing the integer and character separated by a comma.\n * @example\n * processIntegerAndChar(234, 'H')  // Returns \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string", "canonical_solution": "{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}", "test": "const testProcessIntegerAndChar = (): void => {\n    console.assert(processIntegerAndChar(234, 'H') === \"234,H\", \"Test 1 Failed\");\n    console.assert(processIntegerAndChar(123, 'A') === \"123,A\", \"Test 2 Failed\");\n    console.assert(processIntegerAndChar(0, 'Z') === \"0,Z\", \"Test 3 Failed\");\n    \n    // Additional tests can be added here with different input values\n    // Example:\n    console.assert(processIntegerAndChar(567, 'X') === \"567,X\", \"Example Test Failed\");\n};\n\ntestProcessIntegerAndChar();", "entry_point": "processIntegerAndChar", "signature": "function processIntegerAndChar(integer_value: number, char_value: string): string", "docstring": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value The input integer.\n@param char_value The input character.\n@returns A string containing the integer and character separated by a comma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"", "instruction": "Write a TypeScript function `function processIntegerAndChar(integer_value: number, char_value: string): string` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value The input integer.\n@param char_value The input character.\n@returns A string containing the integer and character separated by a comma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"", "level": "easy"}
{"task_id": "TypeScript/25", "prompt": "\n/**\n * Shifts all characters by 5 positions in alphabetical order. Only letters\n * are replaced, and all letters are in uppercase.\n * \n * @param text The input text to be processed.\n * @returns The transformed text with characters shifted by 5 positions.\n * \n * Example:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string", "canonical_solution": "{\n    let result = \"\";\n    for (let i = 0; i < text.length; ++i) {\n        let charCode = text.charCodeAt(i);\n        if (charCode >= 65 && charCode <= 69) { // 'A'.charCodeAt(0) == 65, 'E'.charCodeAt(0) == 69\n            result += String.fromCharCode(charCode + 21); // 'V'.charCodeAt(0) == 86; 'V' - 'A' = 21\n        } else if (charCode >= 70 && charCode <= 90) { // 'F'.charCodeAt(0) == 70, 'Z'.charCodeAt(0) == 90\n            result += String.fromCharCode(charCode - 5);\n        } else {\n            result += text[i];\n        }\n    }\n    return result;\n}", "test": "function testShiftCharacters() {\n    let test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    let test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    let test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    console.assert(shiftCharacters(test1) === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\", \"Test 1 failed\");\n    console.assert(shiftCharacters(test2) === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\", \"Test 2 failed\");\n    console.assert(shiftCharacters(test3) === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\", \"Test 3 failed\");\n}\n\ntestShiftCharacters();", "entry_point": "shiftCharacters", "signature": "function shiftCharacters(text: string): string", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text The input text to be processed.\n@returns The transformed text with characters shifted by 5 positions.\n\nExample:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "instruction": "Write a TypeScript function `function shiftCharacters(text: string): string` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text The input text to be processed.\n@returns The transformed text with characters shifted by 5 positions.\n\nExample:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "level": "hard"}
{"task_id": "TypeScript/26", "prompt": "\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n *\n * @param x - The string representation of the integer to be classified.\n * @returns The class to which the integer x belongs.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number", "canonical_solution": "{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i]);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}", "test": "const testClassifyInteger = (): void => {\n    console.assert(classifyInteger(\"24\") === 6, \"Test failed for input '24'\");\n    console.assert(classifyInteger(\"39\") === 3, \"Test failed for input '39'\");\n    console.assert(classifyInteger(\"123456789\") === 9, \"Test failed for input '123456789'\");\n    console.assert(classifyInteger(\"123456789012345678901234567890\") === 9, \"Test failed for input '123456789012345678901234567890'\");\n    console.assert(classifyInteger(\"12345\") === 6, \"Test failed for input '12345'\");\n    console.assert(classifyInteger(\"999999999\") === 9, \"Test failed for input '999999999'\");\n};\n\ntestClassifyInteger();", "entry_point": "classifyInteger", "signature": "function classifyInteger(x: string): number", "docstring": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The string representation of the integer to be classified.\n\nReturns:\nThe class to which the integer x belongs.\n\nExample:\nclassifyInteger(\"24\") // returns 6", "instruction": "Write a TypeScript function `function classifyInteger(x: string): number` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The string representation of the integer to be classified.\n\nReturns:\nThe class to which the integer x belongs.\n\nExample:\nclassifyInteger(\"24\") // returns 6", "level": "easy"}
{"task_id": "TypeScript/27", "prompt": "\n/**\n * Transforms the case of a given letter.\n * \n * Parameters:\n * - letter (string): The input letter to be transformed.\n * \n * Returns:\n * - string: The letter with its case reversed. If the input is lowercase, \n *           it returns the uppercase version, and if the input is uppercase, \n *           it returns the lowercase version.\n * \n * Examples:\n * transformLetterCase('b') // Returns 'B'\n */\nfunction transformLetterCase(letter: string): string", "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter.toLowerCase();\n    } else if (letter >= 'a' && letter <= 'z') {\n        return letter.toUpperCase();\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "test": "const testTransformLetterCase = (): void => {\n    console.assert(transformLetterCase('b') === 'B', 'Test failed: transformLetterCase(\\'b\\') should return \\'B\\'');\n    console.assert(transformLetterCase('B') === 'b', 'Test failed: transformLetterCase(\\'B\\') should return \\'b\\'');\n    console.assert(transformLetterCase('z') === 'Z', 'Test failed: transformLetterCase(\\'z\\') should return \\'Z\\'');\n    console.assert(transformLetterCase('Z') === 'z', 'Test failed: transformLetterCase(\\'Z\\') should return \\'z\\'');\n    console.assert(transformLetterCase('m') === 'M', 'Test failed: transformLetterCase(\\'m\\') should return \\'M\\'');\n    console.assert(transformLetterCase('M') === 'm', 'Test failed: transformLetterCase(\\'M\\') should return \\'m\\'');\n    console.assert(transformLetterCase('1') === '1', 'Test failed: transformLetterCase(\\'1\\') should return \\'1\\' (unchanged)');\n    console.assert(transformLetterCase('!') === '!', 'Test failed: transformLetterCase(\\'!\\') should return \\'!\\' (unchanged)');\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestTransformLetterCase();", "entry_point": "transformLetterCase", "signature": "function transformLetterCase(letter: string): string", "docstring": "Transforms the case of a given letter.\n\nParameters:\n- letter (string): The input letter to be transformed.\n\nReturns:\n- string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n\nExamples:\ntransformLetterCase('b') // Returns 'B'", "instruction": "Write a TypeScript function `function transformLetterCase(letter: string): string` to solve the following problem:\nTransforms the case of a given letter.\n\nParameters:\n- letter (string): The input letter to be transformed.\n\nReturns:\n- string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n\nExamples:\ntransformLetterCase('b') // Returns 'B'", "level": "easy"}
{"task_id": "TypeScript/28", "prompt": "\n/**\n * Display the ASCII information for a given character.\n * \n * Parameters:\n * - character (string): The input character for which ASCII information is to be displayed.\n *    \n * Returns:\n * - number: corresponding ASCII code\n *    \n * Examples:\n * ```\n * console.log(display_ascii_info('A'));\n * // expected output: 65\n * ```\n */\nfunction display_ascii_info(character: string): number", "canonical_solution": "{\n    return character.charCodeAt(0);\n}", "test": "const testDisplayAsciiInfo = (): void => {\n    console.assert(display_ascii_info('A') === 65);\n    console.assert(display_ascii_info('B') === 66); // Additional test case\n    console.assert(display_ascii_info('0') === 48); // Additional test case\n    console.assert(display_ascii_info(' ') === 32); // Additional test case\n    // console.log(\"All tests passed.\");\n};\n\ntestDisplayAsciiInfo();", "entry_point": "display_ascii_info", "signature": "function display_ascii_info(character: string): number", "docstring": "Display the ASCII information for a given character.\n\nParameters:\n- character (string): The input character for which ASCII information is to be displayed.\n\nReturns:\n- number: corresponding ASCII code\n\nExamples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```\n", "instruction": "Write a TypeScript function `function display_ascii_info(character: string): number` to solve the following problem:\nDisplay the ASCII information for a given character.\n\nParameters:\n- character (string): The input character for which ASCII information is to be displayed.\n\nReturns:\n- number: corresponding ASCII code\n\nExamples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```\n", "level": "easy"}
{"task_id": "TypeScript/29", "prompt": "\n/**\n * Evaluate the grade for an input integer.\n * @param score - The integer score to be evaluated.\n * @returns The grade corresponding to the input score.\n *          If the score is between 90 and 100 (inclusive), returns 'A'.\n *          Otherwise, returns 'B'.\n * \n * Examples:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string", "canonical_solution": "{\n    return (score >= 90 && score <= 100) ? 'A' : 'B';\n}", "test": "const testEvaluateIntegerGrade = (): void => {\n    console.assert(evaluateIntegerGrade(90) === 'A', \"Expected 'A' for score 90\");\n    console.assert(evaluateIntegerGrade(89) === 'B', \"Expected 'B' for score 89\");\n    console.assert(evaluateIntegerGrade(95) === 'A', \"Expected 'A' for score 95\");\n    console.assert(evaluateIntegerGrade(100) === 'A', \"Expected 'A' for score 100\");\n    console.assert(evaluateIntegerGrade(101) === 'B', \"Expected 'B' for score 101\");\n    \n    // console.log(\"All tests passed\");\n};\n\ntestEvaluateIntegerGrade();", "entry_point": "evaluateIntegerGrade", "signature": "function evaluateIntegerGrade(score: number): string", "docstring": "Evaluate the grade for an input integer.\n@param score - The integer score to be evaluated.\n@returns The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\nExamples:\n evaluateIntegerGrade(90) // returns 'A'\n\n", "instruction": "Write a TypeScript function `function evaluateIntegerGrade(score: number): string` to solve the following problem:\nEvaluate the grade for an input integer.\n@param score - The integer score to be evaluated.\n@returns The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\nExamples:\n evaluateIntegerGrade(90) // returns 'A'\n\n", "level": "easy"}
{"task_id": "TypeScript/30", "prompt": "\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n *\n * @param str The three-character string to be checked.\n * @return Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n * \n * Examples:\n *  checkTwoEqualDigits(\"112\") // Returns 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string", "canonical_solution": "{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "test": "function testCheckTwoEqualDigits(): void {\n    // Testing the logic with various cases.\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\");\n\n    // Additional test cases to cover more scenarios\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\n\n    // Uncomment the next line if you wish to print to console upon successful tests\n    //console.log(\"All tests passed successfully.\");\n}\n\n// Run the tests\ntestCheckTwoEqualDigits();", "entry_point": "checkTwoEqualDigits", "signature": "function checkTwoEqualDigits(str: string): string", "docstring": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: The three-character string to be checked.\n\nReturns:\n- Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'", "instruction": "Write a TypeScript function `function checkTwoEqualDigits(str: string): string` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: The three-character string to be checked.\n\nReturns:\n- Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'", "level": "easy"}
{"task_id": "TypeScript/31", "prompt": "\n/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * \n * @param s The input string.\n * @returns The minimum number of rounds to make all characters in the string the same.\n * \n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n */\nfunction minRoundsToSameChar(s: string): number", "canonical_solution": "{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test": "const testMinRoundsToSameChar = (): void => {\n    console.assert(minRoundsToSameChar(\"aab\") === 1, \"Expected 1 round for 'aab'\");\n    console.assert(minRoundsToSameChar(\"abc\") === 2, \"Expected 2 rounds for 'abc'\");\n    console.assert(minRoundsToSameChar(\"aaa\") === 0, \"Expected 0 rounds for 'aaa'\");\n    console.assert(minRoundsToSameChar(\"abab\") === 1, \"Expected 1 round for 'abab'\");\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0, \"Expected 0 rounds for 'zzzzz'\");\n};\n\ntestMinRoundsToSameChar();", "entry_point": "minRoundsToSameChar", "signature": "function minRoundsToSameChar(s: string): number", "docstring": "Given a string consisting of lowercase English letters, you can change one character to another\nin each round. This function calculates the minimum number of rounds needed to make the string\ncomposed of the same character.\n\n@param s The input string.\n@returns The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1", "instruction": "Write a TypeScript function `function minRoundsToSameChar(s: string): number` to solve the following problem:\nGiven a string consisting of lowercase English letters, you can change one character to another\nin each round. This function calculates the minimum number of rounds needed to make the string\ncomposed of the same character.\n\n@param s The input string.\n@returns The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1", "level": "middle"}
{"task_id": "TypeScript/32", "prompt": "\n/**\n * Calculates the year Y_n when the n-th event occurs, considering that each\n * event has a periodicity of a_i years. The countdown for event i+1 starts\n * the year after event i occurs.\n *\n * @param n - the total number of events\n * @param signs - an array representing the periodicities of the events\n * @returns The year when the n-th event occurs\n * \n * Example:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number", "canonical_solution": "{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "test": "const testApocalypseYear = (): void => {\n    console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36);\n    console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5);\n    console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5);\n    console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012);\n    console.assert(apocalypseYear(2, [1, 2]) === 2);\n    console.assert(apocalypseYear(3, [3, 1, 2]) === 6);\n    console.assert(apocalypseYear(3, [2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13);\n    console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10);\n    console.assert(apocalypseYear(3, [6, 10, 15]) === 15);\n    console.assert(apocalypseYear(3, [4, 6, 14]) === 14);\n    console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800);\n    console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6);\n    console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998);\n};\n\ntestApocalypseYear();", "entry_point": "apocalypseYear", "signature": "function apocalypseYear(n: number, signs: number[]): number", "docstring": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n\nParameters:\n- n - the total number of events\n- signs - an array representing the periodicities of the events\n\nReturns The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n", "instruction": "Write a TypeScript function `function apocalypseYear(n: number, signs: number[]): number` to solve the following problem:\nCalculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n\nParameters:\n- n - the total number of events\n- signs - an array representing the periodicities of the events\n\nReturns The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n", "level": "easy"}
{"task_id": "TypeScript/33", "prompt": "\n/**\n * This problem introduces a new modulo operation, denoted by the symbol \"\u2295\".\n * When calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y.\n * Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\n * Then the result is the remainder of x' divided by y.\n * For example, 4\u22955=4, 20\u22955=4, 100\u22955=4.\n * Given a prime number p, there will be several queries. For each query, an integer n is given,\n * and you need to compute the value of n! \u2295 p, where n! is the factorial of n,\n * i.e. the product of all positive integers less than or equal to n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {", "canonical_solution": "const pj: number[] = new Array(p).fill(1);\n    for (let i = 2; i < p; i++) pj[i] = (i * pj[i - 1]) % p;\n    \n    let ans = 1;\n    while (n > 0) {\n        ans = (ans * pj[n % p]) % p;\n        ans = ((n / p) & 1) ? p - ans : ans;\n        n = Math.floor(n / p);\n    }\n    return ans;\n}", "test": "(function testNewModuloFactorial(): void {\n    console.assert(newModuloFactorial(3, 7) === 6, 'Test at n=3, p=7 failed');\n    console.assert(newModuloFactorial(10, 3) === 1, 'Test at n=10, p=3 failed');\n    console.assert(newModuloFactorial(11, 7) === 4, 'Test at n=11, p=7 failed');\n    console.assert(newModuloFactorial(45, 7) === 1, 'Test at n=45, p=7 failed');\n    console.assert(newModuloFactorial(14, 7) === 2, 'Test at n=14, p=7 failed');\n    console.assert(newModuloFactorial(1919, 10007) === 3152, 'Test at n=1919, p=10007 failed');\n    console.assert(newModuloFactorial(810, 10007) === 3679, 'Test at n=810, p=10007 failed');\n    console.assert(newModuloFactorial(1, 2) === 1, 'Test at n=1, p=2 failed');\n    console.assert(newModuloFactorial(5, 11) === 10, 'Test at n=5, p=11 failed');\n    console.assert(newModuloFactorial(6, 13) === 5, 'Test at n=6, p=13 failed');\n    console.assert(newModuloFactorial(8, 17) === 13, 'Test at n=8, p=17 failed');\n    console.assert(newModuloFactorial(15, 19) === 16, 'Test at n=15, p=19 failed');\n    console.assert(newModuloFactorial(21, 23) === 1, 'Test at n=21, p=23 failed');\n    console.assert(newModuloFactorial(30, 29) === 28, 'Test at n=30, p=29 failed');\n    console.assert(newModuloFactorial(100, 101) === 100, 'Test at n=100, p=101 failed');\n})();", "entry_point": "newModuloFactorial", "signature": "function newModuloFactorial(n: number, p: number): number", "docstring": "This problem introduces a new modulo operation, denoted by the symbol '\u2295'.\nWhen calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y.\nFor example, 4\u22955=4, 20\u22955=4, 100\u22955=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! \u2295 p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6", "instruction": "Write a TypeScript function `function newModuloFactorial(n: number, p: number): number` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol '\u2295'.\nWhen calculating x \u2295 y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y.\nFor example, 4\u22955=4, 20\u22955=4, 100\u22955=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! \u2295 p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6", "level": "easy"}
{"task_id": "TypeScript/34", "prompt": "\n/**\n * You are given an array a of n integers. You can perform at most one operation where\n * you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n * with x, at a cost of (j - i + 1).\n * Find the minimum cost to make all elements in the array equal.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {", "canonical_solution": "let j = 0, p = 1, q = 0, c, d;\n  let k = n;\n  for (p = 1; p < k; p++) {\n      if (a[p] !== a[p - 1])\n          break;\n  }\n  for (q = k - 1; q > p; q--) {\n      if (a[q] !== a[p - 1])\n          break;\n  }\n  for (d = k - 2; d >= 0; d--) {\n      if (a[d] !== a[d + 1])\n          break;\n  }\n  for (c = 0; c < d; c++) {\n      if (a[c] !== a[c + 1])\n          break;\n  }\n  if (q - p + 1 < d - c + 1)\n      return q - p + 1;\n  else\n      return d - c + 1;\n};", "test": "function testMakeEqualAgain(): void {\n  console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4);\n  console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0);\n  console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2);\n  console.assert(makeEqualAgain(3, [1, 2, 3]) === 2);\n  console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6);\n  console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7);\n  \n  console.assert(makeEqualAgain(3, [1, 2, 1]) === 1);\n  console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1);\n  console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0);\n  console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1);\n  console.assert(makeEqualAgain(1, [1]) === 0);\n  console.assert(makeEqualAgain(2, [1, 2]) === 1);\n  console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2);\n  console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2);\n  console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3);\n  console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5);\n\n};\n\ntestMakeEqualAgain();", "entry_point": "makeEqualAgain", "signature": "function makeEqualAgain(n: number, a: number[]): number", "docstring": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.", "instruction": "Write a TypeScript function `function makeEqualAgain(n: number, a: number[]): number` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.", "level": "middle"}
{"task_id": "TypeScript/35", "prompt": "\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\n * this function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\n * and they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\n * Movement is done in positive numbers. The player forced to only move stones in the last pile loses.\n * Assuming optimal play, the function determines the winner.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles: number[]): string", "canonical_solution": "{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    // With only two piles, Charlie always wins.\n    if (n === 2) {\n        return \"Charlie\";\n    }\n    // If the first pile has only one stone, Dan wins.\n    if (firstPileStones === 1) {\n        return \"Dan\";\n    }\n    // In all other cases, Charlie wins.\n    return \"Charlie\";\n}", "test": "(() => {\n    console.assert(gameWinner([1, 2, 2]) === \"Dan\", \"Test 1 failed\");\n    console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\", \"Test 2 failed\");\n    console.assert(gameWinner([2, 1, 2]) === \"Charlie\", \"Test 3 failed\");\n    console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\", \"Test 4 failed\");\n    console.assert(gameWinner([1, 1]) === \"Charlie\", \"Test 5 failed\");\n    console.assert(gameWinner([2, 1]) === \"Charlie\", \"Test 6 failed\");\n    console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\", \"Test 7 failed\");\n    console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\", \"Test 8 failed\");\n    console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\", \"Test 9 failed\");\n    console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\", \"Test 10 failed\");\n})();", "entry_point": "gameWinner", "signature": "function gameWinner(piles: number[]): string", "docstring": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\nthis function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\nand they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\nMovement is done in positive numbers. The player forced to only move stones in the last pile loses.\nAssuming optimal play, the function determines the winner.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"\n", "instruction": "Write a TypeScript function `function gameWinner(piles: number[]): string` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\nthis function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\nand they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\nMovement is done in positive numbers. The player forced to only move stones in the last pile loses.\nAssuming optimal play, the function determines the winner.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"\n", "level": "middle"}
{"task_id": "TypeScript/36", "prompt": "\n/**\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps\n * to the right and then open the door at that position. It is guaranteed that\n * C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number", "canonical_solution": "{\n   return C[n-2] * (n - 1) + C[n-1];\n}", "test": "function testMinTotalCost(): void {\n    console.assert(minTotalCost(5, [4, 3, 3, 3, 3]) === 15);\n    console.assert(minTotalCost(3, [1, 1, 1]) === 3);\n    console.assert(minTotalCost(4, [5, 4, 3, 2]) === 11);\n    console.assert(minTotalCost(4, [100, 99, 98, 97]) === 391);\n    console.assert(minTotalCost(6, [10, 9, 8, 7, 6, 5]) === 35);\n    console.assert(minTotalCost(7, [2, 2, 2, 2, 2, 2, 2]) === 14);\n    console.assert(minTotalCost(8, [9, 7, 7, 7, 7, 7, 7, 7]) === 56);\n    console.assert(minTotalCost(9, [3, 2, 2, 2, 2, 2, 2, 2, 2]) === 18);\n    console.assert(minTotalCost(10, [6, 5, 5, 5, 5, 5, 5, 5, 5, 5]) === 50);\n    console.assert(minTotalCost(11, [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === 11);\n}\n\ntestMinTotalCost();", "entry_point": "minTotalCost", "signature": "function minTotalCost(n: number, C: number[]): number", "docstring": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n", "instruction": "Write a TypeScript function `function minTotalCost(n: number, C: number[]): number` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n", "level": "easy"}
{"task_id": "TypeScript/37", "prompt": "\n/**\n * Calculates the total number of handshakes in a classroom where each student shakes\n * hands with every student already in the room with a smaller student ID. The student\n * IDs range from 0 to N-1, and the sequence of ID entries represents the order in which\n * they enter the classroom.\n * \n * @param n - the number of students\n * @param order - the sequence of student IDs entering the classroom\n * @returns the total number of handshakes\n * \n * Examples:\n *    countHandshakes(3, [2, 1, 0])  // returns 0\n */\nfunction countHandshakes(n: number, order: number[]): number", "canonical_solution": "{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n};", "test": "(() => {\n    console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2, \"Test 1 failed\");\n    console.assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) === 15, \"Test 2 failed\");\n    console.assert(countHandshakes(3, [1, 2, 0]) === 1, \"Test 3 failed\");\n    console.assert(countHandshakes(4, [3, 2, 1, 0]) === 0, \"Test 4 failed\");\n    console.assert(countHandshakes(4, [0, 1, 2, 3]) === 6, \"Test 5 failed\");\n    console.assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) === 0, \"Test 6 failed\");\n    console.assert(countHandshakes(4, [0, 2, 1, 3]) === 5, \"Test 7 failed\");\n    console.assert(countHandshakes(5, [3, 1, 4, 2, 0]) === 3, \"Test 8 failed\");\n    console.assert(countHandshakes(4, [1, 0, 3, 2]) === 4, \"Test 9 failed\");\n    console.assert(countHandshakes(3, [2, 0, 1]) === 1, \"Test 10 failed\");\n    console.assert(countHandshakes(5, [1, 3, 0, 2, 4]) === 7, \"Test 11 failed\");\n    console.assert(countHandshakes(5, [4, 3, 2, 1, 0]) === 0, \"Test 12 failed\");\n})();", "entry_point": "countHandshakes", "signature": "function countHandshakes(n: number, order: number[]): number", "docstring": "Calculates the total number of handshakes in a classroom where each student shakes hands with every student already in the room with a smaller student ID. The student IDs range from 0 to N-1, and the sequence of ID entries represents the order in which they enter the classroom.\n\n@param n - the number of students\n@param order - the sequence of student IDs entering the classroom\n@returns the total number of handshakes\n\nExamples:\n   countHandshakes(3, [2, 1, 0])  // returns 0\n", "instruction": "Write a TypeScript function `function countHandshakes(n: number, order: number[]): number` to solve the following problem:\nCalculates the total number of handshakes in a classroom where each student shakes hands with every student already in the room with a smaller student ID. The student IDs range from 0 to N-1, and the sequence of ID entries represents the order in which they enter the classroom.\n\n@param n - the number of students\n@param order - the sequence of student IDs entering the classroom\n@returns the total number of handshakes\n\nExamples:\n   countHandshakes(3, [2, 1, 0])  // returns 0\n", "level": "middle"}
{"task_id": "TypeScript/38", "prompt": "\n/**\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   maxModeSum(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number", "canonical_solution": "{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n  \n  for (let i = 0; i < n; ++i) {\n    f[i] = 0;\n  }\n  \n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}", "test": "(function testMaxModeSum(): void {\n  console.assert(maxModeSum(3, [1, 3, 2]) === 17, 'Test case 1 failed');\n  console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37, 'Test case 2 failed');\n  console.assert(maxModeSum(2, [1, 1]) === 4, 'Test case 3 failed');\n  console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75, 'Test case 4 failed');\n  console.assert(maxModeSum(1, [100000]) === 100000, 'Test case 5 failed');\n  console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62, 'Test case 6 failed');\n  console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000, 'Test case 7 failed');\n  console.assert(maxModeSum(3, [2, 2, 5]) === 27, 'Test case 8 failed');\n  console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64, 'Test case 9 failed');\n  console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126, 'Test case 10 failed');\n  console.assert(maxModeSum(3, [3, 1, 2]) === 16, 'Test case 11 failed');\n})();", "entry_point": "maxModeSum", "signature": "function maxModeSum(n: number, counts: number[]): number", "docstring": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nFor example:\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.", "instruction": "Write a TypeScript function `function maxModeSum(n: number, counts: number[]): number` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nFor example:\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.", "level": "easy"}
{"task_id": "TypeScript/39", "prompt": "\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n */\nfunction sumOfXorSubarrays(A: number[]): number", "canonical_solution": "{\n    const n: number = A.length;\n    let q: number[] = new Array(n + 1).fill(0);\n    let w: number[][] = Array.from({ length: 21 }, () => [0, 0]);\n    let ans: number = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n};", "test": "const testSumOfXorSubarrays = (): void => {\n    console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39);\n    console.assert(sumOfXorSubarrays([1, 1, 1]) === 4);\n    console.assert(sumOfXorSubarrays([2, 3, 1]) === 9);\n    console.assert(sumOfXorSubarrays([4, 5, 7, 9]) === 74);\n    console.assert(sumOfXorSubarrays([0, 0, 0, 0]) === 0);\n    console.assert(sumOfXorSubarrays([8, 8, 8, 8, 8]) === 72);\n    console.assert(sumOfXorSubarrays([3, 6, 9, 12, 15]) === 125);\n    console.assert(sumOfXorSubarrays([10, 20, 30, 40, 50]) === 390);\n    console.assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16]) === 192);\n    console.assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13]) === 192);\n    console.assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218);\n};\n\ntestSumOfXorSubarrays();", "entry_point": "sumOfXorSubarrays", "signature": "function sumOfXorSubarrays(A: number[]): number", "docstring": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n", "instruction": "Write a TypeScript function `function sumOfXorSubarrays(A: number[]): number` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n", "level": "middle"}
{"task_id": "TypeScript/40", "prompt": "\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\n * and b >= k. Different legal representations of the same number are counted only once.\n * Example:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n: number, k: number): number {", "canonical_solution": "let count = 0;\n    let x = 0;\n    const mp: boolean[] = new Array(n + 1).fill(false);\n    \n    for (let i = 2; i <= Math.cbrt(n); ++i) {\n        let t = i * i;\n        let m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if (Math.pow(Math.floor(Math.sqrt(t)), 2) === t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k === 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += Math.floor(Math.sqrt(n)) - x;\n    }\n    return count;\n}", "test": "const testCountPowerNumbers = (): void => {\n    console.assert(countPowerNumbers(99, 1) === 99, `Expected 99, got ${countPowerNumbers(99, 1)}`);\n    console.assert(countPowerNumbers(99, 3) === 7, `Expected 7, got ${countPowerNumbers(99, 3)}`);\n    console.assert(countPowerNumbers(99, 2) === 12, `Expected 12, got ${countPowerNumbers(99, 2)}`);\n    console.assert(countPowerNumbers(10, 1) === 10, `Expected 10, got ${countPowerNumbers(10, 1)}`);\n    console.assert(countPowerNumbers(10, 2) === 4, `Expected 4, got ${countPowerNumbers(10, 2)}`);\n    console.assert(countPowerNumbers(500, 1) === 500, `Expected 500, got ${countPowerNumbers(500, 1)}`);\n    console.assert(countPowerNumbers(500, 2) === 30, `Expected 30, got ${countPowerNumbers(500, 2)}`);\n    console.assert(countPowerNumbers(500, 3) === 13, `Expected 13, got ${countPowerNumbers(500, 3)}`);\n    console.assert(countPowerNumbers(1000, 1) === 1000, `Expected 1000, got ${countPowerNumbers(1000, 1)}`);\n    console.assert(countPowerNumbers(1000, 2) === 41, `Expected 41, got ${countPowerNumbers(1000, 2)}`);\n    console.assert(countPowerNumbers(1000, 3) === 17, `Expected 17, got ${countPowerNumbers(1000, 3)}`);\n    console.assert(countPowerNumbers(1000, 93) === 1, `Expected 1, got ${countPowerNumbers(1000, 93)}`);\n    console.assert(countPowerNumbers(50, 2) === 10, `Expected 10, got ${countPowerNumbers(50, 2)}`);\n    console.assert(countPowerNumbers(50, 3) === 5, `Expected 5, got ${countPowerNumbers(50, 3)}`);\n    console.assert(countPowerNumbers(2, 3) === 1, `Expected 1, got ${countPowerNumbers(2, 3)}`);\n};\n\ntestCountPowerNumbers();", "entry_point": "countPowerNumbers", "signature": "function countPowerNumbers(n: number, k: number): number", "docstring": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99", "instruction": "Write a TypeScript function `function countPowerNumbers(n: number, k: number): number` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99", "level": "hard"}
{"task_id": "TypeScript/41", "prompt": "\n/**\n * Computes the number of sequences consisting of n '(' and m ')', such that the longest balanced\n * subsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Example:\n *   countBalancedSubsequences(2, 2, 2) returns 2\n *\n * @param n The number of '(' characters.\n * @param m The number of ')' characters.\n * @param k The half-length of the longest balanced subsequence.\n * @returns The number of valid sequences modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {", "canonical_solution": "const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n \n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n \n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test": "(() => {\n    console.assert(countBalancedSubsequences(2, 2, 2) === 2, 'Test case 1 failed');\n    console.assert(countBalancedSubsequences(3, 2, 3) === 0, 'Test case 2 failed');\n    console.assert(countBalancedSubsequences(3, 2, 1) === 4, 'Test case 3 failed');\n    console.assert(countBalancedSubsequences(4, 3, 2) === 14, 'Test case 4 failed');\n    console.assert(countBalancedSubsequences(5, 5, 2) === 35, 'Test case 5 failed');\n    console.assert(countBalancedSubsequences(6, 1, 1) === 6, 'Test case 6 failed');\n    console.assert(countBalancedSubsequences(1, 6, 1) === 6, 'Test case 7 failed');\n    console.assert(countBalancedSubsequences(7, 2, 2) === 27, 'Test case 8 failed');\n    console.assert(countBalancedSubsequences(8, 3, 3) === 110, 'Test case 9 failed');\n    console.assert(countBalancedSubsequences(10, 10, 5) === 10659, 'Test case 10 failed');\n    console.assert(countBalancedSubsequences(20, 20, 10) === 574221648, 'Test case 11 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531, 'Test case 12 failed');\n    console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485, 'Test case 13 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024, 'Test case 14 failed');\n})();", "entry_point": "countBalancedSubsequences", "signature": "function countBalancedSubsequences(n: number, m: number, k: number): number", "docstring": "Computes the number of sequences consisting of n '(' and m ')', such that the longest balanced\nsubsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExample:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n The number of '(' characters.\n@param m The number of ')' characters.\n@param k The half-length of the longest balanced subsequence.\n@returns The number of valid sequences modulo 10^9 + 7.", "instruction": "Write a TypeScript function `function countBalancedSubsequences(n: number, m: number, k: number): number` to solve the following problem:\nComputes the number of sequences consisting of n '(' and m ')', such that the longest balanced\nsubsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExample:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n The number of '(' characters.\n@param m The number of ')' characters.\n@param k The half-length of the longest balanced subsequence.\n@returns The number of valid sequences modulo 10^9 + 7.", "level": "hard"}
{"task_id": "TypeScript/42", "prompt": "\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\n * corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations\n * to cut the paper such that the remaining area is less than k. In each operation, a line is randomly\n * chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through\n * (not just touching the edge) the paper. The bottom or right part of the paper along this line is then\n * discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *    expectedCuts(3, 3, 4) // returns 3\n *    expectedCuts(5, 5, 12) // returns 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number", "canonical_solution": "{\n    const MD: number = 1000000007;\n    const N: number = 1000000;\n    let vv: number[] = new Array(N * 2 + 2).fill(0);\n    let ans: number = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}", "test": "function testExpectedCuts(): void {\n    console.assert(expectedCuts(2, 4, 10) === 0, 'Test 1 failed');\n    console.assert(expectedCuts(2, 4, 8) === 1, 'Test 2 failed');\n    console.assert(expectedCuts(2, 4, 2) === 833333342, 'Test 3 failed');\n    console.assert(expectedCuts(2, 4, 6) === 250000003, 'Test 4 failed');\n    console.assert(expectedCuts(3, 3, 4) === 666666673, 'Test 5 failed');\n    console.assert(expectedCuts(5, 5, 12) === 666666673, 'Test 6 failed');\n    console.assert(expectedCuts(6, 7, 20) === 722222229, 'Test 7 failed');\n    console.assert(expectedCuts(10, 10, 50) === 714285721, 'Test 9 failed');\n    console.assert(expectedCuts(1, 10, 5) === 945634929, 'Test 10 failed');\n    console.assert(expectedCuts(10, 1, 5) === 945634929, 'Test 11 failed');\n}\n\ntestExpectedCuts();", "entry_point": "expectedCuts", "signature": "function expectedCuts(n: number, m: number, k: number): number", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n   expectedCuts(3, 3, 4) // returns 3\n   expectedCuts(5, 5, 12) // returns 2\n", "instruction": "Write a TypeScript function `function expectedCuts(n: number, m: number, k: number): number` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n   expectedCuts(3, 3, 4) // returns 3\n   expectedCuts(5, 5, 12) // returns 2\n", "level": "hard"}
{"task_id": "TypeScript/43", "prompt": "\n/**\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number", "canonical_solution": "{\n    const P = 998244353;\n    let dp: number[][] = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc: number[] = new Array(n + 1).fill(0);\n    let f: number[] = new Array(n + 1).fill(0);\n\n    dp[0][0] = f[0] = jc[0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n\n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n\n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n\n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n\n    return ans;\n};", "test": "console.assert(countPermutations(2, 1, [1, 2]) === 2, 'Test failed for input ([1, 2])');\nconsole.assert(countPermutations(3, 3, [3, 1, 2]) === 1, 'Test failed for input ([3, 1, 2])');\nconsole.assert(countPermutations(6, 3, [1, 2, 3, 6, 5, 4]) === 13, 'Test failed for input ([1, 2, 3, 6, 5, 4])');\nconsole.assert(countPermutations(6, 1, [1, 2, 3, 4, 5, 6]) === 720, 'Test failed for input ([1, 2, 3, 4, 5, 6])');\nconsole.assert(countPermutations(6, 3, [1, 2, 5, 3, 4, 5]) === 0, 'Test failed for input ([1, 2, 5, 3, 4, 5])');\nconsole.assert(countPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1, 'Test failed for input ([1, 2, 3, 4, 5, 6, 7, 8, 9])');\nconsole.assert(countPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093);", "entry_point": "countPermutations", "signature": "function countPermutations(n: number, k: number, q: number[]): number", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2", "instruction": "Write a TypeScript function `function countPermutations(n: number, k: number, q: number[]): number` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2", "level": "hard"}
{"task_id": "TypeScript/44", "prompt": "\n/**\n * Determines the number of ways to choose a triplet (a, b, c)\n * from an array of distinct integers representing heights such that the\n * greatest common divisor (GCD) of the maximum and minimum values\n * of the triplet is 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights: number[]): number", "canonical_solution": "{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a: number, b: number): number {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}", "test": "const main = (): void => {\n    console.assert(countTriplets([1, 5, 7]) === 1);\n    console.assert(countTriplets([1, 6, 2, 3]) === 3);\n    console.assert(countTriplets([16, 4, 8, 2]) === 0);\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77);\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7);\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104);\n    console.assert(countTriplets([3, 7, 11, 13]) === 4);\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10);\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87);\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122);\n}\n\nmain();", "entry_point": "countTriplets", "signature": "function countTriplets(heights: number[]): number", "docstring": "Determines the number of ways to choose a triplet (a, b, c)\nfrom an array of distinct integers representing heights such that the\ngreatest common divisor (GCD) of the maximum and minimum values\nof the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n", "instruction": "Write a TypeScript function `function countTriplets(heights: number[]): number` to solve the following problem:\nDetermines the number of ways to choose a triplet (a, b, c)\nfrom an array of distinct integers representing heights such that the\ngreatest common divisor (GCD) of the maximum and minimum values\nof the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n", "level": "hard"}
{"task_id": "TypeScript/45", "prompt": "\n/**\n * Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\n * connected pixels of the same color to a chosen color, where two pixels are connected if they are\n * adjacent and have the same color. The goal is to find the minimum number of operations required\n * to make all pixels the same color.\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *    minOperations(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction minOperations(n: number, pixels: number[]): number", "canonical_solution": "{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}", "test": "(() => {\n    console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2);\n    console.assert(minOperations(4, [1, 1, 2, 2]) === 1);\n    console.assert(minOperations(5, [1, 2, 1, 4, 2]) === 3);\n    console.assert(minOperations(5, [5, 5, 5, 5, 5]) === 0);\n    console.assert(minOperations(6, [1, 1, 1, 2, 2, 2]) === 1);\n    console.assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) === 2);\n    console.assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1);\n    console.assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8);\n    console.assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5);\n    console.assert(minOperations(3, [3, 3, 3]) === 0);\n    console.assert(minOperations(4, [2, 1, 1, 2]) === 1);\n})();", "entry_point": "minOperations", "signature": "function minOperations(n: number, pixels: number[]): number", "docstring": "Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\nconnected pixels of the same color to a chosen color, where two pixels are connected if they are\nadjacent and have the same color. The goal is to find the minimum number of operations required\nto make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2\n", "instruction": "Write a TypeScript function `function minOperations(n: number, pixels: number[]): number` to solve the following problem:\nGiven a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\nconnected pixels of the same color to a chosen color, where two pixels are connected if they are\nadjacent and have the same color. The goal is to find the minimum number of operations required\nto make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2\n", "level": "hard"}
{"task_id": "TypeScript/46", "prompt": "\n/**\n * Given an integer n, write a function to compute the sum of all numbers from 1 to n\n * that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\n * it should only be counted once.\n * \n * For example:\n *     sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {", "canonical_solution": "let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "test": "const testSumOfMultiples = (): void => {\n    console.assert(sumOfMultiples(10) === 33, 'Test case n=10 failed');\n    console.assert(sumOfMultiples(15) === 60, 'Test case n=15 failed');\n    console.assert(sumOfMultiples(20) === 98, 'Test case n=20 failed');\n    console.assert(sumOfMultiples(5) === 8, 'Test case n=5 failed');\n    console.assert(sumOfMultiples(3) === 3, 'Test case n=3 failed');\n    console.assert(sumOfMultiples(6) === 14, 'Test case n=6 failed');\n    console.assert(sumOfMultiples(9) === 23, 'Test case n=9 failed');\n    console.assert(sumOfMultiples(12) === 45, 'Test case n=12 failed');\n    console.assert(sumOfMultiples(17) === 60, 'Test case n=17 failed');\n    console.assert(sumOfMultiples(21) === 119, 'Test case n=21 failed');\n    console.assert(sumOfMultiples(25) === 168, 'Test case n=25 failed');\n};\n\ntestSumOfMultiples();", "entry_point": "sumOfMultiples", "signature": "function sumOfMultiples(n: number): number", "docstring": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "instruction": "Write a TypeScript function `function sumOfMultiples(n: number): number` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)", "level": "easy"}
{"task_id": "TypeScript/47", "prompt": "\n/**\n * Determine if a given string is a palindrome.\n * A palindrome is a word, phrase, number, or other sequence of characters\n * that reads the same forward and backward (ignoring spaces, punctuation,\n * and capitalization).\n * \n * Examples:\n * isPalindrome(\"racecar\") // returns true\n */\nfunction isPalindrome(str: string): boolean", "canonical_solution": "{\n  let start: number = 0;\n  let end: number = str.length - 1;\n\n  while (start < end) {\n    // Skip non-alphanumeric characters and handle case insensitivity\n    while (!isalnum(str[start]) && start < end) start++;\n    while (!isalnum(str[end]) && start < end) end--;\n    if (str[start].toLowerCase() !== str[end].toLowerCase())\n      return false;\n    start++;\n    end--;\n  }\n  return true;\n}\n\n// Helper function to check if a character is alphanumeric\nfunction isalnum(char: string): boolean {\n  let code: number = char.charCodeAt(0);\n  return (code > 47 && code < 58) || // numeric (0-9)\n         (code > 64 && code < 91) || // upper alpha (A-Z)\n         (code > 96 && code < 123);  // lower alpha (a-z)\n}", "test": "const testIsPalindrome = (): void => {\n  console.assert(isPalindrome(\"A man a plan a canal Panama\") === true, \"Test 1 failed\");\n  console.assert(isPalindrome(\"No lemon, no melon\") === true, \"Test 2 failed\");\n  console.assert(isPalindrome(\"Was it a car or a cat I saw\") === true, \"Test 3 failed\");\n  console.assert(isPalindrome(\"Madam, in Eden, I'm Adam\") === true, \"Test 4 failed\");\n  console.assert(isPalindrome(\"Never odd or even\") === true, \"Test 5 failed\");\n  console.assert(isPalindrome(\"Eva, can I see bees in a cave\") === true, \"Test 6 failed\");\n  console.assert(isPalindrome(\"hello\") === false, \"Test 7 failed\");\n  console.assert(isPalindrome(\"GitHub\") === false, \"Test 8 failed\");\n  console.assert(isPalindrome(\"programming\") === false, \"Test 9 failed\");\n};\n\ntestIsPalindrome();", "entry_point": "isPalindrome", "signature": "function isPalindrome(str: string): boolean", "docstring": "Determine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\n", "instruction": "Write a TypeScript function `function isPalindrome(str: string): boolean` to solve the following problem:\nDetermine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\n", "level": "hard"}
{"task_id": "TypeScript/48", "prompt": "\n/**\n * Given a non-negative integer num, repeatedly add all its digits until\n * the result has only one digit. \n * For example:\n *   addDigits(38)  // returns 2\n *   Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n */\nfunction addDigits(num: number): number {", "canonical_solution": "while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}", "test": "const testAddDigits = (): void => {\n    console.assert(addDigits(38) === 2, 'Test 1 failed');\n    console.assert(addDigits(0) === 0, 'Test 2 failed');\n    console.assert(addDigits(9) === 9, 'Test 3 failed');\n    console.assert(addDigits(123) === 6, 'Test 4 failed');\n    console.assert(addDigits(456) === 6, 'Test 5 failed');\n    console.assert(addDigits(9999) === 9, 'Test 6 failed');\n    console.assert(addDigits(100) === 1, 'Test 7 failed');\n    console.assert(addDigits(1010) === 2, 'Test 8 failed');\n    console.assert(addDigits(1234) === 1, 'Test 9 failed');\n    console.assert(addDigits(9876) === 3, 'Test 10 failed');\n    console.assert(addDigits(199) === 1, 'Test 11 failed');\n};\n\ntestAddDigits();", "entry_point": "addDigits", "signature": "function addDigits(num: number): number", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "instruction": "Write a TypeScript function `function addDigits(num: number): number` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "level": "easy"}
{"task_id": "TypeScript/49", "prompt": "\n/**\n * You are playing a game called Nim. In this game, you start with a pile\n * of n stones, and you and your opponent take turns to remove 1 to 3\n * stones from the pile. The one who removes the last stone wins the game.\n * Given the number of stones n, determine if you can win the game if both\n * you and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *   canWinNim(1) // returns true\n */\nfunction canWinNim(n: number): boolean", "canonical_solution": "{\n    return n % 4 !== 0;\n}", "test": "function testCanWinNim(): void {\n    console.assert(canWinNim(1) === true, \"Test case 1 failed\");\n    console.assert(canWinNim(2) === true, \"Test case 2 failed\");\n    console.assert(canWinNim(3) === true, \"Test case 3 failed\");\n    console.assert(canWinNim(4) === false, \"Test case 4 failed\");\n    console.assert(canWinNim(5) === true, \"Test case 5 failed\");\n    console.assert(canWinNim(6) === true, \"Test case 6 failed\");\n    console.assert(canWinNim(7) === true, \"Test case 7 failed\");\n    console.assert(canWinNim(8) === false, \"Test case 8 failed\");\n    console.assert(canWinNim(9) === true, \"Test case 9 failed\");\n    console.assert(canWinNim(10) === true, \"Test case 10 failed\");\n    console.assert(canWinNim(11) === true, \"Test case 11 failed\");\n    console.assert(canWinNim(12) === false, \"Test case 12 failed\");\n    console.assert(canWinNim(13) === true, \"Test case 13 failed\");\n    console.assert(canWinNim(14) === true, \"Test case 14 failed\");\n    console.assert(canWinNim(15) === true, \"Test case 15 failed\");\n    console.assert(canWinNim(16) === false, \"Test case 16 failed\");\n    console.assert(canWinNim(17) === true, \"Test case 17 failed\");\n    console.assert(canWinNim(18) === true, \"Test case 18 failed\");\n    console.assert(canWinNim(19) === true, \"Test case 19 failed\");\n    console.assert(canWinNim(20) === false, \"Test case 20 failed\");\n}\ntestCanWinNim();", "entry_point": "canWinNim", "signature": "function canWinNim(n: number): boolean", "docstring": "You are playing a game called Nim. In this game, you start with a pile\nof n stones, and you and your opponent take turns to remove 1 to 3\nstones from the pile. The one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both\nyou and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true\n", "instruction": "Write a TypeScript function `function canWinNim(n: number): boolean` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile\nof n stones, and you and your opponent take turns to remove 1 to 3\nstones from the pile. The one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both\nyou and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true\n", "level": "easy"}
{"task_id": "TypeScript/50", "prompt": "\n/**\n * Given two integers a and b, return the sum if the sum is even,\n * or return the product of a and b if the sum is odd.\n * Examples:\n *   evenSumOrOddProduct(2, 3) returns 6\n *   evenSumOrOddProduct(5, 5) returns 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {", "canonical_solution": "let sum = a + b;\n    if (sum % 2 === 0) {\n        return sum;\n    } else {\n        return a * b;\n    }\n}", "test": "const testEvenSumOrOddProduct = (): void => {\n    console.assert(evenSumOrOddProduct(2, 3) === 6, 'Test Case 1 Failed');\n    console.assert(evenSumOrOddProduct(5, 5) === 10, 'Test Case 2 Failed');\n    console.assert(evenSumOrOddProduct(1, 1) === 2, 'Test Case 3 Failed');\n    console.assert(evenSumOrOddProduct(0, 0) === 0, 'Test Case 4 Failed');\n    console.assert(evenSumOrOddProduct(-1, -1) === -2, 'Test Case 5 Failed');\n    console.assert(evenSumOrOddProduct(100, 200) === 300, 'Test Case 6 Failed');\n    console.assert(evenSumOrOddProduct(3, 4) === 12, 'Test Case 7 Failed');\n    console.assert(evenSumOrOddProduct(-5, 5) === 0, 'Test Case 8 Failed');\n    console.assert(evenSumOrOddProduct(7, 8) === 56, 'Test Case 9 Failed');\n    console.assert(evenSumOrOddProduct(9, 10) === 90, 'Test Case 10 Failed');\n    console.assert(evenSumOrOddProduct(11, 14) === 154, 'Test Case 11 Failed');\n};\n\ntestEvenSumOrOddProduct();", "entry_point": "evenSumOrOddProduct", "signature": "function evenSumOrOddProduct(a: number, b: number): number", "docstring": "Given two integers a and b, return the sum if the sum is even,\nor return the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10\n", "instruction": "Write a TypeScript function `function evenSumOrOddProduct(a: number, b: number): number` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even,\nor return the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10\n", "level": "easy"}
