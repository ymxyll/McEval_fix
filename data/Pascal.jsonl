{"task_id": "Pascal/1", "prompt": "{$ASSERTIONS ON}\n// Return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string;", "canonical_solution": "begin\n    // Solution\n    hello_mmcodeeval := 'Hello, MMCODEEVAL: Massively Multilingual Code Evaluation';\nend;", "test": "procedure testHelloMMCodeEval();\nbegin\n    Assert(hello_mmcodeeval() = 'Hello, MMCODEEVAL: Massively Multilingual Code Evaluation');\nend;\n\nbegin\n    testHelloMMCodeEval();\nend.", "entry_point": "hello_mmcodeeval", "signature": "function hello_mmcodeeval(): string;", "docstring": "Return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "instruction": "Write a Pascal function `function hello_mmcodeeval(): string;` to solve the following problem:\nReturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "level": "easy"}
{"task_id": "Pascal/2", "prompt": "{$ASSERTIONS ON}\n\nuses \n  Math, SysUtils;\n(*\nCalculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.\n\nExamples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00\n*)\nfunction calculate_triangle_area(a, b, c: real): real;\nvar\n  s: real;", "canonical_solution": "begin\n  if (a + b > c) and (a + c > b) and (b + c > a) then\n  begin\n    s := (a + b + c) / 2;\n    calculate_triangle_area := sqrt(s * (s - a) * (s - b) * (s - c));\n  end\n  else\n    calculate_triangle_area := -1; (* Not a triangle *)\nend;", "test": "procedure testCalculateTriangleArea;\nvar\n  area: real;\nbegin\n  (* Triangle with sides 3, 5, 4 should return area 6 *)\n  area := calculate_triangle_area(3, 5, 4);\n  Assert(abs(area - 6) < 1e-6);\n\n  (* Not a triangle with sides 1, 1, 4 should return -1 *)\n  area := calculate_triangle_area(1, 1, 4);\n  Assert(area = -1);\n\n  (* Triangle with sides 7, 24, 25 should return area 84 *)\n  area := calculate_triangle_area(7, 24, 25);\n  Assert(abs(area - 84) < 1e-6);\n\n  (* Triangle with sides 10.5, 6.2, 7.3 should return a calculated area *)\n  area := calculate_triangle_area(10.5, 6.2, 7.3);\n  (* For precision issues, we test if the calculated area is close enough to the expected value *)\n  Assert(abs(area - 22.15) < 1e-2);\nend;\n\n(* Main *)\nbegin\n  testCalculateTriangleArea;\nend.", "entry_point": "calculate_triangle_area", "signature": "function calculate_triangle_area(a, b, c: real): real;", "docstring": "Calculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.\n\nExamples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00", "instruction": "Write a Pascal function `function calculate_triangle_area(a, b, c: real): real;` to solve the following problem:\nCalculates the area of a triangle given the lengths of its three sides.\n\nParameters:\n- a (real): Length of side 'a'.\n- b (real): Length of side 'b'.\n- c (real): Length of side 'c'.\n\nReturns:\n- real: If the sides can form a triangle, returns the calculated area rounded to 2 decimal places.\n         Otherwise, returns -1 indicating that the sides do not form a triangle.\n\nExamples:\n    >>> calculate_triangle_area(3, 5, 4)\n    6.00", "level": "easy"}
{"task_id": "Pascal/3", "prompt": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\n(*\n    Calculates the value of the function for a given input.\n      Parameters:\n        - x (integer): Input value for the function.\n      Returns:\n        - A string with either the calculated function value rounded to 5 decimal places,\n          or a notice that the input is not in the defined domain (\"Not define\").\n       \n      Function Definitions:\n        - For 0 <= x < 10: y = cos(x + 3.0)\n        - For 10 <= x < 20: y = (cos(x + 7.5))^2\n        - For 20 <= x < 30: y = (cos(x + 4.0))^4\n        >>> calculate_function_value(40)\n        'Not define'\n*)\nfunction calculate_function_value(x: Integer): string;", "canonical_solution": "var\n  calculated_value: Double;\nbegin\n  if (0 <= x) and (x < 10) then\n  begin\n    calculated_value := cos(x + 3.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (10 <= x) and (x < 20) then\n  begin\n    calculated_value := Power(cos(x + 7.5), 2.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else if (20 <= x) and (x < 30) then\n  begin\n    calculated_value := Power(cos(x + 4.0), 4.0);\n    calculate_function_value := FormatFloat('0.00000', calculated_value);\n  end\n  else\n  begin\n    calculate_function_value := 'Not define';\n  end;\nend;", "test": "procedure testCalculateFunctionValue;\nvar\n  result: string;\nbegin\n  result := calculate_function_value(40);\n  Assert(result = 'Not define');\n  // WriteLn(calculate_function_value(5))\n\n  // Additional test cases based on provided function definitions\n  Assert(calculate_function_value(5) = '-0.14550');\n  Assert(calculate_function_value(15) = '0.76266');\n  Assert(calculate_function_value(25) = '0.31314');\n  Assert(calculate_function_value(-1) = 'Not define');\nend;\n\nbegin\n  testCalculateFunctionValue;\nend.", "entry_point": "calculate_function_value", "signature": "function calculate_function_value(x: Integer): string;", "docstring": "Calculates the value of the function for a given input.\n      Parameters:\n        - x (integer): Input value for the function.\n      Returns:\n        - A string with either the calculated function value rounded to 5 decimal places,\n          or a notice that the input is not in the defined domain ('Not define').\n       \n      Function Definitions:\n        - For 0 <= x < 10: y = cos(x + 3.0)\n        - For 10 <= x < 20: y = (cos(x + 7.5))^2\n        - For 20 <= x < 30: y = (cos(x + 4.0))^4\n        >>> calculate_function_value(40)\n        'Not define'", "instruction": "Write a Pascal function `function calculate_function_value(x: Integer): string;` to solve the following problem:\nCalculates the value of the function for a given input.\n      Parameters:\n        - x (integer): Input value for the function.\n      Returns:\n        - A string with either the calculated function value rounded to 5 decimal places,\n          or a notice that the input is not in the defined domain ('Not define').\n       \n      Function Definitions:\n        - For 0 <= x < 10: y = cos(x + 3.0)\n        - For 10 <= x < 20: y = (cos(x + 7.5))^2\n        - For 20 <= x < 30: y = (cos(x + 4.0))^4\n        >>> calculate_function_value(40)\n        'Not define'", "level": "hard"}
{"task_id": "Pascal/4", "prompt": "\n(*\n  Determines the maximum and minimum of three distinct integers.\n\n  Parameters:\n  a, b, c (integers): Input values among which max and min are to be found.\n\n  This procedure assigns the maximum to the variable 'max', and the minimum to the variable 'min'. Since Pascal does not support returning multiple values directly, we pass parameters by reference.\n\n  Examples:\n  var max, min: integer;\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1));\n*)\nprocedure find_max_min(a, b, c: integer; var max, min: integer);", "canonical_solution": "begin\n  if a > b then\n  begin\n    if a > c then\n    begin\n      max := a;\n      if b < c then\n        min := b\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      min := b;\n    end;\n  end\n  else\n  begin\n    if b > c then\n    begin\n      max := b;\n      if a < c then\n        min := a\n      else\n        min := c;\n    end\n    else\n    begin\n      max := c;\n      if a < b then\n        min := a\n      else\n        min := b;\n    end;\n  end;\nend;", "test": "procedure TestFindMaxMin;\nvar\n  max, min: integer;\nbegin\n  find_max_min(1, 2, 3, max, min);\n  Assert((max = 3) and (min = 1), 'Test case 1 failed');\n\n  find_max_min(5, 3, 4, max, min);\n  Assert((max = 5) and (min = 3), 'Test case 2 failed');\n\n  find_max_min(10, -2, 7, max, min);\n  Assert((max = 10) and (min = -2), 'Test case 3 failed');\n\n  find_max_min(-1, -3, -2, max, min);\n  Assert((max = -1) and (min = -3), 'Test case 4 failed');\nend;\n\nbegin\n  TestFindMaxMin;\n  WriteLn('All tests passed.');\nend.", "entry_point": "find_max_min", "signature": "procedure find_max_min(a, b, c: integer; var max, min: integer);", "docstring": "Determines the maximum and minimum of three distinct integers.\n\nParameters:\na, b, c (integers): Input values among which max and min are to be found.\n\nThis procedure assigns the maximum to the variable 'max', and the minimum to the variable 'min'. Since Pascal does not support returning multiple values directly, we pass parameters by reference.\n\nExamples:\nvar max, min: integer;\nfind_max_min(1, 2, 3, max, min);\nAssert((max = 3) and (min = 1));\n", "instruction": "Write a Pascal function `procedure find_max_min(a, b, c: integer; var max, min: integer);` to solve the following problem:\nDetermines the maximum and minimum of three distinct integers.\n\nParameters:\na, b, c (integers): Input values among which max and min are to be found.\n\nThis procedure assigns the maximum to the variable 'max', and the minimum to the variable 'min'. Since Pascal does not support returning multiple values directly, we pass parameters by reference.\n\nExamples:\nvar max, min: integer;\nfind_max_min(1, 2, 3, max, min);\nAssert((max = 3) and (min = 1));\n", "level": "middle"}
{"task_id": "Pascal/5", "prompt": "{$ASSERTIONS ON}\n\n(* Pascal does not have a direct equivalent to <math.h> or <string.h>, but its built-in math support will suffice for this conversion. SysUtils can be used for extended system functionality. *)\n\nuses\n  SysUtils, Math;\n(**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n *\n * Parameters:\n * - xa (Double): x-coordinate of point A.\n * - ya (Double): y-coordinate of point A.\n * - xb (Double): x-coordinate of point B.\n * - yb (Double): y-coordinate of point B.\n *\n * Returns:\n * Double: The distance between points A and B.\n *\n * Examples:\n * >>> calculate_distance(0,0,3,4)\n * 5\n *)\nfunction calculate_distance(xa, ya, xb, yb: Double): Double;", "canonical_solution": "begin\n    calculate_distance := sqrt(sqr(xa - xb) + sqr(ya - yb));\nend;", "test": "procedure testCalculateDistance;\nvar\n  epsilon: Double;\nbegin\n  epsilon := 1e-6;\n  Assert(abs(calculate_distance(0, 0, 3, 4) - 5) < epsilon);\n  Assert(abs(calculate_distance(0, 0, 0, 0) - 0) < epsilon);\n  Assert(abs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < epsilon);\n  Assert(abs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < epsilon);\n  // writeln('All test cases passed!');\nend;\n\nbegin\n  testCalculateDistance;\nend.", "entry_point": "calculate_distance", "signature": "function calculate_distance(xa, ya, xb, yb: Double): Double;", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (Double): x-coordinate of point A.\n- ya (Double): y-coordinate of point A.\n- xb (Double): x-coordinate of point B.\n- yb (Double): y-coordinate of point B.\n\nReturns:\nDouble: The distance between points A and B.\n\nExamples:\n>>> calculate_distance(0,0,3,4)\n5", "instruction": "Write a Pascal function `function calculate_distance(xa, ya, xb, yb: Double): Double;` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (Double): x-coordinate of point A.\n- ya (Double): y-coordinate of point A.\n- xb (Double): x-coordinate of point B.\n- yb (Double): y-coordinate of point B.\n\nReturns:\nDouble: The distance between points A and B.\n\nExamples:\n>>> calculate_distance(0,0,3,4)\n5", "level": "easy"}
{"task_id": "Pascal/6", "prompt": "{$ASSERTIONS ON}\n{\n  Calculates the factorial of a given number N modulo 10007.\n  \n  Parameters:\n  - N (integer): An integer representing the input value (N <= 10000).\n  \n  Returns:\n  - integer: The factorial of N modulo 10007.\n  \n  Examples:\n  - process_request(1) returns 1\n  - process_request(2) returns 2\n  - process_request(3) returns 6\n}\nfunction process_request(n: integer): integer;", "canonical_solution": "const\n  MODULO = 10007;\nvar\n  a: array[0..10000] of integer;\n  i: integer;\nbegin\n  // Initialize the first two factorials\n  a[0] := 1;\n  a[1] := 1;\n  // Calculate factorials up to 10000 modulo 10007\n  for i := 2 to 10000 do\n  begin\n    a[i] := (a[i-1] * i) mod MODULO;\n  end;\n  \n  // Return the requested factorial modulo\n  process_request := a[n];\nend;", "test": "procedure testProcessRequest;\nbegin\n  Assert(process_request(0) = 1, 'Test for N = 0 failed');\n  Assert(process_request(1) = 1, 'Test for N = 1 failed');\n  Assert(process_request(2) = 2, 'Test for N = 2 failed');\n  Assert(process_request(3) = 6, 'Test for N = 3 failed');\n  Assert(process_request(4) = 24, 'Test for N = 4 failed');\n  Assert(process_request(10) = 6266, 'Test for N = 10 failed');\n  Assert(process_request(10000) = 6991, 'Test for N = 10000 failed');\nend;\n\nbegin\n  (* Run the tests *)\n  testProcessRequest;\n  // WriteLn('All tests passed.');\nend.", "entry_point": "process_request", "signature": "function process_request(n: integer): integer;", "docstring": "Calculates the factorial of a given number N modulo 10007.\n\nParameters:\n- N (integer): An integer representing the input value (N <= 10000).\n\nReturns:\n- integer: The factorial of N modulo 10007.\n\nExamples:\n- process_request(1) returns 1\n- process_request(2) returns 2\n- process_request(3) returns 6\n", "instruction": "Write a Pascal function `function process_request(n: integer): integer;` to solve the following problem:\nCalculates the factorial of a given number N modulo 10007.\n\nParameters:\n- N (integer): An integer representing the input value (N <= 10000).\n\nReturns:\n- integer: The factorial of N modulo 10007.\n\nExamples:\n- process_request(1) returns 1\n- process_request(2) returns 2\n- process_request(3) returns 6\n", "level": "easy"}
{"task_id": "Pascal/7", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n(*\n  Calculate the area of a triangle given its base and height.\n  Parameters:\n  - base (Integer): The base length of the triangle.\n  - height (Integer): The height of the triangle.\n  Returns:\n  Float: The calculated area of the triangle, rounded to one decimal place.\n  Example Usage:\n  >>> calculate_triangle_area(1, 2)\n  1.0\n*)\nfunction calculate_triangle_area(base, height: Integer): Double;", "canonical_solution": "begin\n  // The area formula for a triangle is: area = (base * height) / 2\n  calculate_triangle_area := base * height / 2.0;\nend;", "test": "procedure testCalculateTriangleArea;\nvar\n  epsilon: Double;\nbegin\n  epsilon := 1e-6;\n  Assert(abs(calculate_triangle_area(1, 2) - 1.0) < epsilon);\n  Assert(abs(calculate_triangle_area(3, 4) - 6.0) < epsilon);\n  Assert(abs(calculate_triangle_area(5, 8) - 20.0) < epsilon);\n  Assert(abs(calculate_triangle_area(7, 3) - 10.5) < epsilon);\n  Assert(abs(calculate_triangle_area(10, 10) - 50.0) < epsilon);\nend;\n\nbegin\n  testCalculateTriangleArea;\nend.", "entry_point": "calculate_triangle_area", "signature": "function calculate_triangle_area(base, height: Integer): Double;", "docstring": "Calculate the area of a triangle given its base and height.\nParameters:\n- base (Integer): The base length of the triangle.\n- height (Integer): The height of the triangle.\nReturns:\nFloat: The calculated area of the triangle, rounded to one decimal place.\nExample Usage:\n>>> calculate_triangle_area(1, 2)\n1.0\n", "instruction": "Write a Pascal function `function calculate_triangle_area(base, height: Integer): Double;` to solve the following problem:\nCalculate the area of a triangle given its base and height.\nParameters:\n- base (Integer): The base length of the triangle.\n- height (Integer): The height of the triangle.\nReturns:\nFloat: The calculated area of the triangle, rounded to one decimal place.\nExample Usage:\n>>> calculate_triangle_area(1, 2)\n1.0\n", "level": "easy"}
{"task_id": "Pascal/8", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\nCalculate the Hamming distance between two integers in binary representation.\n\nParameters:\n- x (Integer): The first positive integer (x <= 1,000,000,000).\n- y (Integer): The second positive integer (y <= 1,000,000,000).\n\nReturns:\nInteger: The Hamming distance between x and y, i.e., the number of bits that \n         need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n*)\nfunction hamming_distance(x, y: Integer): Integer;", "canonical_solution": "var\n  distance: Integer;\n  xor_result: Integer;\nbegin\n  distance := 0;\n  xor_result := x xor y; // XOR x and y to get a number where set bits are the differences\n  // Count the number of bits set in xor_result\n  while xor_result <> 0 do\n  begin\n    if xor_result and 1 = 1 then\n      Inc(distance);\n    xor_result := xor_result shr 1;\n  end;\n  hamming_distance := distance;\nend;", "test": "procedure testHammingDistance;\nbegin\n  Assert(hamming_distance(1, 2) = 2, 'Test Failed: (1, 2)'); // 01 and 10 have 2 different bits\n  Assert(hamming_distance(4, 7) = 2, 'Test Failed: (4, 7)'); // 100 and 111 have 2 different bits\n  Assert(hamming_distance(25, 30) = 3, 'Test Failed: (25, 30)'); // Additional test: 11001 and 11110 have 3 different bits\n  Assert(hamming_distance(0, 0) = 0, 'Test Failed: (0, 0)'); // Additional test: Same numbers have 0 different bits\n  Assert(hamming_distance($7FFF, 0) = 15, 'Test Failed: ($7FFF, 0)'); // Additional test: Max unsigned int and 0 have 32 different bits\nend;\n\nbegin\n  testHammingDistance;\nend.", "entry_point": "hamming_distance", "signature": "function hamming_distance(x, y: Integer): Integer;", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n\nParameters:\n- x (Integer): The first positive integer (x <= 1,000,000,000).\n- y (Integer): The second positive integer (y <= 1,000,000,000).\n\nReturns:\nInteger: The Hamming distance between x and y, i.e., the number of bits that \n         need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n", "instruction": "Write a Pascal function `function hamming_distance(x, y: Integer): Integer;` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\n\nParameters:\n- x (Integer): The first positive integer (x <= 1,000,000,000).\n- y (Integer): The second positive integer (y <= 1,000,000,000).\n\nReturns:\nInteger: The Hamming distance between x and y, i.e., the number of bits that \n         need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n", "level": "middle"}
{"task_id": "Pascal/9", "prompt": "{$ASSERTIONS ON}\n{\n  Counts the number of odd integers in a given list of numbers.\n  Parameters:\n    - count: The number of integers to evaluate.\n    - numbers: An open array of integers.\n  Returns:\n    The count of odd numbers in the input array.\n  Example:\n    >>> count_odd_numbers(5, [1, 4, 3, 2, 5])\n    Result: 3\n}\nfunction count_odd_numbers(count: Integer; const numbers: array of Integer): Integer;", "canonical_solution": "var\n  i, ans: Integer;\nbegin\n  ans := 0;\n  for i := 0 to count - 1 do\n  begin\n    if (numbers[i] and 1) <> 0 then\n      Inc(ans);\n  end;\n  count_odd_numbers := ans;\nend;", "test": "procedure testCountOddNumbers;\nbegin\n  Assert(count_odd_numbers(5, [1, 4, 3, 2, 5]) = 3);\n  Assert(count_odd_numbers(4, [2, 2, 0, 0]) = 0);\n  Assert(count_odd_numbers(6, [7, 7, 8, 1, 9, 10]) = 4); // Additional Test Sample\nend;\n\nbegin\n  testCountOddNumbers;\n  // WriteLn('All tests passed!');\nend.", "entry_point": "count_odd_numbers", "signature": "function count_odd_numbers(count: Integer; const numbers: array of Integer): Integer;", "docstring": "Counts the number of odd integers in a given list of numbers.\nParameters:\n  - count: The number of integers to evaluate.\n  - numbers: An open array of integers.\nReturns:\n  The count of odd numbers in the input array.\nExample:\n  >>> count_odd_numbers(5, [1, 4, 3, 2, 5])\n  Result: 3\n", "instruction": "Write a Pascal function `function count_odd_numbers(count: Integer; const numbers: array of Integer): Integer;` to solve the following problem:\nCounts the number of odd integers in a given list of numbers.\nParameters:\n  - count: The number of integers to evaluate.\n  - numbers: An open array of integers.\nReturns:\n  The count of odd numbers in the input array.\nExample:\n  >>> count_odd_numbers(5, [1, 4, 3, 2, 5])\n  Result: 3\n", "level": "easy"}
{"task_id": "Pascal/10", "prompt": "{$ASSERTIONS ON}\n(**\n * Calculate the sum of even numbers in a given list.\n * Parameters:\n * - numbers: An array of integers.\n * - size: The number of elements in the array.\n * Returns:\n * The sum of even numbers in the input array.\n *\n * Example usage:\n * >>> calculate_even_sum([1, 4, 3, 2, 5], 5)\n * 6\n *)\nfunction calculate_even_sum(numbers: array of Integer; size: Integer): Integer;", "canonical_solution": "var\n  i, ans: Integer;\nbegin\n  ans := 0;\n  for i := 0 to size - 1 do\n  begin\n    if (numbers[i] mod 2) = 0 then\n    begin\n      ans := ans + numbers[i];\n    end;\n  end;\n  calculate_even_sum := ans;\nend;", "test": "procedure testCalculateEvenSum;\nvar\n  sample1: array[0..4] of Integer = (1, 4, 3, 2, 5);\n  sample2: array[0..3] of Integer = (2, 2, 0, 0);\n  sample3: array[0..2] of Integer = (7, 11, 19);\n  sample4: array[0..4] of Integer = (12, 14, 16, 18, 20);\nbegin\n  Assert(calculate_even_sum(sample1, 5) = 6);\n  Assert(calculate_even_sum(sample2, 4) = 4);\n  Assert(calculate_even_sum(sample3, 3) = 0);\n  Assert(calculate_even_sum(sample4, 5) = 12 + 14 + 16 + 18 + 20);\nend;\n\nbegin\n  testCalculateEvenSum;\nend.", "entry_point": "calculate_even_sum", "signature": "function calculate_even_sum(numbers: array of Integer; size: Integer): Integer;", "docstring": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers: An array of integers.\n- size: The number of elements in the array.\nReturns:\n- The sum of even numbers in the input array.\n\nExample usage:\n- >>> calculate_even_sum([1, 4, 3, 2, 5], 5)\n- 6\n", "instruction": "Write a Pascal function `function calculate_even_sum(numbers: array of Integer; size: Integer): Integer;` to solve the following problem:\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers: An array of integers.\n- size: The number of elements in the array.\nReturns:\n- The sum of even numbers in the input array.\n\nExample usage:\n- >>> calculate_even_sum([1, 4, 3, 2, 5], 5)\n- 6\n", "level": "easy"}
{"task_id": "Pascal/11", "prompt": "{$MODE OBJFPC}{$H+}{$ASSERTIONS ON}\n(*\n  Determine if two closed intervals intersect.\n    Arguments:\n    a, b: Represent the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Represent the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    An integer: 1 if the intervals intersect, 0 otherwise.\n*)\nfunction AreIntervalsIntersecting(a, b, c, d: Integer): Integer;", "canonical_solution": "begin\n  if ((c <= a) and (b <= d)) or\n     ((a <= c) and (c <= b) and (b <= d)) or\n     ((a <= c) and (d <= b)) or\n     ((c <= a) and (a <= d) and (d <= b)) then\n  begin\n    Result := 1; // Yes\n  end else\n  begin\n    Result := 0; // No\n  end;\nend;", "test": "procedure TestAreIntervalsIntersecting;\nbegin\n  Assert(AreIntervalsIntersecting(1, 1, 1, 2) = 1);\n  Assert(AreIntervalsIntersecting(3, 5, 2, 6) = 1);\n  Assert(AreIntervalsIntersecting(3, 5, 4, 7) = 1);\n  Assert(AreIntervalsIntersecting(3, 5, 6, 7) = 0);\n  // Additional test cases\n  Assert(AreIntervalsIntersecting(0, 0, 0, 0) = 1);\n  Assert(AreIntervalsIntersecting(1, 3, 2, 4) = 1);\n  Assert(AreIntervalsIntersecting(1, 3, 4, 6) = 0);\n  Assert(AreIntervalsIntersecting(10, 20, 20, 30) = 1);\n  Assert(AreIntervalsIntersecting(10, 20, 21, 30) = 0);\nend;\n\nbegin\n  TestAreIntervalsIntersecting;\nend.", "entry_point": "AreIntervalsIntersecting", "signature": "function AreIntervalsIntersecting(a, b, c, d: Integer): Integer;", "docstring": "Determine if two closed intervals intersect.\n    Arguments:\n    a, b: Represent the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Represent the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    An integer: 1 if the intervals intersect, 0 otherwise.\n", "instruction": "Write a Pascal function `function AreIntervalsIntersecting(a, b, c, d: Integer): Integer;` to solve the following problem:\nDetermine if two closed intervals intersect.\n    Arguments:\n    a, b: Represent the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Represent the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    An integer: 1 if the intervals intersect, 0 otherwise.\n", "level": "easy"}
{"task_id": "Pascal/12", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n(*\nGiven three integers a, b, and c, with two of them being equal and the third one being distinct,\nthe task is to identify and return the distinct integer that occurs exactly once.\nExamples:\n>>> extraNumber(0,0,1) returns 1\n>>> extraNumber(4,3,4) returns 3\n*)\nfunction extraNumber(a, b, c: integer): integer;", "canonical_solution": "begin\n    if a = b then\n        extraNumber := c\n    else if a = c then\n        extraNumber := b\n    else\n        extraNumber := a;\nend;", "test": "procedure testExtraNumber;\nbegin\n    Assert(extraNumber(2, 7, 2) = 7);\n    Assert(extraNumber(3, 2, 2) = 3);\n    Assert(extraNumber(5, 5, 1) = 1);\n    Assert(extraNumber(500000000, 3, 500000000) = 3);\n    Assert(extraNumber(500000000, 500000000, 3) = 3);\nend;\n\nbegin\n    testExtraNumber;\n    WriteLn('All test cases passed!');\nend.", "entry_point": "extraNumber", "signature": "function extraNumber(a, b, c: integer): integer;", "docstring": "Given three integers a, b, and c, with two of them being equal and the third one being distinct,\nthe task is to identify and return the distinct integer that occurs exactly once.\nExamples:\n>>> extraNumber(0,0,1) returns 1\n>>> extraNumber(4,3,4) returns 3", "instruction": "Write a Pascal function `function extraNumber(a, b, c: integer): integer;` to solve the following problem:\nGiven three integers a, b, and c, with two of them being equal and the third one being distinct,\nthe task is to identify and return the distinct integer that occurs exactly once.\nExamples:\n>>> extraNumber(0,0,1) returns 1\n>>> extraNumber(4,3,4) returns 3", "level": "easy"}
{"task_id": "Pascal/13", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n(*\n  Calculate the total score for a student based on the scores in different subjects.\n  The function takes five integer arguments, each representing the score in one subject,\n  and returns the total score by adding them together.\n  Example:\n    >>> calculate_total_score(100, 100, 100, 100, 100)\n    500\n*)\nfunction calculate_total_score(score1, score2, score3, score4, score5: integer): integer;", "canonical_solution": "begin\n    calculate_total_score := score1 + score2 + score3 + score4 + score5;\nend;", "test": "procedure testCalculateTotalScore;\nbegin\n    Assert(calculate_total_score(100, 100, 100, 100, 100) = 500);\n    Assert(calculate_total_score(0, 0, 0, 0, 0) = 0);\n    Assert(calculate_total_score(20, 30, 40, 10, 50) = 150);\n    Assert(calculate_total_score(23, 45, 67, 89, 12) = 236);\n    Assert(calculate_total_score(5, 5, 5, 5, 5) = 25);\nend;\n\nbegin\n    testCalculateTotalScore;\nend.", "entry_point": "calculate_total_score", "signature": "function calculate_total_score(score1, score2, score3, score4, score5: integer): integer;", "docstring": "Calculate the total score for a student based on the scores in different subjects.\nThe function takes five integer arguments, each representing the score in one subject,\nand returns the total score by adding them together.\nExample:\n  >>> calculate_total_score(100, 100, 100, 100, 100)\n  500", "instruction": "Write a Pascal function `function calculate_total_score(score1, score2, score3, score4, score5: integer): integer;` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\nThe function takes five integer arguments, each representing the score in one subject,\nand returns the total score by adding them together.\nExample:\n  >>> calculate_total_score(100, 100, 100, 100, 100)\n  500", "level": "easy"}
{"task_id": "Pascal/14", "prompt": "{$ASSERTIONS ON}\n(*\n  Decode a series of numbers to reveal the pattern and understand the actual values\n  each digit represents.\n  0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n  \n  Parameters:\n  - data_str: A string representing a series of numbers. Length does not exceed 100.\n  \n  Returns:\n  integer: The result of each data string corresponding to the right-hand side of the equation.\n  \n  Example usage:\n  Assert(decodeNumbers('0000') = 4);\n*)\nfunction decodeNumbers(data_str: AnsiString): Integer;", "canonical_solution": "var\n  a: array[0..9] of Integer = (1, 0, 0, 0, 1, 0, 1, 0, 2, 1);\n  ans, i: Integer;\nbegin\n  ans := 0;\n  for i := 1 to Length(data_str) do\n  begin\n    ans := ans + a[Ord(data_str[i]) - Ord('0')];\n  end;\n  decodeNumbers := ans;\nend;", "test": "procedure testDecodeNumbers;\nbegin\n  Assert(decodeNumbers('0000') = 4);\n  Assert(decodeNumbers('8888') = 8);\n  Assert(decodeNumbers('1234') = 1);\n  Assert(decodeNumbers('5678') = 3);\n  Assert(decodeNumbers('9012') = 2);\n  Assert(decodeNumbers('1357') = 0);\n  Assert(decodeNumbers('2468') = 4);\n  // Additional test samples\n  Assert(decodeNumbers('9999') = 4);\n  Assert(decodeNumbers('1111') = 0);\n  Assert(decodeNumbers('2222') = 0);\n  Assert(decodeNumbers('3333') = 0);\n  Assert(decodeNumbers('4444') = 4);\n  Assert(decodeNumbers('5555') = 0);\n  Assert(decodeNumbers('6666') = 4);\n  Assert(decodeNumbers('7777') = 0);\n  Assert(decodeNumbers('0001') = 3);\n  Assert(decodeNumbers('2301') = 1);\nend;\n\nbegin\n  testDecodeNumbers;\nend.", "entry_point": "decodeNumbers", "signature": "function decodeNumbers(data_str: AnsiString): Integer;", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values\n  each digit represents.\n  0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n  \n  Parameters:\n  - data_str: A string representing a series of numbers. Length does not exceed 100.\n  \n  Returns:\n  integer: The result of each data string corresponding to the right-hand side of the equation.\n  \n  Example usage:\n  Assert(decodeNumbers('0000') = 4);", "instruction": "Write a Pascal function `function decodeNumbers(data_str: AnsiString): Integer;` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values\n  each digit represents.\n  0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n  \n  Parameters:\n  - data_str: A string representing a series of numbers. Length does not exceed 100.\n  \n  Returns:\n  integer: The result of each data string corresponding to the right-hand side of the equation.\n  \n  Example usage:\n  Assert(decodeNumbers('0000') = 4);", "level": "easy"}
{"task_id": "Pascal/15", "prompt": "{$ASSERTIONS ON}\n(**\n  Counts the number of different coloring methods for a series of n squares\n  using m colors. The coloring must ensure that adjacent squares, as well\n  as the first and last squares, are of different colors.\n  \n  Parameters:\n  - n (integer): The number of squares.\n  - m (integer): The number of colors.\n\n  Returns:\n  The count of different compatible coloring methods.\n  The result is computed modulo 1000003.\n\n  Examples:\n    >>> count_coloring_methods(1,1)\n    1\n*)\nfunction count_coloring_methods(n, m: integer): int64;", "canonical_solution": "var\n  f: array[1..1111] of int64; // Array to store results\n  i: integer;\nbegin\n  if n = 1 then Exit(m);\n  if n = 2 then Exit((int64(m) * (m - 1)) mod 1000003);\n\n  // Initialization\n  f[1] := m;\n  f[2] := (int64(m) * (m - 1)) mod 1000003;\n  f[3] := (int64(f[2]) * (m - 2)) mod 1000003;\n  \n  for i := 4 to n do begin\n    f[i] := ((int64(f[i - 1]) * (m - 2)) mod 1000003 +\n             (int64(f[i - 2]) * (m - 1)) mod 1000003) mod 1000003;\n  end;\n  \n  count_coloring_methods := f[n];\nend;", "test": "procedure testCountColoringMethods;\nbegin\n  // WriteLn(count_coloring_methods(1000, 10));\n  Assert(count_coloring_methods(1, 1) = 1);\n  Assert(count_coloring_methods(2, 2) = 2);\n  Assert(count_coloring_methods(3, 3) = 6);\n  Assert(count_coloring_methods(4, 2) = 2);\n  Assert(count_coloring_methods(1000, 10) = 566585); // Expected result not confirmed\n  \n  // Additional test cases\n  Assert(count_coloring_methods(2, 3) = 6);\n  Assert(count_coloring_methods(1000, 1000) = 67911);\n  Assert(count_coloring_methods(999, 66) = 501817);\n  Assert(count_coloring_methods(5, 3) = 30); // Example of an expected output\nend;\n\nbegin\n  testCountColoringMethods;\n  // Uncomment the line below if you want to print a success message\n  // Writeln('All tests passed!');\nend.", "entry_point": "count_coloring_methods", "signature": "function count_coloring_methods(n, m: integer): int64;", "docstring": "Counts the number of different coloring methods for a series of n squares\nusing m colors. The coloring must ensure that adjacent squares, as well\nas the first and last squares, are of different colors.\n\nParameters:\n- n (integer): The number of squares.\n- m (integer): The number of colors.\n\nReturns:\nThe count of different compatible coloring methods.\nThe result is computed modulo 1000003.\n\nExamples:\n  >>> count_coloring_methods(1,1)\n  1\n", "instruction": "Write a Pascal function `function count_coloring_methods(n, m: integer): int64;` to solve the following problem:\nCounts the number of different coloring methods for a series of n squares\nusing m colors. The coloring must ensure that adjacent squares, as well\nas the first and last squares, are of different colors.\n\nParameters:\n- n (integer): The number of squares.\n- m (integer): The number of colors.\n\nReturns:\nThe count of different compatible coloring methods.\nThe result is computed modulo 1000003.\n\nExamples:\n  >>> count_coloring_methods(1,1)\n  1\n", "level": "middle"}
{"task_id": "Pascal/16", "prompt": "{$ASSERTIONS ON}\n(*\nFunction that counts the number of valid coin toss sequences\nwithout consecutive heads. It calculates possible combinations\nfor a given number of tosses.\n\nParameters:\n- n: an integer representing the number of coin tosses.\n\nReturns:\nThe count of valid sequences as an unsigned 64-bit integer.\n\nExamples:\n>>> count_valid_coin_toss_sequences(1)\n2\n*)\nfunction count_valid_coin_toss_sequences(n: integer): int64;", "canonical_solution": "var\n  a: array[0..40, 0..1] of int64;\n  i: integer;\nbegin\n  a[1][0] := 1;\n  a[1][1] := 1;\n\n  for i := 2 to n do\n  begin\n    a[i][0] := a[i - 1][0] + a[i - 1][1];\n    a[i][1] := a[i - 1][0];\n  end;\n\n  count_valid_coin_toss_sequences := a[n][0] + a[n][1];\nend;", "test": "procedure test_count_valid_coin_toss_sequences;\nbegin\n  Assert(count_valid_coin_toss_sequences(1) = 2);\n  Assert(count_valid_coin_toss_sequences(2) = 3);\n  Assert(count_valid_coin_toss_sequences(3) = 5);\n  Assert(count_valid_coin_toss_sequences(4) = 8);\n  Assert(count_valid_coin_toss_sequences(5) = 13);\n  Assert(count_valid_coin_toss_sequences(40) = 267914296);\n  Assert(count_valid_coin_toss_sequences(39) = 165580141);\n  Assert(count_valid_coin_toss_sequences(38) = 102334155);\n\n  (* Uncomment the line below to add output for successful tests *)\n  // WriteLn('All tests passed!');\nend;\n\nbegin\n  test_count_valid_coin_toss_sequences;\nend.", "entry_point": "count_valid_coin_toss_sequences", "signature": "function count_valid_coin_toss_sequences(n: integer): int64;", "docstring": "Function that counts the number of valid coin toss sequences without consecutive heads. It calculates possible combinations for a given number of tosses.\n\nParameters:\n- n: an integer representing the number of coin tosses.\n\nReturns:\nThe count of valid sequences as an unsigned 64-bit integer.\n\nExamples:\n>>> count_valid_coin_toss_sequences(1)\n2\n", "instruction": "Write a Pascal function `function count_valid_coin_toss_sequences(n: integer): int64;` to solve the following problem:\nFunction that counts the number of valid coin toss sequences without consecutive heads. It calculates possible combinations for a given number of tosses.\n\nParameters:\n- n: an integer representing the number of coin tosses.\n\nReturns:\nThe count of valid sequences as an unsigned 64-bit integer.\n\nExamples:\n>>> count_valid_coin_toss_sequences(1)\n2\n", "level": "easy"}
{"task_id": "Pascal/17", "prompt": "uses\n  SysUtils;\n(*\n  Find the length of the longest consecutive sequence of 1s in the binary\n  representation of a non-negative integer.\n  \n    Parameters:\n    - n: an integer (0 \u2264 n \u2264 2^64 - 1).\n    \n    Returns:\n    The length of the longest consecutive sequence of 1s in binary.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*)\nfunction find_longest_consecutive_ones_length(n: UInt64): integer;", "canonical_solution": "var\n  max, ans: integer;\nbegin\n  max := 0;\n  ans := 0;\n  while n <> 0 do\n  begin\n    if (n and 1) <> 0 then\n      inc(ans)  // Increment the counter when a '1' is found\n    else\n    begin\n      if ans > max then\n        max := ans;\n      ans := 0;\n    end;\n    n := n shr 1; // Right-shift to move to the next bit\n  end;\n  \n  // Check the final sequence if it's the longest one\n  if ans > max then\n    max := ans;\n    \n  find_longest_consecutive_ones_length := max;\nend;", "test": "procedure testFindLongestConsecutiveOnesLength;\nbegin\n  Assert(find_longest_consecutive_ones_length(7) = 3);\n  Assert(find_longest_consecutive_ones_length(13) = 2);\n  Assert(find_longest_consecutive_ones_length(12345) = 3); // New test sample\n  // Assert(find_longest_consecutive_ones_length(bin2dec('11011101111')) = 4); // New test sample: binary literal conversion\n  Assert(find_longest_consecutive_ones_length($FFFFFFFF) = 32); // New test sample: all ones for a 32-bit number\n  Assert(find_longest_consecutive_ones_length(0) = 0); // New test sample: no ones in a zero\nend;\n\nbegin\n  testFindLongestConsecutiveOnesLength;\n  // Writeln('All tests passed!');\nend.", "entry_point": "find_longest_consecutive_ones_length", "signature": "function find_longest_consecutive_ones_length(n: UInt64): integer;", "docstring": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\n  Parameters:\n  - n: an integer (0 \u2264 n \u2264 2^64 - 1).\n\n  Returns:\n  The length of the longest consecutive sequence of 1s in binary.\n\n  Examples:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n", "instruction": "Write a Pascal function `function find_longest_consecutive_ones_length(n: UInt64): integer;` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\n  Parameters:\n  - n: an integer (0 \u2264 n \u2264 2^64 - 1).\n\n  Returns:\n  The length of the longest consecutive sequence of 1s in binary.\n\n  Examples:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n", "level": "middle"}
{"task_id": "Pascal/18", "prompt": "{$mode objfpc}{$H+}\nuses\n  SysUtils;\n(*\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\nExamples:\n    >>> create_id('fish','cat')\n     = 'ftiasch'\n*)\nfunction create_id(const word1, word2: AnsiString): AnsiString;", "canonical_solution": "var\n  length1, length2, total_length: Integer;\n  i, j, k: Integer;\nbegin\n  length1 := Length(word1);\n  length2 := Length(word2);\n  total_length := length1 + length2;\n  SetLength(Result, total_length);\n\n  j := 1;\n  k := length2;\n  for i := 1 to total_length do\n  begin\n    if Odd(i) then\n    begin\n      Result[i] := word2[k];\n      Dec(k);\n    end\n    else\n    begin\n      Result[i] := word1[j];\n      Inc(j);\n    end;\n  end;\nend;", "test": "procedure TestCreateID;\nvar\n  id: AnsiString;\nbegin\n  id := create_id('fish', 'cat');\n  Assert(id = 'ftiasch');\n\n  id := create_id('icpc', 'acm');\n  Assert(id = 'imccpac');\n\n  id := create_id('oo', 'w');\n  Assert(id = 'owo');\n\n  // Add more test samples\n  id := create_id('hello', 'world');\n  Assert(id = 'hdellrloow');\n\n  id := create_id('abc', 'def');\n  Assert(id = 'afbecd');\n\n  id := create_id('buaanb', 'nbbuaa');\n  Assert(id = 'bauaauabnbbn');\n\n  id := create_id('xtuisgood', 'ilovextu');\n  Assert(id = 'xuttuxiesvgooloid');\nend;\n\nbegin\n  TestCreateID;\nend.", "entry_point": "create_id", "signature": "function create_id(const word1, word2: AnsiString): AnsiString;", "docstring": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\nExamples:\n    >>> create_id('fish','cat')\n     = 'ftiasch'\n", "instruction": "Write a Pascal function `function create_id(const word1, word2: AnsiString): AnsiString;` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\nExamples:\n    >>> create_id('fish','cat')\n     = 'ftiasch'\n", "level": "middle"}
{"task_id": "Pascal/19", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n(* \n  Count the number of different permutation schemes for a binary string of length n,\n  where the number of '1's is m and the number of '0's is n - m.\n\n  This function accepts two parameters:\n  - n (integer): The length of the binary string.\n  - m (integer): The number of '1's in the binary string.\n\n  It returns an Int64 indicating the total number of different permutation schemes.\n*)\nfunction countPermutationsOfBinaryString(n, m: integer): Int64;", "canonical_solution": "var\n  i: integer;\n  numerator, denominator: Int64;\nbegin\n  if (n + m) mod 2 = 1 then\n  begin\n    countPermutationsOfBinaryString := 0;\n    exit;\n  end\n  else if n = m then\n  begin\n    countPermutationsOfBinaryString := 1;\n    exit;\n  end;\n\n  numerator := 1;\n  denominator := 1;\n\n  for i := 1 to (n - m) div 2 do\n  begin\n    numerator := numerator * (n - i + 1);\n    denominator := denominator * i;\n    // Reduce the fraction at each step to prevent overflow\n    if numerator mod denominator = 0 then\n    begin\n      numerator := numerator div denominator;\n      denominator := 1;\n    end;\n  end;\n  \n  countPermutationsOfBinaryString := numerator; // This is now C(n, (n-m)/2)\nend;", "test": "procedure testCountPermutationsOfBinaryString;\nbegin\n  Assert(countPermutationsOfBinaryString(2, 0) = 2);\n  Assert(countPermutationsOfBinaryString(2, 1) = 0);\n  Assert(countPermutationsOfBinaryString(3, 0) = 0);\n  Assert(countPermutationsOfBinaryString(3, 1) = 3);\n  Assert(countPermutationsOfBinaryString(4, 2) = 4);\n  Assert(countPermutationsOfBinaryString(5, 5) = 1);\n  Assert(countPermutationsOfBinaryString(30, 2) = 145422675);\n  Assert(countPermutationsOfBinaryString(33, 17) = 13884156);\n  Assert(countPermutationsOfBinaryString(1000, 1000) = 1);\n  // Add more test cases if necessary\nend;\n\n(* Main *)\nbegin\n  testCountPermutationsOfBinaryString;\n  // WriteLn('All test cases passed.');\n  // ReadLn;\nend.", "entry_point": "countPermutationsOfBinaryString", "signature": "function countPermutationsOfBinaryString(n, m: integer): Int64;", "docstring": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nThis function accepts two parameters:\n- n (integer): The length of the binary string.\n- m (integer): The number of '1's in the binary string.\n\nIt returns an Int64 indicating the total number of different permutation schemes.", "instruction": "Write a Pascal function `function countPermutationsOfBinaryString(n, m: integer): Int64;` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nThis function accepts two parameters:\n- n (integer): The length of the binary string.\n- m (integer): The number of '1's in the binary string.\n\nIt returns an Int64 indicating the total number of different permutation schemes.", "level": "hard"}
{"task_id": "Pascal/20", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\n    Answer a series of questions by providing choices A, B, C, or D for each question.\n\n    Question 1:\n    Constants like 1e6 belong to which data type?\n        A. unsigned int\n        B. int\n        C. float\n        D. double\n\n    Question 2:\n    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n        A. int\n        B. long long (In Pascal, use Int64 for long integers)\n        C. double\n        D. None of the above\n\n    Question 3:\n    Which statement about left values in expressions is incorrect?\n        A. Variable name expressions are left values.\n        B. Increment operation requires the operand to be a left value.\n        C. Pointer dereference expressions are left values.\n        D. Prefix increment operation expressions are left values.\n\n    Question 4:\n    Which statement about functions is incorrect?\n        A. Formal parameters of a function are local variables.\n        B. Local variables are allocated space in the stack.\n        C. The function type is the same as the return value type.\n        D. A function can call itself from within its body.\n\n    Question 5:\n    Which statement about pointers is incorrect?\n        A. Subtracting two pointers equals the difference in their address values.\n        B. Pointer dereference involves resolving based on the pointer's type.\n        C. int *p[4], p is an array of int pointers.\n        D. Function names can be assigned to function pointers.\n\n    You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*)\nfunction answer_questions: string;", "canonical_solution": "begin\n    answer_questions := 'DDDBA';\nend;", "test": "procedure testAnswerQuestions;\nbegin\n    Assert(answer_questions = 'DDDBA', 'The answer string should match DDDBA');\nend;\n\nbegin\n    testAnswerQuestions;\nend.", "entry_point": "answer_questions", "signature": "function answer_questions: string;", "docstring": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long (In Pascal, use Int64 for long integers)\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "instruction": "Write a Pascal function `function answer_questions: string;` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long (In Pascal, use Int64 for long integers)\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "level": "easy"}
{"task_id": "Pascal/21", "prompt": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\n(*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a number of squares with a side length of 1, into a single larger square.\nThe function receives the length of the list and an array of numbers as input.\nExample usage:\n    Is_Square(1, [9]) should return true (1 in Pascal), because 9 is a perfect square.\n*)\nfunction Is_Square(length: integer; const squares: array of integer): boolean;", "canonical_solution": "var\n  sum: Int64;\n  root, i: integer;\nbegin\n  sum := 0;\n  for i := 0 to length - 1 do\n  begin\n    sum := sum + squares[i];\n  end;\n  root := Trunc(Sqrt(sum));\n  Is_Square := (root * root = sum);\nend;", "test": "procedure TestIsSquare;\nbegin\n  Assert(Is_Square(1, [9]) = true);\n  Assert(Is_Square(2, [14, 2]) = true);\n  Assert(Is_Square(2, [7, 7]) = false);\n  Assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) = false);\n  Assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) = true);\n  Assert(Is_Square(4, [2, 2, 2, 2]) = false);\n  Assert(Is_Square(3, [4, 5, 6]) = false);\n  Assert(Is_Square(4, [16, 9, 4, 1]) = false);\n  Assert(Is_Square(5, [1, 1, 1, 1, 1]) = false);\n  Assert(Is_Square(2, [25, 25]) = false);\n  Assert(Is_Square(3, [10, 10, 5]) = true);\nend;\n\nbegin\n  TestIsSquare;\nend.", "entry_point": "Is_Square", "signature": "function Is_Square(length: integer; const squares: array of integer): boolean;", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a number of squares with a side length of 1, into a single larger square.\nThe function receives the length of the list and an array of numbers as input.\nExample usage:\n    Is_Square(1, [9]) should return true (1 in Pascal), because 9 is a perfect square.\n", "instruction": "Write a Pascal function `function Is_Square(length: integer; const squares: array of integer): boolean;` to solve the following problem:\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a number of squares with a side length of 1, into a single larger square.\nThe function receives the length of the list and an array of numbers as input.\nExample usage:\n    Is_Square(1, [9]) should return true (1 in Pascal), because 9 is a perfect square.\n", "level": "easy"}
{"task_id": "Pascal/22", "prompt": "{$ASSERTIONS ON}\n(*\nGiven integers c and d, with the conditions a + b = c and a * b = d, determine a\npossible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\nthe conditions, choose the one with the smallest value of a. If there are no such\npairs, return -1.\n\n    Parameters:\n    - c (integer): The sum of a and b.\n    - d (integer): The product of a and b.\n\n    Returns:\n    An integer representing a possible value of a, or -1 if no valid pairs are found.\n\n    Examples:\n    - find_integers(7, 11): -1\n*)\nfunction find_integers(c, d: integer): integer;", "canonical_solution": "var\n  i: integer;\nbegin\n    for i := 0 to c div 2 do\n    begin\n        if (i * (c - i) = d) then\n        begin\n            find_integers := i;\n            Exit; // Exit the loop and function on the first match.\n        end;\n    end;\n    find_integers := -1; // Return -1 if no valid pairs (a, b) are found.\nend;", "test": "procedure testFindIntegers;\nbegin\n    Assert(find_integers(5, 6) = 2);\n    Assert(find_integers(6, 9) = 3);\n    Assert(find_integers(7, 12) = 3);\n    Assert(find_integers(7, 11) = -1);\n    Assert(find_integers(9, 8) = 1);\n    Assert(find_integers(10, 25) = 5);\n    Assert(find_integers(10000, 8765) = -1);\nend;\n\nbegin\n    testFindIntegers;\nend.", "entry_point": "find_integers", "signature": "function find_integers(c, d: integer): integer;", "docstring": "Given integers c and d, with the conditions a + b = c and a * b = d, determine a\npossible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\nthe conditions, choose the one with the smallest value of a. If there are no such\npairs, return -1.\n\n    Parameters:\n    - c (integer): The sum of a and b.\n    - d (integer): The product of a and b.\n\n    Returns:\n    An integer representing a possible value of a, or -1 if no valid pairs are found.\n\n    Examples:\n    - find_integers(7, 11): -1\n", "instruction": "Write a Pascal function `function find_integers(c, d: integer): integer;` to solve the following problem:\nGiven integers c and d, with the conditions a + b = c and a * b = d, determine a\npossible value for integer a (where a <= b). If multiple pairs (a, b) satisfy\nthe conditions, choose the one with the smallest value of a. If there are no such\npairs, return -1.\n\n    Parameters:\n    - c (integer): The sum of a and b.\n    - d (integer): The product of a and b.\n\n    Returns:\n    An integer representing a possible value of a, or -1 if no valid pairs are found.\n\n    Examples:\n    - find_integers(7, 11): -1\n", "level": "easy"}
{"task_id": "Pascal/23", "prompt": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\n(*\n  Determines the number of acute-angled triangles that can be formed from a given set of edge lengths.\n  \n  Parameters:\n  - edges: An open array of integers representing edge lengths.\n\n  Returns:\n  The count of distinct, valid acute-angled triangles that can be formed.\n  \n  Examples:\n  writeln(count_acute_triangles([1, 1, 1, 1])); (* Output: 4 *)\n*)\nfunction count_acute_triangles(var edges: array of integer): integer;", "canonical_solution": "var\n  i, j, k, temp, edges_count, sum: integer;\nbegin\n  edges_count := length(edges);\n  // Bubble sort to sort the array of edges\n  for i := 0 to edges_count - 2 do\n    for j := 0 to edges_count - i - 2 do\n      if edges[j] > edges[j + 1] then\n      begin\n        temp := edges[j];\n        edges[j] := edges[j + 1];\n        edges[j + 1] := temp;\n      end;\n\n  sum := 0;\n  // Counting acute-angled triangles\n  for i := 0 to edges_count - 3 do\n    for j := i + 1 to edges_count - 2 do\n      for k := j + 1 to edges_count - 1 do\n        if (edges[i] < edges[j] + edges[k]) and (sqr(edges[i]) + sqr(edges[j]) > sqr(edges[k])) then\n          inc(sum);\n\n  count_acute_triangles := sum;\nend;", "test": "procedure testCountAcuteTriangles;\nvar\n  test_array: array of integer;\nbegin\n  SetLength(test_array, 4);test_array[0] := 1;test_array[1] := 1;test_array[2] := 1;test_array[3] := 1;\n  Assert(count_acute_triangles(test_array) = 4);\n  SetLength(test_array, 3);test_array[0] := 1;test_array[1] := 2;test_array[2] := 3; \n  Assert(count_acute_triangles(test_array) = 0);\n  SetLength(test_array, 5);test_array[0] := 3;test_array[1] := 4;test_array[2] := 5;test_array[3] := 7;test_array[4] := 10;\n  Assert(count_acute_triangles(test_array) = 0);\n  SetLength(test_array, 6);test_array[0] := 6;test_array[1] := 8;test_array[2] := 10;test_array[3] := 5;test_array[4] := 5;test_array[5] := 5;\n  Assert(count_acute_triangles(test_array) = 4);\nend;\n\nbegin\n  testCountAcuteTriangles;\nend.", "entry_point": "count_acute_triangles", "signature": "function count_acute_triangles(var edges: array of integer): integer;", "docstring": "Determines the number of acute-angled triangles that can be formed from a given set of edge lengths.\n\nParameters:\n- edges: An open array of integers representing edge lengths.\n\nReturns:\nThe count of distinct, valid acute-angled triangles that can be formed.\n\nExamples:\nwriteln(count_acute_triangles([1, 1, 1, 1])); (* Output: 4 *)", "instruction": "Write a Pascal function `function count_acute_triangles(var edges: array of integer): integer;` to solve the following problem:\nDetermines the number of acute-angled triangles that can be formed from a given set of edge lengths.\n\nParameters:\n- edges: An open array of integers representing edge lengths.\n\nReturns:\nThe count of distinct, valid acute-angled triangles that can be formed.\n\nExamples:\nwriteln(count_acute_triangles([1, 1, 1, 1])); (* Output: 4 *)", "level": "hard"}
{"task_id": "Pascal/24", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\n  Constructs a formatted string containing the given integer and character separated by a comma.\n  \n  Parameters:\n    - integer_value : Integer; The input integer.\n    - char_value    : Char; The input character.\n  \n  Returns:\n    - String: The formatted string representing the integer and character separated by a comma.\n  \n  Example Usage:\n    > process_integer_and_char(234, 'H')\n    '234,H'\n*)\nfunction process_integer_and_char(integer_value: Integer; char_value: Char): String;", "canonical_solution": "begin\n  // Result is a special variable in Pascal that refers to the function's return value\n  process_integer_and_char := IntToStr(integer_value) + ',' + char_value;\nend;", "test": "procedure testProcessIntegerAndChar;\nvar\n  testOutput: String;\nbegin\n  // Test with expected output \"234,H\"\n  testOutput := process_integer_and_char(234, 'H');\n  Assert(testOutput = '234,H', 'Test 1 failed');\n  \n  // Additional test cases can be provided below\n  \n  // Test with expected output \"123,A\"\n  testOutput := process_integer_and_char(123, 'A');\n  Assert(testOutput = '123,A', 'Test 2 failed');\n\n  // Test with expected output \"0,Z\"\n  testOutput := process_integer_and_char(0, 'Z');\n  Assert(testOutput = '0,Z', 'Test 3 failed');\nend;\n\n(* Main Program *)\nbegin\n  testProcessIntegerAndChar;\nend.", "entry_point": "process_integer_and_char", "signature": "function process_integer_and_char(integer_value: Integer; char_value: Char): String;", "docstring": "Constructs a formatted string containing the given integer and character separated by a comma.\n\n  Parameters:\n    - integer_value : Integer; The input integer.\n    - char_value    : Char; The input character.\n\n  Returns:\n    - String: The formatted string representing the integer and character separated by a comma.\n\n  Example Usage:\n    > process_integer_and_char(234, 'H')\n    '234,H'\n", "instruction": "Write a Pascal function `function process_integer_and_char(integer_value: Integer; char_value: Char): String;` to solve the following problem:\nConstructs a formatted string containing the given integer and character separated by a comma.\n\n  Parameters:\n    - integer_value : Integer; The input integer.\n    - char_value    : Char; The input character.\n\n  Returns:\n    - String: The formatted string representing the integer and character separated by a comma.\n\n  Example Usage:\n    > process_integer_and_char(234, 'H')\n    '234,H'\n", "level": "easy"}
{"task_id": "Pascal/25", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\n  Shifts all characters by 5 positions in alphabetical order. \n  Only letters are replaced, and all letters are in uppercase.\n  \n  Parameters:\n  text (str): The input text to be processed.\n  \n  Returns:\n  str: The transformed text with characters shifted by 5 positions.\n  >>> shift_characters('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n  'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n*)\nfunction shift_characters(text: ansistring): ansistring;", "canonical_solution": "var\n  i: Integer;\nbegin\n  for i := 1 to Length(text) do begin\n    if (text[i] >= 'A') and (text[i] <= 'E') then begin\n      text[i] := Chr(Ord(text[i]) + 21);\n    end else if (text[i] >= 'F') and (text[i] <= 'Z') then begin\n      text[i] := Chr(Ord(text[i]) - 5);\n    end;\n  end;\n  shift_characters := text;\nend;", "test": "procedure testShiftCharacters;\nvar\n  test1, test2, test3: ansistring;\nbegin\n  test1 := 'NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX';\n  test2 := 'N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ';\n  test3 := 'IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ';\n\n  Assert(shift_characters(test1) = 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES');\n  Assert(shift_characters(test2) = 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME');\n  Assert(shift_characters(test3) = 'DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE');\nend;\n\nbegin\n  testShiftCharacters;\nend.", "entry_point": "shift_characters", "signature": "function shift_characters(text: ansistring): ansistring", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n>>> shift_characters('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "instruction": "Write a Pascal function `function shift_characters(text: ansistring): ansistring` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n>>> shift_characters('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'", "level": "easy"}
{"task_id": "Pascal/26", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, StrUtils;\n(*\n  Classify the integer x as follows:\n    - If x is a single-digit number, x belongs to its own class.\n    - Otherwise, sum the digits of x, get a new x, and continue this process iteratively \n      until the class is determined.\n\n  @param x: The string representation of the integer to be classified.\n  @return: The class to which the integer x belongs.\n\n  Examples:\n      >>> classify_integer('24')\n      6\n*)\nfunction classify_integer(x: string): Integer;\nvar\n  n, i, a, t: Integer;", "canonical_solution": "begin\n  n := 0;\n  for i := 1 to Length(x) do\n    n := n + Ord(x[i]) - Ord('0');\n  while n > 9 do\n  begin\n    t := n;\n    a := 0;\n    while t > 0 do\n    begin\n      a := a + (t mod 10);\n      t := t div 10;\n    end;\n    n := a;\n  end;\n  classify_integer := n;\nend;", "test": "procedure testClassifyInteger;\nbegin\n  Assert(classify_integer('24') = 6);\n  Assert(classify_integer('39') = 3);\n  Assert(classify_integer('123456789') = 9);\n  Assert(classify_integer('123456789012345678901234567890') = 9);\n  Assert(classify_integer('12345') = 6);\n  Assert(classify_integer('999999999') = 9);\nend;\n\nbegin\n  testClassifyInteger;\nend.", "entry_point": "classify_integer", "signature": "function classify_integer(x: string): Integer;", "docstring": "Classify the integer x as follows:\n- If x is a single-digit number, x belongs to its own class.\n- Otherwise, sum the digits of x, get a new x, and continue this process iteratively until the class is determined.\n\n@param x: The string representation of the integer to be classified.\n@return: The class to which the integer x belongs.\n\nExamples:\n>>> classify_integer('24')\n6\n", "instruction": "Write a Pascal function `function classify_integer(x: string): Integer;` to solve the following problem:\nClassify the integer x as follows:\n- If x is a single-digit number, x belongs to its own class.\n- Otherwise, sum the digits of x, get a new x, and continue this process iteratively until the class is determined.\n\n@param x: The string representation of the integer to be classified.\n@return: The class to which the integer x belongs.\n\nExamples:\n>>> classify_integer('24')\n6\n", "level": "easy"}
{"task_id": "Pascal/27", "prompt": "{$ASSERTIONS ON}\n{\n  Transforms the case of a given letter.\n  Parameters:\n  - letter (Char): The input letter to be transformed.\n  Returns:\n  - Char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n    Example usage:\n    >>> transform_letter_case('b')\n    'B'\n}\nfunction transform_letter_case(letter: Char): Char;", "canonical_solution": "begin\n  if (letter >= 'A') and (letter <= 'Z') then\n  begin\n    transform_letter_case := Chr(Ord(letter) + 32);\n  end\n  else if (letter >= 'a') and (letter <= 'z') then\n  begin\n    transform_letter_case := Chr(Ord(letter) - 32);\n  end\n  else\n  begin\n    // Non-alphabetic characters are returned unchanged\n    transform_letter_case := letter;\n  end;\nend;", "test": "procedure testTransformLetterCase;\nbegin\n  Assert(transform_letter_case('b') = 'B');\n  Assert(transform_letter_case('B') = 'b');\n  \n  // Additional test cases\n  Assert(transform_letter_case('z') = 'Z');\n  Assert(transform_letter_case('Z') = 'z');\n  Assert(transform_letter_case('m') = 'M');\n  Assert(transform_letter_case('M') = 'm');\n  Assert(transform_letter_case('1') = '1'); // Non-alphabetic, should be unchanged\n  Assert(transform_letter_case('!') = '!'); // Non-alphabetic, should be unchanged\nend;\n\nbegin\n  testTransformLetterCase;\nend.", "entry_point": "transform_letter_case", "signature": "function transform_letter_case(letter: Char): Char;", "docstring": "Transforms the case of a given letter.\n  Parameters:\n  - letter (Char): The input letter to be transformed.\n  Returns:\n  - Char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n    Example usage:\n    >>> transform_letter_case('b')\n    'B'", "instruction": "Write a Pascal function `function transform_letter_case(letter: Char): Char;` to solve the following problem:\nTransforms the case of a given letter.\n  Parameters:\n  - letter (Char): The input letter to be transformed.\n  Returns:\n  - Char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n    Example usage:\n    >>> transform_letter_case('b')\n    'B'", "level": "easy"}
{"task_id": "Pascal/28", "prompt": "{$ASSERTIONS ON}\n(*\n  Display the ASCII information for a given character.\n    Parameters:\n    - character: The input character for which ASCII information is to be displayed.\n\n    Returns:\n    - The corresponding ASCII code as an integer.\n      Example usage:\n      >>> display_ascii_info('A')\n      65\n*)\nfunction display_ascii_info(character: char): integer;", "canonical_solution": "begin\n  display_ascii_info := ord(character);\nend;", "test": "procedure testDisplayAsciiInfo;\nbegin\n  Assert(display_ascii_info('A') = 65);\n  Assert(display_ascii_info('B') = 66); // Additional test case\n  Assert(display_ascii_info('0') = 48); // Additional test case\n  Assert(display_ascii_info(' ') = 32); // Additional test case\nend;\n\nbegin\n  testDisplayAsciiInfo;\n  // WriteLn('All tests passed.');\nend.", "entry_point": "display_ascii_info", "signature": "function display_ascii_info(character: char): integer;", "docstring": "Display the ASCII information for a given character.\n    Parameters:\n    - character: The input character for which ASCII information is to be displayed.\n\n    Returns:\n    - The corresponding ASCII code as an integer.\n      Example usage:\n      >>> display_ascii_info('A')\n      65\n", "instruction": "Write a Pascal function `function display_ascii_info(character: char): integer;` to solve the following problem:\nDisplay the ASCII information for a given character.\n    Parameters:\n    - character: The input character for which ASCII information is to be displayed.\n\n    Returns:\n    - The corresponding ASCII code as an integer.\n      Example usage:\n      >>> display_ascii_info('A')\n      65\n", "level": "easy"}
{"task_id": "Pascal/29", "prompt": "{$ASSERTIONS ON}\n(*\n  Evaluate the grade for an input integer.\n  Given an integer score, this function returns a character representing the grade.\n  An 'A' grade is assigned for scores between 90 and 100 (inclusive),\n  while a 'B' grade is given for all other scores.\n  \n  Example usage:\n    >>> evaluate_integer_grade(90)\n    A\n*)\nfunction evaluate_integer_grade(score: integer): char;", "canonical_solution": "begin\n  if (90 <= score) and (score <= 100) then\n    evaluate_integer_grade := 'A'\n  else\n    evaluate_integer_grade := 'B';\nend;", "test": "procedure testEvaluateIntegerGrade;\nbegin\n  Assert(evaluate_integer_grade(90) = 'A');\n  Assert(evaluate_integer_grade(89) = 'B');\n  Assert(evaluate_integer_grade(95) = 'A');\n  Assert(evaluate_integer_grade(100) = 'A');\n  Assert(evaluate_integer_grade(101) = 'B');\nend;\n\nbegin\n  testEvaluateIntegerGrade;\nend.", "entry_point": "evaluate_integer_grade", "signature": "function evaluate_integer_grade(score: integer): char;", "docstring": "Evaluate the grade for an input integer.\nGiven an integer score, this function returns a character representing the grade.\nAn 'A' grade is assigned for scores between 90 and 100 (inclusive),\nwhile a 'B' grade is given for all other scores.\n\nExample usage:\n  >>> evaluate_integer_grade(90)\n  A\n", "instruction": "Write a Pascal function `function evaluate_integer_grade(score: integer): char;` to solve the following problem:\nEvaluate the grade for an input integer.\nGiven an integer score, this function returns a character representing the grade.\nAn 'A' grade is assigned for scores between 90 and 100 (inclusive),\nwhile a 'B' grade is given for all other scores.\n\nExample usage:\n  >>> evaluate_integer_grade(90)\n  A\n", "level": "easy"}
{"task_id": "Pascal/30", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\n  Checks if a three-character string has exactly two characters that are the same.\n\n  Args:\n    s: The three-character string to be checked.\n  \n  Returns:\n    Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits('112')\n    Yes\n*)\nfunction check_two_equal_digits(const s: string): string;", "canonical_solution": "begin\n  if ((s[1] = s[2]) and (s[2] <> s[3])) or\n     ((s[1] = s[3]) and (s[1] <> s[2])) or\n     ((s[2] = s[3]) and (s[1] <> s[2])) then\n    check_two_equal_digits := 'Yes'\n  else\n    check_two_equal_digits := 'No';\nend;", "test": "procedure testCheckTwoEqualDigits;\nbegin\n  Assert(check_two_equal_digits('112') = 'Yes');\n  Assert(check_two_equal_digits('123') = 'No');\n  Assert(check_two_equal_digits('232') = 'Yes');\n  Assert(check_two_equal_digits('444') = 'No'); // All three characters are equal, not two.\n  Assert(check_two_equal_digits('121') = 'Yes');\n\n  // Additional test cases to cover more scenarios\n  Assert(check_two_equal_digits('787') = 'Yes');\n  Assert(check_two_equal_digits('999') = 'No'); // All three characters are equal\n  Assert(check_two_equal_digits('890') = 'No');\n  Assert(check_two_equal_digits('556') = 'Yes');\n  Assert(check_two_equal_digits('353') = 'Yes'); // No two characters are equal\nend;\n\nbegin\n  testCheckTwoEqualDigits;\nend.", "entry_point": "check_two_equal_digits", "signature": "function check_two_equal_digits(const s: string): string;", "docstring": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n  s: The three-character string to be checked.\n\nReturns:\n  Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n  >>> check_two_equal_digits('112')\n  Yes\n", "instruction": "Write a Pascal function `function check_two_equal_digits(const s: string): string;` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nArgs:\n  s: The three-character string to be checked.\n\nReturns:\n  Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n  >>> check_two_equal_digits('112')\n  Yes\n", "level": "easy"}
{"task_id": "Pascal/31", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\n  Function: minRoundsToSameChar\n  Given a string consisting of lowercase English letters, this function\n  calculates the minimum number of rounds needed to modify the string so\n  that all of its characters are the same. In each round, you can change\n  one character to another character.\n\n  Examples:\n    - minRoundsToSameChar('aab') -> 1\n*)\nfunction minRoundsToSameChar(s: AnsiString): Integer;", "canonical_solution": "var\n  charCount: array[0..25] of Integer;\n  i, maxCount: Integer;\nbegin\n  // Initialize character counts\n  for i := 0 to 25 do\n    charCount[i] := 0;\n\n  // Count the occurrences of each character\n  for i := 1 to Length(s) do\n    Inc(charCount[Ord(s[i]) - Ord('a')]);\n\n  // Find the number of different characters with non-zero counts\n  maxCount := 0;\n  for i := 0 to 25 do\n    if charCount[i] > 0 then\n      Inc(maxCount);\n\n  // The minimum number of rounds required is the count of different\n  // characters minus one, because one character does not need to be changed\n  minRoundsToSameChar := maxCount - 1;\nend;", "test": "procedure testMinRoundsToSameChar;\nbegin\n  Assert(minRoundsToSameChar('aab') = 1);\n  Assert(minRoundsToSameChar('abc') = 2);\n  Assert(minRoundsToSameChar('aaa') = 0);\n  Assert(minRoundsToSameChar('abab') = 1);\n  Assert(minRoundsToSameChar('zzzzz') = 0);\nend;\n\nbegin\n  testMinRoundsToSameChar;\nend.", "entry_point": "minRoundsToSameChar", "signature": "function minRoundsToSameChar(s: AnsiString): Integer;", "docstring": "Given a string consisting of lowercase English letters, this function calculates the minimum number of rounds needed to modify the string so that all of its characters are the same. In each round, you can change one character to another character.\n\nExamples:\n  - minRoundsToSameChar('aab') -> 1", "instruction": "Write a Pascal function `function minRoundsToSameChar(s: AnsiString): Integer;` to solve the following problem:\nGiven a string consisting of lowercase English letters, this function calculates the minimum number of rounds needed to modify the string so that all of its characters are the same. In each round, you can change one character to another character.\n\nExamples:\n  - minRoundsToSameChar('aab') -> 1", "level": "hard"}
{"task_id": "Pascal/32", "prompt": "{$ASSERTIONS ON}\n(*\nGiven a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Yn when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.\n    >>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36\n*)\nfunction apocalypseYear(n: Int64; signs: array of Int64): Int64;", "canonical_solution": "var\n  i, period, nextOccurrence, year: Int64;\nbegin\n  year := 0;\n  for i := 0 to n - 1 do\n  begin\n    period := signs[i];\n    nextOccurrence := (year div period + 1) * period;\n    year := nextOccurrence;\n  end;\n  apocalypseYear := year;\nend;", "test": "procedure testApocalypseYear;\nbegin\n  Assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) = 36);\n  Assert(apocalypseYear(5, [1, 2, 3, 4, 5]) = 5);\n  Assert(apocalypseYear(5, [1, 1, 1, 1, 1]) = 5);\n  Assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) = 2012);\n  Assert(apocalypseYear(2, [1, 2]) = 2);\n  Assert(apocalypseYear(3, [3, 1, 2]) = 6);\n  Assert(apocalypseYear(3, [2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [1, 2, 3, 4]) = 4);\n  Assert(apocalypseYear(4, [5, 7, 11, 13]) = 13);\n  Assert(apocalypseYear(5, [2, 2, 2, 2, 2]) = 10);\n  Assert(apocalypseYear(3, [6, 10, 15]) = 15);\n  Assert(apocalypseYear(3, [4, 6, 14]) = 14);\n  Assert(apocalypseYear(4, [50, 30, 711, 200]) = 800);\n  Assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) = 6);\n  Assert(apocalypseYear(2, [1000000, 999999]) = 1999998);\nend;\n\nbegin\n  testApocalypseYear;\nend.", "entry_point": "apocalypseYear", "signature": "function apocalypseYear(n: Int64; signs: array of Int64): Int64;", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Yn when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.\n    >>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36\n", "instruction": "Write a Pascal function `function apocalypseYear(n: Int64; signs: array of Int64): Int64;` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Yn when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.\n    >>> apocalypseYear(6, [3, 2, 4, 5, 9, 18])\n    36\n", "level": "easy"}
{"task_id": "Pascal/33", "prompt": "{$ASSERTIONS ON}\n(*\nThis problem introduces a new modulo operation, denoted by \"\u2295\". Calculation of x \u2295 y:\n- If x is not a multiple of y, the result is x mod y.\n- Otherwise, if x is a multiple of y, divide x by y until it's no longer a multiple, resulting in x'.\n  The result is then x' mod y.\nFor instance, 4\u22955=4, 20\u22955=4, and 100\u22955=4.\nGiven a prime number p and an integer n, compute the value of n! \u2295 p, where n! is the factorial of n.\n    >>> newModuloFactorial(3, 7)\n    6\n*)\nfunction newModuloFactorial(n, p: QWord): QWord;", "canonical_solution": "var\n  i: QWord;\n  pj: array of QWord;\n  ans: QWord;\nbegin\n  SetLength(pj, p);\n  pj[0] := 1;\n  pj[1] := 1;\n  for i := 2 to p - 1 do\n    pj[i] := (i * pj[i - 1]) mod p;\n\n  ans := 1;\n  while n > 0 do\n  begin\n    ans := (ans * pj[n mod p]) mod p;\n    if (n div p) and 1 = 1 then\n      ans := p - ans;\n    n := n div p;\n  end;\n  newModuloFactorial := ans;\nend;", "test": "procedure TestNewModuloFactorial;\nbegin\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(11, 7) = 4);\n  Assert(newModuloFactorial(45, 7) = 1);\n  Assert(newModuloFactorial(14, 7) = 2);\n  Assert(newModuloFactorial(1919, 10007) = 3152);\n  Assert(newModuloFactorial(810, 10007) = 3679);\n  Assert(newModuloFactorial(3, 7) = 6);\n  Assert(newModuloFactorial(10, 3) = 1);\n  Assert(newModuloFactorial(1, 2) = 1);\n  Assert(newModuloFactorial(5, 11) = 10);\n  Assert(newModuloFactorial(6, 13) = 5);\n  Assert(newModuloFactorial(8, 17) = 13);\n  Assert(newModuloFactorial(15, 19) = 16);\n  Assert(newModuloFactorial(21, 23) = 1);\n  Assert(newModuloFactorial(30, 29) = 28);\n  Assert(newModuloFactorial(100, 101) = 100);\nend;\n\nbegin\n  TestNewModuloFactorial;\n  WriteLn('All tests passed successfully.');\nend.", "entry_point": "newModuloFactorial", "signature": "function newModuloFactorial(n, p: QWord): QWord;", "docstring": "This problem introduces a new modulo operation, denoted by \"\u2295\". Calculation of x \u2295 y:\n- If x is not a multiple of y, the result is x mod y.\n- Otherwise, if x is a multiple of y, divide x by y until it's no longer a multiple, resulting in x'.\n  The result is then x' mod y.\nFor instance, 4\u22955=4, 20\u22955=4, and 100\u22955=4.\nGiven a prime number p and an integer n, compute the value of n! \u2295 p, where n! is the factorial of n.\n    >>> newModuloFactorial(3, 7)\n    6", "instruction": "Write a Pascal function `function newModuloFactorial(n, p: QWord): QWord;` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by \"\u2295\". Calculation of x \u2295 y:\n- If x is not a multiple of y, the result is x mod y.\n- Otherwise, if x is a multiple of y, divide x by y until it's no longer a multiple, resulting in x'.\n  The result is then x' mod y.\nFor instance, 4\u22955=4, 20\u22955=4, and 100\u22955=4.\nGiven a prime number p and an integer n, compute the value of n! \u2295 p, where n! is the factorial of n.\n    >>> newModuloFactorial(3, 7)\n    6", "level": "easy"}
{"task_id": "Pascal/34", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\nYou are given an array a of n integers. You can perform at most one operation where \nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from \na[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all \nelements in the array equal.\n    >>> makeEqualAgain(3, [1, 2, 1])\n    1\n    >>> makeEqualAgain(5, [5, 5, 1, 5, 5])\n    1\n*)\nfunction makeEqualAgain(n: Integer; a: array of Integer): Integer;", "canonical_solution": "var\n  p, q, c, d, k: Integer;\nbegin\n  k := n;\n  p := 1;\n  q := 0;\n  for p := 1 to k - 1 do begin\n    if a[p] <> a[p - 1] then\n      Break;\n  end;\n  for q := k - 1 downto p - 1 do begin\n    if a[q] <> a[p - 1] then\n      Break;\n  end;\n  for d := k - 2 downto 0 do begin\n    if a[d] <> a[d + 1] then\n      Break;\n  end;\n  for c := 0 to d - 1 do begin\n    if a[c] <> a[c + 1] then\n      Break;\n  end;\n  if q - p + 1 < d - c + 1 then\n    makeEqualAgain := q - p + 1\n  else\n    makeEqualAgain := d - c + 1;\nend;", "test": "procedure testMakeEqualAgain;\nvar\n  test1, test2, test3, test4, test5, test6, test7, test8, test9, test10, a1, a2, a3, a4, a5, a6: array of Integer;\nbegin\n  test1 := [1, 2, 1];\n  test2 := [5, 5, 1, 5, 5];\n  test3 := [1, 1, 1, 1];\n  test4 := [2, 2, 2, 3, 2, 2];\n  test5 := [1];\n  test6 := [1, 2];\n  test7 := [1, 2, 2, 1];\n  test8 := [4, 4, 4, 3, 3, 4, 4];\n  test9 := [5, 4, 4, 4, 5, 5];\n  test10 := [1, 2, 1, 2, 1, 2, 1];\n  a1 := [1, 2, 3, 4, 5, 1];\n  a2 := [1, 1, 1, 1, 1, 1, 1];\n  a3 := [8, 8, 8, 1, 2, 8, 8, 8];\n  a4 := [1, 2, 3];\n  a5 := [4, 3, 2, 7, 1, 1, 3];\n  a6 := [9, 9, 2, 9, 2, 5, 5, 5, 3];\n\n  Assert(makeEqualAgain(6, a1) = 4);\n  Assert(makeEqualAgain(7, a2) = 0);\n  Assert(makeEqualAgain(8, a3) = 2);\n  Assert(makeEqualAgain(3, a4) = 2);\n  Assert(makeEqualAgain(7, a5) = 6);\n  Assert(makeEqualAgain(9, a6) = 7);\n\n  Assert(makeEqualAgain(3, test1) = 1);\n  Assert(makeEqualAgain(5, test2) = 1);\n  Assert(makeEqualAgain(4, test3) = 0);\n  Assert(makeEqualAgain(6, test4) = 1);\n  Assert(makeEqualAgain(1, test5) = 0);\n  Assert(makeEqualAgain(2, test6) = 1);\n  Assert(makeEqualAgain(4, test7) = 2);\n  Assert(makeEqualAgain(7, test8) = 2);\n  Assert(makeEqualAgain(6, test9) = 3);\n  Assert(makeEqualAgain(7, test10) = 5);\nend;\n\nbegin\n  testMakeEqualAgain;\nend.", "entry_point": "makeEqualAgain", "signature": "function makeEqualAgain(n: Integer; a: array of Integer): Integer;", "docstring": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, [1, 2, 1])\n    1\n    >>> makeEqualAgain(5, [5, 5, 1, 5, 5])\n    1\n", "instruction": "Write a Pascal function `function makeEqualAgain(n: Integer; a: array of Integer): Integer;` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, [1, 2, 1])\n    1\n    >>> makeEqualAgain(5, [5, 5, 1, 5, 5])\n    1\n", "level": "middle"}
{"task_id": "Pascal/35", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\n  Given a sequence of N piles of stones numbered from 1 to N, each pile containing a positive number of stones,\n  determine the game's winner between Charlie and Dan. Charlie starts, and players alternately move stones\n  from the leftmost non-empty pile to the adjacent right pile. The player forced to move in the last pile loses.\n  Assuming optimal play, decide who wins.\n      >>> gameWinner([3, 1, 2, 2])\n      \"Dan\"\n*)\nfunction gameWinner(n: Integer; const piles: array of Integer): AnsiString;", "canonical_solution": "var\n  firstPileStones: Integer;\nbegin\n  // Only the first pile's stone count is needed to determine the winner.\n  firstPileStones := piles[0];\n  if n = 2 then begin // With only two piles, Charlie always wins.\n    Exit('Charlie');\n  end;\n  if firstPileStones = 1 then begin // If the first pile has only one stone, Dan wins.\n    Exit('Dan');\n  end;\n  // In all other cases, Charlie wins.\n  Exit('Charlie');\nend;", "test": "procedure TestGameWinner;\nvar\n  test1: array[0..2] of Integer = (1, 2, 2);\n  test2: array[0..4] of Integer = (5, 5, 5, 5, 5);\n  test3: array[0..2] of Integer = (2, 1, 2);\n  test4: array[0..3] of Integer = (3, 3, 3, 3);\n  test5: array[0..1] of Integer = (1, 1);\n  test6: array[0..1] of Integer = (2, 1);\n  test7: array[0..10] of Integer = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n  test8: array[0..9] of Integer = (2, 2, 2, 2, 2, 2, 2, 2, 2, 1);\n  test9: array[0..9] of Integer = (10, 10, 10, 10, 10, 10, 10, 10, 10, 10);\n  test10: array[0..9] of Integer = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nbegin\n  Assert(gameWinner(3, test1) = 'Dan');\n  Assert(gameWinner(5, test2) = 'Charlie');\n  Assert(gameWinner(3, test3) = 'Charlie');\n  Assert(gameWinner(4, test4) = 'Charlie');\n  Assert(gameWinner(2, test5) = 'Charlie');\n  Assert(gameWinner(2, test6) = 'Charlie');\n  Assert(gameWinner(11, test7) = 'Dan');\n  Assert(gameWinner(10, test8) = 'Charlie');\n  Assert(gameWinner(10, test9) = 'Charlie');\n  Assert(gameWinner(10, test10) = 'Dan');\nend;\n\nbegin\n  TestGameWinner;\nend.", "entry_point": "gameWinner", "signature": "function gameWinner(n: Integer; const piles: array of Integer): AnsiString;", "docstring": "Given a sequence of N piles of stones numbered from 1 to N, each pile containing a positive number of stones,\n  determine the game's winner between Charlie and Dan. Charlie starts, and players alternately move stones\n  from the leftmost non-empty pile to the adjacent right pile. The player forced to move in the last pile loses.\n  Assuming optimal play, decide who wins.\n      >>> gameWinner([3, 1, 2, 2])\n      \"Dan\"", "instruction": "Write a Pascal function `function gameWinner(n: Integer; const piles: array of Integer): AnsiString;` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each pile containing a positive number of stones,\n  determine the game's winner between Charlie and Dan. Charlie starts, and players alternately move stones\n  from the leftmost non-empty pile to the adjacent right pile. The player forced to move in the last pile loses.\n  Assuming optimal play, decide who wins.\n      >>> gameWinner([3, 1, 2, 2])\n      \"Dan\"", "level": "middle"}
{"task_id": "Pascal/36", "prompt": "{$ASSERTIONS ON}\n(*\n  Given n doors arranged in a circle, the player starts in front of door 1. Each turn,\n  the player can choose a number i and pay a cost C_i to move i steps to the right and\n  then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\n  The task is to determine the minimum total cost required to open all doors.\n\n  Example:\n      >>> minTotalCost(3, (1, 1, 1))\n      3\n*)\nfunction minTotalCost(n: Integer; var C: array of Integer): Int64;", "canonical_solution": "begin\n   minTotalCost := Int64(C[n - 2]) * (n - 1) + C[n - 1];\nend;", "test": "procedure testMinTotalCost;\nvar\n  costs1: array[1..5] of Integer = (4, 3, 3, 3, 3); // 1-indexed array\n  costs2: array[1..3] of Integer = (1, 1, 1);\n  costs3: array[1..4] of Integer = (5, 4, 3, 2);\n  costs4: array[1..4] of Integer = (100, 99, 98, 97);\n  costs5: array[1..6] of Integer = (10, 9, 8, 7, 6, 5);\n  costs6: array[1..7] of Integer = (2, 2, 2, 2, 2, 2, 2);\n  costs7: array[1..8] of Integer = (9, 7, 7, 7, 7, 7, 7, 7);\n  costs8: array[1..9] of Integer = (3, 2, 2, 2, 2, 2, 2, 2, 2);\n  costs9: array[1..10] of Integer = (6, 5, 5, 5, 5, 5, 5, 5, 5, 5);\n  costs10: array[1..11] of Integer = (8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\nbegin\n  Assert(minTotalCost(5, costs1) = 15);\n  Assert(minTotalCost(3, costs2) = 3);\n  Assert(minTotalCost(4, costs3) = 11);\n  Assert(minTotalCost(4, costs4) = 391);\n  Assert(minTotalCost(6, costs5) = 35);\n  Assert(minTotalCost(7, costs6) = 14);\n  Assert(minTotalCost(8, costs7) = 56);\n  Assert(minTotalCost(9, costs8) = 18);\n  Assert(minTotalCost(10, costs9) = 50);\n  Assert(minTotalCost(11, costs10) = 11);\nend;\n\nbegin\n  testMinTotalCost;\nend.", "entry_point": "minTotalCost", "signature": "function minTotalCost(n: Integer; var C: array of Integer): Int64;", "docstring": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn,\nthe player can choose a number i and pay a cost C_i to move i steps to the right and\nthen open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n", "instruction": "Write a Pascal function `function minTotalCost(n: Integer; var C: array of Integer): Int64;` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn,\nthe player can choose a number i and pay a cost C_i to move i steps to the right and\nthen open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n", "level": "easy"}
{"task_id": "Pascal/37", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n\nconst\n  N = 10000; // Adding a constant for array size\n(*\n  Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n  calculate the total number of handshakes that occur. Each student will shake hands with every\n  student already in the classroom with a smaller ID number. The sequence represents the order\n  in which students enter the classroom.\n\n  Examples:\n      >>> countHandshakes(3, [2, 1, 0])\n      0\n*)\nfunction countHandshakes(n: Integer; order: array of Integer): Int64;", "canonical_solution": "const\n  MAX_N = 10000;\nvar\n  ans: Int64;\n  tr: array[1..MAX_N] of Integer;\n  i, j, x: Integer;\nbegin\n  ans := 0;\n  for i := 1 to MAX_N do\n    tr[i] := 0;\n  for i := 0 to n - 1 do\n  begin\n    x := order[i] + 1; // Convert 0-indexed to 1-indexed\n    j := x - 1;\n    while j > 0 do\n    begin\n      ans := ans + tr[j];\n      j := j - (j and -j);\n    end;\n    j := x;\n    while j <= n do\n    begin\n      Inc(tr[j]);\n      j := j + (j and -j);\n    end;\n  end;\n  countHandshakes := ans;\nend;", "test": "procedure testCountHandshakes;\nbegin\n  Assert(countHandshakes(4, [2, 1, 3, 0]) = 2);\n  Assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) = 15);\n  Assert(countHandshakes(3, [1, 2, 0]) = 1);\n  Assert(countHandshakes(4, [3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 1, 2, 3]) = 6);\n  Assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) = 0);\n  Assert(countHandshakes(4, [0, 2, 1, 3]) = 5);\n  Assert(countHandshakes(5, [3, 1, 4, 2, 0]) = 3);\n  Assert(countHandshakes(4, [1, 0, 3, 2]) = 4);\n  Assert(countHandshakes(3, [2, 0, 1]) = 1);\n  Assert(countHandshakes(5, [1, 3, 0, 2, 4]) = 7);\n  Assert(countHandshakes(5, [4, 3, 2, 1, 0]) = 0);\nend;\n\nbegin\n  testCountHandshakes;\nend.", "entry_point": "countHandshakes", "signature": "function countHandshakes(n: Integer; order: array of Integer): Int64;", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with every\nstudent already in the classroom with a smaller ID number. The sequence represents the order\nin which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, [2, 1, 0])\n    0\n", "instruction": "Write a Pascal function `function countHandshakes(n: Integer; order: array of Integer): Int64;` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with every\nstudent already in the classroom with a smaller ID number. The sequence represents the order\nin which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, [2, 1, 0])\n    0\n", "level": "middle"}
{"task_id": "Pascal/38", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode for all prefixes of a sequence constructed from these numbers. \nThe mode is the largest number among the most frequent elements in a sequence.\nExample:\n    >>> maxModeSum(3, [1, 2, 3])\n    Should return 17\n    An example sequence that reaches this maximum value is (3,2,3,1,2,2).\n*)\nfunction maxModeSum(n: int64; const counts: array of int64): int64;", "canonical_solution": "var\n  f: array[0..99999] of int64;\n  mx, i: int64;\n  ans : int64;\nbegin\n  ans := 0;\n  mx := 0;\n  for i := 0 to n do f[i] := 0;\n\n  for i := n downto 1 do\n  begin\n    while mx < counts[i - 1] do\n    begin\n      mx := mx + 1;\n      f[mx] := f[mx - 1] + i;\n    end;\n    ans := ans + f[counts[i - 1]];\n  end;\n  maxModeSum := ans;\nend;", "test": "procedure testMaxModeSum;\nbegin\n  Assert(maxModeSum(3, [1, 3, 2]) = 17);\n  Assert(maxModeSum(4, [4, 1, 2, 3]) = 37);\n  Assert(maxModeSum(2, [1, 1]) = 4);\n  Assert(maxModeSum(5, [1, 2, 3, 4, 5]) = 75);\n  Assert(maxModeSum(1, [100000]) = 100000);\n  Assert(maxModeSum(5, [5, 3, 2, 4, 1]) = 62);\n  Assert(maxModeSum(3, [100000, 100000, 100000]) = 900000);\n  Assert(maxModeSum(3, [2, 2, 5]) = 27);\n  Assert(maxModeSum(4, [4, 4, 4, 4]) = 64);\n  Assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) = 126);\n  Assert(maxModeSum(3, [3, 1, 2]) = 16);\nend;\n\n(* Main *)\nbegin\n  testMaxModeSum;\nend.", "entry_point": "maxModeSum", "signature": "function maxModeSum(n: int64; const counts: array of int64): int64;", "docstring": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nExample:\n    >>> maxModeSum(3, [1, 2, 3])\n    Should return 17\n    An example sequence that reaches this maximum value is (3,2,3,1,2,2).", "instruction": "Write a Pascal function `function maxModeSum(n: int64; const counts: array of int64): int64;` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nExample:\n    >>> maxModeSum(3, [1, 2, 3])\n    Should return 17\n    An example sequence that reaches this maximum value is (3,2,3,1,2,2).", "level": "easy"}
{"task_id": "Pascal/39", "prompt": "{$ASSERTIONS ON}\n(*\nGiven an array of integers A, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is a sequence of consecutive elements of A, defined by two indices L and R,\nsuch that 1 <= L <= R <= n, where n is the size of the array A.\nThe XOR sum of a subarray is obtained by performing a bitwise XOR operation over all elements from L to R in the subarray.\nThe final result is the sum of XOR sums for all possible subarrays within the array A.\n\nExample cases:\n    >>> sumOfXorSubarrays([1, 2, 3, 4, 5], 5)\n    39\n*)\nfunction sumOfXorSubarrays(A: array of integer; n: integer): int64;", "canonical_solution": "var\n  q: array[0..100009] of int64;\n  w: array[0..20, 0..1] of int64;\n  ans: int64;\n  i, j: integer;\nbegin\n  FillChar(q, SizeOf(q), 0);\n  FillChar(w, SizeOf(w), 0);\n  ans := 0;\n  q[1] := 0;  // q[0] is already initialized to zero by FillChar\n  \n  for i := 1 to n do q[i] := q[i - 1] xor A[i - 1];\n  for i := 0 to n do\n    for j := 20 downto 0 do\n      w[j][(q[i] shr j) and 1] := w[j][(q[i] shr j) and 1] + 1;\n  for i := 0 to 20 do\n    ans := ans + w[i][0] * w[i][1] * (1 shl i);\n  sumOfXorSubarrays := ans;\nend;", "test": "procedure TestSumOfXorSubarrays;\nbegin\n  Assert(sumOfXorSubarrays([1, 2, 3, 4, 5], 5) = 39);\n  Assert(sumOfXorSubarrays([1, 1, 1], 3) = 4);\n  Assert(sumOfXorSubarrays([2, 3, 1], 3) = 9);\n  Assert(sumOfXorSubarrays([4, 5, 7, 9], 4) = 74);\n  Assert(sumOfXorSubarrays([0, 0, 0, 0], 4) = 0);\n  Assert(sumOfXorSubarrays([8, 8, 8, 8, 8], 5) = 72);\n  Assert(sumOfXorSubarrays([3, 6, 9, 12, 15], 5) = 125);\n  Assert(sumOfXorSubarrays([10, 20, 30, 40, 50], 5) = 390);\n  Assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16], 6) = 192);\n  Assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13], 7) = 192);\n  Assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 10) = 218);\nend;\n\nbegin\n  TestSumOfXorSubarrays;\nend.", "entry_point": "sumOfXorSubarrays", "signature": "function sumOfXorSubarrays(A: array of integer; n: integer): int64;", "docstring": "Given an array of integers A, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is a sequence of consecutive elements of A, defined by two indices L and R,\nsuch that 1 <= L <= R <= n, where n is the size of the array A.\nThe XOR sum of a subarray is obtained by performing a bitwise XOR operation over all elements from L to R in the subarray.\nThe final result is the sum of XOR sums for all possible subarrays within the array A.\n\nExample cases:\n    >>> sumOfXorSubarrays([1, 2, 3, 4, 5], 5)\n    39\n", "instruction": "Write a Pascal function `function sumOfXorSubarrays(A: array of integer; n: integer): int64;` to solve the following problem:\nGiven an array of integers A, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is a sequence of consecutive elements of A, defined by two indices L and R,\nsuch that 1 <= L <= R <= n, where n is the size of the array A.\nThe XOR sum of a subarray is obtained by performing a bitwise XOR operation over all elements from L to R in the subarray.\nThe final result is the sum of XOR sums for all possible subarrays within the array A.\n\nExample cases:\n    >>> sumOfXorSubarrays([1, 2, 3, 4, 5], 5)\n    39\n", "level": "middle"}
{"task_id": "Pascal/40", "prompt": "{$ASSERTIONS ON}\n\nuses\n  Math, SysUtils;\n(* \nGiven two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive\nintegers and b >= k. Different legal representations of the same number are counted\nonly once.\n    >>> countPowerNumbers(99, 1)\n    99\n*)\nfunction countPowerNumbers(n, k: integer): integer;", "canonical_solution": "var\n  count, x, i, m: integer;\n  t: int64;\n  mp: array of boolean;\nbegin\n  count := 0;\n  x := 0;\n  SetLength(mp, n + 1);\n  i := 2;\n  while i * i * i <= n do\n  // for i := 2 to trunc(exp(1/3 * ln(n))) do\n  begin\n    t := i * i;\n    m := 2;\n    while t <= n div i do\n    begin\n      t := t * i;\n      Inc(m);\n      if (m < k) or (mp[t]) then\n        continue;\n\n      if trunc(sqrt(t)) * trunc(sqrt(t)) = t then\n        Inc(x);\n\n      mp[t] := true;\n      Inc(count);\n    end;\n    i := i + 1;\n  end;\n\n  if k = 1 then\n  begin\n    count := n;\n  end\n  else if k >= 3 then\n  begin\n    count := count + 1;\n  end\n  else\n  begin\n    count := count + trunc(sqrt(n)) - x;\n  end;\n\n  countPowerNumbers := count;\nend;", "test": "procedure testCountPowerNumbers;\nbegin\n  Assert(countPowerNumbers(99, 1) = 99);\n  Assert(countPowerNumbers(99, 3) = 7);\n  Assert(countPowerNumbers(99, 2) = 12);\n  Assert(countPowerNumbers(10, 1) = 10);\n  Assert(countPowerNumbers(10, 2) = 4);\n  Assert(countPowerNumbers(500, 1) = 500);\n  Assert(countPowerNumbers(500, 2) = 30);\n  Assert(countPowerNumbers(500, 3) = 13);\n  Assert(countPowerNumbers(1000, 1) = 1000);\n  Assert(countPowerNumbers(1000, 2) = 41);\n  Assert(countPowerNumbers(1000, 3) = 17);\n  Assert(countPowerNumbers(1000, 93) = 1);\n  Assert(countPowerNumbers(50, 2) = 10);\n  Assert(countPowerNumbers(50, 3) = 5);\n  Assert(countPowerNumbers(2, 3) = 1);\nend;\n\nbegin\n  testCountPowerNumbers;\nend.", "entry_point": "countPowerNumbers", "signature": "function countPowerNumbers(n, k: integer): integer;", "docstring": "Given two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive\nintegers and b >= k. Different legal representations of the same number are counted\nonly once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "instruction": "Write a Pascal function `function countPowerNumbers(n, k: integer): integer;` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive\nintegers and b >= k. Different legal representations of the same number are counted\nonly once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "level": "hard"}
{"task_id": "Pascal/41", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\nGiven three integers n, m, and k, the task is to find the number of sequences constructed from \nn '(' and m ')', with the longest balanced subsequence having a length of 2 * k. This value \nshould be computed modulo 1,000,000,007 (10^9 + 7).\n\nExample usage:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*)\nfunction countBalancedSubsequences(n, m, k: int64): int64;", "canonical_solution": "const\n  P: int64 = 1000000007; // 10^9 + 7\nvar\n  C: array[0..1003, 0..503] of int64;\n  i, j: int64;\n\nbegin\n  // Initialize binomial coefficient matrix.\n  for i := 0 to n + m + 2 do\n    C[i][0] := 1;\n    for j := 1 to i do\n      C[i][j] := 0;\n  for i := 1 to n + m + 2 do\n    for j := 1 to i do\n      C[i][j] := (C[i - 1][j - 1] + C[i - 1][j]) mod P;\n  // Return the number of balanced subsequences.\n  if (k > n) or (k > m) then\n  begin\n    countBalancedSubsequences := 0;\n    exit;\n  end;\n\n  countBalancedSubsequences := (C[n + m][k] - C[n + m][k - 1] + P) mod P;\nend;", "test": "procedure testCountBalancedSubsequences;\nbegin\n  Assert(countBalancedSubsequences(2, 2, 2) = 2);\n  Assert(countBalancedSubsequences(3, 2, 3) = 0);\n  Assert(countBalancedSubsequences(3, 2, 1) = 4);\n  Assert(countBalancedSubsequences(4, 3, 2) = 14);\n  Assert(countBalancedSubsequences(5, 5, 2) = 35);\n  Assert(countBalancedSubsequences(6, 1, 1) = 6);\n  Assert(countBalancedSubsequences(1, 6, 1) = 6);\n  Assert(countBalancedSubsequences(7, 2, 2) = 27);\n  Assert(countBalancedSubsequences(8, 3, 3) = 110);\n  Assert(countBalancedSubsequences(10, 10, 5) = 10659);\n  Assert(countBalancedSubsequences(20, 20, 10) = 574221648);\n  Assert(countBalancedSubsequences(233, 233, 233) = 280916397);\n  Assert(countBalancedSubsequences(233, 666, 233) = 956287259);\n  Assert(countBalancedSubsequences(233, 233, 666) = 0);\nend;\n\nbegin\n  // Run the test cases\n  testCountBalancedSubsequences;\n  WriteLn('All test cases passed');\nend.", "entry_point": "countBalancedSubsequences", "signature": "function countBalancedSubsequences(n, m, k: int64): int64;", "docstring": "Given three integers n, m, and k, the task is to find the number of sequences constructed from n '(' and m ')', with the longest balanced subsequence having a length of 2 * k. This value should be computed modulo 1,000,000,007 (10^9 + 7).\n\nExample usage:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "instruction": "Write a Pascal function `function countBalancedSubsequences(n, m, k: int64): int64;` to solve the following problem:\nGiven three integers n, m, and k, the task is to find the number of sequences constructed from n '(' and m ')', with the longest balanced subsequence having a length of 2 * k. This value should be computed modulo 1,000,000,007 (10^9 + 7).\n\nExample usage:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "level": "hard"}
{"task_id": "Pascal/42", "prompt": "{$ASSERTIONS ON}\nuses\n  SysUtils;\n(*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \ncalculate the expected number of operations to cut the paper so that the remaining area is less than k. \nIn each operation, a randomly chosen line parallel to the axes passes through points with Int64 coordinates and cuts the paper, \ndiscarding the bottom or right part of the paper along this line. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n*)\nfunction expectedCuts(n, m: Int64; k: Int64): Int64;", "canonical_solution": "const\n  MD = 1000000007;\nvar\n  vv: array[1..200001] of Int64; // Note: Pascal arrays must be statically sized, and the index must start at 1\n  i, j: Int64;\n  ans: Int64;\n\nbegin\n  vv[1] := 1;\n  for i := 2 to High(vv) do\n    vv[i] := (Int64(vv[i - MD mod i]) * (MD div i + 1)) mod MD;\n\n  if k > Int64(n) * m then\n  begin\n    expectedCuts := 0;\n    Exit;\n  end;\n\n  ans := 1;\n  for i := Int64((k + m - 1) div m) to n - 1 do\n    ans := (ans + vv[i + Int64((k + Int64(i) - 1) div Int64(i)) - 1]) mod MD;\n  for j := Int64((k + n - 1) div n) to m - 1 do\n    ans := (ans + vv[Int64((k + Int64(j) - 1) div Int64(j)) + j - 1]) mod MD;\n\n  expectedCuts := ans;\nend;", "test": "procedure TestExpectedCuts;\nbegin\n  Assert(expectedCuts(2, 4, 10) = 0);\n  Assert(expectedCuts(2, 4, 8) = 1);\n  Assert(expectedCuts(2, 4, 2) = 833333342);\n  Assert(expectedCuts(2, 4, 6) = 250000003);\n  Assert(expectedCuts(3, 3, 4) = 666666673);\n  Assert(expectedCuts(5, 5, 12) = 666666673);\n  Assert(expectedCuts(6, 7, 20) = 722222229);\n  Assert(expectedCuts(8, 8, 30) = 72727275);\n  Assert(expectedCuts(10, 10, 50) = 714285721);\n  Assert(expectedCuts(1, 10, 5) = 945634929);\n  Assert(expectedCuts(10, 1, 5) = 945634929);\nend;\n\nbegin\n  TestExpectedCuts;\nend.", "entry_point": "expectedCuts", "signature": "function expectedCuts(n, m: Int64; k: Int64): Int64;", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \ncalculate the expected number of operations to cut the paper so that the remaining area is less than k. \nIn each operation, a randomly chosen line parallel to the axes passes through points with Int64 coordinates and cuts the paper, \ndiscarding the bottom or right part of the paper along this line. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "instruction": "Write a Pascal function `function expectedCuts(n, m: Int64; k: Int64): Int64;` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \ncalculate the expected number of operations to cut the paper so that the remaining area is less than k. \nIn each operation, a randomly chosen line parallel to the axes passes through points with Int64 coordinates and cuts the paper, \ndiscarding the bottom or right part of the paper along this line. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "level": "hard"}
{"task_id": "Pascal/43", "prompt": "{$ASSERTIONS ON}\nuses\n  SysUtils;\n(*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n*)\nfunction countPermutations(n, k: int64; qq: array of int64): int64;", "canonical_solution": "var\n  P, i, j, m, ans, c, kk: int64;\n  q, jc, f: array[0..504] of int64;\n  dp: array[0..504, 0..504] of int64;\nbegin\n  // N := 505;\n  P := 998244353;\n  ans := 0;\n  for i := 0 to n+2 do\n  begin\n    q[i] := 0;\n    jc[i] := 0;\n    f[i] := 0;\n    for j := 0 to n+2 do\n      dp[i][j] := 0;\n  end;\n\n  for i := 1 to n do\n    q[i] := qq[i - 1];\n  dp[0][0] := 1;\n  f[0] := 1;\n  jc[0] := 1;\n  for i := 1 to n do\n    jc[i] := (jc[i - 1] * i) mod P;\n  for i := 1 to n do\n  begin\n    f[i] := jc[i];\n    for j := 1 to i - 1 do\n      f[i] := (f[i] + P - (f[j] * jc[i - j]) mod P) mod P;\n  end;\n  for i := 1 to n do\n  begin\n    for j := 0 to i - 1 do\n      for kk := 1 to n do\n        dp[i][kk] := (dp[i][kk] + (dp[j][kk - 1] * f[i - j]) mod P) mod P;\n  end;\n  m := 0;\n  for i := 1 to n do\n    if q[i] > q[i + 1] then\n    begin\n      m := i;\n      break;\n    end;\n  if m = n then\n  begin\n    for i := k to n do\n    begin\n      ans := (ans + dp[n][i]) mod P;\n    end\n  end\n  else\n  begin\n    for i := m + 1 to n do\n    begin\n      if ((i xor (m + 1) <> 0) and ((q[i - 1] > q[i]) or (q[i] < q[m]))) then\n        break;\n      c := k + i - n - 1;\n      if c >= 0 then\n        ans := (ans + (dp[m][c] * jc[i - m - 1]) mod P) mod P;\n    end;\n  end;\n  countPermutations := ans;\nend;", "test": "procedure testCountPermutations;\nvar\n  q1, q2, q3, q4, q5, q6, q7: array of int64;\nbegin\n  q1 := [1, 2];\n  Assert(countPermutations(2, 1, q1) = 2);\n\n  q2 := [3, 1, 2];\n  Assert(countPermutations(3, 3, q2) = 1);\n\n  q3 := [1, 2, 3, 6, 5, 4];\n  Assert(countPermutations(6, 3, q3) = 13);\n\n  q4 := [1, 2, 3, 4, 5, 6];\n  Assert(countPermutations(6, 1, q4) = 720);\n\n  q5 := [1, 2, 5, 3, 4, 5];\n  Assert(countPermutations(6, 3, q5) = 0);\n\n  q6 := [1, 2, 3, 4, 5, 6, 7, 8, 9];\n  Assert(countPermutations(9, 9, q6) = 1);\n\n  q7 := [1, 2, 3, 4, 5, 6, 7, 9, 8];\n  Assert(countPermutations(9, 2, q7) = 29093);\nend;\n\nbegin\n  testCountPermutations;\nend.", "entry_point": "countPermutations", "signature": "function countPermutations(n, k: int64; qq: array of int64): int64;", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n", "instruction": "Write a Pascal function `function countPermutations(n, k: int64; qq: array of int64): int64;` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n", "level": "hard"}
{"task_id": "Pascal/44", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Math;\n(*\n   Given an array of n distinct integers representing the heights of Kira's friends,\n   find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\n   of the maximum and minimum values of the triplet is 1.\n   Example:\n   >>> countTriplets([1, 5, 7])\n   1\n*)\nfunction countTriplets(heights: array of integer; n: integer): integer;", "canonical_solution": "var\n  i, j, k, minVal, maxVal, a, b, t, count: integer;\nbegin\n  count := 0;\n  for i := 0 to n - 1 do\n  begin\n    for j := i + 1 to n - 1 do\n    begin\n      for k := j + 1 to n - 1 do\n      begin\n        minVal := Min(Min(heights[i], heights[j]), heights[k]);\n        maxVal := Max(Max(heights[i], heights[j]), heights[k]);\n        a := minVal;\n        b := maxVal;\n\n        while b <> 0 do\n        begin\n          t := b;\n          b := a mod b;\n          a := t;\n        end;\n\n        if a = 1 then\n          Inc(count);\n      end;\n    end;\n  end;\n  countTriplets := count;\nend;", "test": "procedure testCountTriplets;\nbegin\n  Assert(countTriplets([1, 5, 7], 3) = 1);\n  Assert(countTriplets([1, 6, 2, 3], 4) = 3);\n  Assert(countTriplets([16, 4, 8, 2], 4) = 0);\n  Assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2], 10) = 77);\n  Assert(countTriplets([4, 5, 9, 11, 14], 5) = 7);\n  Assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2], 11) = 104);\n  Assert(countTriplets([3, 7, 11, 13], 4) = 4);\n  Assert(countTriplets([5, 12, 13, 17, 19], 5) = 10);\n  Assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 11) = 87);\n  Assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], 11) = 122);\nend;\n\nbegin\n  testCountTriplets;\nend.", "entry_point": "countTriplets", "signature": "function countTriplets(heights: array of integer; n: integer): integer;", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\nExample:\n>>> countTriplets([1, 5, 7])\n1", "instruction": "Write a Pascal function `function countTriplets(heights: array of integer; n: integer): integer;` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\nExample:\n>>> countTriplets([1, 5, 7])\n1", "level": "hard"}
{"task_id": "Pascal/45", "prompt": "{$ASSERTIONS ON}\n(*\n   Given a 1 by n pixel image where each pixel has a color represented by an integer,\n   you can pick a color and change all connected pixels of the same color to the chosen color.\n   Two pixels are connected if they are adjacent and have the same color.\n   Find the minimum number of operations required to make all pixels the same color.\n\n   Note: For each color, there are at most 20 pixels of that color.\n\n   Examples:\n       >>> minOperations(5, [1, 2, 3, 2, 1])\n       2\n*)\nfunction minOperations(n: Integer; pixels: array of Integer): Integer;", "canonical_solution": "var\n  pre, u: array of Integer;\n  f: array of array of int64;\n  i, j, len, l: Integer;\nbegin\n  SetLength(pre, n + 1);\n  SetLength(u, n + 1);\n  SetLength(f, n + 1, n + 1);\n\n  for i := 1 to n do\n  begin\n    pre[i] := 0;\n    u[i] := 0;\n  end;\n\n  for i := 1 to n do\n  begin\n    pre[i] := u[pixels[i - 1]];\n    u[pixels[i - 1]] := i;\n  end;\n\n  for i := 1 to n do\n    for j := 1 to n do\n      if i <> j then f[i, j] := 10000000\n      else f[i, j] := 0;\n  for len := 2 to n do\n    for i := 1 to n - len + 1 do\n    begin\n      j := i + len - 1;\n      f[i, j] := f[i, j - 1] + 1;\n      l := pre[j];\n      while l >= i do\n      begin\n        if f[i, j] < f[i, l] + f[l + 1, j] then\n          f[i, j] := f[i, j]\n        else\n          f[i, j] := f[i, l] + f[l + 1, j];\n        l := pre[l];\n      end;\n    end;\n\n  minOperations := f[1, n];\nend;", "test": "procedure testMinOperations;\nbegin\n  Assert(minOperations(5, [1, 2, 3, 2, 1]) = 2);\n  Assert(minOperations(4, [1, 1, 2, 2]) = 1);\n  Assert(minOperations(5, [1, 2, 1, 4, 2]) = 3);\n  Assert(minOperations(5, [5, 5, 5, 5, 5]) = 0);\n  Assert(minOperations(6, [1, 1, 1, 2, 2, 2]) = 1);\n  Assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) = 2);\n  Assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) = 1);\n  Assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) = 8);\n  Assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) = 5);\n  Assert(minOperations(3, [3, 3, 3]) = 0);\n  Assert(minOperations(4, [2, 1, 1, 2]) = 1);\nend;\n\nbegin\n  testMinOperations;\nend.", "entry_point": "minOperations", "signature": "function minOperations(n: Integer; pixels: array of Integer): Integer;", "docstring": "Given a 1 by n pixel image where each pixel has a color represented by an integer,\n   you can pick a color and change all connected pixels of the same color to the chosen color.\n   Two pixels are connected if they are adjacent and have the same color.\n   Find the minimum number of operations required to make all pixels the same color.\n\n   Note: For each color, there are at most 20 pixels of that color.\n\n   Examples:\n       >>> minOperations(5, [1, 2, 3, 2, 1])\n       2\n", "instruction": "Write a Pascal function `function minOperations(n: Integer; pixels: array of Integer): Integer;` to solve the following problem:\nGiven a 1 by n pixel image where each pixel has a color represented by an integer,\n   you can pick a color and change all connected pixels of the same color to the chosen color.\n   Two pixels are connected if they are adjacent and have the same color.\n   Find the minimum number of operations required to make all pixels the same color.\n\n   Note: For each color, there are at most 20 pixels of that color.\n\n   Examples:\n       >>> minOperations(5, [1, 2, 3, 2, 1])\n       2\n", "level": "hard"}
{"task_id": "Pascal/46", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils;\n(*\n  Given an integer n, this function calculates the sum of all numbers from 1 to n that\n  are multiples of either 3 or 5. Each qualifying number is counted only once, even if\n  it is a multiple of both 3 and 5.\n\n  Example usage:\n    >>> sumOfMultiples(10)\n    Returns 33, which represents the sum of 3, 5, 6, 9, and 10.\n*)\nfunction sumOfMultiples(n: integer): integer;", "canonical_solution": "var\n    sum, i: integer;\nbegin\n    sum := 0;\n    for i := 1 to n do\n    begin\n        if (i mod 3 = 0) or (i mod 5 = 0) then\n        begin\n            sum := sum + i;\n        end;\n    end;\n    sumOfMultiples := sum;\nend;", "test": "procedure testSumOfMultiples;\nbegin\n    Assert(sumOfMultiples(10) = 33);\n    Assert(sumOfMultiples(15) = 60);\n    Assert(sumOfMultiples(20) = 98);\n    Assert(sumOfMultiples(5) = 8);\n    Assert(sumOfMultiples(3) = 3);\n    Assert(sumOfMultiples(6) = 14);\n    Assert(sumOfMultiples(9) = 23);\n    Assert(sumOfMultiples(12) = 45);\n    Assert(sumOfMultiples(17) = 60);\n    Assert(sumOfMultiples(21) = 119);\n    Assert(sumOfMultiples(25) = 168);\nend;\n\nbegin\n    testSumOfMultiples;\nend.", "entry_point": "sumOfMultiples", "signature": "function sumOfMultiples(n: integer): integer;", "docstring": "Given an integer n, this function calculates the sum of all numbers from 1 to n that are multiples of either 3 or 5. Each qualifying number is counted only once, even if it is a multiple of both 3 and 5.\n\nExample usage:\n  >>> sumOfMultiples(10)\n  Returns 33, which represents the sum of 3, 5, 6, 9, and 10.", "instruction": "Write a Pascal function `function sumOfMultiples(n: integer): integer;` to solve the following problem:\nGiven an integer n, this function calculates the sum of all numbers from 1 to n that are multiples of either 3 or 5. Each qualifying number is counted only once, even if it is a multiple of both 3 and 5.\n\nExample usage:\n  >>> sumOfMultiples(10)\n  Returns 33, which represents the sum of 3, 5, 6, 9, and 10.", "level": "easy"}
{"task_id": "Pascal/47", "prompt": "{$ASSERTIONS ON}\n\nuses\n  SysUtils, Character;\n(*\n  Determine if a given string is a palindrome. A palindrome is a word, phrase,\n  number, or other sequence of characters that reads the same forward and backward\n  (ignoring spaces, punctuation, and capitalization).\n      >>> isPalindrome('hello')\n      false\n*)\nfunction isPalindrome(str: String): Boolean;", "canonical_solution": "var\n  start, end_: Integer;\nbegin\n  start := 1;\n  end_ := Length(str);\n\n  while (start < end_) do\n  begin\n    // Skip non-alphanumeric characters and handle case insensitivity\n    while ((not TCharacter.IsLetterOrDigit(str[start])) and (start < end_)) do Inc(start);\n    while ((not TCharacter.IsLetterOrDigit(str[end_])) and (start < end_)) do Dec(end_);\n\n    if (LowerCase(str[start]) <> LowerCase(str[end_])) then\n    begin\n      isPalindrome := False;\n      Exit;\n    end;\n\n    Inc(start);\n    Dec(end_);\n  end;\n\n  isPalindrome := True;\nend;", "test": "procedure testIsPalindrome;\nbegin\n  Assert(isPalindrome('A man a plan a canal Panama') = True);\n  Assert(isPalindrome('No lemon, no melon') = True);\n  Assert(isPalindrome('Was it a car or a cat I saw') = True);\n  Assert(isPalindrome('Madam, in Eden, I''m Adam') = True);\n  Assert(isPalindrome('Never odd or even') = True);\n  Assert(isPalindrome('Eva, can I see bees in a cave') = True);\n  Assert(isPalindrome('hello') = False);\n  Assert(isPalindrome('GitHub') = False);\n  Assert(isPalindrome('programming') = False);\nend;\n\nbegin\n  testIsPalindrome;\nend.", "entry_point": "isPalindrome", "signature": "function isPalindrome(str: String): Boolean;", "docstring": "Determine if a given string is a palindrome. A palindrome is a word, phrase,\nnumber, or other sequence of characters that reads the same forward and backward\n(ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome('hello')\n    false\n", "instruction": "Write a Pascal function `function isPalindrome(str: String): Boolean;` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase,\nnumber, or other sequence of characters that reads the same forward and backward\n(ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome('hello')\n    false\n", "level": "middle"}
{"task_id": "Pascal/48", "prompt": "{$ASSERTIONS ON}\n(*\n  Given a non-negative integer num, repeatedly add all its digits until the\n  result has only one digit.\n  For example:\n      >>> addDigits(38)\n      2\n  Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*)\nfunction addDigits(num: Integer): Integer;", "canonical_solution": "var\n    sum: Integer;\nbegin\n    while num >= 10 do\n    begin\n        sum := 0;\n        while num > 0 do\n        begin\n            sum := sum + (num mod 10);\n            num := num div 10;\n        end;\n        num := sum;\n    end;\n    addDigits := num;\nend;", "test": "procedure testAddDigits;\nbegin\n    Assert(addDigits(38) = 2);\n    Assert(addDigits(0) = 0);\n    Assert(addDigits(9) = 9);\n    Assert(addDigits(123) = 6);\n    Assert(addDigits(456) = 6);\n    Assert(addDigits(9999) = 9);\n    Assert(addDigits(100) = 1);\n    Assert(addDigits(1010) = 2);\n    Assert(addDigits(1234) = 1);\n    Assert(addDigits(9876) = 3);\n    Assert(addDigits(199) = 1);\nend;\n\nbegin\n    testAddDigits;\nend.", "entry_point": "addDigits", "signature": "function addDigits(num: Integer): Integer;", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\nBecause 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "instruction": "Write a Pascal function `function addDigits(num: Integer): Integer;` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\nBecause 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "level": "easy"}
{"task_id": "Pascal/49", "prompt": "{$ASSERTIONS ON}\n(* \n  Nim Game:\n  You are playing a game called Nim. In this game, you start with a pile of n stones,\n  and you and your opponent take turns to remove 1 to 3 stones from the pile.\n  The one who removes the last stone wins the game.\n  Given the number of stones n, determine if you can win the game if both you and your\n  opponent play optimally. You always take the first turn.\n  \n  Examples:\n    >>> canWinNim(1)  returns true\n*)\nfunction canWinNim(n: integer): boolean;", "canonical_solution": "begin\n    canWinNim := n mod 4 <> 0;\nend;", "test": "procedure testCanWinNim;\nbegin\n    Assert(canWinNim(1) = true);\n    Assert(canWinNim(2) = true);\n    Assert(canWinNim(3) = true);\n    Assert(canWinNim(4) = false);\n    Assert(canWinNim(5) = true);\n    Assert(canWinNim(6) = true);\n    Assert(canWinNim(7) = true);\n    Assert(canWinNim(8) = false);\n    Assert(canWinNim(9) = true);\n    Assert(canWinNim(10) = true);\n    Assert(canWinNim(11) = true);\n    Assert(canWinNim(12) = false);\n    Assert(canWinNim(13) = true);\n    Assert(canWinNim(14) = true);\n    Assert(canWinNim(15) = true);\n    Assert(canWinNim(16) = false);\n    Assert(canWinNim(17) = true);\n    Assert(canWinNim(18) = true);\n    Assert(canWinNim(19) = true);\n    Assert(canWinNim(20) = false);\nend;\n\nbegin\n    testCanWinNim;\nend.", "entry_point": "canWinNim", "signature": "function canWinNim(n: integer): boolean;", "docstring": "Nim Game:\n  You are playing a game called Nim. In this game, you start with a pile of n stones,\n  and you and your opponent take turns to remove 1 to 3 stones from the pile.\n  The one who removes the last stone wins the game.\n  Given the number of stones n, determine if you can win the game if both you and your\n  opponent play optimally. You always take the first turn.\n\n  Examples:\n    >>> canWinNim(1)  returns true\n", "instruction": "Write a Pascal function `function canWinNim(n: integer): boolean;` to solve the following problem:\nNim Game:\n  You are playing a game called Nim. In this game, you start with a pile of n stones,\n  and you and your opponent take turns to remove 1 to 3 stones from the pile.\n  The one who removes the last stone wins the game.\n  Given the number of stones n, determine if you can win the game if both you and your\n  opponent play optimally. You always take the first turn.\n\n  Examples:\n    >>> canWinNim(1)  returns true\n", "level": "easy"}
{"task_id": "Pascal/50", "prompt": "{$ASSERTIONS ON}\n(**\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExample usage:\n  evenSumOrOddProduct(2, 3) returns 6\n*)\nfunction evenSumOrOddProduct(a, b: Integer): Integer;", "canonical_solution": "var\n  sum: Integer;\nbegin\n  sum := a + b;\n  if sum mod 2 = 0 then\n    evenSumOrOddProduct := sum\n  else\n    evenSumOrOddProduct := a * b;\nend;", "test": "procedure testEvenSumOrOddProduct;\nbegin\n  Assert(evenSumOrOddProduct(2, 3) = 6);\n  Assert(evenSumOrOddProduct(5, 5) = 10);\n  Assert(evenSumOrOddProduct(1, 1) = 2);\n  Assert(evenSumOrOddProduct(0, 0) = 0);\n  Assert(evenSumOrOddProduct(-1, -1) = -2);\n  Assert(evenSumOrOddProduct(100, 200) = 300);\n  Assert(evenSumOrOddProduct(3, 4) = 12);\n  Assert(evenSumOrOddProduct(-5, 5) = 0);\n  Assert(evenSumOrOddProduct(7, 8) = 56);\n  Assert(evenSumOrOddProduct(9, 10) = 90);\n  Assert(evenSumOrOddProduct(11, 14) = 154);\nend;\n\nbegin\n  testEvenSumOrOddProduct;\nend.", "entry_point": "evenSumOrOddProduct", "signature": "function evenSumOrOddProduct(a, b: Integer): Integer;", "docstring": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExample usage:\n  evenSumOrOddProduct(2, 3) returns 6", "instruction": "Write a Pascal function `function evenSumOrOddProduct(a, b: Integer): Integer;` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\nExample usage:\n  evenSumOrOddProduct(2, 3) returns 6", "level": "easy"}
