{"task_id": "Groovy/1", "prompt": "class CloseElementsChecker {\n    static boolean hasCloseElements(List<Double> numbers, double threshold) {\n        \"\"\"\n        Check if in given list of numbers, are any two numbers closer to each other than\n        given threshold.\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n        \"\"\"", "canonical_solution": "for (int i = 0; i < numbers.size(); i++) {\n            for (int j = 0; j < numbers.size(); j++) {\n                if (i != j) {\n                    def distance = Math.abs(numbers[i] - numbers[j])\n                    if (distance < threshold) {\n                        return true\n                    }\n                }\n            }\n        }\n        return false\n    }\n}", "test": "// Test cases\ndef closeElementsChecker = new CloseElementsChecker()\nassert closeElementsChecker.hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true\nassert closeElementsChecker.hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false\nassert closeElementsChecker.hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true\nassert closeElementsChecker.hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false\nassert closeElementsChecker.hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true\nassert closeElementsChecker.hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true\nassert closeElementsChecker.hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false", "entry_point": "hasCloseElements", "signature": "static boolean hasCloseElements(List<Double> numbers, double threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\n        given threshold.\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True", "instruction": "Write a Groovy function `static boolean hasCloseElements(List<Double> numbers, double threshold)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\n        given threshold.\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True", "level": "easy"}
{"task_id": "Groovy/2", "prompt": "boolean isPalindrome(int x) {\n\"\"\"\n    Check if the given integer is a palindrome.\n    A palindrome is a number that reads the same forward as backward.\n    >>> isPalindrome(121)\n    true\n    >>> isPalindrome(-12321)\n    false\n    >>> isPalindrome(10)\n    false\n\"\"\"    ", "canonical_solution": "    String strX = String.valueOf(x)\n    String reversedStrX = strX.reverse()\n    return strX.equals(reversedStrX)\n}", "test": "assert isPalindrome(121) == true\nassert isPalindrome(-12321) == false\nassert isPalindrome(10) == false\nassert isPalindrome(12321) == true\nassert isPalindrome(98789) == true\nassert isPalindrome(12345) == false", "entry_point": "isPalindrome", "signature": "boolean isPalindrome(int x)", "docstring": "Check if the given integer is a palindrome.\n    A palindrome is a number that reads the same forward as backward.\n    >>> isPalindrome(121)\n    true\n    >>> isPalindrome(-12321)\n    false\n    >>> isPalindrome(10)\n    false", "instruction": "Write a Groovy function `boolean isPalindrome(int x)` to solve the following problem:\nCheck if the given integer is a palindrome.\n    A palindrome is a number that reads the same forward as backward.\n    >>> isPalindrome(121)\n    true\n    >>> isPalindrome(-12321)\n    false\n    >>> isPalindrome(10)\n    false", "level": "easy"}
{"task_id": "Groovy/3", "prompt": "class LongestUniqueSubstring {\n    static int lengthOfLongestUniqueSubstring(String s) {\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    >>> lengthOfLongestUniqueSubstring(\"abcabcbb\")\n    3\n    >>> lengthOfLongestUniqueSubstring(\"bbbbb\")\n    1\n    >>> lengthOfLongestUniqueSubstring(\"pwwkew\")\n    3\n    \"\"\"", "canonical_solution": "    def maxLength = 0\n    def start = 0\n    def charIndexMap = [:]\n\n    for (int i = 0; i < s.length(); i++) {\n        if (charIndexMap.containsKey(s[i]) && charIndexMap[s[i]] >= start) {\n            start = charIndexMap[s[i]] + 1\n        }\n        charIndexMap[s[i]] = i\n        maxLength = Math.max(maxLength, i - start + 1)\n    }\n\n    return maxLength\n    }\n}", "test": "def longestUniqueSubstring = new LongestUniqueSubstring()\nassert longestUniqueSubstring.lengthOfLongestUniqueSubstring(\"abcxyzabc\") == 6\nassert longestUniqueSubstring.lengthOfLongestUniqueSubstring(\"bbccdef\") == 4\nassert longestUniqueSubstring.lengthOfLongestUniqueSubstring(\"abcdabcde\") == 5\nassert longestUniqueSubstring.lengthOfLongestUniqueSubstring(\"pqrstuvw\") == 8\nassert longestUniqueSubstring.lengthOfLongestUniqueSubstring(\"xyzxyz\") == 3\nassert longestUniqueSubstring.lengthOfLongestUniqueSubstring(\"abcdefg\") == 7", "entry_point": "lengthOfLongestUniqueSubstring", "signature": "static int lengthOfLongestUniqueSubstring(String s)", "docstring": "Given a string s, find the length of the longest substring without repeating characters.\n    >>> lengthOfLongestUniqueSubstring(\"abcabcbb\")\n    3\n    >>> lengthOfLongestUniqueSubstring(\"bbbbb\")\n    1\n    >>> lengthOfLongestUniqueSubstring(\"pwwkew\")\n    3", "instruction": "Write a Groovy function `static int lengthOfLongestUniqueSubstring(String s)` to solve the following problem:\nGiven a string s, find the length of the longest substring without repeating characters.\n    >>> lengthOfLongestUniqueSubstring(\"abcabcbb\")\n    3\n    >>> lengthOfLongestUniqueSubstring(\"bbbbb\")\n    1\n    >>> lengthOfLongestUniqueSubstring(\"pwwkew\")\n    3", "level": "easy"}
{"task_id": "Groovy/4", "prompt": "class ThreeSumFinder {\n    static List<List<Integer>> threeSum(List<Integer> nums) {\n\"\"\"\n    Given an integer list, finds all unique triplets [nums[i], nums[j], nums[k]] such that\n    i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.\n    Returns a list of lists containing the unique triplets.\n    \n    @param nums List of integers\n    @return List of lists containing unique triplets whose sum is zero\n    \n    Example:\n    >>> threeSum([-1, 0, 1, 2, -1, -4])\n    Returns: [[-1, -1, 2], [-1, 0, 1]]\n    \n    >>> threeSum([3, 0, -2, -1, 1, 2])\n    Returns: [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]\n\"\"\"", "canonical_solution": "        List<List<Integer>> result = []\n        nums.sort()\n\n        for (int i = 0; i < nums.size() - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue\n\n            int left = i + 1\n            int right = nums.size() - 1\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right]\n                if (sum == 0) {\n                    result.add([nums[i], nums[left], nums[right]])\n\n                    while (left < right && nums[left] == nums[left + 1]) left++\n                    while (left < right && nums[right] == nums[right - 1]) right--\n\n                    left++\n                    right--\n                } else if (sum < 0) {\n                    left++\n                } else {\n                    right--\n                }\n            }\n        }\n\n        return result\n    }\n}", "test": "def threeSumFinder = new ThreeSumFinder()\ndef result1 = threeSumFinder.threeSum([-1, 0, 1, 2, -1, -4])\nassert result1.toSet() == [[-1, -1, 2], [-1, 0, 1]].toSet()\n\ndef result2 = threeSumFinder.threeSum([3, 0, -2, -1, 1, 2])\nassert result2.toSet() == [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]].toSet()\n\ndef result3 = threeSumFinder.threeSum([1, 2, -2, -1])\nassert result3.toSet() == [].toSet()\n\ndef result4 = threeSumFinder.threeSum([0, 0, 0])\nassert result4.toSet() == [[0, 0, 0]].toSet()\n\ndef result5 = threeSumFinder.threeSum([5, -2, 2, -1, 1, 0, 2, 3, -3, 0, 3, 4, -4, 6, 3, 4, -3, -4, 1, -1])\nassert result5.toSet() == [[-4, -2, 6], [-4, -1, 5], [-4, 0, 4], [-4, 1, 3], [-4, 2, 2], [-3, -3, 6], [-3, -2, 5], [-3, -1, 4], [-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1]].toSet()", "entry_point": "threeSum", "signature": "static List<List<Integer>> threeSum(List<Integer> nums)", "docstring": "Given an integer list, finds all unique triplets [nums[i], nums[j], nums[k]] such that\n    i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.\n    Returns a list of lists containing the unique triplets.\n    \n    @param nums List of integers\n    @return List of lists containing unique triplets whose sum is zero\n    \n    Example:\n    >>> threeSum([-1, 0, 1, 2, -1, -4])\n    Returns: [[-1, -1, 2], [-1, 0, 1]]\n    \n    >>> threeSum([3, 0, -2, -1, 1, 2])\n    Returns: [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]", "instruction": "Write a Groovy function `static List<List<Integer>> threeSum(List<Integer> nums)` to solve the following problem:\nGiven an integer list, finds all unique triplets [nums[i], nums[j], nums[k]] such that\n    i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.\n    Returns a list of lists containing the unique triplets.\n    \n    @param nums List of integers\n    @return List of lists containing unique triplets whose sum is zero\n    \n    Example:\n    >>> threeSum([-1, 0, 1, 2, -1, -4])\n    Returns: [[-1, -1, 2], [-1, 0, 1]]\n    \n    >>> threeSum([3, 0, -2, -1, 1, 2])\n    Returns: [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]", "level": "hard"}
{"task_id": "Groovy/5", "prompt": "class NextPermutationFinder {\n    static List<Integer> findNextPermutation(List<Integer> nums) {\n        \"\"\"\n        Find the next permutation of the given list of numbers.\n        If no such permutation exists, return the smallest permutation.\n        >>> findNextPermutation([1, 2, 3])\n        [1, 3, 2]\n        >>> findNextPermutation([3, 2, 1])\n        [1, 2, 3]\n        >>> findNextPermutation([1, 1, 5])\n        [1, 5, 1]\n        \"\"\"", "canonical_solution": "        int i = nums.size() - 2\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--\n        }\n        if (i >= 0) {\n            int j = nums.size() - 1\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--\n            }\n            Collections.swap(nums, i, j)\n        }\n        Collections.reverse(nums.subList(i + 1, nums.size()))\n        return nums\n    }\n}", "test": "def nextPermutationFinder = new NextPermutationFinder()\nassert nextPermutationFinder.findNextPermutation([1, 2, 3]) == [1, 3, 2]\nassert nextPermutationFinder.findNextPermutation([3, 2, 1]) == [1, 2, 3]\nassert nextPermutationFinder.findNextPermutation([1, 1, 5]) == [1, 5, 1]\nassert nextPermutationFinder.findNextPermutation([1, 3, 2]) == [2, 1, 3]\nassert nextPermutationFinder.findNextPermutation([2, 3, 1]) == [3, 1, 2]\nassert nextPermutationFinder.findNextPermutation([3, 1, 2]) == [3, 2, 1]\nassert nextPermutationFinder.findNextPermutation([1, 5, 1]) == [5, 1, 1]", "entry_point": "findNextPermutation", "signature": "static List<Integer> findNextPermutation(List<Integer> nums)", "docstring": "Find the next permutation of the given list of numbers.\n        If no such permutation exists, return the smallest permutation.\n        >>> findNextPermutation([1, 2, 3])\n        [1, 3, 2]\n        >>> findNextPermutation([3, 2, 1])\n        [1, 2, 3]\n        >>> findNextPermutation([1, 1, 5])\n        [1, 5, 1]", "instruction": "Write a Groovy function `static List<Integer> findNextPermutation(List<Integer> nums)` to solve the following problem:\nFind the next permutation of the given list of numbers.\n        If no such permutation exists, return the smallest permutation.\n        >>> findNextPermutation([1, 2, 3])\n        [1, 3, 2]\n        >>> findNextPermutation([3, 2, 1])\n        [1, 2, 3]\n        >>> findNextPermutation([1, 1, 5])\n        [1, 5, 1]", "level": "easy"}
{"task_id": "Groovy/6", "prompt": "class RotatedArraySearch {\n    static int search(List<Integer> nums, int target) {\n        \"\"\"\n        Search for a target in a rotated sorted array.\n        The array is rotated at some pivot unknown to you beforehand.\n        (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n        You are given a target value to search. If found in the array return its index, otherwise return -1.\n        You may assume no duplicate exists in the array.\n        Your algorithm's runtime complexity must be in the order of O(log n).\n        >>> search([4,5,6,7,0,1,2], 0)\n        4\n        >>> search([4,5,6,7,0,1,2], 3)\n        -1\n        >>> search([1], 0)\n        -1\n        \"\"\"", "canonical_solution": "        int start = 0, end = nums.size() - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            if (nums[start] <= nums[mid]) {\n                if (target < nums[mid] && target >= nums[start]) \n                    end = mid - 1;\n                else start = mid + 1;\n            }\n            if (nums[mid] <= nums[end]) {\n                if (target > nums[mid] && target <= nums[end]) \n                    start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n}", "test": "def rotatedArraySearch = new RotatedArraySearch()\nassert rotatedArraySearch.search([4,5,6,7,0,1,2], 0) == 4\nassert rotatedArraySearch.search([4,5,6,7,0,1,2], 3) == -1\nassert rotatedArraySearch.search([1], 0) == -1\nassert rotatedArraySearch.search([4,5,6,7,0,1,2], 5) == 1\nassert rotatedArraySearch.search([4,5,6,7,0,1,2], 1) == 5\nassert rotatedArraySearch.search([4,5,6,7,0,1,2], 7) == 3\nassert rotatedArraySearch.search([4,5,6,7,0,1,2], 4) == 0\nassert rotatedArraySearch.search([4,5,6,7,0,1,2], 2) == 6", "entry_point": "search", "signature": "static int search(List<Integer> nums, int target)", "docstring": "Search for a target in a rotated sorted array.\n        The array is rotated at some pivot unknown to you beforehand.\n        (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n        You are given a target value to search. If found in the array return its index, otherwise return -1.\n        You may assume no duplicate exists in the array.\n        Your algorithm's runtime complexity must be in the order of O(log n).\n        >>> search([4,5,6,7,0,1,2], 0)\n        4\n        >>> search([4,5,6,7,0,1,2], 3)\n        -1\n        >>> search([1], 0)\n        -1", "instruction": "Write a Groovy function `static int search(List<Integer> nums, int target)` to solve the following problem:\nSearch for a target in a rotated sorted array.\n        The array is rotated at some pivot unknown to you beforehand.\n        (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n        You are given a target value to search. If found in the array return its index, otherwise return -1.\n        You may assume no duplicate exists in the array.\n        Your algorithm's runtime complexity must be in the order of O(log n).\n        >>> search([4,5,6,7,0,1,2], 0)\n        4\n        >>> search([4,5,6,7,0,1,2], 3)\n        -1\n        >>> search([1], 0)\n        -1", "level": "middle"}
{"task_id": "Groovy/7", "prompt": "class ReversePolishNotationCalculator {\n    static int calculate(List<String> tokens) {\n        \"\"\"\n        Calculate the result of an arithmetic expression in Reverse Polish Notation.\n        Reverse Polish notation (RPN) is a mathematical notation in which every operator follows all of its operands.\n\n        Example:\n        >>> calculate([\"2\", \"1\", \"+\", \"3\", \"*\"])\n        9\n        Explanation: ((2 + 1) * 3) = 9\n\n        >>> calculate([\"4\", \"13\", \"5\", \"/\", \"+\"])\n        6\n        Explanation: (4 + (13 / 5)) = 6\n\n        >>> calculate([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"])\n        22\n        Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = 22\n        \"\"\"", "canonical_solution": "        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\")) {\n                int operand2 = stack.pop();\n                int operand1 = stack.pop();\n                switch (token) {\n                    case \"+\":\n                        stack.push(operand1 + operand2);\n                        break;\n                    case \"-\":\n                        stack.push(operand1 - operand2);\n                        break;\n                    case \"*\":\n                        stack.push(operand1 * operand2);\n                        break;\n                    case \"/\":\n                        stack.push(operand1 / operand2);\n                        break;\n                }\n            } else {\n                stack.push(Integer.parseInt(token));\n            }\n        }\n        return stack.pop();\n    }\n}", "test": "def calculator = new ReversePolishNotationCalculator()\nassert calculator.calculate([\"2\", \"1\", \"+\", \"3\", \"*\"]) == 9\nassert calculator.calculate([\"4\", \"13\", \"5\", \"/\", \"+\"]) == 6\nassert calculator.calculate([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]) == 22\nassert calculator.calculate([\"3\", \"4\", \"+\", \"2\", \"*\"]) == 14\nassert calculator.calculate([\"15\", \"7\", \"1\", \"1\", \"+\", \"-\", \"/\", \"3\", \"*\", \"2\", \"1\", \"1\", \"+\", \"+\", \"-\"]) == 5\nassert calculator.calculate([\"1\", \"2\", \"+\", \"3\", \"*\"]) == 9\nassert calculator.calculate([\"10\", \"6\", \"9\", \"3\", \"-\", \"11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]) == 22", "entry_point": "calculate", "signature": "static int calculate(List<String> tokens)", "docstring": "Calculate the result of an arithmetic expression in Reverse Polish Notation.\n        Reverse Polish notation (RPN) is a mathematical notation in which every operator follows all of its operands.\n\n        Example:\n        >>> calculate([\"2\", \"1\", \"+\", \"3\", \"*\"])\n        9\n        Explanation: ((2 + 1) * 3) = 9\n\n        >>> calculate([\"4\", \"13\", \"5\", \"/\", \"+\"])\n        6\n        Explanation: (4 + (13 / 5)) = 6\n\n        >>> calculate([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"])\n        22\n        Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = 22", "instruction": "Write a Groovy function `static int calculate(List<String> tokens)` to solve the following problem:\nCalculate the result of an arithmetic expression in Reverse Polish Notation.\n        Reverse Polish notation (RPN) is a mathematical notation in which every operator follows all of its operands.\n\n        Example:\n        >>> calculate([\"2\", \"1\", \"+\", \"3\", \"*\"])\n        9\n        Explanation: ((2 + 1) * 3) = 9\n\n        >>> calculate([\"4\", \"13\", \"5\", \"/\", \"+\"])\n        6\n        Explanation: (4 + (13 / 5)) = 6\n\n        >>> calculate([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"])\n        22\n        Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = 22", "level": "easy"}
{"task_id": "Groovy/8", "prompt": "\"\"\"\nclass MinStack:\n\n    def __init__(self):\n\n\n    def push(self, val: int) -> None:\n\n\n    def pop(self) -> None:\n\n\n    def top(self) -> int:\n\n\n    def getMin(self) -> int:\n\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n\"\"\"", "canonical_solution": "class MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        if (minStack.isEmpty() || val <= minStack.peek()) {\n            minStack.push(val);\n        }\n    }\n\n    public void pop() {\n        if (!stack.isEmpty()) {\n            int val = stack.pop();\n            if (val == minStack.peek()) {\n                minStack.pop();\n            }\n        }\n    }\n\n    public int top() {\n        if (!stack.isEmpty()) {\n            return stack.peek();\n        }\n        return -1; // or throw exception\n    }\n\n    public int getMin() {\n        if (!minStack.isEmpty()) {\n            return minStack.peek();\n        }\n        return -1; // or throw exception\n    }\n}", "test": "MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nassert minStack.getMin() == -3;\nminStack.pop();\nassert minStack.top() == 0;\nassert minStack.getMin() == -2;\n\nminStack = new MinStack();\nminStack.push(1);\nminStack.push(2);\nminStack.push(3);\nassert minStack.getMin() == 1;\nminStack.pop();\nassert minStack.top() == 2;\nassert minStack.getMin() == 1;\n\nminStack = new MinStack();\nminStack.push(3);\nminStack.push(2);\nminStack.push(1);\nassert minStack.getMin() == 1;\nminStack.pop();\nassert minStack.top() == 2;\nassert minStack.getMin() == 2;", "entry_point": "MinStack", "signature": "class MinStack:\n\n    def __init__(self):\n\n\n    def push(self, val: int) -> None:\n\n\n    def pop(self) -> None:\n\n\n    def top(self) -> int:\n\n\n    def getMin(self) -> int:", "docstring": "# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()", "instruction": "Write a Groovy function `class MinStack:\n\n    def __init__(self):\n\n\n    def push(self, val: int) -> None:\n\n\n    def pop(self) -> None:\n\n\n    def top(self) -> int:\n\n\n    def getMin(self) -> int:` to solve the following problem:\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(val)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()", "level": "hard"}
{"task_id": "Groovy/9", "prompt": "class PeakElementFinder {\n    static int findPeakElement(List<Integer> nums) {\n        \"\"\"\n        Find a peak element in the given array. A peak element is an element that is greater than its neighbors.\n        The array may contain multiple peaks, in which case, return the index of any one of them.\n        You may assume that nums[-1] = nums[n] = -\u221e.\n        You must solve the problem in O(log n) time complexity.\n        >>> findPeakElement([1,2,3,1])\n        2\n        >>> findPeakElement([1,2,1,3,5,6,4])\n        1 or 5\n        \"\"\"", "canonical_solution": "        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > nums[mid + 1])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return left;\n    }\n}", "test": "def peakElementFinder = new PeakElementFinder()\nassert peakElementFinder.findPeakElement([1, 2, 3, 1]) == 2\nassert peakElementFinder.findPeakElement([1, 2, 1, 3, 5, 6, 4]) == 1 || peakElementFinder.findPeakElement([1, 2, 1, 3, 5, 6, 4]) == 5\nassert peakElementFinder.findPeakElement([1, 2, 3, 4, 5, 6, 7]) == 6\nassert peakElementFinder.findPeakElement([7, 6, 5, 4, 3, 2, 1]) == 0\nassert peakElementFinder.findPeakElement([1, 1, 1, 1, 1, 1, 1]) == 0 || \n       peakElementFinder.findPeakElement([1, 1, 1, 1, 1, 1, 1]) == 1 || \n       peakElementFinder.findPeakElement([1, 1, 1, 1, 1, 1, 1]) == 2 || \n       peakElementFinder.findPeakElement([1, 1, 1, 1, 1, 1, 1]) == 3 || \n       peakElementFinder.findPeakElement([1, 1, 1, 1, 1, 1, 1]) == 4 || \n       peakElementFinder.findPeakElement([1, 1, 1, 1, 1, 1, 1]) == 5 || \n       peakElementFinder.findPeakElement([1, 1, 1, 1, 1, 1, 1]) == 6", "entry_point": "findPeakElement", "signature": "static int findPeakElement(List<Integer> nums)", "docstring": "Find a peak element in the given array. A peak element is an element that is greater than its neighbors.\n        The array may contain multiple peaks, in which case, return the index of any one of them.\n        You may assume that nums[-1] = nums[n] = -\u221e.\n        You must solve the problem in O(log n) time complexity.\n        >>> findPeakElement([1,2,3,1])\n        2\n        >>> findPeakElement([1,2,1,3,5,6,4])\n        1 or 5", "instruction": "Write a Groovy function `static int findPeakElement(List<Integer> nums)` to solve the following problem:\nFind a peak element in the given array. A peak element is an element that is greater than its neighbors.\n        The array may contain multiple peaks, in which case, return the index of any one of them.\n        You may assume that nums[-1] = nums[n] = -\u221e.\n        You must solve the problem in O(log n) time complexity.\n        >>> findPeakElement([1,2,3,1])\n        2\n        >>> findPeakElement([1,2,1,3,5,6,4])\n        1 or 5", "level": "easy"}
{"task_id": "Groovy/11", "prompt": "class MinSubArrayLen {\n    static int minSubArrayLen(int target, int[] nums) {\n        \"\"\"\n        Find the minimal length of a contiguous subarray of which the sum is greater than or equal to target.\n        If there is no such subarray, return 0 instead.\n        >>> minSubArrayLen(7, [2,3,1,2,4,3])\n        2\n        >>> minSubArrayLen(4, [1,4,4])\n        1\n        >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n        0\n        \"\"\"", "canonical_solution": "        int minLen = Integer.MAX_VALUE;\n        int sum = 0;\n        int left = 0;\n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n            while (sum >= target) {\n                minLen = Math.min(minLen, right - left + 1);\n                sum -= nums[left++];\n            }\n        }\n        return minLen == Integer.MAX_VALUE ? 0 : minLen;\n    }\n}", "test": "def minSubArrayLen = new MinSubArrayLen()\nassert minSubArrayLen.minSubArrayLen(7, [2,3,1,2,4,3] as int[]) == 2\nassert minSubArrayLen.minSubArrayLen(4, [1,4,4] as int[]) == 1\nassert minSubArrayLen.minSubArrayLen(11, [1,1,1,1,1,1,1,1] as int[]) == 0\nassert minSubArrayLen.minSubArrayLen(15, [1,2,3,4,5] as int[]) == 5\nassert minSubArrayLen.minSubArrayLen(100, [1,2,3,4,5,6,7,8,9,10] as int[]) == 0\nassert minSubArrayLen.minSubArrayLen(15, [5,1,3,5,10,7,4,9,2,8] as int[]) == 2\nassert minSubArrayLen.minSubArrayLen(11, [1,2,3,4,5,6,7,8,9,10] as int[]) == 2", "entry_point": "minSubArrayLen", "signature": "static int minSubArrayLen(int target, int[] nums)", "docstring": "Find the minimal length of a contiguous subarray of which the sum is greater than or equal to target.\n        If there is no such subarray, return 0 instead.\n        >>> minSubArrayLen(7, [2,3,1,2,4,3])\n        2\n        >>> minSubArrayLen(4, [1,4,4])\n        1\n        >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n        0", "instruction": "Write a Groovy function `static int minSubArrayLen(int target, int[] nums)` to solve the following problem:\nFind the minimal length of a contiguous subarray of which the sum is greater than or equal to target.\n        If there is no such subarray, return 0 instead.\n        >>> minSubArrayLen(7, [2,3,1,2,4,3])\n        2\n        >>> minSubArrayLen(4, [1,4,4])\n        1\n        >>> minSubArrayLen(11, [1,1,1,1,1,1,1,1])\n        0", "level": "easy"}
{"task_id": "Groovy/12", "prompt": "class CloseElementsChecker {\n    static boolean hasCloseElements(List<Integer> nums, int indexDiff, int valueDiff) {\n        \"\"\"\n        Check if in given list of numbers, are any two numbers closer to each other than\n        given threshold, and their indices are within the given index difference.\n        >>> hasCloseElements([1, 2, 3, 1], 3, 0)\n        True\n        >>> hasCloseElements([1, 5, 9, 1, 5, 9], 2, 3)\n        False\n        \"\"\"", "canonical_solution": "        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j <= i + indexDiff && j < nums.size(); j++) {\n                if (Math.abs(nums[i] - nums[j]) <= valueDiff) {\n                    return true\n                }\n            }\n        }\n        return false\n    }\n}", "test": "def closeElementsChecker = new CloseElementsChecker()\nassert closeElementsChecker.hasCloseElements([1, 2, 3, 1], 3, 0) == true\nassert closeElementsChecker.hasCloseElements([1, 5, 9, 1, 5, 9], 2, 3) == false\nassert closeElementsChecker.hasCloseElements([1, 2, 3, 4, 5, 6], 2, 1) == true\nassert closeElementsChecker.hasCloseElements([1, 2, 3, 4, 5, 6], 1, 0) == false\nassert closeElementsChecker.hasCloseElements([1, 2, 3, 4, 5, 6], 3, 2) == true\nassert closeElementsChecker.hasCloseElements([1, 2, 3, 4, 5, 6], 2, 0) == false", "entry_point": "hasCloseElements", "signature": "static boolean hasCloseElements(List<Integer> nums, int indexDiff, int valueDiff)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\n        given threshold, and their indices are within the given index difference.\n        >>> hasCloseElements([1, 2, 3, 1], 3, 0)\n        True\n        >>> hasCloseElements([1, 5, 9, 1, 5, 9], 2, 3)\n        False", "instruction": "Write a Groovy function `static boolean hasCloseElements(List<Integer> nums, int indexDiff, int valueDiff)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\n        given threshold, and their indices are within the given index difference.\n        >>> hasCloseElements([1, 2, 3, 1], 3, 0)\n        True\n        >>> hasCloseElements([1, 5, 9, 1, 5, 9], 2, 3)\n        False", "level": "easy"}
{"task_id": "Groovy/13", "prompt": "class MaxSlidingWindow {\n    static List<Integer> maxSlidingWindow(List<Integer> nums, int k) {  \n        \"\"\"\n        Given an integer array 'nums' and an integer 'k', return an array where the i-th element is the maximum number in the window of size 'k' starting from position i.\n        >>> maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3)\n        [3, 3, 5, 5, 6, 7]\n        >>> maxSlidingWindow([1], 1)\n        [1]\n        \"\"\"", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        Deque<Integer> deque = new ArrayDeque<>();\n        for (int i = 0; i < nums.size(); i++) {\n            // remove numbers out of range k\n            if (!deque.isEmpty() && deque.peekFirst() == i - k) {\n                deque.pollFirst();\n            }\n            // remove smaller numbers in k range as they are useless\n            while (!deque.isEmpty() && nums.get(i) > nums.get(deque.peekLast())) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n            if (i >= k - 1) {\n                result.add(nums.get(deque.peekFirst()));\n            }\n        }\n        return result;\n    }\n}", "test": "def maxSlidingWindow = new MaxSlidingWindow()\nassert maxSlidingWindow.maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7]\nassert maxSlidingWindow.maxSlidingWindow([1], 1) == [1]\nassert maxSlidingWindow.maxSlidingWindow([1, 2, 3, 4, 5, 6, 7], 3) == [3, 4, 5, 6, 7]\nassert maxSlidingWindow.maxSlidingWindow([7, 6, 5, 4, 3, 2, 1], 3) == [7, 6, 5, 4, 3]\nassert maxSlidingWindow.maxSlidingWindow([1, 1, 1, 1, 1, 1, 1], 3) == [1, 1, 1, 1, 1]\nassert maxSlidingWindow.maxSlidingWindow([1, 2, 3, 2, 1, 2, 3], 3) == [3, 3, 3, 2, 3]\nassert maxSlidingWindow.maxSlidingWindow([1, 2, 3, 4, 5, 6, 7], 1) == [1, 2, 3, 4, 5, 6, 7]", "entry_point": "maxSlidingWindow", "signature": "static List<Integer> maxSlidingWindow(List<Integer> nums, int k)", "docstring": "Given an integer array 'nums' and an integer 'k', return an array where the i-th element is the maximum number in the window of size 'k' starting from position i.\n        >>> maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3)\n        [3, 3, 5, 5, 6, 7]\n        >>> maxSlidingWindow([1], 1)\n        [1]", "instruction": "Write a Groovy function `static List<Integer> maxSlidingWindow(List<Integer> nums, int k)` to solve the following problem:\nGiven an integer array 'nums' and an integer 'k', return an array where the i-th element is the maximum number in the window of size 'k' starting from position i.\n        >>> maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3)\n        [3, 3, 5, 5, 6, 7]\n        >>> maxSlidingWindow([1], 1)\n        [1]", "level": "middle"}
{"task_id": "Groovy/14", "prompt": "class DuplicateFinder {\n    static int findDuplicate(List<Integer> nums) {\n        \"\"\"\n        Given an array of integers 'nums' containing 'n + 1' integers where each integer is in the range [1, n] inclusive.\n        There is only one repeated number in 'nums', return this repeated number.\n        The solution must not modify the array 'nums' and only use constant extra space.\n\n        >>> findDuplicate([1, 3, 4, 2, 2])\n        2\n        >>> findDuplicate([3, 1, 3, 4, 2])\n        3\n        \"\"\"", "canonical_solution": "        // Floyd's Tortoise and Hare (Cycle Detection)\n        int tortoise = nums[0];\n        int hare = nums[0];\n\n        // Phase 1: Find the meeting point\n        do {\n            tortoise = nums[tortoise];\n            hare = nums[nums[hare]];\n        } while (tortoise != hare);\n\n        // Phase 2: Find the start of the cycle\n        tortoise = nums[0];\n        while (tortoise != hare) {\n            tortoise = nums[tortoise];\n            hare = nums[hare];\n        }\n\n        return hare;\n    }\n}", "test": "def duplicateFinder = new DuplicateFinder()\nassert duplicateFinder.findDuplicate([1, 3, 4, 2, 2]) == 2\nassert duplicateFinder.findDuplicate([3, 1, 3, 4, 2]) == 3\nassert duplicateFinder.findDuplicate([1, 2, 3, 4, 5, 5]) == 5\nassert duplicateFinder.findDuplicate([5, 1, 2, 3, 4, 5]) == 5\nassert duplicateFinder.findDuplicate([1, 1]) == 1\nassert duplicateFinder.findDuplicate([2, 5, 9, 6, 9, 3, 8, 9, 7, 1]) == 9", "entry_point": "findDuplicate", "signature": "static int findDuplicate(List<Integer> nums)", "docstring": "Given an array of integers 'nums' containing 'n + 1' integers where each integer is in the range [1, n] inclusive.\n        There is only one repeated number in 'nums', return this repeated number.\n        The solution must not modify the array 'nums' and only use constant extra space.\n\n        >>> findDuplicate([1, 3, 4, 2, 2])\n        2\n        >>> findDuplicate([3, 1, 3, 4, 2])\n        3", "instruction": "Write a Groovy function `static int findDuplicate(List<Integer> nums)` to solve the following problem:\nGiven an array of integers 'nums' containing 'n + 1' integers where each integer is in the range [1, n] inclusive.\n        There is only one repeated number in 'nums', return this repeated number.\n        The solution must not modify the array 'nums' and only use constant extra space.\n\n        >>> findDuplicate([1, 3, 4, 2, 2])\n        2\n        >>> findDuplicate([3, 1, 3, 4, 2])\n        3", "level": "middle"}
{"task_id": "Groovy/15", "prompt": "\"\"\"\nclass MedianFinder {\n\n    public MedianFinder() {\n\n    }\n    \n    public void addNum(int num) {\n\n    }\n    \n    public double findMedian() {\n\n    }\n}\nThis class is used to find the median of a data stream.\nThe data stream is a list of integers.\nThe median is the middle value in an ordered integer list.\nIf the size of the list is even, there is no single middle value;\nthe median is then usually defined to be the mean of the two middle values.\n\nFor example:\nIf we add the numbers 2, 3, 4 in order, the median is 3.\nIf we add the numbers 2, 3, 4, 5 in order, the median is (3 + 4) / 2 = 3.5.\n\"\"\"", "canonical_solution": "import java.util.PriorityQueue\n\nclass MedianFinder {\n    private PriorityQueue<Integer> maxHeap\n    private PriorityQueue<Integer> minHeap\n\n    MedianFinder() {\n        maxHeap = new PriorityQueue<>((a, b) -> b - a)\n        minHeap = new PriorityQueue<>()\n    }\n\n    void addNum(int num) {\n        maxHeap.offer(num)\n        minHeap.offer(maxHeap.poll())\n        if (maxHeap.size() < minHeap.size()) {\n            maxHeap.offer(minHeap.poll())\n        }\n    }\n\n    double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0\n        } else {\n            return maxHeap.peek()\n        }\n    }\n}", "test": "def medianFinder = new MedianFinder()\nmedianFinder.addNum(1)\nmedianFinder.addNum(2)\nassert medianFinder.findMedian() == 1.5\nmedianFinder.addNum(3)\nassert medianFinder.findMedian() == 2.0\n\nmedianFinder = new MedianFinder()\nmedianFinder.addNum(1)\nmedianFinder.addNum(2)\nmedianFinder.addNum(3)\nmedianFinder.addNum(4)\nassert medianFinder.findMedian() == 2.5\nmedianFinder.addNum(5)\nassert medianFinder.findMedian() == 3.0", "entry_point": "MedianFinder", "signature": "class MedianFinder {\n\n    public MedianFinder() {\n\n    }\n    \n    public void addNum(int num) {\n\n    }\n    \n    public double findMedian() {\n\n    }\n}", "docstring": "class MedianFinder {\n\n    public MedianFinder() {\n\n    }\n    \n    public void addNum(int num) {\n\n    }\n    \n    public double findMedian() {\n\n    }\n}\nThis class is used to find the median of a data stream.\nThe data stream is a list of integers.\nThe median is the middle value in an ordered integer list.\nIf the size of the list is even, there is no single middle value;\nthe median is then usually defined to be the mean of the two middle values.\n\nFor example:\nIf we add the numbers 2, 3, 4 in order, the median is 3.\nIf we add the numbers 2, 3, 4, 5 in order, the median is (3 + 4) / 2 = 3.5.", "instruction": "Write a Groovy function `class MedianFinder {\n\n    public MedianFinder() {\n\n    }\n    \n    public void addNum(int num) {\n\n    }\n    \n    public double findMedian() {\n\n    }\n}` to solve the following problem:\nclass MedianFinder {\n\n    public MedianFinder() {\n\n    }\n    \n    public void addNum(int num) {\n\n    }\n    \n    public double findMedian() {\n\n    }\n}\nThis class is used to find the median of a data stream.\nThe data stream is a list of integers.\nThe median is the middle value in an ordered integer list.\nIf the size of the list is even, there is no single middle value;\nthe median is then usually defined to be the mean of the two middle values.\n\nFor example:\nIf we add the numbers 2, 3, 4 in order, the median is 3.\nIf we add the numbers 2, 3, 4, 5 in order, the median is (3 + 4) / 2 = 3.5.", "level": "middle"}
{"task_id": "Groovy/16", "prompt": "class ParenthesesRemover {\n    static List<String> removeInvalidParentheses(String s) {\n        \"\"\"\n        Remove the minimum number of invalid parentheses in order to make the input string valid.\n        A string is considered valid if it has the same number of open and close parentheses.\n        >>> removeInvalidParentheses(\"()())()\")\n        [\"(())()\",\"()()()\"]\n        >>> removeInvalidParentheses(\"(a)())()\")\n        [\"(a())()\",\"(a)()()\"]\n        >>> removeInvalidParentheses(\")(\")\n        [\"\"]\n        \"\"\"", "canonical_solution": "        List<String> result = new ArrayList<>()\n        if (s == null) return result\n\n        Set<String> visited = new HashSet<>()\n        Queue<String> queue = new LinkedList<>()\n\n        queue.offer(s)\n        visited.add(s)\n\n        boolean found = false\n\n        while (!queue.isEmpty()) {\n            s = queue.poll()\n\n            if (isValid(s)) {\n                result.add(s)\n                found = true\n            }\n\n            if (found) continue\n\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) != '(' && s.charAt(i) != ')') continue\n\n                String t = s.substring(0, i) + s.substring(i + 1)\n\n                if (!visited.contains(t)) {\n                    queue.offer(t)\n                    visited.add(t)\n                }\n            }\n        }\n\n        return result\n    }\n\n    static boolean isValid(String s) {\n        int count = 0\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i)\n            if (c == '(') count++\n            if (c == ')' && count-- == 0) return false\n        }\n\n        return count == 0\n    }\n}", "test": "def parenthesesRemover = new ParenthesesRemover()\nassert parenthesesRemover.removeInvalidParentheses(\"()())()\") == [\"(())()\",\"()()()\"]\nassert parenthesesRemover.removeInvalidParentheses(\"(a)())()\") == [\"(a())()\",\"(a)()()\"]\nassert parenthesesRemover.removeInvalidParentheses(\")(\") == [\"\"]\nassert parenthesesRemover.removeInvalidParentheses(\"()\") == [\"()\"]\nassert parenthesesRemover.removeInvalidParentheses(\")\") == [\"\"]\nassert parenthesesRemover.removeInvalidParentheses(\"(\") == [\"\"]\nassert parenthesesRemover.removeInvalidParentheses(\"\") == [\"\"]", "entry_point": "removeInvalidParentheses", "signature": "static List<String> removeInvalidParentheses(String s)", "docstring": "Remove the minimum number of invalid parentheses in order to make the input string valid.\n        A string is considered valid if it has the same number of open and close parentheses.\n        >>> removeInvalidParentheses(\"()())()\")\n        [\"(())()\",\"()()()\"]\n        >>> removeInvalidParentheses(\"(a)())()\")\n        [\"(a())()\",\"(a)()()\"]\n        >>> removeInvalidParentheses(\")(\")\n        [\"\"]", "instruction": "Write a Groovy function `static List<String> removeInvalidParentheses(String s)` to solve the following problem:\nRemove the minimum number of invalid parentheses in order to make the input string valid.\n        A string is considered valid if it has the same number of open and close parentheses.\n        >>> removeInvalidParentheses(\"()())()\")\n        [\"(())()\",\"()()()\"]\n        >>> removeInvalidParentheses(\"(a)())()\")\n        [\"(a())()\",\"(a)()()\"]\n        >>> removeInvalidParentheses(\")(\")\n        [\"\"]", "level": "hard"}
{"task_id": "Groovy/17", "prompt": "class BulbSwitcher {\n    static int numBulbsOn(int n) {\n        \"\"\"\n        Given an integer n, which represents the number of rounds of switching bulbs,\n        return the number of bulbs that are on after n rounds.\n\n        Each bulb is initially off. The first round, all bulbs are turned on.\n        Each subsequent round, every second bulb is toggled (i.e., turned off if it was on, and turned on if it was off).\n        The nth round, only the bulb at position n is toggled.\n\n        Example:\n        >>> numBulbsOn(3)\n        1\n        >>> numBulbsOn(0)\n        0\n        >>> numBulbsOn(1)\n        1\n        \"\"\"", "canonical_solution": "        int count = 0;\n        for (int i = 1; i * i <= n; i++) {\n            count++;\n        }\n        return count;\n    }\n}", "test": "def bulbSwitcher = new BulbSwitcher()\nassert bulbSwitcher.numBulbsOn(3) == 1\nassert bulbSwitcher.numBulbsOn(0) == 0\nassert bulbSwitcher.numBulbsOn(1) == 1\nassert bulbSwitcher.numBulbsOn(2) == 1\nassert bulbSwitcher.numBulbsOn(4) == 2\nassert bulbSwitcher.numBulbsOn(5) == 2\nassert bulbSwitcher.numBulbsOn(6) == 2\nassert bulbSwitcher.numBulbsOn(7) == 2\nassert bulbSwitcher.numBulbsOn(8) == 2\nassert bulbSwitcher.numBulbsOn(9) == 3\nassert bulbSwitcher.numBulbsOn(10) == 3", "entry_point": "numBulbsOn", "signature": "static int numBulbsOn(int n)", "docstring": "Given an integer n, which represents the number of rounds of switching bulbs,\n        return the number of bulbs that are on after n rounds.\n\n        Each bulb is initially off. The first round, all bulbs are turned on.\n        Each subsequent round, every second bulb is toggled (i.e., turned off if it was on, and turned on if it was off).\n        The nth round, only the bulb at position n is toggled.\n\n        Example:\n        >>> numBulbsOn(3)\n        1\n        >>> numBulbsOn(0)\n        0\n        >>> numBulbsOn(1)\n        1", "instruction": "Write a Groovy function `static int numBulbsOn(int n)` to solve the following problem:\nGiven an integer n, which represents the number of rounds of switching bulbs,\n        return the number of bulbs that are on after n rounds.\n\n        Each bulb is initially off. The first round, all bulbs are turned on.\n        Each subsequent round, every second bulb is toggled (i.e., turned off if it was on, and turned on if it was off).\n        The nth round, only the bulb at position n is toggled.\n\n        Example:\n        >>> numBulbsOn(3)\n        1\n        >>> numBulbsOn(0)\n        0\n        >>> numBulbsOn(1)\n        1", "level": "easy"}
{"task_id": "Groovy/18", "prompt": "class PowerOfThreeChecker {\n    static boolean isPowerOfThree(int n) {\n        \"\"\"\n        Check if a given number is a power of three.\n        >>> isPowerOfThree(27)\n        True\n        >>> isPowerOfThree(0)\n        False\n        >>> isPowerOfThree(9)\n        True\n        >>> isPowerOfThree(45)\n        False\n        \"\"\"", "canonical_solution": "        if (n < 1) {\n            return false;\n        }\n\n        while (n % 3 == 0) {\n            n /= 3;\n        }\n\n        return n == 1;\n    }\n}", "test": "def powerOfThreeChecker = new PowerOfThreeChecker()\nassert powerOfThreeChecker.isPowerOfThree(27) == true\nassert powerOfThreeChecker.isPowerOfThree(0) == false\nassert powerOfThreeChecker.isPowerOfThree(9) == true\nassert powerOfThreeChecker.isPowerOfThree(45) == false\nassert powerOfThreeChecker.isPowerOfThree(1) == true\nassert powerOfThreeChecker.isPowerOfThree(2) == false\nassert powerOfThreeChecker.isPowerOfThree(81) == true\nassert powerOfThreeChecker.isPowerOfThree(100) == false", "entry_point": "isPowerOfThree", "signature": "static boolean isPowerOfThree(int n)", "docstring": "Check if a given number is a power of three.\n        >>> isPowerOfThree(27)\n        True\n        >>> isPowerOfThree(0)\n        False\n        >>> isPowerOfThree(9)\n        True\n        >>> isPowerOfThree(45)\n        False", "instruction": "Write a Groovy function `static boolean isPowerOfThree(int n)` to solve the following problem:\nCheck if a given number is a power of three.\n        >>> isPowerOfThree(27)\n        True\n        >>> isPowerOfThree(0)\n        False\n        >>> isPowerOfThree(9)\n        True\n        >>> isPowerOfThree(45)\n        False", "level": "easy"}
{"task_id": "Groovy/19", "prompt": "class Solution {\n    static int findNthDigit(int n) {\n        \"\"\"\n        Find the nth digit in the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].\n        >>> findNthDigit(3)\n        3\n        >>> findNthDigit(11)\n        0\n        \"\"\"", "canonical_solution": "        long len = 1\n        long count = 9\n        long start = 1\n\n        while (n > len * count) {\n            n -= len * count\n            len += 1\n            count *= 10\n            start *= 10\n        }\n\n        start += (n - 1) / len\n        String s = String.valueOf(start)\n        return Character.getNumericValue(s.charAt((int)((n - 1) % len)))\n    }\n}", "test": "def solution = new Solution()\nassert solution.findNthDigit(3) == 3\nassert solution.findNthDigit(11) == 0\nassert solution.findNthDigit(100) == 5\nassert solution.findNthDigit(1000) == 3\nassert solution.findNthDigit(10000) == 7\nassert solution.findNthDigit(100000) == 2\nassert solution.findNthDigit(1000000) == 1\nassert solution.findNthDigit(10000000) == 7", "entry_point": "findNthDigit", "signature": "static int findNthDigit(int n)", "docstring": "Find the nth digit in the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].\n        >>> findNthDigit(3)\n        3\n        >>> findNthDigit(11)\n        0", "instruction": "Write a Groovy function `static int findNthDigit(int n)` to solve the following problem:\nFind the nth digit in the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].\n        >>> findNthDigit(3)\n        3\n        >>> findNthDigit(11)\n        0", "level": "easy"}
{"task_id": "Groovy/20", "prompt": "class WordCounter {\n    static int countWords(String s) {\n        \"\"\"\n        Count the number of words in a given string. A word is defined as a sequence of non-space characters.\n        >>> countWords(\"Hello, my name is John\")\n        5\n        >>> countWords(\"This is a test\")\n        4\n        \"\"\"", "canonical_solution": "        int count = 0;\n        boolean inWord = false;\n        for (char c : s.toCharArray()) {\n            if (c != ' ' && !inWord) {\n                count++;\n                inWord = true;\n            } else if (c == ' ') {\n                inWord = false;\n            }\n        }\n        return count;\n    }\n}", "test": "def wordCounter = new WordCounter()\nassert wordCounter.countWords(\"Hello, my name is John\") == 5\nassert wordCounter.countWords(\"This is a test\") == 4\nassert wordCounter.countWords(\"OneWord\") == 1\nassert wordCounter.countWords(\"\") == 0\nassert wordCounter.countWords(\"Multiple   spaces\") == 2\nassert wordCounter.countWords(\"Leading space\") == 2\nassert wordCounter.countWords(\"Trailing space \") == 2\nassert wordCounter.countWords(\"  Both sides space \") == 3", "entry_point": "countWords", "signature": "static int countWords(String s)", "docstring": "Count the number of words in a given string. A word is defined as a sequence of non-space characters.\n        >>> countWords(\"Hello, my name is John\")\n        5\n        >>> countWords(\"This is a test\")\n        4", "instruction": "Write a Groovy function `static int countWords(String s)` to solve the following problem:\nCount the number of words in a given string. A word is defined as a sequence of non-space characters.\n        >>> countWords(\"Hello, my name is John\")\n        5\n        >>> countWords(\"This is a test\")\n        4", "level": "easy"}
{"task_id": "Groovy/21", "prompt": "class PermutationGenerator {\n    static List<List> generatePermutations(List nums) {\n        \"\"\"\n        Generate all possible permutations of a given list of numbers.\n        >>> generatePermutations([1, 2, 3])\n        [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        >>> generatePermutations([0, 1])\n        [[0, 1], [1, 0]]\n        \"\"\"", "canonical_solution": "List<List<Integer>> result = new ArrayList<>()\n        backtrack(result, new ArrayList<>(), nums)\n        return result\n    }\n\n    static void backtrack(List<List<Integer>> result, List<Integer> tempList, List<Integer> nums) {\n        if (tempList.size() == nums.size()) {\n            result.add(new ArrayList<>(tempList))\n        } else {\n            for (int i = 0; i < nums.size(); i++) {\n                if (tempList.contains(nums.get(i))) continue\n                tempList.add(nums.get(i))\n                backtrack(result, tempList, nums)\n                tempList.remove(tempList.size() - 1)\n            }\n        }\n    }\n}", "test": "// Test cases\ndef permutationGenerator = new PermutationGenerator()\nassert permutationGenerator.generatePermutations([1, 2, 3]) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\nassert permutationGenerator.generatePermutations([0, 1]) == [[0, 1], [1, 0]]\nassert permutationGenerator.generatePermutations([1]) == [[1]]\nassert permutationGenerator.generatePermutations([1, 2, 3, 4]) == [[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]\nassert permutationGenerator.generatePermutations([0, 1, 2]) == [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]", "entry_point": "generatePermutations", "signature": "static List<List> generatePermutations(List nums)", "docstring": "Generate all possible permutations of a given list of numbers.\n        >>> generatePermutations([1, 2, 3])\n        [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        >>> generatePermutations([0, 1])\n        [[0, 1], [1, 0]]", "instruction": "Write a Groovy function `static List<List> generatePermutations(List nums)` to solve the following problem:\nGenerate all possible permutations of a given list of numbers.\n        >>> generatePermutations([1, 2, 3])\n        [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        >>> generatePermutations([0, 1])\n        [[0, 1], [1, 0]]", "level": "middle"}
{"task_id": "Groovy/22", "prompt": "class SpiralMatrix {\n    static List spiralOrder(ArrayList matrix) {\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        >>> spiralOrder([[1,2,3],[4,5,6],[7,8,9]])\n        [1,2,3,6,9,8,7,4,5]\n        >>> spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\n        [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.size == 0) {\n            return result;\n        }\n\n        int rowBegin = 0;\n        int rowEnd = matrix.size-1;\n        int colBegin = 0;\n        int colEnd = matrix[0].size - 1;\n\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\n            for (int i = colBegin; i <= colEnd; i ++) {\n                result.add(matrix[rowBegin][i]);\n            }\n            rowBegin++;\n\n            for (int i = rowBegin; i <= rowEnd; i ++) {\n                result.add(matrix[i][colEnd]);\n            }\n            colEnd--;\n\n            if (rowBegin <= rowEnd) {\n                for (int i = colEnd; i >= colBegin; i --) {\n                    result.add(matrix[rowEnd][i]);\n                }\n            }\n            rowEnd--;\n\n            if (colBegin <= colEnd) {\n                for (int i = rowEnd; i >= rowBegin; i --) {\n                    result.add(matrix[i][colBegin]);\n                }\n            }\n            colBegin ++;\n        }\n\n        return result;\n    }\n}", "test": "// Test cases\ndef spiralMatrix = new SpiralMatrix()\nassert spiralMatrix.spiralOrder([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,6,9,8,7,4,5]\nassert spiralMatrix.spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == [1,2,3,4,8,12,11,10,9,5,6,7]\nassert spiralMatrix.spiralOrder([[1,2],[3,4]]) == [1,2,4,3]\nassert spiralMatrix.spiralOrder([[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]) == [1,2,3,4,5,10,15,14,13,12,11,6,7,8,9]\nassert spiralMatrix.spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) == [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]\nassert spiralMatrix.spiralOrder([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]) == [1,2,3,6,9,12,11,10,7,4,5,8]\nassert spiralMatrix.spiralOrder([[1,2,3,4,5]]) == [1,2,3,4,5]\nassert spiralMatrix.spiralOrder([[1],[2],[3],[4],[5]]) == [1,2,3,4,5]", "entry_point": "spiralOrder", "signature": "static List spiralOrder(ArrayList matrix)", "docstring": "Given an m x n matrix, return all elements of the matrix in spiral order.\n        >>> spiralOrder([[1,2,3],[4,5,6],[7,8,9]])\n        [1,2,3,6,9,8,7,4,5]\n        >>> spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\n        [1,2,3,4,8,12,11,10,9,5,6,7]", "instruction": "Write a Groovy function `static List spiralOrder(ArrayList matrix)` to solve the following problem:\nGiven an m x n matrix, return all elements of the matrix in spiral order.\n        >>> spiralOrder([[1,2,3],[4,5,6],[7,8,9]])\n        [1,2,3,6,9,8,7,4,5]\n        >>> spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\n        [1,2,3,4,8,12,11,10,9,5,6,7]", "level": "hard"}
{"task_id": "Groovy/23", "prompt": "class IntervalMerger {\n    static List<List<Integer>> merge(List<List<Integer>> intervals) {\n        \"\"\"\n        Merge all overlapping intervals in the given list of intervals.\n        Each interval is represented as a list of two integers [start, end].\n        The function should return a list of non-overlapping intervals that cover all the input intervals.\n        \n        Example:\n        >>> merge([[1,3],[2,6],[8,10],[15,18]])\n        [[1,6],[8,10],[15,18]]\n        >>> merge([[1,4],[4,5]])\n        [[1,5]]\n        \"\"\"", "canonical_solution": "intervals.sort { a, b -> a[0] <=> b[0] }\n        List<List<Integer>> merged = new ArrayList<>()\n        for (List<Integer> interval : intervals) {\n            if (merged.isEmpty() || merged.get(merged.size() - 1)[1] < interval[0]) {\n                merged.add(interval)\n            } else {\n                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], interval[1])\n            }\n        }\n        return merged\n    }\n}", "test": "// Test cases\ndef intervalMerger = new IntervalMerger()\nassert intervalMerger.merge([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]\nassert intervalMerger.merge([[1,4],[4,5]]) == [[1,5]]\nassert intervalMerger.merge([[1,4],[0,4]]) == [[0,4]]\nassert intervalMerger.merge([[1,4],[5,6]]) == [[1,4],[5,6]]\nassert intervalMerger.merge([[1,4],[2,3]]) == [[1,4]]\nassert intervalMerger.merge([[1,4],[0,0]]) == [[0,0],[1,4]]\nassert intervalMerger.merge([[1,4],[0,2],[3,5]]) == [[0,5]]", "entry_point": "merge", "signature": "static List<List<Integer>> merge(List<List<Integer>> intervals)", "docstring": "Merge all overlapping intervals in the given list of intervals.\n        Each interval is represented as a list of two integers [start, end].\n        The function should return a list of non-overlapping intervals that cover all the input intervals.\n        \n        Example:\n        >>> merge([[1,3],[2,6],[8,10],[15,18]])\n        [[1,6],[8,10],[15,18]]\n        >>> merge([[1,4],[4,5]])\n        [[1,5]]", "instruction": "Write a Groovy function `static List<List<Integer>> merge(List<List<Integer>> intervals)` to solve the following problem:\nMerge all overlapping intervals in the given list of intervals.\n        Each interval is represented as a list of two integers [start, end].\n        The function should return a list of non-overlapping intervals that cover all the input intervals.\n        \n        Example:\n        >>> merge([[1,3],[2,6],[8,10],[15,18]])\n        [[1,6],[8,10],[15,18]]\n        >>> merge([[1,4],[4,5]])\n        [[1,5]]", "level": "easy"}
{"task_id": "Groovy/24", "prompt": "class IPAddressGenerator {\n    static List<String> generateValidIPAddresses(String s) {\n        \"\"\"\n        Generate all possible valid IP addresses by inserting '.' in the given string.\n        Each part of the IP address must be a number between 0 and 255 and cannot have leading zeros.\n        >>> generateValidIPAddresses(\"25525511135\")\n        [\"255.255.11.135\", \"255.255.111.35\"]\n        >>> generateValidIPAddresses(\"0000\")\n        [\"0.0.0.0\"]\n        >>> generateValidIPAddresses(\"101023\")\n        [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]\n        \"\"\"", "canonical_solution": "List<String> result = new ArrayList<>();\n        for (int i = 1; i < 4 && i < s.length(); i++) {\n            String firstPart = s.substring(0, i);\n            if (isValidPart(firstPart)) {\n                for (int j = i + 1; j < i + 4 && j < s.length(); j++) {\n                    String secondPart = s.substring(i, j);\n                    if (isValidPart(secondPart)) {\n                        for (int k = j + 1; k < j + 4 && k < s.length(); k++) {\n                            String thirdPart = s.substring(j, k);\n                            String fourthPart = s.substring(k);\n                            if (isValidPart(thirdPart) && isValidPart(fourthPart)) {\n                                result.add(firstPart + \".\" + secondPart + \".\" + thirdPart + \".\" + fourthPart);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private static boolean isValidPart(String s) {\n        if (s.length() > 1 && s.charAt(0) == '0') return false;\n        int num = Integer.parseInt(s);\n        return num >= 0 && num <= 255;\n    }\n}", "test": "// Test cases\ndef ipAddressGenerator = new IPAddressGenerator()\nassert ipAddressGenerator.generateValidIPAddresses(\"25525511135\") == [\"255.255.11.135\", \"255.255.111.35\"]\nassert ipAddressGenerator.generateValidIPAddresses(\"0000\") == [\"0.0.0.0\"]\nassert ipAddressGenerator.generateValidIPAddresses(\"101023\") == [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]\nassert ipAddressGenerator.generateValidIPAddresses(\"255255255255\") == [\"255.255.255.255\"]\nassert ipAddressGenerator.generateValidIPAddresses(\"1111\") == [\"1.1.1.1\"]\nassert ipAddressGenerator.generateValidIPAddresses(\"010010\") == [\"0.10.0.10\", \"0.100.1.0\"]", "entry_point": "generateValidIPAddresses", "signature": "static List<String> generateValidIPAddresses(String s)", "docstring": "Generate all possible valid IP addresses by inserting '.' in the given string.\n        Each part of the IP address must be a number between 0 and 255 and cannot have leading zeros.\n        >>> generateValidIPAddresses(\"25525511135\")\n        [\"255.255.11.135\", \"255.255.111.35\"]\n        >>> generateValidIPAddresses(\"0000\")\n        [\"0.0.0.0\"]\n        >>> generateValidIPAddresses(\"101023\")\n        [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]", "instruction": "Write a Groovy function `static List<String> generateValidIPAddresses(String s)` to solve the following problem:\nGenerate all possible valid IP addresses by inserting '.' in the given string.\n        Each part of the IP address must be a number between 0 and 255 and cannot have leading zeros.\n        >>> generateValidIPAddresses(\"25525511135\")\n        [\"255.255.11.135\", \"255.255.111.35\"]\n        >>> generateValidIPAddresses(\"0000\")\n        [\"0.0.0.0\"]\n        >>> generateValidIPAddresses(\"101023\")\n        [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]", "level": "hard"}
{"task_id": "Groovy/25", "prompt": "class SquareRootCalculator {\n    static int calculateSquareRoot(int x) {\n        \"\"\"\n        Calculate the integer part of the square root of a given non-negative integer.\n        >>> calculateSquareRoot(4)\n        2\n        >>> calculateSquareRoot(8)\n        2\n        \"\"\"", "canonical_solution": "int left = 0, right = x, ans = -1\n        while (left <= right) {\n            int mid = left + (right - left) / 2\n            if ((long)mid * mid <= x) {\n                ans = mid\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        return ans\n    }\n}", "test": "// Test cases\ndef squareRootCalculator = new SquareRootCalculator()\nassert squareRootCalculator.calculateSquareRoot(16) == 4\nassert squareRootCalculator.calculateSquareRoot(36) == 6\nassert squareRootCalculator.calculateSquareRoot(50) == 7\nassert squareRootCalculator.calculateSquareRoot(110) == 10\nassert squareRootCalculator.calculateSquareRoot(0) == 0", "entry_point": "calculateSquareRoot", "signature": "static int calculateSquareRoot(int x)", "docstring": "Calculate the integer part of the square root of a given non-negative integer.\n        >>> calculateSquareRoot(4)\n        2\n        >>> calculateSquareRoot(8)\n        2", "instruction": "Write a Groovy function `static int calculateSquareRoot(int x)` to solve the following problem:\nCalculate the integer part of the square root of a given non-negative integer.\n        >>> calculateSquareRoot(4)\n        2\n        >>> calculateSquareRoot(8)\n        2", "level": "easy"}
{"task_id": "Groovy/26", "prompt": "class StairClimber {\n    static int climbStairs(int n) {\n        \"\"\"\n        Given an integer n, representing the number of stairs to reach the top.\n        Each time you can either climb 1 or 2 stairs.\n        Return the number of distinct ways you can climb to the top.\n        >>> climbStairs(2)\n        2\n        >>> climbStairs(3)\n        3\n        \"\"\"", "canonical_solution": "if (n == 1) {\n            return 1\n        }\n        int[] dp = new int[n + 1]\n        dp[1] = 1\n        dp[2] = 2\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2]\n        }\n        return dp[n]\n    }\n}", "test": "// Test cases\ndef stairClimber = new StairClimber()\nassert stairClimber.climbStairs(1) == 1\nassert stairClimber.climbStairs(2) == 2\nassert stairClimber.climbStairs(3) == 3\nassert stairClimber.climbStairs(4) == 5\nassert stairClimber.climbStairs(5) == 8\nassert stairClimber.climbStairs(6) == 13\nassert stairClimber.climbStairs(7) == 21\nassert stairClimber.climbStairs(8) == 34", "entry_point": "climbStairs", "signature": "class StairClimber {\n    static int climbStairs(int n) {", "docstring": "Given an integer n, representing the number of stairs to reach the top.\n        Each time you can either climb 1 or 2 stairs.\n        Return the number of distinct ways you can climb to the top.\n        >>> climbStairs(2)\n        2\n        >>> climbStairs(3)\n        3", "instruction": "Write a Groovy function `class StairClimber {\n    static int climbStairs(int n) {` to solve the following problem:\nGiven an integer n, representing the number of stairs to reach the top.\n        Each time you can either climb 1 or 2 stairs.\n        Return the number of distinct ways you can climb to the top.\n        >>> climbStairs(2)\n        2\n        >>> climbStairs(3)\n        3", "level": "easy"}
{"task_id": "Groovy/27", "prompt": "class VersionComparator {\n    static int compareVersions(String version1, String version2) {\n        \"\"\"\n        Compare two version numbers version1 and version2.\n        Each version number consists of multiple revisions separated by dots.\n        Each revision is a sequence of digits.\n        Revisions are compared from left to right.\n        Leading zeros in each revision are ignored.\n        If a version number does not specify a revision at a particular index, it is treated as 0.\n        If version1 > version2, return 1.\n        If version1 < version2, return -1.\n        Otherwise, return 0.\n        >>> compareVersions(\"1.01\", \"1.001\")\n        0\n        >>> compareVersions(\"1.0\", \"1.0.0\")\n        0\n        >>> compareVersions(\"0.1\", \"1.1\")\n        -1\n        \"\"\"", "canonical_solution": "def revisions1 = version1.split('\\\\.')\n        def revisions2 = version2.split('\\\\.')\n\n        int maxLength = Math.max(revisions1.length, revisions2.length)\n\n        for (int i = 0; i < maxLength; i++) {\n            int revision1 = i < revisions1.length ? Integer.parseInt(revisions1[i]) : 0\n            int revision2 = i < revisions2.length ? Integer.parseInt(revisions2[i]) : 0\n\n            if (revision1 > revision2) {\n                return 1\n            } else if (revision1 < revision2) {\n                return -1\n            }\n        }\n\n        return 0\n    }\n}", "test": "// Test cases\ndef versionComparator = new VersionComparator()\nassert versionComparator.compareVersions(\"1.01\", \"1.001\") == 0\nassert versionComparator.compareVersions(\"1.0\", \"1.0.0\") == 0\nassert versionComparator.compareVersions(\"0.1\", \"1.1\") == -1\nassert versionComparator.compareVersions(\"1.1\", \"0.1\") == 1\nassert versionComparator.compareVersions(\"1.0.1\", \"1\") == 1\nassert versionComparator.compareVersions(\"1\", \"1.0.1\") == -1\nassert versionComparator.compareVersions(\"1.0.0\", \"1.0\") == 0\nassert versionComparator.compareVersions(\"1.0.0.0\", \"1.0\") == 0\nassert versionComparator.compareVersions(\"1.0.0.1\", \"1.0\") == 1", "entry_point": "compareVersions", "signature": "static int compareVersions(String version1, String version2)", "docstring": "Compare two version numbers version1 and version2.\n        Each version number consists of multiple revisions separated by dots.\n        Each revision is a sequence of digits.\n        Revisions are compared from left to right.\n        Leading zeros in each revision are ignored.\n        If a version number does not specify a revision at a particular index, it is treated as 0.\n        If version1 > version2, return 1.\n        If version1 < version2, return -1.\n        Otherwise, return 0.\n        >>> compareVersions(\"1.01\", \"1.001\")\n        0\n        >>> compareVersions(\"1.0\", \"1.0.0\")\n        0\n        >>> compareVersions(\"0.1\", \"1.1\")\n        -1", "instruction": "Write a Groovy function `static int compareVersions(String version1, String version2)` to solve the following problem:\nCompare two version numbers version1 and version2.\n        Each version number consists of multiple revisions separated by dots.\n        Each revision is a sequence of digits.\n        Revisions are compared from left to right.\n        Leading zeros in each revision are ignored.\n        If a version number does not specify a revision at a particular index, it is treated as 0.\n        If version1 > version2, return 1.\n        If version1 < version2, return -1.\n        Otherwise, return 0.\n        >>> compareVersions(\"1.01\", \"1.001\")\n        0\n        >>> compareVersions(\"1.0\", \"1.0.0\")\n        0\n        >>> compareVersions(\"0.1\", \"1.1\")\n        -1", "level": "middle"}
{"task_id": "Groovy/28", "prompt": "class CoinChange {\n    static int minCoins(ArrayList coins, int amount) {\n        \"\"\"\n        Given an array of coin denominations and a total amount of money,\n        return the fewest number of coins that you need to make up that amount.\n        If that amount of money cannot be made up by any combination of the coins, return -1.\n        You may assume that you have an infinite number of each kind of coin.\n        >>> minCoins([1, 2, 5], 11)\n        3\n        >>> minCoins([2], 3)\n        -1\n        >>> minCoins([1], 0)\n        0\n        \"\"\"", "canonical_solution": "int[] dp = new int[amount + 1]\n        Arrays.fill(dp, amount + 1)\n        dp[0] = 0\n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (coin <= i) {\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1)\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount]\n    }\n}", "test": "// Test cases\ndef coinChange = new CoinChange()\nassert coinChange.minCoins([1, 2, 5], 11) == 3\nassert coinChange.minCoins([2], 3) == -1\nassert coinChange.minCoins([1], 0) == 0\nassert coinChange.minCoins([1, 2, 5], 10) == 2\nassert coinChange.minCoins([2, 5, 10, 1], 27) == 4\nassert coinChange.minCoins([5, 10, 25], 63) == -1\nassert coinChange.minCoins([1, 5, 10, 25], 100) == 4", "entry_point": "minCoins", "signature": "static int minCoins(ArrayList coins, int amount)", "docstring": "Given an array of coin denominations and a total amount of money,\n        return the fewest number of coins that you need to make up that amount.\n        If that amount of money cannot be made up by any combination of the coins, return -1.\n        You may assume that you have an infinite number of each kind of coin.\n        >>> minCoins([1, 2, 5], 11)\n        3\n        >>> minCoins([2], 3)\n        -1\n        >>> minCoins([1], 0)\n        0", "instruction": "Write a Groovy function `static int minCoins(ArrayList coins, int amount)` to solve the following problem:\nGiven an array of coin denominations and a total amount of money,\n        return the fewest number of coins that you need to make up that amount.\n        If that amount of money cannot be made up by any combination of the coins, return -1.\n        You may assume that you have an infinite number of each kind of coin.\n        >>> minCoins([1, 2, 5], 11)\n        3\n        >>> minCoins([2], 3)\n        -1\n        >>> minCoins([1], 0)\n        0", "level": "easy"}
{"task_id": "Groovy/29", "prompt": "class ReverseWords {\n    static String reverseWords(String s) {\n        \"\"\"\n        Reverse the order of words in a given string.\n        A word is defined as a sequence of non-space characters.\n        The input string may contain leading or trailing spaces,\n        and there may be multiple spaces between words.\n        The output string should have the words in reverse order,\n        separated by a single space, and no leading or trailing spaces.\n        >>> reverseWords(\"the sky is blue\")\n        \"blue is sky the\"\n        >>> reverseWords(\"  hello world  \")\n        \"world hello\"\n        >>> reverseWords(\"a good   example\")\n        \"example good a\"\n        \"\"\"", "canonical_solution": "// Split the string into words\n        String[] words = s.trim().split(\"\\\\s+\");\n        // Reverse the order of the words\n        Collections.reverse(Arrays.asList(words));\n        // Join the words with a single space\n        return String.join(\" \", words);\n    }\n}", "test": "// Test cases\ndef reverseWords = new ReverseWords()\nassert reverseWords.reverseWords(\"the sky is blue\") == \"blue is sky the\"\nassert reverseWords.reverseWords(\"  hello world  \") == \"world hello\"\nassert reverseWords.reverseWords(\"a good   example\") == \"example good a\"\nassert reverseWords.reverseWords(\"  a  b  c  \") == \"c b a\"\nassert reverseWords.reverseWords(\"\") == \"\"\nassert reverseWords.reverseWords(\"single\") == \"single\"\nassert reverseWords.reverseWords(\"  leading space\") == \"space leading\"\nassert reverseWords.reverseWords(\"trailing space  \") == \"space trailing\"", "entry_point": "reverseWords", "signature": "static String reverseWords(String s)", "docstring": "Reverse the order of words in a given string.\n        A word is defined as a sequence of non-space characters.\n        The input string may contain leading or trailing spaces,\n        and there may be multiple spaces between words.\n        The output string should have the words in reverse order,\n        separated by a single space, and no leading or trailing spaces.\n        >>> reverseWords(\"the sky is blue\")\n        \"blue is sky the\"\n        >>> reverseWords(\"  hello world  \")\n        \"world hello\"\n        >>> reverseWords(\"a good   example\")\n        \"example good a\"", "instruction": "Write a Groovy function `static String reverseWords(String s)` to solve the following problem:\nReverse the order of words in a given string.\n        A word is defined as a sequence of non-space characters.\n        The input string may contain leading or trailing spaces,\n        and there may be multiple spaces between words.\n        The output string should have the words in reverse order,\n        separated by a single space, and no leading or trailing spaces.\n        >>> reverseWords(\"the sky is blue\")\n        \"blue is sky the\"\n        >>> reverseWords(\"  hello world  \")\n        \"world hello\"\n        >>> reverseWords(\"a good   example\")\n        \"example good a\"", "level": "easy"}
{"task_id": "Groovy/30", "prompt": "class SingleNumberFinder {\n    static int findSingleNumber(List nums) {\n        \"\"\"\n        Find the single number in the given list of numbers. All numbers appear twice except one.\n        >>> findSingleNumber([2, 2, 1])\n        1\n        >>> findSingleNumber([4, 1, 2, 1, 2])\n        4\n        >>> findSingleNumber([1])\n        1\n        \"\"\"", "canonical_solution": "int result = 0\n        for (int num : nums) {\n            result ^= num\n        }\n        return result\n    }\n}", "test": "// Test cases\ndef singleNumberFinder = new SingleNumberFinder()\nassert singleNumberFinder.findSingleNumber([2, 2, 1, 3, 3]) == 1\nassert singleNumberFinder.findSingleNumber([4, 1, 2, 1, 2, 3, 3]) == 4\nassert singleNumberFinder.findSingleNumber([1, 2, 2]) == 1\nassert singleNumberFinder.findSingleNumber([1, 1, 2, 2, 3]) == 3\nassert singleNumberFinder.findSingleNumber([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5\nassert singleNumberFinder.findSingleNumber([1, 1, 2, 2, 3, 3, 4]) == 4\nassert singleNumberFinder.findSingleNumber([1]) == 1", "entry_point": "findSingleNumber", "signature": "static int findSingleNumber(List nums)", "docstring": "Find the single number in the given list of numbers. All numbers appear twice except one.\n        >>> findSingleNumber([2, 2, 1])\n        1\n        >>> findSingleNumber([4, 1, 2, 1, 2])\n        4\n        >>> findSingleNumber([1])\n        1", "instruction": "Write a Groovy function `static int findSingleNumber(List nums)` to solve the following problem:\nFind the single number in the given list of numbers. All numbers appear twice except one.\n        >>> findSingleNumber([2, 2, 1])\n        1\n        >>> findSingleNumber([4, 1, 2, 1, 2])\n        4\n        >>> findSingleNumber([1])\n        1", "level": "easy"}
{"task_id": "Groovy/31", "prompt": "class MatrixDiagonalTraversal {\n    static List traverseDiagonally(ArrayList matrix) {\n        \"\"\"\n        Traverse a given matrix in a diagonal order and return the elements in a list.\n        >>> traverseDiagonally([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [1, 2, 4, 7, 5, 3, 6, 8, 9]\n        >>> traverseDiagonally([[1, 2], [3, 4]])\n        [1, 2, 3, 4]\n        \"\"\"", "canonical_solution": "List<Integer> result = new ArrayList<>()\n        if (matrix == null || matrix.size == 0) {\n            return result\n        }\n\n        int m = matrix.size\n        int n = matrix[0].size\n        int row = 0\n        int col = 0\n\n        for (int i = 0; i < m * n; i++) {\n            result.add(matrix[row][col])\n            if ((row + col) % 2 == 0) { // moving up\n                if (col == n - 1) {\n                    row++\n                } else if (row == 0) {\n                    col++\n                } else {\n                    row--\n                    col++\n                }\n            } else { // moving down\n                if (row == m - 1) {\n                    col++\n                } else if (col == 0) {\n                    row++\n                } else {\n                    row++\n                    col--\n                }\n            }\n        }\n        return result\n    }\n}", "test": "// Test cases\ndef matrixDiagonalTraversal = new MatrixDiagonalTraversal()\nassert matrixDiagonalTraversal.traverseDiagonally([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 4, 7, 5, 3, 6, 8, 9]\nassert matrixDiagonalTraversal.traverseDiagonally([[1, 2], [3, 4]]) == [1, 2, 3, 4]\nassert matrixDiagonalTraversal.traverseDiagonally([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12]\nassert matrixDiagonalTraversal.traverseDiagonally([[1, 2, 3, 4, 5]]) == [1, 2, 3, 4, 5]\nassert matrixDiagonalTraversal.traverseDiagonally([[1], [2], [3], [4], [5]]) == [1, 2, 3, 4, 5]", "entry_point": "traverseDiagonally", "signature": "static List traverseDiagonally(ArrayList matrix)", "docstring": "Traverse a given matrix in a diagonal order and return the elements in a list.\n        >>> traverseDiagonally([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [1, 2, 4, 7, 5, 3, 6, 8, 9]\n        >>> traverseDiagonally([[1, 2], [3, 4]])\n        [1, 2, 3, 4]", "instruction": "Write a Groovy function `static List traverseDiagonally(ArrayList matrix)` to solve the following problem:\nTraverse a given matrix in a diagonal order and return the elements in a list.\n        >>> traverseDiagonally([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [1, 2, 4, 7, 5, 3, 6, 8, 9]\n        >>> traverseDiagonally([[1, 2], [3, 4]])\n        [1, 2, 3, 4]", "level": "hard"}
{"task_id": "Groovy/32", "prompt": "class ContainerWithMostWater {\n    static int maxArea(ArrayList height) {\n        \"\"\"\n        Given an integer array 'height' of length n, where the i-th element represents the height of the line at position i.\n        Find two lines, which together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Note: You may not slant the container.\n        >>> maxArea([1,8,6,2,5,4,8,3,7])\n        49\n        >>> maxArea([1,1])\n        1\n        \"\"\"", "canonical_solution": "int maxArea = 0;\n        int left = 0;\n        int right = height.size - 1;\n\n        while (left < right) {\n            int width = right - left;\n            maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * width);\n            if (height[left] <= height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxArea;\n    }\n}", "test": "// Test cases\ndef containerWithMostWater = new ContainerWithMostWater()\nassert containerWithMostWater.maxArea([1,8,6,2,5,4,8,3,7]) == 49\nassert containerWithMostWater.maxArea([1,1]) == 1\nassert containerWithMostWater.maxArea([4,3,2,1,4]) == 16\nassert containerWithMostWater.maxArea([1,2,1]) == 2\nassert containerWithMostWater.maxArea([1,2,4,3]) == 4\nassert containerWithMostWater.maxArea([1,3,2,5,25,24,5]) == 24\nassert containerWithMostWater.maxArea([1,8,100,2,100,4,8,3,7]) == 200", "entry_point": "maxArea", "signature": "static int maxArea(ArrayList height)", "docstring": "Given an integer array 'height' of length n, where the i-th element represents the height of the line at position i.\n        Find two lines, which together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Note: You may not slant the container.\n        >>> maxArea([1,8,6,2,5,4,8,3,7])\n        49\n        >>> maxArea([1,1])\n        1", "instruction": "Write a Groovy function `static int maxArea(ArrayList height)` to solve the following problem:\nGiven an integer array 'height' of length n, where the i-th element represents the height of the line at position i.\n        Find two lines, which together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Note: You may not slant the container.\n        >>> maxArea([1,8,6,2,5,4,8,3,7])\n        49\n        >>> maxArea([1,1])\n        1", "level": "easy"}
{"task_id": "Groovy/33", "prompt": "class StockTrader {\n    static int maxProfit(List<Integer> prices) {\n        \"\"\"\n        Given a list of stock prices for each day, find out the maximum profit that can be achieved with at most two transactions.\n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        >>> maxProfit([3,3,5,0,0,3,1,4])\n        6\n        >>> maxProfit([1,2,3,4,5])\n        4\n        >>> maxProfit([7,6,4,3,1])\n        0\n        >>> maxProfit([1])\n        0\n        \"\"\"", "canonical_solution": "if (prices.size() < 2) return 0\n        int[] left = new int[prices.size()]\n        int[] right = new int[prices.size()]\n\n        // DP from left to right\n        int minPrice = prices[0]\n        for (int i = 1; i < prices.size(); i++) {\n            minPrice = Math.min(minPrice, prices[i])\n            left[i] = Math.max(left[i - 1], prices[i] - minPrice)\n        }\n\n        // DP from right to left\n        int maxPrice = prices[prices.size() - 1]\n        for (int i = prices.size() - 2; i >= 0; i--) {\n            maxPrice = Math.max(maxPrice, prices[i])\n            right[i] = Math.max(right[i + 1], maxPrice - prices[i])\n        }\n\n        int maxProfit = 0\n        for (int i = 0; i < prices.size(); i++) {\n            maxProfit = Math.max(maxProfit, left[i] + right[i])\n        }\n\n        return maxProfit\n    }\n}", "test": "// Test cases\ndef stockTrader = new StockTrader()\nassert stockTrader.maxProfit([3,3,5,0,0,3,1,4]) == 6\nassert stockTrader.maxProfit([1,2,3,4,5]) == 4\nassert stockTrader.maxProfit([7,6,4,3,1]) == 0\nassert stockTrader.maxProfit([1]) == 0\nassert stockTrader.maxProfit([2,1,2,0,1]) == 2\nassert stockTrader.maxProfit([3,2,6,5,0,3]) == 7\nassert stockTrader.maxProfit([1,2,4,2,5,7,2,4,9,0]) == 13", "entry_point": "maxProfit", "signature": "static int maxProfit(List<Integer> prices)", "docstring": "Given a list of stock prices for each day, find out the maximum profit that can be achieved with at most two transactions.\n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        >>> maxProfit([3,3,5,0,0,3,1,4])\n        6\n        >>> maxProfit([1,2,3,4,5])\n        4\n        >>> maxProfit([7,6,4,3,1])\n        0\n        >>> maxProfit([1])\n        0", "instruction": "Write a Groovy function `static int maxProfit(List<Integer> prices)` to solve the following problem:\nGiven a list of stock prices for each day, find out the maximum profit that can be achieved with at most two transactions.\n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        >>> maxProfit([3,3,5,0,0,3,1,4])\n        6\n        >>> maxProfit([1,2,3,4,5])\n        4\n        >>> maxProfit([7,6,4,3,1])\n        0\n        >>> maxProfit([1])\n        0", "level": "middle"}
{"task_id": "Groovy/34", "prompt": "class JumpGameChecker {\n    static boolean canJumpToEnd(List nums) {\n        \"\"\"\n        Given a non-negative integer array 'nums', where each element represents the maximum\n        length of a jump at that position. Determine if you are able to reach the last index.\n        You can assume that you can always reach the first index.\n        >>> canJumpToEnd([2,3,1,1,4])\n        True\n        >>> canJumpToEnd([3,2,1,0,4])\n        False\n        \"\"\"", "canonical_solution": "int maxReach = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (i > maxReach) return false;\n            maxReach = Math.max(maxReach, i + nums[i]);\n        }\n        return true;\n    }\n}", "test": "// Test cases\ndef jumpGameChecker = new JumpGameChecker()\nassert jumpGameChecker.canJumpToEnd([2,3,1,1,4]) == true\nassert jumpGameChecker.canJumpToEnd([3,2,1,0,4]) == false\nassert jumpGameChecker.canJumpToEnd([1,1,1,1,1]) == true\nassert jumpGameChecker.canJumpToEnd([0,0,0,0,0]) == false\nassert jumpGameChecker.canJumpToEnd([1,2,3,4,5]) == true\nassert jumpGameChecker.canJumpToEnd([5,4,3,2,1]) == true\nassert jumpGameChecker.canJumpToEnd([1,0,1,0,1]) == false", "entry_point": "canJumpToEnd", "signature": "static boolean canJumpToEnd(List nums)", "docstring": "Given a non-negative integer array 'nums', where each element represents the maximum\n        length of a jump at that position. Determine if you are able to reach the last index.\n        You can assume that you can always reach the first index.\n        >>> canJumpToEnd([2,3,1,1,4])\n        True\n        >>> canJumpToEnd([3,2,1,0,4])\n        False", "instruction": "Write a Groovy function `static boolean canJumpToEnd(List nums)` to solve the following problem:\nGiven a non-negative integer array 'nums', where each element represents the maximum\n        length of a jump at that position. Determine if you are able to reach the last index.\n        You can assume that you can always reach the first index.\n        >>> canJumpToEnd([2,3,1,1,4])\n        True\n        >>> canJumpToEnd([3,2,1,0,4])\n        False", "level": "easy"}
{"task_id": "Groovy/35", "prompt": "class StockTradeChecker {\n    static int countInversionPairs(List<Integer> record) {\n        \"\"\"\n        Count the total number of inversion pairs in a given record of stock prices.\n        An inversion pair is defined as a pair of prices where the earlier price is higher than the later one.\n        >>> countInversionPairs([9, 7, 5, 4, 6])\n        8\n        >>> countInversionPairs([1, 2, 3, 4, 5])\n        0\n        \"\"\"", "canonical_solution": "int count = 0;\n        for (int i = 0; i < record.size(); i++) {\n            for (int j = i + 1; j < record.size(); j++) {\n                if (record[i] > record[j]) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}", "test": "// Test cases\ndef stockTradeChecker = new StockTradeChecker()\nassert stockTradeChecker.countInversionPairs([9, 7, 5, 4, 6]) == 8\nassert stockTradeChecker.countInversionPairs([1, 2, 3, 4, 5]) == 0\nassert stockTradeChecker.countInversionPairs([5, 4, 3, 2, 1]) == 10\nassert stockTradeChecker.countInversionPairs([1, 3, 5, 7, 9]) == 0\nassert stockTradeChecker.countInversionPairs([10, 8, 6, 4, 2]) == 10\nassert stockTradeChecker.countInversionPairs([1, 1, 1, 1, 1]) == 0\nassert stockTradeChecker.countInversionPairs([5, 5, 5, 5, 5]) == 0", "entry_point": "countInversionPairs", "signature": "static int countInversionPairs(List<Integer> record)", "docstring": "Count the total number of inversion pairs in a given record of stock prices.\n        An inversion pair is defined as a pair of prices where the earlier price is higher than the later one.\n        >>> countInversionPairs([9, 7, 5, 4, 6])\n        8\n        >>> countInversionPairs([1, 2, 3, 4, 5])\n        0", "instruction": "Write a Groovy function `static int countInversionPairs(List<Integer> record)` to solve the following problem:\nCount the total number of inversion pairs in a given record of stock prices.\n        An inversion pair is defined as a pair of prices where the earlier price is higher than the later one.\n        >>> countInversionPairs([9, 7, 5, 4, 6])\n        8\n        >>> countInversionPairs([1, 2, 3, 4, 5])\n        0", "level": "easy"}
{"task_id": "Groovy/36", "prompt": "class CombinationSum {\n    static List<List<Integer>> findCombinations(List<Integer> candidates, int target) {\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), \n        find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output:\n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        \"\"\"", "canonical_solution": "candidates.sort()\n        List<List<Integer>> result = new ArrayList<>()\n        backtrack(result, new ArrayList<>(), candidates, target, 0)\n        return result\n    }\n\n    static void backtrack(List<List<Integer>> result, List<Integer> tempList, List<Integer> candidates, int remain, int start) {\n        if (remain < 0) return\n        else if (remain == 0) result.add(new ArrayList<>(tempList))\n        else {\n            for (int i = start; i < candidates.size(); i++) {\n                if (i > start && candidates.get(i) == candidates.get(i-1)) continue\n                tempList.add(candidates.get(i))\n                backtrack(result, tempList, candidates, remain - candidates.get(i), i + 1)\n                tempList.remove(tempList.size() - 1)\n            }\n        }\n    }\n}", "test": "// Test cases\ndef combinationSum = new CombinationSum()\nassert combinationSum.findCombinations([10,1,2,7,6,1,5], 8) == [[1,1,6],[1,2,5],[1,7],[2,6]]\nassert combinationSum.findCombinations([2,5,2,1,2], 5) == [[1,2,2],[5]]\nassert combinationSum.findCombinations([1,2,3,4,5], 10) == [[1,2,3,4],[1,4,5],[2,3,5]]\nassert combinationSum.findCombinations([2,3,5], 8) == [[3,5]]\nassert combinationSum.findCombinations([2,3,6,7], 7) == [[7]]", "entry_point": "findCombinations", "signature": "static List<List<Integer>> findCombinations(List<Integer> candidates, int target)", "docstring": "Given a collection of candidate numbers (candidates) and a target number (target), \n        find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output:\n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]", "instruction": "Write a Groovy function `static List<List<Integer>> findCombinations(List<Integer> candidates, int target)` to solve the following problem:\nGiven a collection of candidate numbers (candidates) and a target number (target), \n        find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output:\n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]", "level": "middle"}
{"task_id": "Groovy/37", "prompt": "class SpiralMatrixGenerator {\n    static List<List<Integer>> generateMatrix(int n) {\n        \"\"\"\n        Generate a n x n spiral matrix.\n        >>> generateMatrix(3)\n        [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n        >>> generateMatrix(1)\n        [[1]]\n        \"\"\"", "canonical_solution": "List<List<Integer>> matrix = new ArrayList<>()\n        for (int i = 0; i < n; i++) {\n            List<Integer> row = new ArrayList<>()\n            for (int j = 0; j < n; j++) {\n                row.add(0)\n            }\n            matrix.add(row)\n        }\n\n        int num = 1\n        int left = 0\n        int right = n - 1\n        int top = 0\n        int bottom = n - 1\n\n        while (num <= n * n) {\n            for (int i = left; i <= right; i++) {\n                matrix[top][i] = num++\n            }\n            top++\n\n            for (int i = top; i <= bottom; i++) {\n                matrix[i][right] = num++\n            }\n            right--\n\n            for (int i = right; i >= left; i--) {\n                matrix[bottom][i] = num++\n            }\n            bottom--\n\n            for (int i = bottom; i >= top; i--) {\n                matrix[i][left] = num++\n            }\n            left++\n        }\n\n        return matrix\n    }\n}", "test": "// Test cases\ndef spiralMatrixGenerator = new SpiralMatrixGenerator()\nassert spiralMatrixGenerator.generateMatrix(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\nassert spiralMatrixGenerator.generateMatrix(1) == [[1]]\nassert spiralMatrixGenerator.generateMatrix(2) == [[1, 2], [4, 3]]\nassert spiralMatrixGenerator.generateMatrix(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]", "entry_point": "generateMatrix", "signature": "static List<List<Integer>> generateMatrix(int n)", "docstring": "Generate a n x n spiral matrix.\n        >>> generateMatrix(3)\n        [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n        >>> generateMatrix(1)\n        [[1]]", "instruction": "Write a Groovy function `static List<List<Integer>> generateMatrix(int n)` to solve the following problem:\nGenerate a n x n spiral matrix.\n        >>> generateMatrix(3)\n        [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n        >>> generateMatrix(1)\n        [[1]]", "level": "middle"}
{"task_id": "Groovy/38", "prompt": "class StockManager {\n    static List<Integer> getLeastStockItems(List<Integer> stock, int cnt) {\n        \"\"\"\n        Given a list of stock quantities and a count, return the least stock quantities.\n        If there are multiple items with the same least stock, return them all.\n        >>> getLeastStockItems([2, 5, 7, 4], 1)\n        [2]\n        >>> getLeastStockItems([0, 2, 3, 6], 2)\n        [0, 2] or [2, 0]\n        \"\"\"", "canonical_solution": "// Sort the stock list\n        stock.sort()\n\n        // Get the least stock items\n        List<Integer> leastStockItems = stock.take(cnt)\n\n        return leastStockItems\n    }\n}", "test": "// Test cases\ndef stockManager = new StockManager()\nassert stockManager.getLeastStockItems([2, 5, 7, 4], 1) == [2]\nassert stockManager.getLeastStockItems([0, 2, 3, 6], 2) == [0, 2] || stockManager.getLeastStockItems([0, 2, 3, 6], 2) == [2, 0]\nassert stockManager.getLeastStockItems([10, 20, 30, 40], 3) == [10, 20, 30]\nassert stockManager.getLeastStockItems([50, 40, 30, 20, 10], 4) == [10, 20, 30, 40]\nassert stockManager.getLeastStockItems([1, 1, 1, 1], 2) == [1, 1]\nassert stockManager.getLeastStockItems([100, 200, 300, 400], 1) == [100]\nassert stockManager.getLeastStockItems([5, 5, 5, 5], 3) == [5, 5, 5]", "entry_point": "getLeastStockItems", "signature": "static List<Integer> getLeastStockItems(List<Integer> stock, int cnt)", "docstring": "Given a list of stock quantities and a count, return the least stock quantities.\n        If there are multiple items with the same least stock, return them all.\n        >>> getLeastStockItems([2, 5, 7, 4], 1)\n        [2]\n        >>> getLeastStockItems([0, 2, 3, 6], 2)\n        [0, 2] or [2, 0]", "instruction": "Write a Groovy function `static List<Integer> getLeastStockItems(List<Integer> stock, int cnt)` to solve the following problem:\nGiven a list of stock quantities and a count, return the least stock quantities.\n        If there are multiple items with the same least stock, return them all.\n        >>> getLeastStockItems([2, 5, 7, 4], 1)\n        [2]\n        >>> getLeastStockItems([0, 2, 3, 6], 2)\n        [0, 2] or [2, 0]", "level": "easy"}
{"task_id": "Groovy/39", "prompt": "class JumpWaysCalculator {\n    static int calculateJumpWays(int num) {\n        \"\"\"\n        Calculate the number of different ways a student can jump across a platform with 'num' cells.\n        The student can jump one cell or two cells at a time.\n        The result is returned modulo 1e9+7 to prevent it from being too large.\n        >>> calculateJumpWays(2)\n        2\n        >>> calculateJumpWays(5)\n        8\n        \"\"\"", "canonical_solution": "int[] dp = new int[num + 1]\n        dp[0] = 1\n        dp[1] = 1\n        for (int i = 2; i <= num; i++) {\n            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\n        }\n        return dp[num]\n    }\n}", "test": "// Test cases\ndef jumpWaysCalculator = new JumpWaysCalculator()\nassert jumpWaysCalculator.calculateJumpWays(2) == 2\nassert jumpWaysCalculator.calculateJumpWays(5) == 8\nassert jumpWaysCalculator.calculateJumpWays(10) == 89\nassert jumpWaysCalculator.calculateJumpWays(20) == 10946\nassert jumpWaysCalculator.calculateJumpWays(50) == 365010934\nassert jumpWaysCalculator.calculateJumpWays(100) == 782204094", "entry_point": "calculateJumpWays", "signature": "static int calculateJumpWays(int num)", "docstring": "Calculate the number of different ways a student can jump across a platform with 'num' cells.\n        The student can jump one cell or two cells at a time.\n        The result is returned modulo 1e9+7 to prevent it from being too large.\n        >>> calculateJumpWays(2)\n        2\n        >>> calculateJumpWays(5)\n        8", "instruction": "Write a Groovy function `static int calculateJumpWays(int num)` to solve the following problem:\nCalculate the number of different ways a student can jump across a platform with 'num' cells.\n        The student can jump one cell or two cells at a time.\n        The result is returned modulo 1e9+7 to prevent it from being too large.\n        >>> calculateJumpWays(2)\n        2\n        >>> calculateJumpWays(5)\n        8", "level": "easy"}
{"task_id": "Groovy/40", "prompt": "class MaximumSalesSum {\n    static int maxSalesSum(ArrayList sales) {\n        \"\"\"\n        Find the maximum sum of a continuous subarray in the given sales array.\n        >>> maxSalesSum([-2,1,-3,4,-1,2,1,-5,4])\n        6\n        >>> maxSalesSum([5,4,-1,7,8])\n        23\n        \"\"\"", "canonical_solution": "int maxSum = Integer.MIN_VALUE;\n        int currentSum = 0;\n\n        for (int sale : sales) {\n            currentSum = Math.max(sale, currentSum + sale);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n\n        return maxSum;\n    }\n}", "test": "// Test cases\ndef maxSalesSum = new MaximumSalesSum()\nassert maxSalesSum.maxSalesSum([1, -3, 2, 1, -1]) == 3\nassert maxSalesSum.maxSalesSum([-2, -1, -3, -4, -1]) == -1\nassert maxSalesSum.maxSalesSum([5, -4, 1, -7, 8]) == 8\nassert maxSalesSum.maxSalesSum([-5, -4, -1, -7, -8]) == -1\nassert maxSalesSum.maxSalesSum([1, 2, 3, 4, 5]) == 15\nassert maxSalesSum.maxSalesSum([-1, -2, -3, -4, -5]) == -1", "entry_point": "maxSalesSum", "signature": "static int maxSalesSum(ArrayList sales)", "docstring": "Find the maximum sum of a continuous subarray in the given sales array.\n        >>> maxSalesSum([-2,1,-3,4,-1,2,1,-5,4])\n        6\n        >>> maxSalesSum([5,4,-1,7,8])\n        23", "instruction": "Write a Groovy function `static int maxSalesSum(ArrayList sales)` to solve the following problem:\nFind the maximum sum of a continuous subarray in the given sales array.\n        >>> maxSalesSum([-2,1,-3,4,-1,2,1,-5,4])\n        6\n        >>> maxSalesSum([5,4,-1,7,8])\n        23", "level": "easy"}
{"task_id": "Groovy/41", "prompt": "class ColorSorter {\n    static void sortColors(int[] nums) {\n        \"\"\"\n        Sort an array of integers representing colors (0 - red, 1 - white, 2 - blue)\n        in place, so that the same colors are adjacent and sorted in the order\n        red, white, blue.\n        >>> sortColors([2, 0, 2, 1, 1, 0])\n        [0, 0, 1, 1, 2, 2]\n        >>> sortColors([2, 0, 1])\n        [0, 1, 2]\n        \"\"\"", "canonical_solution": "int red = 0, white = 0, blue = nums.length - 1\n        while (white <= blue) {\n            if (nums[white] == 0) {\n                int temp = nums[red]\n                nums[red] = nums[white]\n                nums[white] = temp\n                white++\n                red++\n            } else if (nums[white] == 1) {\n                white++\n            } else {\n                int temp = nums[white]\n                nums[white] = nums[blue]\n                nums[blue] = temp\n                blue--\n            }\n        }\n    }\n}", "test": "// Test cases\ndef colorSorter = new ColorSorter()\nint[] nums1 = [2, 0, 2, 1, 1, 0]\ncolorSorter.sortColors(nums1)\nassert nums1 == [0, 0, 1, 1, 2, 2]\n\nint[] nums2 = [2, 0, 1]\ncolorSorter.sortColors(nums2)\nassert nums2 == [0, 1, 2]\n\nint[] nums3 = [0, 1, 2, 0, 1, 2]\ncolorSorter.sortColors(nums3)\nassert nums3 == [0, 0, 1, 1, 2, 2]\n\nint[] nums4 = [1, 2, 0, 1, 2, 0]\ncolorSorter.sortColors(nums4)\nassert nums4 == [0, 0, 1, 1, 2, 2]\n\nint[] nums5 = [2, 2, 2, 1, 1, 1, 0, 0, 0]\ncolorSorter.sortColors(nums5)\nassert nums5 == [0, 0, 0, 1, 1, 1, 2, 2, 2]", "entry_point": "sortColors", "signature": "static void sortColors(int[] nums)", "docstring": "Sort an array of integers representing colors (0 - red, 1 - white, 2 - blue)\n        in place, so that the same colors are adjacent and sorted in the order\n        red, white, blue.\n        >>> sortColors([2, 0, 2, 1, 1, 0])\n        [0, 0, 1, 1, 2, 2]\n        >>> sortColors([2, 0, 1])\n        [0, 1, 2]", "instruction": "Write a Groovy function `static void sortColors(int[] nums)` to solve the following problem:\nSort an array of integers representing colors (0 - red, 1 - white, 2 - blue)\n        in place, so that the same colors are adjacent and sorted in the order\n        red, white, blue.\n        >>> sortColors([2, 0, 2, 1, 1, 0])\n        [0, 0, 1, 1, 2, 2]\n        >>> sortColors([2, 0, 1])\n        [0, 1, 2]", "level": "middle"}
{"task_id": "Groovy/42", "prompt": "class CandyDistributor {\n    static int minCandies(List ratings) {\n        \"\"\"\n        Distribute candies to children based on their ratings. Each child must have at least one candy.\n        Children with a higher rating than their neighbors get more candies.\n        Return the minimum number of candies needed.\n        >>> min_candies([1, 0, 2])\n        5\n        >>> min_candies([1, 2, 2])\n        4\n        \"\"\"", "canonical_solution": "int[] candies = new int[ratings.size()]\n        Arrays.fill(candies, 1)\n\n        for (int i = 1; i < ratings.size(); i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1\n            }\n        }\n\n        for (int i = ratings.size() - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1)\n            }\n        }\n\n        return candies.sum() as int\n    }\n}", "test": "// Test cases\ndef candyDistributor = new CandyDistributor()\nassert candyDistributor.minCandies([1, 0, 2]) == 5\nassert candyDistributor.minCandies([1, 2, 2]) == 4\nassert candyDistributor.minCandies([1, 2, 3, 4, 5]) == 15\nassert candyDistributor.minCandies([5, 4, 3, 2, 1]) == 15\nassert candyDistributor.minCandies([1, 2, 2, 3, 4, 5]) == 13\nassert candyDistributor.minCandies([5, 4, 3, 2, 1, 2]) == 17\nassert candyDistributor.minCandies([1, 2, 3, 2, 1]) == 9", "entry_point": "minCandies", "signature": "static int minCandies(List ratings)", "docstring": "Distribute candies to children based on their ratings. Each child must have at least one candy.\n        Children with a higher rating than their neighbors get more candies.\n        Return the minimum number of candies needed.\n        >>> min_candies([1, 0, 2])\n        5\n        >>> min_candies([1, 2, 2])\n        4", "instruction": "Write a Groovy function `static int minCandies(List ratings)` to solve the following problem:\nDistribute candies to children based on their ratings. Each child must have at least one candy.\n        Children with a higher rating than their neighbors get more candies.\n        Return the minimum number of candies needed.\n        >>> min_candies([1, 0, 2])\n        5\n        >>> min_candies([1, 2, 2])\n        4", "level": "easy"}
{"task_id": "Groovy/43", "prompt": "class LongestIncreasingPath {\n    static int longestIncreasingPath(ArrayList matrix) {\n        \"\"\"\n        Find the length of the longest increasing path in the given matrix.\n        You can move in four directions: up, down, left, right.\n        You are not allowed to move diagonally or outside the boundary.\n        >>> longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]])\n        4\n        >>> longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]])\n        4\n        >>> longestIncreasingPath([[1]])\n        1\n        \"\"\"", "canonical_solution": "int[][] dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n        int m = matrix.size\n        int n = matrix[0].size\n        int[][] cache = new int[m][n]\n        int max = 1\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int len = dfs(matrix, i, j, m, n, cache, dirs)\n                max = Math.max(max, len)\n            }\n        }\n        return max\n    }\n\n    static int dfs(ArrayList matrix, int i, int j, int m, int n, int[][] cache, int[][] dirs) {\n        if (cache[i][j] != 0) return cache[i][j]\n        int max = 1\n        for (int[] dir : dirs) {\n            int x = i + dir[0], y = j + dir[1]\n            if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) continue\n            int len = 1 + dfs(matrix, x, y, m, n, cache, dirs)\n            max = Math.max(max, len)\n        }\n        cache[i][j] = max\n        return max\n    }\n}", "test": "// Test cases\ndef longestIncreasingPath = new LongestIncreasingPath()\nassert longestIncreasingPath.longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]]) == 4\nassert longestIncreasingPath.longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]]) == 4\nassert longestIncreasingPath.longestIncreasingPath([[1]]) == 1\nassert longestIncreasingPath.longestIncreasingPath([[1,2,3],[8,9,4],[7,6,5]]) == 9\nassert longestIncreasingPath.longestIncreasingPath([[1,10,2],[9,3,3],[8,4,5]]) == 4\nassert longestIncreasingPath.longestIncreasingPath([[1,10,2],[9,3,3],[8,4,5],[7,6,6]]) == 6\nassert longestIncreasingPath.longestIncreasingPath([[1,10,2,11],[9,3,3,12],[8,4,5,13],[7,6,6,14]]) == 6", "entry_point": "longestIncreasingPath", "signature": "static int longestIncreasingPath(ArrayList matrix)", "docstring": "Find the length of the longest increasing path in the given matrix.\n        You can move in four directions: up, down, left, right.\n        You are not allowed to move diagonally or outside the boundary.\n        >>> longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]])\n        4\n        >>> longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]])\n        4\n        >>> longestIncreasingPath([[1]])\n        1", "instruction": "Write a Groovy function `static int longestIncreasingPath(ArrayList matrix)` to solve the following problem:\nFind the length of the longest increasing path in the given matrix.\n        You can move in four directions: up, down, left, right.\n        You are not allowed to move diagonally or outside the boundary.\n        >>> longestIncreasingPath([[9,9,4],[6,6,8],[2,1,1]])\n        4\n        >>> longestIncreasingPath([[3,4,5],[3,2,6],[2,2,1]])\n        4\n        >>> longestIncreasingPath([[1]])\n        1", "level": "hard"}
{"task_id": "Groovy/44", "prompt": "class PatternMatcher {\n    static boolean isMatch(String s, String p) {\n        \"\"\"\n        Check if the string s matches the pattern p. The pattern p can contain '.' and '*'.\n        '.' matches any single character.\n        '*' matches zero or more of the preceding element.\n        The matching should cover the entire string s.\n        >>> isMatch(\"aa\", \"a\")\n        false\n        >>> isMatch(\"aa\", \"a*\")\n        true\n        >>> isMatch(\"ab\", \".*\")\n        true\n        \"\"\"", "canonical_solution": "int sLen = s.length(), pLen = p.length();\n        boolean[][] dp = new boolean[sLen + 1][pLen + 1];\n        dp[0][0] = true;\n\n        for (int i = 0; i <= sLen; i++) {\n            for (int j = 1; j <= pLen; j++) {\n                if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i][j - 2] || (i > 0 && dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n                } else {\n                    dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');\n                }\n            }\n        }\n\n        return dp[sLen][pLen];\n    }\n}", "test": "// Test cases\ndef patternMatcher = new PatternMatcher()\nassert patternMatcher.isMatch(\"aab\", \"c*a*b\") == true\nassert patternMatcher.isMatch(\"mississippi\", \"mis*is*p*.\") == false\nassert patternMatcher.isMatch(\"ab\", \".*c\") == false\nassert patternMatcher.isMatch(\"aaa\", \"a*a\") == true\nassert patternMatcher.isMatch(\"aaa\", \"ab*a*c*a\") == true\nassert patternMatcher.isMatch(\"a\", \"ab*\") == true\nassert patternMatcher.isMatch(\"ab\", \".*..\") == true\nassert patternMatcher.isMatch(\"aaa\", \"ab*a*c*a\") == true", "entry_point": "isMatch", "signature": "static boolean isMatch(String s, String p)", "docstring": "Check if the string s matches the pattern p. The pattern p can contain '.' and '*'.\n        '.' matches any single character.\n        '*' matches zero or more of the preceding element.\n        The matching should cover the entire string s.\n        >>> isMatch(\"aa\", \"a\")\n        false\n        >>> isMatch(\"aa\", \"a*\")\n        true\n        >>> isMatch(\"ab\", \".*\")\n        true", "instruction": "Write a Groovy function `static boolean isMatch(String s, String p)` to solve the following problem:\nCheck if the string s matches the pattern p. The pattern p can contain '.' and '*'.\n        '.' matches any single character.\n        '*' matches zero or more of the preceding element.\n        The matching should cover the entire string s.\n        >>> isMatch(\"aa\", \"a\")\n        false\n        >>> isMatch(\"aa\", \"a*\")\n        true\n        >>> isMatch(\"ab\", \".*\")\n        true", "level": "middle"}
{"task_id": "Groovy/45", "prompt": "class EggDroppingPuzzle {\n    static int minOperations(int k, int n) {\n        \"\"\"\n        Given k identical eggs and a building with n floors, determine the minimum number of operations\n        needed to find out the value of f (the critical floor) with the least number of drops.\n        The critical floor f is defined as the highest floor from which an egg dropped will not break.\n        If an egg breaks when dropped from floor x, then all eggs dropped from floors higher than x will also break.\n        If an egg does not break when dropped from floor x, then all eggs dropped from floors lower than x will not break.\n        >>> minOperations(1, 2)\n        2\n        >>> minOperations(2, 6)\n        3\n        >>> minOperations(3, 14)\n        4\n        \"\"\"", "canonical_solution": "// Right now, dp[i] represents dp(1, i)\n        int[] dp = new int[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            dp[i] = i;\n        }\n\n        for (int j = 2; j <= k; ++j) {\n            // Now, we will develop dp2[i] = dp(j, i)\n            int[] dp2 = new int[n + 1];\n            int x = 1;\n            for (int m = 1; m <= n; ++m) {\n                // Let's find dp2[m] = dp(j, m)\n                // Increase our optimal x while we can make our answer better.\n                // Notice max(dp[x-1], dp2[m-x]) > max(dp[x], dp2[m-x-1])\n                // is simply max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)).\n                while (x < m && Math.max(dp[x - 1], dp2[m - x]) > Math.max(dp[x], dp2[m - x - 1])) {\n                    x++;\n                }\n\n                // The final answer happens at this x.\n                dp2[m] = 1 + Math.max(dp[x - 1], dp2[m - x]);\n            }\n\n            dp = dp2;\n        }\n\n        return dp[n];\n    }\n}", "test": "// Test cases\ndef eggDroppingPuzzle = new EggDroppingPuzzle()\nassert eggDroppingPuzzle.minOperations(1, 10) == 10\nassert eggDroppingPuzzle.minOperations(2, 10) == 4\nassert eggDroppingPuzzle.minOperations(3, 10) == 4\nassert eggDroppingPuzzle.minOperations(3, 100) == 9\nassert eggDroppingPuzzle.minOperations(10, 100) == 7", "entry_point": "minOperations", "signature": "static int minOperations(int k, int n)", "docstring": "Given k identical eggs and a building with n floors, determine the minimum number of operations\n        needed to find out the value of f (the critical floor) with the least number of drops.\n        The critical floor f is defined as the highest floor from which an egg dropped will not break.\n        If an egg breaks when dropped from floor x, then all eggs dropped from floors higher than x will also break.\n        If an egg does not break when dropped from floor x, then all eggs dropped from floors lower than x will not break.\n        >>> minOperations(1, 2)\n        2\n        >>> minOperations(2, 6)\n        3\n        >>> minOperations(3, 14)\n        4", "instruction": "Write a Groovy function `static int minOperations(int k, int n)` to solve the following problem:\nGiven k identical eggs and a building with n floors, determine the minimum number of operations\n        needed to find out the value of f (the critical floor) with the least number of drops.\n        The critical floor f is defined as the highest floor from which an egg dropped will not break.\n        If an egg breaks when dropped from floor x, then all eggs dropped from floors higher than x will also break.\n        If an egg does not break when dropped from floor x, then all eggs dropped from floors lower than x will not break.\n        >>> minOperations(1, 2)\n        2\n        >>> minOperations(2, 6)\n        3\n        >>> minOperations(3, 14)\n        4", "level": "hard"}
{"task_id": "Groovy/46", "prompt": "class IntersectionFinder {\n    static List<Integer> findIntersection(List<Integer> nums1, List<Integer> nums2) {\n        \"\"\"\n        Find the intersection of two lists of integers.\n        The intersection of two arrays is the list of unique elements that are present in both arrays.\n        The result can be in any order.\n        >>> findIntersection([1, 2, 2, 1], [2, 2])\n        [2]\n        >>> findIntersection([4, 9, 5], [9, 4, 9, 8, 4])\n        [9, 4]\n        \"\"\"", "canonical_solution": "Set<Integer> set1 = new HashSet<>(nums1)\n        Set<Integer> set2 = new HashSet<>(nums2)\n        List<Integer> intersection = new ArrayList<>()\n\n        for (int num : set1) {\n            if (set2.contains(num)) {\n                intersection.add(num)\n            }\n        }\n\n        return intersection\n    }\n}", "test": "// Test cases\ndef intersectionFinder = new IntersectionFinder()\nassert intersectionFinder.findIntersection([1, 2, 2, 1], [2, 2]) == [2]\nassert intersectionFinder.findIntersection([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9]\nassert intersectionFinder.findIntersection([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []\nassert intersectionFinder.findIntersection([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\nassert intersectionFinder.findIntersection([1, 1, 2, 2, 3, 3], [2, 2, 3, 3, 4, 4]) == [2, 3]\nassert intersectionFinder.findIntersection([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]", "entry_point": "findIntersection", "signature": "static List<Integer> findIntersection(List<Integer> nums1, List<Integer> nums2)", "docstring": "Find the intersection of two lists of integers.\n        The intersection of two arrays is the list of unique elements that are present in both arrays.\n        The result can be in any order.\n        >>> findIntersection([1, 2, 2, 1], [2, 2])\n        [2]\n        >>> findIntersection([4, 9, 5], [9, 4, 9, 8, 4])\n        [9, 4]", "instruction": "Write a Groovy function `static List<Integer> findIntersection(List<Integer> nums1, List<Integer> nums2)` to solve the following problem:\nFind the intersection of two lists of integers.\n        The intersection of two arrays is the list of unique elements that are present in both arrays.\n        The result can be in any order.\n        >>> findIntersection([1, 2, 2, 1], [2, 2])\n        [2]\n        >>> findIntersection([4, 9, 5], [9, 4, 9, 8, 4])\n        [9, 4]", "level": "easy"}
{"task_id": "Groovy/47", "prompt": "class RepeatedSubstringPatternChecker {\n    static boolean hasRepeatedSubstringPattern(String s) {\n        \"\"\"\n        Check if a non-empty string can be constructed by taking a substring of it and appending multiple copies of the substring together.\n        >>> hasRepeatedSubstringPattern(\"abab\")\n        True\n        >>> hasRepeatedSubstringPattern(\"aba\")\n        False\n        >>> hasRepeatedSubstringPattern(\"abcabcabcabc\")\n        True\n        \"\"\"", "canonical_solution": "int len = s.length()\n        for (int i = len / 2; i >= 1; i--) {\n            if (len % i == 0) {\n                int m = len / i\n                String subS = s.substring(0, i)\n                StringBuilder sb = new StringBuilder()\n                for (int j = 0; j < m; j++) {\n                    sb.append(subS)\n                }\n                if (sb.toString().equals(s)) return true\n            }\n        }\n        return false\n    }\n}", "test": "// Test cases\ndef repeatedSubstringPatternChecker = new RepeatedSubstringPatternChecker()\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"abab\") == true\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"aba\") == false\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"abcabcabcabc\") == true\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"abcdabcd\") == true\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"abcabcabc\") == true\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"abcabc\") == true\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"abc\") == false\nassert repeatedSubstringPatternChecker.hasRepeatedSubstringPattern(\"a\") == false", "entry_point": "hasRepeatedSubstringPattern", "signature": "static boolean hasRepeatedSubstringPattern(String s)", "docstring": "Check if a non-empty string can be constructed by taking a substring of it and appending multiple copies of the substring together.\n        >>> hasRepeatedSubstringPattern(\"abab\")\n        True\n        >>> hasRepeatedSubstringPattern(\"aba\")\n        False\n        >>> hasRepeatedSubstringPattern(\"abcabcabcabc\")\n        True", "instruction": "Write a Groovy function `static boolean hasRepeatedSubstringPattern(String s)` to solve the following problem:\nCheck if a non-empty string can be constructed by taking a substring of it and appending multiple copies of the substring together.\n        >>> hasRepeatedSubstringPattern(\"abab\")\n        True\n        >>> hasRepeatedSubstringPattern(\"aba\")\n        False\n        >>> hasRepeatedSubstringPattern(\"abcabcabcabc\")\n        True", "level": "easy"}
{"task_id": "Groovy/48", "prompt": "class UglyNumberFinder {\n    static int findNthUglyNumber(int n) {\n        \"\"\"\n        Find the nth ugly number.\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        For example, the first 10 ugly numbers are [1, 2, 3, 4, 5, 6, 8, 9, 10, 12].\n        >>> findNthUglyNumber(10)\n        12\n        >>> findNthUglyNumber(1)\n        1\n        \"\"\"", "canonical_solution": "int[] dp = new int[n + 1];\n        dp[1] = 1;\n        int p2 = 1, p3 = 1, p5 = 1;\n        for (int i = 2; i <= n; i++) {\n            int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;\n            dp[i] = Math.min(Math.min(num2, num3), num5);\n            if (dp[i] == num2) {\n                p2++;\n            }\n            if (dp[i] == num3) {\n                p3++;\n            }\n            if (dp[i] == num5) {\n                p5++;\n            }\n        }\n        return dp[n];\n    }\n}", "test": "// Test cases\ndef uglyNumberFinder = new UglyNumberFinder()\nassert uglyNumberFinder.findNthUglyNumber(10) == 12\nassert uglyNumberFinder.findNthUglyNumber(1) == 1\nassert uglyNumberFinder.findNthUglyNumber(15) == 24\nassert uglyNumberFinder.findNthUglyNumber(20) == 36\nassert uglyNumberFinder.findNthUglyNumber(30) == 80\nassert uglyNumberFinder.findNthUglyNumber(40) == 144\nassert uglyNumberFinder.findNthUglyNumber(50) == 243\nassert uglyNumberFinder.findNthUglyNumber(60) == 384\nassert uglyNumberFinder.findNthUglyNumber(200) == 16200", "entry_point": "findNthUglyNumber", "signature": "static int findNthUglyNumber(int n)", "docstring": "Find the nth ugly number.\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        For example, the first 10 ugly numbers are [1, 2, 3, 4, 5, 6, 8, 9, 10, 12].\n        >>> findNthUglyNumber(10)\n        12\n        >>> findNthUglyNumber(1)\n        1", "instruction": "Write a Groovy function `static int findNthUglyNumber(int n)` to solve the following problem:\nFind the nth ugly number.\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        For example, the first 10 ugly numbers are [1, 2, 3, 4, 5, 6, 8, 9, 10, 12].\n        >>> findNthUglyNumber(10)\n        12\n        >>> findNthUglyNumber(1)\n        1", "level": "easy"}
{"task_id": "Groovy/49", "prompt": "class StringCompressor {\n    static int compress(ArrayList chars) {\n        \"\"\"\n        Compress a given character array by replacing consecutive repeating characters with the character followed by the count of the consecutive characters.\n        If the count of consecutive characters is 1, the character is left as is.\n        If the count is 10 or more, the count is split into individual digits.\n        The compressed array is stored in the input array itself.\n        The function returns the new length of the array.\n        >>> compress(['a', 'a', 'b', 'b', 'c', 'c', 'c'])\n        6\n        >>> compress(['a'])\n        1\n        >>> compress(['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'])\n        4\n        \"\"\"", "canonical_solution": "int indexAns = 0, index = 0\n        while(index < chars.size){\n            int count = 0\n            char currentChar = chars[index]\n            while(index < chars.size && chars[index] == currentChar){\n                index++\n                count++\n            }\n            chars[indexAns++] = currentChar\n            if(count != 1)\n                for(char c : Integer.toString(count).toCharArray()) \n                    chars[indexAns++] = c\n        }\n        return indexAns\n    }\n}", "test": "// Test cases\ndef stringCompressor = new StringCompressor()\nassert stringCompressor.compress(['a', 'a', 'b', 'b', 'c', 'c', 'c']) == 6\nassert stringCompressor.compress(['a']) == 1\nassert stringCompressor.compress(['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b']) == 4\nassert stringCompressor.compress(['a', 'a', 'a', 'b', 'b', 'a', 'a']) == 6\nassert stringCompressor.compress(['a', 'b', 'c', 'd']) == 4\nassert stringCompressor.compress(['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']) == 3\nassert stringCompressor.compress(['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'b', 'b', 'b']) == 5", "entry_point": "compress", "signature": "static int compress(ArrayList chars)", "docstring": "Compress a given character array by replacing consecutive repeating characters with the character followed by the count of the consecutive characters.\n        If the count of consecutive characters is 1, the character is left as is.\n        If the count is 10 or more, the count is split into individual digits.\n        The compressed array is stored in the input array itself.\n        The function returns the new length of the array.\n        >>> compress(['a', 'a', 'b', 'b', 'c', 'c', 'c'])\n        6\n        >>> compress(['a'])\n        1\n        >>> compress(['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'])\n        4", "instruction": "Write a Groovy function `static int compress(ArrayList chars)` to solve the following problem:\nCompress a given character array by replacing consecutive repeating characters with the character followed by the count of the consecutive characters.\n        If the count of consecutive characters is 1, the character is left as is.\n        If the count is 10 or more, the count is split into individual digits.\n        The compressed array is stored in the input array itself.\n        The function returns the new length of the array.\n        >>> compress(['a', 'a', 'b', 'b', 'c', 'c', 'c'])\n        6\n        >>> compress(['a'])\n        1\n        >>> compress(['a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'])\n        4", "level": "easy"}
{"task_id": "Groovy/50", "prompt": "class PasswordCracker {\n    static String crackPassword(List<Integer> password) {\n        \"\"\"\n        Given a list of non-negative integers representing a password,\n        return the smallest possible number that can be formed by concatenating\n        all the integers in the list.\n        >>> crackPassword([15, 8, 7])\n        \"1578\"\n        >>> crackPassword([0, 3, 30, 34, 5, 9])\n        \"03033459\"\n        \"\"\"", "canonical_solution": "// Convert each integer in the list to a string\n        List<String> passwordStrings = password.collect { it.toString() }\n\n        // Sort the list of strings in a custom order\n        passwordStrings.sort { a, b ->\n            (a + b).compareTo(b + a)\n        }\n\n        // Concatenate all the strings in the sorted list\n        return passwordStrings.join()\n    }\n}", "test": "// Test cases\ndef passwordCracker = new PasswordCracker()\nassert passwordCracker.crackPassword([15, 8, 7]) == \"1578\"\nassert passwordCracker.crackPassword([0, 3, 30, 34, 5, 9]) == \"03033459\"\nassert passwordCracker.crackPassword([10, 2]) == \"102\"\nassert passwordCracker.crackPassword([3, 30, 34, 5, 9]) == \"3033459\"\nassert passwordCracker.crackPassword([1, 1, 1]) == \"111\"\nassert passwordCracker.crackPassword([0, 0]) == \"00\"\nassert passwordCracker.crackPassword([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) == \"1399439856075703697382478249389609\"\nassert passwordCracker.crackPassword([121, 12]) == \"12112\"", "entry_point": "crackPassword", "signature": "static String crackPassword(List<Integer> password)", "docstring": "Given a list of non-negative integers representing a password,\n        return the smallest possible number that can be formed by concatenating\n        all the integers in the list.\n        >>> crackPassword([15, 8, 7])\n        \"1578\"\n        >>> crackPassword([0, 3, 30, 34, 5, 9])\n        \"03033459\"", "instruction": "Write a Groovy function `static String crackPassword(List<Integer> password)` to solve the following problem:\nGiven a list of non-negative integers representing a password,\n        return the smallest possible number that can be formed by concatenating\n        all the integers in the list.\n        >>> crackPassword([15, 8, 7])\n        \"1578\"\n        >>> crackPassword([0, 3, 30, 34, 5, 9])\n        \"03033459\"", "level": "easy"}
{"task_id": "Groovy/51", "prompt": "class Checker{\n    static int totalSmokedCigarettes(int n, int k) {\n        \"\"\"\n        Calculates the total number of cigarettes Peter can smoke given n initial cigarettes\n        and k butts needed to exchange for one new cigarette.\n\n        Parameters:\n        n - the initial number of cigarettes Peter has.\n        k - the number of cigarette butts needed to exchange for one new cigarette.\n\n        Returns:\n        The total number of cigarettes Peter can smoke.\n\n        Examples:\n        >>> total_smoked_cigarettes(4, 3)\n        5\n        >>> total_smoked_cigarettes(10, 3)\n        14\n        \"\"\"", "canonical_solution": "    int totalSmoked = n\n    int butts = n\n\n    while (butts >= k) {\n        int newCigarettes = butts / k\n        totalSmoked += newCigarettes\n        butts = butts % k + newCigarettes\n    }\n    \n    return totalSmoked\n}}", "test": "def checker = new Checker()\n// Test cases\nassert checker.totalSmokedCigarettes(4, 3) == 5\nassert checker.totalSmokedCigarettes(10, 3) == 14\nassert checker.totalSmokedCigarettes(5, 5) == 6\nassert checker.totalSmokedCigarettes(20, 4) == 26\nassert checker.totalSmokedCigarettes(1, 2) == 1 // Edge case, not enough to exchange\nassert checker.totalSmokedCigarettes(100, 5) == 124\nassert checker.totalSmokedCigarettes(0, 3) == 0 // Edge case, starts with no cigarettes", "entry_point": "totalSmokedCigarettes", "signature": "static int totalSmokedCigarettes(int n, int k)", "docstring": "Calculates the total number of cigarettes Peter can smoke given n initial cigarettes\nand k butts needed to exchange for one new cigarette.\n\nParameters:\nn - the initial number of cigarettes Peter has.\nk - the number of cigarette butts needed to exchange for one new cigarette.\n\nReturns:\nThe total number of cigarettes Peter can smoke.\n\nExamples:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14", "instruction": "Write a Groovy function `static int totalSmokedCigarettes(int n, int k)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given n initial cigarettes\nand k butts needed to exchange for one new cigarette.\n\nParameters:\nn - the initial number of cigarettes Peter has.\nk - the number of cigarette butts needed to exchange for one new cigarette.\n\nReturns:\nThe total number of cigarettes Peter can smoke.\n\nExamples:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14", "level": "easy"}
