{"task_id": "Scala/1", "prompt": "object Main extends App {\n\n  /**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n  */\n  def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "canonical_solution": "{\n    \n    for {\n      (elem, idx) <- numbers.zipWithIndex\n      (elem2, idx2) <- numbers.zipWithIndex\n      if idx != idx2\n    } {\n      val distance = math.abs(elem - elem2)\n      if (distance < threshold) {\n        return true\n      }\n    }\n    false\n  }", "test": "// Test cases\n  def test(): Unit = {\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(List(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(List(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(List(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n  }\n\n  // Run the test\n  test()\n}", "entry_point": "hasCloseElements", "signature": "def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "instruction": "Write a Scala function `def hasCloseElements(numbers: List[Double], threshold: Double): Boolean =` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.", "level": "easy"}
{"task_id": "Scala/2", "prompt": "object Solution {\n  /**\n    * Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n    *\n    * A subarray is defined as a contiguous sequence of numbers in an array.\n    *\n    * An ascending subarray is a subarray where the numbers are in strictly increasing order.\n    *\n    * Example:\n    * maxAscendingSum(Array(10,20,30,5,10,50))\n    * Output: 65\n    */\n  def maxAscendingSum(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n    var maxSum = 0\n    var currentSum = nums(0)\n\n    for (i <- 1 until nums.length) {\n      if (nums(i) > nums(i - 1)) {\n        currentSum += nums(i)\n      } else {\n        maxSum = maxSum.max(currentSum)\n        currentSum = nums(i)\n      }\n    }\n\n    maxSum.max(currentSum)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(maxAscendingSum(Array(1, 2, 3, 4, 5, 6)) == 21)\n    assert(maxAscendingSum(Array(10, 20, 30, 40, 50, 5, 6, 7, 8, 9)) == 150)\n    assert(maxAscendingSum(Array(100, 200, 300, 400, 500, 1, 2, 3, 4, 5)) == 1500)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxAscendingSum", "signature": "def maxAscendingSum(nums: Array[Int]): Int =", "docstring": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "instruction": "Write a Scala function `def maxAscendingSum(nums: Array[Int]): Int =` to solve the following problem:\nGiven an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nAn ascending subarray is a subarray where the numbers are in strictly increasing order.\n\nExample:\nmaxAscendingSum(Array(10,20,30,5,10,50))\nOutput: 65", "level": "easy"}
{"task_id": "Scala/3", "prompt": "object Solution {\n  /**\n    * Calculate the total number of matches in a tournament with n teams.\n    *\n    * @param n The number of teams in the tournament.\n    * @return The total number of matches.\n    *\n    * Example:\n    * numberOfMatches(7)\n    * Output: 6\n    */\n  def numberOfMatches(n: Int): Int = ", "canonical_solution": "  {\n\n     // implementation\n     if (n == 1) 0\n    else if (n % 2 == 0) n / 2 + numberOfMatches(n / 2)\n    else (n - 1) / 2 + numberOfMatches((n - 1) / 2 + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(numberOfMatches(8) == 7)\n    assert(numberOfMatches(10) == 9)\n    assert(numberOfMatches(12) == 11)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberOfMatches", "signature": "def numberOfMatches(n: Int): Int =", "docstring": "Calculate the total number of matches in a tournament with n teams.\n\n@param n The number of teams in the tournament.\n@return The total number of matches.\n\nExample:\nnumberOfMatches(7)\nOutput: 6", "instruction": "Write a Scala function `def numberOfMatches(n: Int): Int =` to solve the following problem:\nCalculate the total number of matches in a tournament with n teams.\n\n@param n The number of teams in the tournament.\n@return The total number of matches.\n\nExample:\nnumberOfMatches(7)\nOutput: 6", "level": "easy"}
{"task_id": "Scala/4", "prompt": "import scala.collection.mutable.ArrayBuffer\nobject Solution {\n    /**\n    * Find the most competitive subsequence of length k from the given integer array.\n    *\n    * @param nums The integer array.\n    * @param k The length of the subsequence.\n    * @return The most competitive subsequence.\n    *\n    * Example:\n    * mostCompetitive(Array(3, 5, 2, 6), 2)\n    * Output: Array(2, 6)\n    */\n  def mostCompetitive(nums: Array[Int], k: Int): Array[Int] = ", "canonical_solution": "  {\n \n            val stack = new ArrayBuffer[Int]()\n            for (i <- nums.indices) {\n                while (stack.nonEmpty && stack.last > nums(i) && stack.length + nums.length - i > k) {\n                    stack.remove(stack.length - 1)\n                }\n                if (stack.length < k) {\n                    stack.append(nums(i))\n                }\n            }\n            stack.toArray\n        }", "test": "        def main(args: Array[String]): Unit = {\n            assert(mostCompetitive(Array(3, 5, 2, 6), 2).sameElements(Array(2, 6)))\n            assert(mostCompetitive(Array(2, 4, 3, 3, 5, 4, 9, 6), 4).sameElements(Array(2, 3, 3, 4)))\n            assert(mostCompetitive(Array(6, 7, 5, 3, 5, 6, 4, 2), 3).sameElements(Array(3, 4, 2)))\n            println(\"All tests passed\")\n        }\n    }", "entry_point": "mostCompetitive", "signature": "def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =", "docstring": "Find the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "instruction": "Write a Scala function `def mostCompetitive(nums: Array[Int], k: Int): Array[Int] =` to solve the following problem:\nFind the most competitive subsequence of length k from the given integer array.\n\n@param nums The integer array.\n@param k The length of the subsequence.\n@return The most competitive subsequence.\n\nExample:\nmostCompetitive(Array(3, 5, 2, 6), 2)\nOutput: Array(2, 6)", "level": "middle"}
{"task_id": "Scala/5", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n    /**\n      * Generate all possible palindrome strings by rearranging the characters in the input string.\n      *\n      * @param s The input string.\n      * @return A list of all possible palindrome strings, without duplicates.\n      *\n      * Example:\n      * generatePalindromes(\"aabb\")\n      * Output: List(\"abba\", \"baab\")\n      */\n  def generatePalindromes(s: String): List[String] = ", "canonical_solution": "  {\n\n    val result = ListBuffer[String]()\n    val set = collection.mutable.Set[String]()\n\n    // Count the frequency of each character\n    val count = Array.fill(128)(0)\n    for (c <- s) {\n      count(c) += 1\n    }\n\n    // Check if a palindrome is possible\n    var oddCount = 0\n    var oddChar: Char = 0\n    for (i <- count.indices) {\n      if (count(i) % 2 != 0) {\n        oddCount += 1\n        oddChar = i.toChar\n      }\n      if (oddCount > 1) {\n        return result.toList // Palindrome not possible\n      }\n    }\n\n    // Generate palindromes using backtracking\n    backtrack(set, count, new StringBuilder(), s.length, oddChar)\n\n    result.addAll(set)\n    result.toList\n  }\n\n  private def backtrack(set: collection.mutable.Set[String], count: Array[Int], sb: StringBuilder, length: Int, oddChar: Char): Unit = {\n    if (sb.length == length) {\n      set.addOne(sb.toString())\n      return\n    }\n\n    for (i <- count.indices) {\n      if (count(i) > 1) {\n        count(i) -= 2\n        sb.insert(0, i.toChar)\n        sb.append(i.toChar)\n        backtrack(set, count, sb, length, oddChar)\n        sb.deleteCharAt(0)\n        sb.deleteCharAt(sb.length - 1)\n        count(i) += 2\n      }\n    }\n\n    if (oddChar != 0) {\n      sb.insert(sb.length / 2, oddChar)\n      backtrack(set, count, sb, length, 0.toChar)\n      sb.deleteCharAt(sb.length / 2)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val result1 = generatePalindromes(\"aabb\")\n    assert(result1.contains(\"abba\"))\n    assert(result1.contains(\"baab\"))\n    \n    val result2 = generatePalindromes(\"abc\")\n    assert(result2.isEmpty)\n\n    val result3 = generatePalindromes(\"aabbc\")\n    assert(result3.contains(\"abcba\"))\n    assert(result3.contains(\"bacab\"))\n    \n    println(\"All tests passed\")\n}\n    \n}", "entry_point": "generatePalindromes", "signature": "def generatePalindromes(s: String): List[String] =", "docstring": "Generate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "instruction": "Write a Scala function `def generatePalindromes(s: String): List[String] =` to solve the following problem:\nGenerate all possible palindrome strings by rearranging the characters in the input string.\n\n@param s The input string.\n@return A list of all possible palindrome strings, without duplicates.\n\nExample:\ngeneratePalindromes(\"aabb\")\nOutput: List(\"abba\", \"baab\")", "level": "hard"}
{"task_id": "Scala/6", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n    /**\n      * Find the value of the bottom-most left node in a binary tree.\n      *\n      * @param root The root node of the binary tree.\n      * @return The value of the bottom-most left node.\n      *\n      * Example:\n      * findBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\n      * Output: 1\n      *\n      * findBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\n      * Output: 7\n      */\n  def findBottomLeftValue(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null)\n      throw new IllegalArgumentException(\"Invalid input: root cannot be null.\")\n\n    var queue = scala.collection.mutable.Queue[TreeNode]()\n    queue.enqueue(root)\n    var result = 0\n\n    while (queue.nonEmpty) {\n      val size = queue.size\n      var isFirstNode = true\n\n      for (_ <- 0 until size) {\n        val node = queue.dequeue()\n\n        if (isFirstNode) {\n          result = node.value\n          isFirstNode = false\n        }\n\n        if (node.left != null)\n          queue.enqueue(node.left)\n        if (node.right != null)\n          queue.enqueue(node.right)\n      }\n    }\n\n    result\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2)\n    root1.left = new TreeNode(1)\n    root1.right = new TreeNode(3)\n    assert(findBottomLeftValue(root1) == 1)\n\n    // Test Case 2\n    val root2 = new TreeNode(1)\n    root2.left = new TreeNode(2)\n    root2.left.left = new TreeNode(4)\n    root2.right = new TreeNode(3)\n    root2.right.left = new TreeNode(5)\n    root2.right.left.left = new TreeNode(7)\n    root2.right.left.right = new TreeNode(6)\n    assert(findBottomLeftValue(root2) == 7)\n\n    // Test Case 3\n    val root3 = new TreeNode(5)\n    root3.left = new TreeNode(3)\n    root3.right = new TreeNode(6)\n    root3.left.left = new TreeNode(2)\n    root3.left.right = new TreeNode(4)\n    root3.left.left.left = new TreeNode(1)\n    assert(findBottomLeftValue(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findBottomLeftValue", "signature": "def findBottomLeftValue(root: TreeNode): Int =", "docstring": "Find the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "instruction": "Write a Scala function `def findBottomLeftValue(root: TreeNode): Int =` to solve the following problem:\nFind the value of the bottom-most left node in a binary tree.\n\n@param root The root node of the binary tree.\n@return The value of the bottom-most left node.\n\nExample:\nfindBottomLeftValue(new TreeNode(2, new TreeNode(1), new TreeNode(3)))\nOutput: 1\n\nfindBottomLeftValue(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3, new TreeNode(5, new TreeNode(7), new TreeNode(6))), null))\nOutput: 7", "level": "hard"}
{"task_id": "Scala/7", "prompt": "// Definition for a binary tree node.\ncase class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Determine whether a binary tree is a valid binary search tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a valid binary search tree, false otherwise.\n    *\n    * Example:\n    * isValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\n    * isValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false\n    */\n  def isValidBST(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isValidBSTHelper(node: TreeNode, min: Option[Int], max: Option[Int]): Boolean = {\n      if (node == null) {\n        true\n      } else if ((min.isDefined && node.value <= min.get) || (max.isDefined && node.value >= max.get)) {\n        false\n      } else {\n        isValidBSTHelper(node.left, min, Some(node.value)) && isValidBSTHelper(node.right, Some(node.value), max)\n      }\n    }\n    \n    isValidBSTHelper(root, None, None)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(2, new TreeNode(1), new TreeNode(3))\n    assert(isValidBST(root1), \"Test Case 1 Failed\")\n\n    // Test Case 2\n    val root2 = new TreeNode(5, new TreeNode(1), new TreeNode(4, new TreeNode(3), new TreeNode(6)))\n    assert(!isValidBST(root2), \"Test Case 2 Failed\")\n\n    // Test Case 3\n    val root3 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(5))\n    assert(isValidBST(root3), \"Test Case 3 Failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isValidBST", "signature": "def isValidBST(root: TreeNode): Boolean =", "docstring": "Determine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "instruction": "Write a Scala function `def isValidBST(root: TreeNode): Boolean =` to solve the following problem:\nDetermine whether a binary tree is a valid binary search tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a valid binary search tree, false otherwise.\n\nExample:\nisValidBST(TreeNode(2, TreeNode(1), TreeNode(3))) -> true\nisValidBST(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) -> false", "level": "middle"}
{"task_id": "Scala/8", "prompt": "object Solution {\n    /**\n     * Find all the numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * @param nums An array containing n integers.\n     * @return An array of numbers that are in the range [1, n] but are not present in the given array.\n     *\n     * Example:\n     * findDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\n     * Output: Array(5,6)\n     *\n     * findDisappearedNumbers(Array(1,1))\n     * Output: Array(2)\n     */\n  def findDisappearedNumbers(nums: Array[Int]): List[Int] = ", "canonical_solution": "  {\n\n    val result = collection.mutable.ListBuffer[Int]()\n\n    for (i <- nums.indices) {\n      val num = math.abs(nums(i))\n      val index = num - 1\n      if (nums(index) > 0) {\n        nums(index) = -nums(index)\n      }\n    }\n\n    for (i <- nums.indices) {\n      if (nums(i) > 0) {\n        result += (i + 1)\n      }\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(4, 3, 2, 7, 8, 2, 3, 1)\n    val result1 = findDisappearedNumbers(nums1)\n    assert(result1.contains(5))\n    assert(result1.contains(6))\n\n    val nums2 = Array(1, 1)\n    val result2 = findDisappearedNumbers(nums2)\n    assert(result2.contains(2))\n\n    val nums3 = Array(2, 2, 2, 2, 2)\n    val result3 = findDisappearedNumbers(nums3)\n    assert(result3.contains(1))\n    assert(result3.contains(3))\n    assert(result3.contains(4))\n    assert(result3.contains(5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findDisappearedNumbers", "signature": "def findDisappearedNumbers(nums: Array[Int]): List[Int] =", "docstring": "Find all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "instruction": "Write a Scala function `def findDisappearedNumbers(nums: Array[Int]): List[Int] =` to solve the following problem:\nFind all the numbers that are in the range [1, n] but are not present in the given array.\n\n@param nums An array containing n integers.\n@return An array of numbers that are in the range [1, n] but are not present in the given array.\n\nExample:\nfindDisappearedNumbers(Array(4,3,2,7,8,2,3,1))\nOutput: Array(5,6)\n\nfindDisappearedNumbers(Array(1,1))\nOutput: Array(2)", "level": "easy"}
{"task_id": "Scala/9", "prompt": "object Solution {\n  /**\n    * Given an integer n, returns an array consisting of n unique integers that add up to 0.\n    *\n    * @param n The number of integers in the array.\n    * @return An array of n unique integers that add up to 0.\n    *\n    * Example:\n    * sumZero(5)\n    * Output: [-7, -1, 1, 3, 4]\n    *\n    * Note:\n    * Other valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]\n    */\n  def sumZero(n: Int): Array[Int] = ", "canonical_solution": "  {\n\n    // function implementation goes here\n    val result = new Array[Int](n)\n    var sum = 0\n    \n    for (i <- 0 until n - 1) {\n      result(i) = i + 1\n      sum += result(i)\n    }\n    \n    result(n - 1) = -sum\n    result\n  }", "test": "  \n  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val result1 = sumZero(4)\n    assert(result1.sameElements(Array(1, 2, 3, -6)))\n    \n    // Test case 2\n    val result2 = sumZero(6)\n    assert(result2.sameElements(Array(1, 2, 3, 4, 5, -15)))\n    \n    // Test case 3\n    val result3 = sumZero(8)\n    assert(result3.sameElements(Array(1, 2, 3, 4, 5, 6, 7, -28)))\n    \n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "sumZero", "signature": "def sumZero(n: Int): Array[Int] =", "docstring": "Given an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "instruction": "Write a Scala function `def sumZero(n: Int): Array[Int] =` to solve the following problem:\nGiven an integer n, returns an array consisting of n unique integers that add up to 0.\n\n@param n The number of integers in the array.\n@return An array of n unique integers that add up to 0.\n\nExample:\nsumZero(5)\nOutput: [-7, -1, 1, 3, 4]\n\nNote:\nOther valid arrays: [-5, -1, 1, 2, 3], [-3, -1, 2, -2, 4]", "level": "easy"}
{"task_id": "Scala/10", "prompt": "\nobject Solution {\n    /**\n    * Calculate the number of arguments passed to the function.\n    *\n    * @param args An array of arguments.\n    * @return The number of arguments passed.\n    *\n    * Example:\n    * argumentsLength(Array(5))\n    * Output: 1\n    */\n  def argumentsLength(args: Array[Any]): Int = ", "canonical_solution": "  {\n      args.length\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val testCase1 = Array[Any](\"Hello\", \"World\")\n    assert(argumentsLength(testCase1) == 2)\n\n    // Test Case 2\n    val testCase2 = Array[Any](1, 2, 3, 4, 5)\n    assert(argumentsLength(testCase2) == 5)\n\n    // Test Case 3\n    val testCase3 = Array[Any](10)\n    assert(argumentsLength(testCase3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "argumentsLength", "signature": "def argumentsLength(args: Array[Any]): Int =", "docstring": "Calculate the number of arguments passed to the function.\n\n@param args An array of arguments.\n@return The number of arguments passed.\n\nExample:\nargumentsLength(Array(5))\nOutput: 1", "instruction": "Write a Scala function `def argumentsLength(args: Array[Any]): Int =` to solve the following problem:\nCalculate the number of arguments passed to the function.\n\n@param args An array of arguments.\n@return The number of arguments passed.\n\nExample:\nargumentsLength(Array(5))\nOutput: 1", "level": "easy"}
{"task_id": "Scala/11", "prompt": "\nobject Solution {\n  /**\n    * Calculate the total amount of water that can be trapped between the given heights.\n    *\n    * @param height An array representing the heights of each bar.\n    * @return The total amount of water that can be trapped.\n    *\n    * Example:\n    * trap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\n    * Output: 6\n    *\n    * Explanation:\n    * The heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).\n    */\n  def trap(height: Array[Int]): Int = ", "canonical_solution": "  {\n\n    val n = height.length\n    val leftMax = new Array[Int](n)\n    val rightMax = new Array[Int](n)\n\n    var max = 0\n    for (i <- 0 until n) {\n      leftMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    max = 0\n    for (i <- n - 1 to 0 by -1) {\n      rightMax(i) = max\n      max = math.max(max, height(i))\n    }\n\n    var water = 0\n    for (i <- 0 until n) {\n      val minHeight = math.min(leftMax(i), rightMax(i))\n      if (minHeight > height(i)) {\n        water += minHeight - height(i)\n      }\n    }\n\n    water\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(trap(Array(1, 0, 2, 0, 1)) == 2)\n    assert(trap(Array(3, 2, 1, 0, 1, 2, 3)) == 9)\n    assert(trap(Array(2, 1, 4, 3, 1, 2)) == 2)\n\n    println(\"All tests passed\")\n  }\n}\n      ", "entry_point": "trap", "signature": "def trap(height: Array[Int]): Int =", "docstring": "Calculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "instruction": "Write a Scala function `def trap(height: Array[Int]): Int =` to solve the following problem:\nCalculate the total amount of water that can be trapped between the given heights.\n\n@param height An array representing the heights of each bar.\n@return The total amount of water that can be trapped.\n\nExample:\ntrap(Array(0,1,0,2,1,0,1,3,2,1,2,1))\nOutput: 6\n\nExplanation:\nThe heights are represented by [0,1,0,2,1,0,1,3,2,1,2,1], and in this scenario, 6 units of water can be trapped (represented by the blue section).", "level": "middle"}
{"task_id": "Scala/12", "prompt": "import scala.collection.mutable.ListBuffer\nobject Solution {\n  /**\n    * Remove the minimum number of invalid parentheses from the given string to make it valid.\n    *\n    * @param s The input string containing parentheses and letters.\n    * @return A list of all possible valid strings after removing invalid parentheses.\n    *\n    * Example:\n    * removeInvalidParentheses(\"()())()\")\n    * Output: List(\"(())()\", \"()()()\")\n    */\n  def removeInvalidParentheses(s: String): List[String] = ", "canonical_solution": "  {\n    val result = ListBuffer[String]()\n    removeInvalidParenthesesHelper(s, result, 0, 0, '(', ')')\n    result.toList\n  }\n\n  private def removeInvalidParenthesesHelper(s: String, result: ListBuffer[String], last_i: Int, last_j: Int, open: Char, close: Char): Unit = {\n    var count = 0\n    var i = last_i\n\n    while (i < s.length) {\n      if (s(i) == open) count += 1\n      if (s(i) == close) count -= 1\n      if (count >= 0) {\n        i += 1\n      } else {\n        var j = last_j\n        while (j <= i) {\n          if (s(j) == close && (j == last_j || s(j - 1) != close)) {\n            removeInvalidParenthesesHelper(s.substring(0, j) + s.substring(j + 1), result, i, j, open, close)\n          }\n          j += 1\n        }\n        return\n      }\n    }\n\n    val reversed = s.reverse\n    if (open == '(') {\n      removeInvalidParenthesesHelper(reversed, result, 0, 0, close, open)\n    } else {\n      result += reversed\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test 1\n    val result1 = removeInvalidParentheses(\"()())()\")\n    assert(result1.contains(\"(())()\"))\n    assert(result1.contains(\"()()()\"))\n\n    // Test 2\n    val result2 = removeInvalidParentheses(\"(a)())()\")\n    assert(result2.contains(\"(a())()\"))\n    assert(result2.contains(\"(a)()()\"))\n\n    // Test 3\n    val result3 = removeInvalidParentheses(\")(\")\n    assert(result3.contains(\"\"))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeInvalidParentheses", "signature": "def removeInvalidParentheses(s: String): List[String] =", "docstring": "Remove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "instruction": "Write a Scala function `def removeInvalidParentheses(s: String): List[String] =` to solve the following problem:\nRemove the minimum number of invalid parentheses from the given string to make it valid.\n\n@param s The input string containing parentheses and letters.\n@return A list of all possible valid strings after removing invalid parentheses.\n\nExample:\nremoveInvalidParentheses(\"()())()\")\nOutput: List(\"(())()\", \"()()()\")", "level": "hard"}
{"task_id": "Scala/13", "prompt": "case class TreeNode(var value: Int, var left: Option[TreeNode] = None, var right: Option[TreeNode] = None)\nobject Solution {\n\n    /**\n     * Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n     *\n     * @param root The root node of the binary search tree.\n     * @return The minimum difference between any two different nodes values.\n     *\n     * Example:\n     * minDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\n     * Output: 1\n     */\n  def minDiffInBST(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    var minDiff = Int.MaxValue\n    var prev: Option[TreeNode] = None\n\n    def inorder(node: Option[TreeNode], minDiff: Int): Int = {\n      node match {\n        case Some(n) =>\n          var updatedDiff = inorder(n.left, minDiff)\n\n          prev.foreach(p => updatedDiff = math.min(updatedDiff, n.value - p.value))\n          prev = Some(n)\n\n          inorder(n.right, updatedDiff)\n        case None =>\n          minDiff\n      }\n    }\n\n    inorder(Some(root), minDiff)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val root = TreeNode(5, Some(TreeNode(3)), Some(TreeNode(7)))\n    root.left.get.left = Some(TreeNode(2))\n    root.left.get.right = Some(TreeNode(4))\n    root.right.get.left = Some(TreeNode(6))\n    root.right.get.right = Some(TreeNode(8))\n\n    assert(minDiffInBST(root) == 1)\n\n    val root2 = TreeNode(8, Some(TreeNode(4)), Some(TreeNode(12)))\n    root2.left.get.left = Some(TreeNode(2))\n    root2.left.get.right = Some(TreeNode(6))\n    root2.right.get.left = Some(TreeNode(10))\n    root2.right.get.right = Some(TreeNode(14))\n\n    assert(minDiffInBST(root2) == 2)\n\n    val root3 = TreeNode(1)\n    root3.right = Some(TreeNode(3))\n    root3.right.get.right = Some(TreeNode(6))\n    root3.right.get.right.get.left = Some(TreeNode(4))\n\n    assert(minDiffInBST(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minDiffInBST", "signature": "def minDiffInBST(root: TreeNode): Int =", "docstring": "Given the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "instruction": "Write a Scala function `def minDiffInBST(root: TreeNode): Int =` to solve the following problem:\nGiven the root of a binary search tree, returns the minimum difference between any two different nodes values in the tree.\n\n@param root The root node of the binary search tree.\n@return The minimum difference between any two different nodes values.\n\nExample:\nminDiffInBST(TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6)))\nOutput: 1", "level": "middle"}
{"task_id": "Scala/14", "prompt": "object Solution {\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n  /**\n    * Find the maximum depth of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The maximum depth of the binary tree.\n    *\n    * Example:\n    * maxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: 3\n    */\n  def maxDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n\n    if (root == null) {\n      return 0\n    }\n\n    val leftDepth = maxDepth(root.left)\n    val rightDepth = maxDepth(root.right)\n\n    math.max(leftDepth, rightDepth) + 1\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    val root1 = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    val root2 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5, TreeNode(6), null)))\n    val root3 = TreeNode(10, null, null)\n\n    assert(maxDepth(root1) == 3)\n    assert(maxDepth(root2) == 4)\n    assert(maxDepth(root3) == 1)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "maxDepth", "signature": "def maxDepth(root: TreeNode): Int =", "docstring": "Find the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "instruction": "Write a Scala function `def maxDepth(root: TreeNode): Int =` to solve the following problem:\nFind the maximum depth of a binary tree.\n\n@param root The root node of the binary tree.\n@return The maximum depth of the binary tree.\n\nExample:\nmaxDepth(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\nOutput: 3", "level": "easy"}
{"task_id": "Scala/15", "prompt": "object Solution {\n    /**\n    * Check if a string is a k-palindrome.\n    *\n    * A k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n    *\n    * @param s The input string.\n    * @param k The maximum number of characters that can be removed.\n    * @return True if the string is a k-palindrome, otherwise false.\n    *\n    * Example:\n    * isKPalindrome(\"abcdeca\", 2)\n    * Output: true\n    *\n    * isKPalindrome(\"abbababa\", 1)\n    * Output: true\n    */\n  def isKPalindrome(s: String, k: Int): Boolean = ", "canonical_solution": "  {\n\n    // Check if a string is a k-palindrome.\n\n    if (s.length <= 1) {\n      true\n    } else {\n      val dp = Array.ofDim[Int](s.length + 1, s.length + 1)\n\n      for (i <- 0 to s.length) {\n        dp(i)(0) = i\n        dp(0)(i) = i\n      }\n\n      for (i <- 1 to s.length) {\n        for (j <- 1 to s.length) {\n          if (s(i - 1) == s(s.length - j)) {\n            dp(i)(j) = dp(i - 1)(j - 1)\n          } else {\n            dp(i)(j) = 1 + math.min(dp(i - 1)(j), dp(i)(j - 1))\n          }\n        }\n      }\n\n      dp(s.length)(s.length) <= 2 * k\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(isKPalindrome(\"abcdeca\", 2) == true)\n    assert(isKPalindrome(\"abbababa\", 1) == true)\n    assert(isKPalindrome(\"abcdefg\", 3) == false)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isKPalindrome", "signature": "def isKPalindrome(s: String, k: Int): Boolean =", "docstring": "Check if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "instruction": "Write a Scala function `def isKPalindrome(s: String, k: Int): Boolean =` to solve the following problem:\nCheck if a string is a k-palindrome.\n\nA k-palindrome is a string that can be converted into a palindrome by removing at most k characters.\n\n@param s The input string.\n@param k The maximum number of characters that can be removed.\n@return True if the string is a k-palindrome, otherwise false.\n\nExample:\nisKPalindrome(\"abcdeca\", 2)\nOutput: true\n\nisKPalindrome(\"abbababa\", 1)\nOutput: true", "level": "hard"}
{"task_id": "Scala/16", "prompt": "object Solution {\n\n  case class TreeNode(value: Int, left: TreeNode = null, right: TreeNode = null)\n\n   /**\n    * Find the diameter of a binary tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return The length of the longest path between any two nodes in the tree.\n    *\n    * Example:\n    * diameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\n    * Output: 3\n    *\n    * Note:\n    * The diameter of a binary tree is defined as the length of the longest path between any two nodes,\n    * which may or may not pass through the root.\n    * The length of a path is represented by the number of edges between two nodes.\n    * The given tree is guaranteed to have at most 104 nodes,\n    * and the values of the nodes in the tree are in the range [-100, 100].\n    */\n  def diameterOfBinaryTree(root: TreeNode): Int = ", "canonical_solution": "  {\n \n    def height(node: TreeNode): Int = {\n      if (node == null) 0\n      else 1 + math.max(height(node.left), height(node.right))\n    }\n\n    def diameter(node: TreeNode): Int = {\n      if (node == null) 0\n      else {\n        val leftHeight = height(node.left)\n        val rightHeight = height(node.right)\n        val leftDiameter = diameter(node.left)\n        val rightDiameter = diameter(node.right)\n        math.max(leftHeight + rightHeight, math.max(leftDiameter, rightDiameter))\n      }\n    }\n\n    diameter(root)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\n    assert(diameterOfBinaryTree(root1) == 3)\n\n    // Test case 2\n    val root2 = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))\n    assert(diameterOfBinaryTree(root2) == 3)\n\n    // Test case 3\n    val root3 = TreeNode(1, null, TreeNode(2, null, TreeNode(3, null, TreeNode(4))))\n    assert(diameterOfBinaryTree(root3) == 3)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "diameterOfBinaryTree", "signature": "def diameterOfBinaryTree(root: TreeNode): Int =", "docstring": "Find the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "instruction": "Write a Scala function `def diameterOfBinaryTree(root: TreeNode): Int =` to solve the following problem:\nFind the diameter of a binary tree.\n\n@param root The root node of the binary tree.\n@return The length of the longest path between any two nodes in the tree.\n\nExample:\ndiameterOfBinaryTree(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))\nOutput: 3\n\nNote:\nThe diameter of a binary tree is defined as the length of the longest path between any two nodes,\nwhich may or may not pass through the root.\nThe length of a path is represented by the number of edges between two nodes.\nThe given tree is guaranteed to have at most 104 nodes,\nand the values of the nodes in the tree are in the range [-100, 100].", "level": "middle"}
{"task_id": "Scala/17", "prompt": "object Solution {\n\n    /**\n     * Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n     *\n     * @param date The date in the format \"YYYY-MM-DD\".\n     * @return The day of the year.\n     *\n     * Example:\n     * dayOfYear(\"2019-01-09\")\n     * Output: 9\n     *\n     * dayOfYear(\"2019-02-10\")\n     * Output: 41\n     */\n  def dayOfYear(date: String): Int = ", "canonical_solution": "  {\n\n    val parts = date.split(\"-\")\n    val year = parts(0).toInt\n    val month = parts(1).toInt\n    val day = parts(2).toInt\n\n    val daysInMonth = Array(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n\n    if (isLeapYear(year)) {\n      daysInMonth(2) = 29\n    }\n\n    var dayOfYear = day\n    for (i <- 1 until month) {\n      dayOfYear += daysInMonth(i)\n    }\n\n    dayOfYear\n  }\n\n  def isLeapYear(year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(dayOfYear(\"2022-03-15\") == 74)\n    assert(dayOfYear(\"2023-11-30\") == 334)\n    assert(dayOfYear(\"2024-07-01\") == 183)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "dayOfYear", "signature": "def dayOfYear(date: String): Int =", "docstring": "Given a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "instruction": "Write a Scala function `def dayOfYear(date: String): Int =` to solve the following problem:\nGiven a date in the format \"YYYY-MM-DD\", return the day of the year.\n\n@param date The date in the format \"YYYY-MM-DD\".\n@return The day of the year.\n\nExample:\ndayOfYear(\"2019-01-09\")\nOutput: 9\n\ndayOfYear(\"2019-02-10\")\nOutput: 41", "level": "middle"}
{"task_id": "Scala/18", "prompt": "\nobject Solution {\n  /**\n    * Convert a non-negative integer to its English representation.\n    *\n    * @param num The number to be converted.\n    * @return The English representation of the number.\n    *\n    * Example:\n    * numberToWords(123)\n    * Output: \"One Hundred Twenty Three\"\n    *\n    * numberToWords(12345)\n    * Output: \"Twelve Thousand Three Hundred Forty Five\"\n    *\n    * numberToWords(1234567)\n    * Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n    */\n  def numberToWords(num: Int): String = ", "canonical_solution": "  {\n\n      if (num == 0) {\n      return \"Zero\"\n      }\n\n      val belowTwenty = Array(\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\n      val tens = Array(\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\n      val thousands = Array(\"\", \"Thousand\", \"Million\", \"Billion\")\n\n      val result = new StringBuilder()\n      var i = 0\n      var n = num\n\n      while (n > 0) {\n        if (n % 1000 != 0) {\n          result.insert(0, helper(n % 1000, belowTwenty, tens) + thousands(i) + \" \")\n        }\n        n /= 1000\n        i += 1\n      }\n\n      result.toString().trim\n    }\n\n  def helper(num: Int, belowTwenty: Array[String], tens: Array[String]): String = {\n    if (num == 0) {\n      \"\"\n    } else if (num < 20) {\n      belowTwenty(num) + \" \"\n    } else if (num < 100) {\n      tens(num / 10) + \" \" + helper(num % 10, belowTwenty, tens)\n    } else {\n      belowTwenty(num / 100) + \" Hundred \" + helper(num % 100, belowTwenty, tens)\n    }\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(numberToWords(567) == \"Five Hundred Sixty Seven\")\n    assert(numberToWords(123456) == \"One Hundred Twenty Three Thousand Four Hundred Fifty Six\")\n    assert(numberToWords(987654321) == \"Nine Hundred Eighty Seven Million Six Hundred Fifty Four Thousand Three Hundred Twenty One\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "numberToWords", "signature": "def numberToWords(num: Int): String =", "docstring": "Convert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "instruction": "Write a Scala function `def numberToWords(num: Int): String =` to solve the following problem:\nConvert a non-negative integer to its English representation.\n\n@param num The number to be converted.\n@return The English representation of the number.\n\nExample:\nnumberToWords(123)\nOutput: \"One Hundred Twenty Three\"\n\nnumberToWords(12345)\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nnumberToWords(1234567)\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"", "level": "hard"}
{"task_id": "Scala/19", "prompt": "\nobject Solution {\n  /**\n    * Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\n    * Calculate and return the total number of complete rows that can be formed.\n    *\n    * @param n The total number of coins.\n    * @return The total number of complete rows that can be formed.\n    *\n    * Example:\n    * arrangeCoins(5)\n    * Output: 2\n    * Explanation: The third row is incomplete, so return 2.\n    */\n  def arrangeCoins(n: Int): Int = ", "canonical_solution": "  {\n \n    var row = 1\n    var remaining = n\n    while (remaining >= row) {\n      remaining -= row\n      row += 1\n    }\n    row - 1\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(arrangeCoins(8) == 3)\n    assert(arrangeCoins(15) == 5)\n    assert(arrangeCoins(20) == 5)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "arrangeCoins", "signature": "def arrangeCoins(n: Int): Int =", "docstring": "Given a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "instruction": "Write a Scala function `def arrangeCoins(n: Int): Int =` to solve the following problem:\nGiven a total number of n coins, you plan to arrange them in a staircase pattern. Each row must have exactly the same number of coins as its row index.\nCalculate and return the total number of complete rows that can be formed.\n\n@param n The total number of coins.\n@return The total number of complete rows that can be formed.\n\nExample:\narrangeCoins(5)\nOutput: 2\nExplanation: The third row is incomplete, so return 2.", "level": "easy"}
{"task_id": "Scala/20", "prompt": "class TreeNode(var _value: Int = 0) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\nobject Solution {\n  /**\n   * Calculate the minimum depth of a binary tree.\n   *\n   * The minimum depth is the number of nodes along the shortest path from the root node to\n   * the nearest leaf node.\n   *\n   * @param root The root node of the binary tree.\n   * @return The minimum depth of the tree.\n   *\n   * Examples:\n   * minimumDepth([3,9,20,null,null,15,7])\n   * Output: 2\n   *\n   * minimumDepth([2,null,3,null,4,null,5,null,6])\n   * Output: 5\n   *\n   * Constraints:\n   * - The number of nodes in the tree is in the range [0, 10^5].\n   * - The value of each node is in the range [-1000, 1000].\n   */\n\n  def minimumDepth(root: TreeNode): Int = ", "canonical_solution": "  {\n    if (root == null) {\n      return 0\n    }\n    \n    if (root.left == null && root.right == null) {\n      return 1\n    }\n    \n    if (root.left == null) {\n      return minimumDepth(root.right) + 1\n    }\n    \n    if (root.right == null) {\n      return minimumDepth(root.left) + 1\n    }\n    \n    Math.min(minimumDepth(root.left), minimumDepth(root.right)) + 1\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    val root1 = new TreeNode(3)\n    root1.left = new TreeNode(9)\n    root1.right = new TreeNode(20)\n    root1.right.left = new TreeNode(15)\n    root1.right.right = new TreeNode(7)\n    assert(minimumDepth(root1) == 2)\n    \n    // Test case 2\n    val root2 = new TreeNode(2)\n    root2.right = new TreeNode(3)\n    root2.right.right = new TreeNode(4)\n    root2.right.right.right = new TreeNode(5)\n    root2.right.right.right.right = new TreeNode(6)\n    assert(minimumDepth(root2) == 5)\n    \n    // Test case 3\n    val root3: TreeNode = null\n    assert(minimumDepth(root3) == 0)\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "minimumDepth", "signature": "def minimumDepth(root: TreeNode): Int =", "docstring": "Calculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "instruction": "Write a Scala function `def minimumDepth(root: TreeNode): Int =` to solve the following problem:\nCalculate the minimum depth of a binary tree.\n\nThe minimum depth is the number of nodes along the shortest path from the root node to\nthe nearest leaf node.\n\n@param root The root node of the binary tree.\n@return The minimum depth of the tree.\n\nExamples:\nminimumDepth([3,9,20,null,null,15,7])\nOutput: 2\n\nminimumDepth([2,null,3,null,4,null,5,null,6])\nOutput: 5\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 10^5].\n- The value of each node is in the range [-1000, 1000].", "level": "easy"}
{"task_id": "Scala/21", "prompt": "\nobject Solution {\n  /**\n     * Given a string s, you need to split it into some substrings so that each substring is a palindrome.\n     * Return the minimum number of splits required.\n     *\n     * @param s The input string.\n     * @return The minimum number of splits required.\n     *\n     * Example:\n     * minCut(\"aab\")\n     * Output: 1\n     *\n     * Explanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n     *\n     * Constraints:\n     * - 1 <= s.length <= 2000\n     * - s consists only of lowercase English letters.\n     */\n  def minCut(s: String): Int = ", "canonical_solution": "  {\n\n    val n = s.length\n    val isPalindrome = Array.ofDim[Boolean](n, n)\n    val dp = new Array[Int](n)\n\n    for (i <- 0 until n) {\n      dp(i) = i\n      for (j <- 0 to i) {\n        if (s(i) == s(j) && (i - j <= 1 || isPalindrome(j + 1)(i - 1))) {\n          isPalindrome(j)(i) = true\n          dp(i) = if (j == 0) 0 else Math.min(dp(i), dp(j - 1) + 1)\n        }\n      }\n    }\n\n    dp(n - 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(minCut(\"abcba\") == 0)\n    assert(minCut(\"aabba\") == 1)\n    assert(minCut(\"abbababa\") == 2)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minCut", "signature": "def minCut(s: String): Int =", "docstring": "Given a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "instruction": "Write a Scala function `def minCut(s: String): Int =` to solve the following problem:\nGiven a string s, you need to split it into some substrings so that each substring is a palindrome.\nReturn the minimum number of splits required.\n\n@param s The input string.\n@return The minimum number of splits required.\n\nExample:\nminCut(\"aab\")\nOutput: 1\n\nExplanation: Only one split is required to separate s into [\"aa\", \"b\"], both of which are palindromes.\n\nConstraints:\n- 1 <= s.length <= 2000\n- s consists only of lowercase English letters.", "level": "easy"}
{"task_id": "Scala/22", "prompt": "class TreeNode(val value: Int, var left: TreeNode = null, var right: TreeNode = null)\n\nobject Solution {\n  /**\n    * Check if a binary tree is symmetric.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is symmetric, False otherwise.\n    *\n    * Example:\n    * isSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\n    * Output: true\n    */\n  def isSymmetric(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    def isSymmetricHelper(left: TreeNode, right: TreeNode): Boolean = {\n      if (left == null && right == null)\n        true\n      else if (left == null || right == null)\n        false\n      else if (left.value != right.value)\n        false\n      else\n        isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left)\n    }\n\n    if (root == null)\n      true\n    else\n      isSymmetricHelper(root.left, root.right)\n  }", "test": "def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val root1 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), new TreeNode(4)\n      ),\n      new TreeNode(2,\n        new TreeNode(4), new TreeNode(3)\n      )\n    )\n    assert(isSymmetric(root1))\n\n    // Test Case 2\n    val root2 = new TreeNode(1,\n      new TreeNode(2,\n        null, new TreeNode(3)\n      ),\n      new TreeNode(2,\n        null, new TreeNode(3)\n      )\n    )\n    assert(!isSymmetric(root2))\n\n    // Test Case 3\n    val root3 = new TreeNode(1,\n      new TreeNode(2,\n        new TreeNode(3), null\n      ),\n      new TreeNode(2,\n        new TreeNode(3), null\n      )\n    )\n    assert(!isSymmetric(root3))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "isSymmetric", "signature": "def isSymmetric(root: TreeNode): Boolean =", "docstring": "Check if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "instruction": "Write a Scala function `def isSymmetric(root: TreeNode): Boolean =` to solve the following problem:\nCheck if a binary tree is symmetric.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is symmetric, False otherwise.\n\nExample:\nisSymmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))))\nOutput: true", "level": "middle"}
{"task_id": "Scala/23", "prompt": "object Solution {\n    /**\n     * Find the smallest positive integer b such that the product of all digits of b is equal to a.\n     *\n     * @param a The given integer.\n     * @return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\n     *         is not a 32-bit signed integer, return 0.\n     *\n     * Example:\n     * findSmallestInteger(48)\n     * Output: 68\n     *\n     * Example:\n     * findSmallestInteger(15)\n     * Output: 35\n     */\n  def findSmallestInteger(a: Int): Int = ", "canonical_solution": "  {\n\n    def getProductOfDigits(num: Int): Int = {\n      var product = 1\n      var n = num\n      while (n > 0) {\n        val digit = n % 10\n        product *= digit\n        n /= 10\n      }\n      product\n    }\n\n    for (i <- 1 to Int.MaxValue) {\n      val product = getProductOfDigits(i)\n      if (product == a) {\n        return i\n      }\n    }\n    0\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(findSmallestInteger(48) == 68)\n    assert(findSmallestInteger(15) == 35)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findSmallestInteger", "signature": "def findSmallestInteger(a: Int): Int =", "docstring": "Find the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "instruction": "Write a Scala function `def findSmallestInteger(a: Int): Int =` to solve the following problem:\nFind the smallest positive integer b such that the product of all digits of b is equal to a.\n\n@param a The given integer.\n@return The smallest integer b whose product of digits is equal to a. If no such number exists or the result\nis not a 32-bit signed integer, return 0.\n\nExample:\nfindSmallestInteger(48)\nOutput: 68\n\nExample:\nfindSmallestInteger(15)\nOutput: 35", "level": "easy"}
{"task_id": "Scala/24", "prompt": "object Solution {\n    /**\n     * Calculate the sum of the digits in a number with assigned signs.\n     *\n     * @param n The input number.\n     * @return The sum of the digits with assigned signs.\n     *\n     * Example:\n     * signSum(521)\n     * Output: 4\n     */\n  def signSum(n: Int): Int = ", "canonical_solution": "  {\n\n    val sign = if (n >= 0) 1 else -1\n    val absolute = n.abs\n    var sum = 0\n    var num = absolute\n\n    while (num > 0) {\n      val digit = num % 10\n      sum += sign * digit\n      num /= 10\n    }\n\n    sum\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(signSum(123) == 6)\n    assert(signSum(-456) == -15)\n    assert(signSum(789) == 24)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "signSum", "signature": "def signSum(n: Int): Int =", "docstring": "Calculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "instruction": "Write a Scala function `def signSum(n: Int): Int =` to solve the following problem:\nCalculate the sum of the digits in a number with assigned signs.\n\n@param n The input number.\n@return The sum of the digits with assigned signs.\n\nExample:\nsignSum(521)\nOutput: 4", "level": "easy"}
{"task_id": "Scala/25", "prompt": "\nobject Solution {\n    /**\n    * Returns the elements of the matrix in clockwise spiral order.\n    *\n    * @param matrix The input matrix.\n    * @return The elements of the matrix in spiral order.\n    *\n    * Example:\n    * spiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\n    * Output: List(1, 2, 3, 6, 9, 8, 7, 4, 5)\n    */\n  def spiralOrder(matrix: Array[Array[Int]]): List[Int] = ", "canonical_solution": "  {\n  \n       \n       // Function implementation to be filled\n    if (matrix == null || matrix.length == 0 || matrix(0).length == 0) {\n      return List()\n    }\n\n    val m = matrix.length\n    val n = matrix(0).length\n    val result = scala.collection.mutable.ListBuffer[Int]()\n    var top = 0\n    var bottom = m - 1\n    var left = 0\n    var right = n - 1\n\n    while (result.length < m * n) {\n      // Traverse top row\n      for (i <- left to right if result.length < m * n) {\n        result += matrix(top)(i)\n      }\n      top += 1\n\n      // Traverse right column\n      for (i <- top to bottom if result.length < m * n) {\n        result += matrix(i)(right)\n      }\n      right -= 1\n\n      // Traverse bottom row\n      for (i <- right to left by -1 if result.length < m * n) {\n        result += matrix(bottom)(i)\n      }\n      bottom -= 1\n\n      // Traverse left column\n      for (i <- bottom to top by -1 if result.length < m * n) {\n        result += matrix(i)(left)\n      }\n      left += 1\n    }\n\n    result.toList\n  }", "test": "  def main(args: Array[String]): Unit = {\n    val matrix1 = Array(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))\n    val result1 = spiralOrder(matrix1)\n    assert(result1 == List(1, 2, 3, 6, 9, 8, 7, 4, 5))\n\n    val matrix2 = Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12))\n    val result2 = spiralOrder(matrix2)\n    assert(result2 == List(1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7))\n\n    val matrix3 = Array(Array(1, 2, 3, 4, 5), Array(6, 7, 8, 9, 10), Array(11, 12, 13, 14, 15))\n    val result3 = spiralOrder(matrix3)\n    assert(result3 == List(1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "spiralOrder", "signature": "def spiralOrder(matrix: Array[Array[Int]]): List[Int] =", "docstring": "Returns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "instruction": "Write a Scala function `def spiralOrder(matrix: Array[Array[Int]]): List[Int] =` to solve the following problem:\nReturns the elements of the matrix in clockwise spiral order.\n\n@param matrix The input matrix.\n@return The elements of the matrix in spiral order.\n\nExample:\nspiralOrder(Array(Array(1,2,3),Array(4,5,6),Array(7,8,9)))\nOutput: List(1, 2, 3, 6, 9, 8, 7, 4, 5)", "level": "hard"}
{"task_id": "Scala/26", "prompt": "class TreeNode(var value: Int, var left: TreeNode = null, var right: TreeNode = null)\nobject Solution {\n  /**\n    * Determine if a given binary tree is a univalued tree.\n    *\n    * @param root The root node of the binary tree.\n    * @return True if the binary tree is a univalued tree, False otherwise.\n    *\n    * Example:\n    * isUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\n    * Output: true\n    *\n    * isUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\n    * Output: false\n    */\n  def isUnivalTree(root: TreeNode): Boolean = ", "canonical_solution": "  {\n\n    if (root == null) {\n      true\n    } else {\n      val value = root.value\n      isUnival(root.left, value) && isUnival(root.right, value)\n    }\n  }\n\n  def isUnival(node: TreeNode, value: Int): Boolean = {\n    if (node == null) {\n      true\n    } else if (node.value != value) {\n      false\n    } else {\n      isUnival(node.left, value) && isUnival(node.right, value)\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test Case 1\n    val tree1 = new TreeNode(2)\n    tree1.left = new TreeNode(2)\n    tree1.left.left = new TreeNode(2)\n    tree1.left.left.left = new TreeNode(5)\n    tree1.left.left.right = new TreeNode(2)\n    assert(!isUnivalTree(tree1))  // Output: false\n\n    // Test Case 2\n    val tree2 = new TreeNode(1)\n    tree2.left = new TreeNode(1)\n    tree2.left.left = new TreeNode(1)\n    tree2.left.right = new TreeNode(1)\n    tree2.right = new TreeNode(1)\n    tree2.right.right = new TreeNode(1)\n    assert(isUnivalTree(tree2))  // Output: true\n\n    // Test Case 3\n    val tree3 = new TreeNode(3)\n    tree3.left = new TreeNode(3)\n    tree3.right = new TreeNode(3)\n    assert(isUnivalTree(tree3))  // Output: true\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "isUnivalTree", "signature": "def isUnivalTree(root: TreeNode): Boolean =", "docstring": "Determine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "instruction": "Write a Scala function `def isUnivalTree(root: TreeNode): Boolean =` to solve the following problem:\nDetermine if a given binary tree is a univalued tree.\n\n@param root The root node of the binary tree.\n@return True if the binary tree is a univalued tree, False otherwise.\n\nExample:\nisUnivalTree(TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1)), TreeNode(1, null, TreeNode(1))))\nOutput: true\n\nisUnivalTree(TreeNode(2, TreeNode(2, TreeNode(2, TreeNode(5), TreeNode(2))), null))\nOutput: false", "level": "easy"}
{"task_id": "Scala/27", "prompt": "object Solution {\n    /**\n     * Remove the trailing zeros from a given integer represented as a string.\n     *\n     * @param num The string representation of the integer.\n     * @return The integer with trailing zeros removed represented as a string.\n     *\n     * Example:\n     * removeTrailingZeros(\"51230100\")\n     * Output: \"512301\"\n     *\n     * removeTrailingZeros(\"123\")\n     * Output: \"123\"\n     */\n  def removeTrailingZeros(num: String): String = ", "canonical_solution": "  {\n\n    var index = num.length - 1\n    while (index >= 0 && num.charAt(index) == '0') {\n      index -= 1\n    }\n    num.substring(0, index + 1)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(removeTrailingZeros(\"51230100\") == \"512301\")\n    assert(removeTrailingZeros(\"123\") == \"123\")\n    assert(removeTrailingZeros(\"1000010\") == \"100001\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "removeTrailingZeros", "signature": "def removeTrailingZeros(num: String): String =", "docstring": "Remove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "instruction": "Write a Scala function `def removeTrailingZeros(num: String): String =` to solve the following problem:\nRemove the trailing zeros from a given integer represented as a string.\n\n@param num The string representation of the integer.\n@return The integer with trailing zeros removed represented as a string.\n\nExample:\nremoveTrailingZeros(\"51230100\")\nOutput: \"512301\"\n\nremoveTrailingZeros(\"123\")\nOutput: \"123\"", "level": "easy"}
{"task_id": "Scala/28", "prompt": "object Solution {\n  /**\n    * Check if the binary string contains at most one segment of consecutive '1's.\n    *\n    * @param s The input binary string.\n    * @return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n    *\n    * Example:\n    * checkOnesSegment(\"1001\")\n    * Output: false\n    *\n    * Example:\n    * checkOnesSegment(\"110\")\n    * Output: true\n    */\n  def checkOnesSegment(s: String): Boolean = ", "canonical_solution": "  {\n    var count = 0\n    for (i <- 0 until s.length) {\n      if (s.charAt(i) == '1') {\n        count += 1\n        if (count > 1) {\n          return false\n        }\n      } else {\n        count = 0\n      }\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(checkOnesSegment(\"10101\") == true)\n    assert(checkOnesSegment(\"111000\") == false)\n    assert(checkOnesSegment(\"100111000\") == false)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "checkOnesSegment", "signature": "def checkOnesSegment(s: String): Boolean =", "docstring": "Check if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "instruction": "Write a Scala function `def checkOnesSegment(s: String): Boolean =` to solve the following problem:\nCheck if the binary string contains at most one segment of consecutive '1's.\n\n@param s The input binary string.\n@return True if the binary string contains at most one segment of consecutive '1's, false otherwise.\n\nExample:\ncheckOnesSegment(\"1001\")\nOutput: false\n\nExample:\ncheckOnesSegment(\"110\")\nOutput: true", "level": "easy"}
{"task_id": "Scala/29", "prompt": "object Solution {\n/**\n * Computes the minimum cost of merging N piles of sand into one pile. \n * The cost of merging two adjacent piles is the sum of their sizes. \n * The function aims to find a merge strategy that minimizes the total cost.\n *\n * @param sandPiles An array of integers representing the sizes of each sand pile.\n * @return The minimum total cost of merging all piles into one.\n *\n * Example:\n * minMergeCost(Array(1, 3, 5, 2))\n * Output: 22\n * \n * Explanation:\n * Merging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9), \n * and finally merging the last two piles (cost = 11), results in a total cost of 22.\n */\n\ndef minMergeCost(sandPiles: Array[Int]): Int = ", "canonical_solution": "{\n  val n = sandPiles.length\n  val prefixSum = new Array[Int](n + 1)\n  val dp = Array.ofDim[Int](n, n)\n\n  for (i <- 1 to n) {\n    prefixSum(i) = prefixSum(i - 1) + sandPiles(i - 1)\n  }\n\n  for (length <- 2 to n) {\n    for (left <- 0 to n - length) {\n      val right = left + length - 1\n      dp(left)(right) = Int.MaxValue\n      for (k <- left until right) {\n        val cost = dp(left)(k) + dp(k + 1)(right) + prefixSum(right + 1) - prefixSum(left)\n        dp(left)(right) = dp(left)(right) min cost\n      }\n    }\n  }\n\n  dp(0)(n - 1)\n}", "test": "  def main(args: Array[String]): Unit = {\n    assert(minMergeCost(Array(1, 3, 5, 2)) == 22)\n    assert(minMergeCost(Array(4, 3, 3)) == 16)\n    assert(minMergeCost(Array(10, 20, 30)) == 90)\n    assert(minMergeCost(Array(3, 4, 3, 9, 6, 7, 8, 10 )) == 147)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minMergeCost", "signature": "def minMergeCost(sandPiles: Array[Int]): Int =", "docstring": "Computes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "instruction": "Write a Scala function `def minMergeCost(sandPiles: Array[Int]): Int =` to solve the following problem:\nComputes the minimum cost of merging N piles of sand into one pile.\nThe cost of merging two adjacent piles is the sum of their sizes.\nThe function aims to find a merge strategy that minimizes the total cost.\n\n@param sandPiles An array of integers representing the sizes of each sand pile.\n@return The minimum total cost of merging all piles into one.\n\nExample:\nminMergeCost(Array(1, 3, 5, 2))\nOutput: 22\n\nExplanation:\nMerging piles 1 and 2 first (cost = 4), then merging the result with pile 3 (cost = 9),\nand finally merging the last two piles (cost = 11), results in a total cost of 22.", "level": "middle"}
{"task_id": "Scala/30", "prompt": "/**\n * Sorts an array of names in alphabetical order.\n * This function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\n * It is assumed that each name is a non-empty string consisting of alphabetic characters.\n *\n * Example:\n * >>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\n * Array(\"Apple\", \"Green\", \"Jack\", \"Tom\")\n */\n object Solution {\n def sortNames(names: Array[String]): Array[String] = ", "canonical_solution": " {\n  names.sorted\n}", "test": "  def main(args: Array[String]): Unit = {\n    val names = Array(\"Apple\", \"Tom\", \"Green\", \"Jack\")\n    val sortedNames = sortNames(names)\n    assert(sortedNames.sameElements(Array(\"Apple\", \"Green\", \"Jack\", \"Tom\")))\n\n    val moreNames = Array(\"Banana\", \"Zebra\", \"Elephant\", \"Crocodile\")\n    val sortedMoreNames = sortNames(moreNames)\n    assert(sortedMoreNames.sameElements(Array(\"Banana\", \"Crocodile\", \"Elephant\", \"Zebra\")))\n }\n }", "entry_point": "sortNames", "signature": "def sortNames(names: Array[String]): Array[String] =", "docstring": "Sorts an array of names in alphabetical order.\nThis function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\nIt is assumed that each name is a non-empty string consisting of alphabetic characters.\n\nExample:\n>>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\nArray(\"Apple\", \"Green\", \"Jack\", \"Tom\")", "instruction": "Write a Scala function `def sortNames(names: Array[String]): Array[String] =` to solve the following problem:\nSorts an array of names in alphabetical order.\nThis function takes an array of names as an input and returns a new array with the names sorted in alphabetical order.\nIt is assumed that each name is a non-empty string consisting of alphabetic characters.\n\nExample:\n>>> sortNames(Array(\"Apple\", \"Tom\", \"Green\", \"Jack\"))\nArray(\"Apple\", \"Green\", \"Jack\", \"Tom\")", "level": "easy"}
{"task_id": "Scala/31", "prompt": "\nobject Solution {\n  /**\n  * Reverse the given string based on the following rules:\n  * - Keep all non-alphabetic characters in their original positions.\n  * - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  *\n  * @param s The input string.\n  * @return The reversed string.\n  *\n  * Example:\n  * reverseString(\"ab-cd\")\n  * Output: \"dc-ba\"\n  */\n  def reverseString(s: String): String = ", "canonical_solution": "  {\n \n    val stack = s.filter(_.isLetter).reverse\n      var index = 0\n\n      s.map { c =>\n        if (c.isLetter) {\n          val res = stack(index)\n          index += 1\n          res\n        } else c\n      }.mkString\n    }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"ab-cd\") == \"dc-ba\")\n    assert(reverseString(\"a-bC-dEf-ghIj\") == \"j-Ih-gfE-dCba\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String): String =", "docstring": "Reverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "instruction": "Write a Scala function `def reverseString(s: String): String =` to solve the following problem:\nReverse the given string based on the following rules:\n   - Keep all non-alphabetic characters in their original positions.\n   - Reverse the positions of all alphabetic characters (both lowercase and uppercase).\n  \n   @param s The input string.\n   @return The reversed string.\n  \n   Example:\n   reverseString(\"ab-cd\")\n   Output: \"dc-ba\"", "level": "easy"}
{"task_id": "Scala/32", "prompt": "object Solution {\n    /**\n       * Calculate the maximum number of consecutive 1s in a binary array.\n       *\n       * @param nums The binary array.\n       * @return The maximum number of consecutive 1s.\n       *\n       * Example:\n       * findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\n       * Output: 3\n       */\n  def findMaxConsecutiveOnes(nums: Array[Int]): Int = ", "canonical_solution": "  {\n\n       var maxConsecutiveOnes = 0\n      var currentCount = 0\n      for (num <- nums) {\n          if (num == 1) {\n              currentCount += 1\n              maxConsecutiveOnes = Math.max(currentCount, maxConsecutiveOnes)\n          } else {\n              currentCount = 0\n          }\n      }\n      maxConsecutiveOnes\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    //test case 1\n    assert(findMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1, 0, 0, 1, 1)) == 3)\n    \n    //test case 2\n    assert(findMaxConsecutiveOnes(Array(0, 0, 0)) == 0)\n    \n    //test case 3\n    assert(findMaxConsecutiveOnes(Array(1, 1, 1, 1, 1)) == 5)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "findMaxConsecutiveOnes", "signature": "def findMaxConsecutiveOnes(nums: Array[Int]): Int =", "docstring": "Calculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "instruction": "Write a Scala function `def findMaxConsecutiveOnes(nums: Array[Int]): Int =` to solve the following problem:\nCalculate the maximum number of consecutive 1s in a binary array.\n\n@param nums The binary array.\n@return The maximum number of consecutive 1s.\n\nExample:\nfindMaxConsecutiveOnes(Array(1, 1, 0, 1, 1, 1))\nOutput: 3", "level": "easy"}
{"task_id": "Scala/33", "prompt": "object Solution {\n  /**\n     * Rearrange the numbers in the array to form the largest possible integer.\n     *\n     * @param nums An array of non-negative integers.\n     * @return The largest possible integer formed by rearranging the numbers.\n     *\n     * Example:\n     * largestNumber(Array(10, 2))\n     * Output: \"210\"\n     *\n     * largestNumber(Array(3, 30, 34, 5, 9))\n     * Output: \"9534330\"\n     */\n  def largestNumber(nums: Array[Int]): String = ", "canonical_solution": "  {\n    // Convert the integers to strings for comparison\n    val strNums = nums.map(_.toString)\n    // Define a custom sort function that compares two strings by concatenating them in different orders\n    val sortedNums = strNums.sortWith((a, b) => (a + b) > (b + a))\n    // Combine the sorted strings. If the highest number is '0', return '0' (to avoid leading zeros)\n    if (sortedNums.head == \"0\") \"0\" else sortedNums.mkString(\"\")\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(largestNumber(Array(10, 2)) == \"210\")\n    assert(largestNumber(Array(3, 30, 34, 5, 9)) == \"9534330\")\n    // additional test cases \n    assert(largestNumber(Array(1, 34, 3, 98, 9, 76, 45, 4)) == \"998764543431\")\n    assert(largestNumber(Array(54, 546, 548, 60)) == \"6054854654\")\n    assert(largestNumber(Array(1, 34, 3, 98, 34, 3, 667, 66)) == \"98667663434331\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "largestNumber", "signature": "def largestNumber(nums: Array[Int]): String =", "docstring": "Rearrange the numbers in the array to form the largest possible integer.\n\n@param nums An array of non-negative integers.\n@return The largest possible integer formed by rearranging the numbers.\n\nExample:\nlargestNumber(Array(10, 2))\nOutput: \"210\"\n\nlargestNumber(Array(3, 30, 34, 5, 9))\nOutput: \"9534330\"", "instruction": "Write a Scala function `def largestNumber(nums: Array[Int]): String =` to solve the following problem:\nRearrange the numbers in the array to form the largest possible integer.\n\n@param nums An array of non-negative integers.\n@return The largest possible integer formed by rearranging the numbers.\n\nExample:\nlargestNumber(Array(10, 2))\nOutput: \"210\"\n\nlargestNumber(Array(3, 30, 34, 5, 9))\nOutput: \"9534330\"", "level": "middle"}
{"task_id": "Scala/34", "prompt": "\nobject Solution {\n    /**\n       * Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n       *\n       * @param nums An array of integers.\n       * @return None (In-place modification of the input array).\n       *\n       * Example:\n       * moveZeroes(Array(0, 1, 0, 3, 12))\n       * Output: Array(1, 3, 12, 0, 0)\n       */\n  def moveZeroes(nums: Array[Int]): Unit = ", "canonical_solution": "  {\n\n       var position = 0\n        for (i <- nums.indices) {\n            if(nums(i) != 0){\n                nums(position) = nums(i)\n                position += 1\n            }\n        }\n        for (i <- position until nums.length) {\n            nums(i) = 0\n        }\n    }", "test": "  def main(args: Array[String]): Unit = {\n    val nums1 = Array(1,0,2,0,3)\n    Solution.moveZeroes(nums1)\n    assert(nums1 sameElements Array(1,2,3,0,0))\n\n    val nums2 = Array(0,0,0,1,2)\n    Solution.moveZeroes(nums2)\n    assert(nums2 sameElements Array(1,2,0,0,0))\n\n    val nums3 = Array(1,2,3,0,0)\n    Solution.moveZeroes(nums3)\n    assert(nums3 sameElements Array(1,2,3,0,0))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveZeroes", "signature": "def moveZeroes(nums: Array[Int]): Unit =", "docstring": "Move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "instruction": "Write a Scala function `def moveZeroes(nums: Array[Int]): Unit =` to solve the following problem:\nMove all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n@param nums An array of integers.\n@return None (In-place modification of the input array).\n\nExample:\nmoveZeroes(Array(0, 1, 0, 3, 12))\nOutput: Array(1, 3, 12, 0, 0)", "level": "easy"}
{"task_id": "Scala/35", "prompt": "object Solution {\n  /**\n    * Check if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n    *\n    * @param s The binary string.\n    * @param n The positive integer.\n    * @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n    *\n    * Example:\n    * queryString(\"0110\", 3)\n    * Output: true\n    */\n  def queryString(s: String, n: Int): Boolean = ", "canonical_solution": "  {\n\n       (1 to n).forall(i => s.contains(i.toBinaryString))\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    assert(queryString(\"0110\", 3))\n    assert(!queryString(\"0110\", 4))\n    assert(queryString(\"1111000101\", 5))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "queryString", "signature": "def queryString(s: String, n: Int): Boolean =", "docstring": "Check if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n\n @param s The binary string.\n @param n The positive integer.\n @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n\n Example:\n queryString(\"0110\", 3)\n Output: true", "instruction": "Write a Scala function `def queryString(s: String, n: Int): Boolean =` to solve the following problem:\nCheck if every integer in the range [1, n] has a binary representation that is a substring of the given binary string.\n\n @param s The binary string.\n @param n The positive integer.\n @return True if every integer in the range [1, n] has a binary representation that is a substring of the given binary string, false otherwise.\n\n Example:\n queryString(\"0110\", 3)\n Output: true", "level": "easy"}
{"task_id": "Scala/36", "prompt": "\nobject Solution {\n      /**\n       * Count the number of palindrome substrings in a given string.\n       *\n       * @param s The input string.\n       * @return The number of palindrome substrings.\n       *\n       * Example:\n       * countPalindromeSubstrings(\"abc\")\n       * Output: 3\n       *\n       * Example:\n       * countPalindromeSubstrings(\"aaa\")\n       * Output: 6\n       */\n  def countPalindromeSubstrings(s: String): Int = ", "canonical_solution": "  {\n\n       var count = 0\n      for(i <- 0 until s.length){\n        // Odd length palindromes\n        count += countPalindromesAroundCenter(s, i, i)\n        \n        // Even length palindromes\n        count += countPalindromesAroundCenter(s, i, i+1)\n      }\n      count\n    }\n  \n  private def countPalindromesAroundCenter(s: String, left: Int, right: Int): Int = {\n    var count = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s(l) == s(r)){\n      count += 1\n      l -= 1\n      r += 1\n    }\n    count\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countPalindromeSubstrings(\"abc\") == 3)\n    assert(countPalindromeSubstrings(\"aaa\") == 6)\n    assert(countPalindromeSubstrings(\"abba\") == 6)\n    assert(countPalindromeSubstrings(\"abcd\") == 4)\n    assert(countPalindromeSubstrings(\"aabbccd\") == 10)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPalindromeSubstrings", "signature": "def countPalindromeSubstrings(s: String): Int =", "docstring": "Count the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "instruction": "Write a Scala function `def countPalindromeSubstrings(s: String): Int =` to solve the following problem:\nCount the number of palindrome substrings in a given string.\n\n @param s The input string.\n @return The number of palindrome substrings.\n\n Example:\n countPalindromeSubstrings(\"abc\")\n Output: 3\n\n Example:\n countPalindromeSubstrings(\"aaa\")\n Output: 6", "level": "middle"}
{"task_id": "Scala/37", "prompt": "object Solution {\n  case class ListNode(var value: Int, var next: ListNode = null)\n  /**\n    * Remove the nth node from the end of a linked list and return the head of the modified list.\n    *\n    * @param head The head of the linked list.\n    * @param n The position of the node to be removed from the end of the list.\n    * @return The head of the modified list.\n    *\n    * Example:\n    * removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n    * Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))\n    */\n  def removeNthFromEnd(head: ListNode, n: Int): ListNode = ", "canonical_solution": "  {\n\n    val dummy = ListNode(0)\n    dummy.next = head\n    var first = dummy\n    var second = dummy\n    for (_ <- 1 to n + 1) {\n      first = first.next\n    }\n    while (first != null) {\n      first = first.next\n      second = second.next\n    }\n    second.next = second.next.next\n    dummy.next\n  }\n\n  def listToString(head: ListNode): String = {\n    val sb = new StringBuilder()\n    var node = head\n    while(node != null) {\n      sb ++= node.value.toString\n      if (node.next != null) {\n        sb ++= \"->\"\n      }\n      node = node.next\n    }\n    sb.toString()\n  }\n\n  def createList(array: Array[Int]): ListNode = {\n    val dummy = ListNode(0)\n    var current = dummy\n    array.foreach { value =>\n      current.next = ListNode(value)\n      current = current.next\n    }\n    dummy.next\n  }", "test": "  def main(args: Array[String]): Unit = {\n  // Test cases\n  val test1 = createList(Array(1, 2, 3, 4, 5))\n  assert(listToString(removeNthFromEnd(test1, 2)) == \"1->2->3->5\")\n\n  val test2 = createList(Array(1))\n  assert(listToString(removeNthFromEnd(test2, 1)) == \"\")\n\n  val test3 = createList(Array(1, 2))\n  assert(listToString(removeNthFromEnd(test3, 1)) == \"1\")\n\n  println(\"All tests passed\")}\n}", "entry_point": "removeNthFromEnd", "signature": "def removeNthFromEnd(head: ListNode, n: Int): ListNode =", "docstring": "Remove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "instruction": "Write a Scala function `def removeNthFromEnd(head: ListNode, n: Int): ListNode =` to solve the following problem:\nRemove the nth node from the end of a linked list and return the head of the modified list.\n\n @param head The head of the linked list.\n @param n The position of the node to be removed from the end of the list.\n @return The head of the modified list.\n\n Example:\n removeNthFromEnd(ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))), 2)\n Output: ListNode(1, ListNode(2, ListNode(3, ListNode(5))))", "level": "hard"}
{"task_id": "Scala/38", "prompt": "\nobject Solution {\n/**\n  * Count the number of integers with unique digits from 0 to 10^n.\n  *\n  * @param n The number of digits.\n  * @return The count of integers with unique digits.\n  *\n  * Example:\n  * countNumbersWithUniqueDigits(2)\n  * Output: 91\n  *\n  * Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n  * The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n  *\n  * countNumbersWithUniqueDigits(0)\n  * Output: 1\n  *\n  * Explanation: When n is 0, there is only one number, which is 0 itself.\n  */\n  def countNumbersWithUniqueDigits(n: Int): Int = ", "canonical_solution": "  {\n\n    if (n == 0) return 1\n    var uniqueDigits = 9\n    var availableNumbers = 9\n    var totalCount = 10 // For n = 1, all numbers 0-9 are unique\n\n    for (i <- 2 to n if availableNumbers > 0) {\n      uniqueDigits *= availableNumbers\n      totalCount += uniqueDigits\n      availableNumbers -= 1\n    }\n\n    totalCount\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(countNumbersWithUniqueDigits(1) == 10, \"Test case 1 failed\")\n    assert(countNumbersWithUniqueDigits(3) == 739, \"Test case 2 failed\")\n    assert(countNumbersWithUniqueDigits(4) == 5275, \"Test case 3 failed\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countNumbersWithUniqueDigits", "signature": "def countNumbersWithUniqueDigits(n: Int): Int =", "docstring": "Count the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "instruction": "Write a Scala function `def countNumbersWithUniqueDigits(n: Int): Int =` to solve the following problem:\nCount the number of integers with unique digits from 0 to 10^n.\n\n @param n The number of digits.\n @return The count of integers with unique digits.\n\n Example:\n countNumbersWithUniqueDigits(2)\n Output: 91\n\n Explanation: The answer should be the count of all numbers between 0 and 100 (exclusive) that have unique digits.\n The numbers 11, 22, 33, 44, 55, 66, 77, 88, and 99 should be excluded.\n\n countNumbersWithUniqueDigits(0)\n Output: 1\n\n Explanation: When n is 0, there is only one number, which is 0 itself.", "level": "easy"}
{"task_id": "Scala/39", "prompt": "import scala.annotation.tailrec\n\nobject Solution {\n    class ListNode(var x: Int) {\n    var next: ListNode = null\n  }\n    /**\n      * Swap every two adjacent nodes in a linked list and return its head.\n      *\n      * @param head The head node of the linked list.\n      * @return The head node of the linked list after swapping adjacent nodes.\n      *\n      * Example:\n      * swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n      * swapPairs(null) should return null\n      * swapPairs(ListNode(1)) should return ListNode(1)\n      */\n  def swapPairs(head: ListNode): ListNode = ", "canonical_solution": "  {\n\n       val dummy = new ListNode(-1)\n        dummy.next = head\n\n        @tailrec\n        def swap(current: ListNode): Unit = {\n          if (current.next != null && current.next.next != null) {\n            val first = current.next\n            val second = current.next.next\n            first.next = second.next\n            second.next = first\n            current.next = second\n            swap(first)\n          }\n        }\n\n        swap(dummy)\n        dummy.next\n      }\n    def createList(nums: Array[Int]): ListNode = {\n      val dummy = new ListNode(-1)\n      var current = dummy\n      nums.foreach { num =>\n        current.next = new ListNode(num)\n        current = current.next\n      }\n    dummy.next\n  }\n\n  def listToString(node: ListNode): String = {\n    val sb = new StringBuilder\n    var current = node\n    while (current != null) {\n      sb.append(current.x)\n      if (current.next != null) sb.append(\"->\")\n      current = current.next\n    }\n    sb.toString()\n  }\n\n", "test": "    def main(args: Array[String]): Unit = {\n    // Test cases\n    val test1 = createList(Array(5, 6, 7, 8))\n    assert(listToString(swapPairs(test1)) == \"6->5->8->7\")\n\n    val test2 = createList(Array())\n    assert(listToString(swapPairs(test2)) == \"\")\n\n    val test3 = createList(Array(9))\n    assert(listToString(swapPairs(test3)) == \"9\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "swapPairs", "signature": "def swapPairs(head: ListNode): ListNode =", "docstring": "Swap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "instruction": "Write a Scala function `def swapPairs(head: ListNode): ListNode =` to solve the following problem:\nSwap every two adjacent nodes in a linked list and return its head.\n\n @param head The head node of the linked list.\n @return The head node of the linked list after swapping adjacent nodes.\n\n Example:\n swapPairs(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) should return ListNode(2, ListNode(1, ListNode(4, ListNode(3))))\n swapPairs(null) should return null\n swapPairs(ListNode(1)) should return ListNode(1)", "level": "hard"}
{"task_id": "Scala/40", "prompt": "import scala.collection.mutable.{Queue, ListBuffer}\n\nclass TreeNode(var _value: Int) {\n  var value: Int = _value\n  var left: TreeNode = null\n  var right: TreeNode = null\n}\n\nobject Solution {\n  /**\n    * Return the level order traversal of a binary tree.\n    *\n    \n    * @param root The root node of the binary tree.\n    * @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n    *\n    * Example:\n    * levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n    * Output: List(List(3), List(9, 20), List(15, 7))\n    */\n  def levelOrder(root: TreeNode): List[List[Int]] = ", "canonical_solution": "  {\n\n       var result = List[List[Int]]()\n    if (root == null) return result\n    \n    val queue: Queue[TreeNode] = Queue()\n    queue.enqueue(root)\n    \n    while (queue.nonEmpty) {\n      val levelSize = queue.size\n      val level: ListBuffer[Int] = ListBuffer()\n      \n      for (_ <- 0 until levelSize) {\n        val current = queue.dequeue()\n        level += current.value\n\n        if (current.left != null) {\n          queue.enqueue(current.left)\n        }\n        if (current.right != null) {\n          queue.enqueue(current.right)\n        }\n      }\n      \n      result = result :+ level.toList\n    }\n    \n    result\n  }\n  ", "test": "  def main(args: Array[String]): Unit = {\n    // Test cases\n    val example1 = new TreeNode(1)\n    example1.left = new TreeNode(2)\n    example1.right = new TreeNode(3)\n\n    assert(levelOrder(example1) == List(List(1), List(2, 3)))\n\n    val example2 = new TreeNode(4)\n    example2.left = new TreeNode(2)\n    example2.right = new TreeNode(6)\n    example2.left.left = new TreeNode(1)\n    example2.left.right = new TreeNode(3)\n    example2.right.left = new TreeNode(5)\n    example2.right.right = new TreeNode(7)\n\n    assert(levelOrder(example2) == List(List(4), List(2, 6), List(1, 3, 5, 7)))\n    \n    val example3 = new TreeNode(8)\n\n    assert(levelOrder(example3) == List(List(8)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "levelOrder", "signature": "def levelOrder(root: TreeNode): List[List[Int]] =", "docstring": "Return the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "instruction": "Write a Scala function `def levelOrder(root: TreeNode): List[List[Int]] =` to solve the following problem:\nReturn the level order traversal of a binary tree.\n\n    \n @param root The root node of the binary tree.\n @return The level order traversal as a list of lists, where each inner list represents a level of the tree.\n\n Example:\n levelOrder(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))\n Output: List(List(3), List(9, 20), List(15, 7))", "level": "hard"}
{"task_id": "Scala/41", "prompt": "\nobject Solution {\n/**\n  * Count the number of prime numbers less than a non-negative integer n.\n  *\n  * @param n The non-negative integer.\n  * @return The number of prime numbers less than n.\n  *\n  * Example:\n  * countPrimes(10)\n  * Output: 4\n  *\n  * Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.\n  */\n  def countPrimes(n: Int): Int = ", "canonical_solution": "  {\n\n     if (n <= 2) 0\n    else {\n      val isPrime = Array.fill(n)(true)\n      for {\n        i <- 2 until math.sqrt(n).toInt + 1 if isPrime(i)\n        j <- i * i until n by i\n      } {\n        isPrime(j) = false\n      }\n      isPrime.count(_ == true) - 2 // Subtract 2 because 0 and 1 are not primes\n    }\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Additional test cases\n    assert(countPrimes(15) == 6)\n    assert(countPrimes(30) == 10)\n    assert(countPrimes(50) == 15)\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrimes", "signature": "def countPrimes(n: Int): Int =", "docstring": "Count the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "instruction": "Write a Scala function `def countPrimes(n: Int): Int =` to solve the following problem:\nCount the number of prime numbers less than a non-negative integer n.\n\n @param n The non-negative integer.\n @return The number of prime numbers less than n.\n\n Example:\n countPrimes(10)\n Output: 4\n\n Explanation: There are 4 prime numbers less than 10, which are 2, 3, 5, and 7.", "level": "easy"}
{"task_id": "Scala/42", "prompt": "\nobject Solution {\n  /**\n    * Check if the binary representation of a positive integer has alternating bits.\n    *\n    * @param n The positive integer to check.\n    * @return True if the binary representation has alternating bits, false otherwise.\n    *\n    * Example:\n    * hasAlternatingBits(5)\n    * Output: true\n    */\n  def hasAlternatingBits(n: Int): Boolean = ", "canonical_solution": "  {\n\n    val binaryString = n.toBinaryString\n    for (i <- 0 until binaryString.length - 1) {\n      if (binaryString(i) == binaryString(i + 1)) return false\n    }\n    true\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hasAlternatingBits(10)) // Binary representation of 10 is 1010 which has alternating bits\n    assert(!hasAlternatingBits(7)) // Binary representation of 7 is 111 which does not have alternating bits\n    assert(hasAlternatingBits(21)) // Binary representation of 21 is 10101 which has alternating bits\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "hasAlternatingBits", "signature": "def hasAlternatingBits(n: Int): Boolean =", "docstring": "Check if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "instruction": "Write a Scala function `def hasAlternatingBits(n: Int): Boolean =` to solve the following problem:\nCheck if the binary representation of a positive integer has alternating bits.\n\n @param n The positive integer to check.\n @return True if the binary representation has alternating bits, false otherwise.\n\n Example:\n hasAlternatingBits(5)\n Output: true", "level": "easy"}
{"task_id": "Scala/43", "prompt": "import scala.collection.mutable.ArrayBuffer\n\nobject Solution {\n  /**\n    * Move all even elements to the front of the array, followed by all odd elements.\n    *\n    * @param nums An array of integers.\n    * @return The modified array with even elements in the front and odd elements at the end.\n    *\n    * Example:\n    * moveEvenOdd(Array(3, 1, 2, 4))\n    * Output: Array(2, 4, 3, 1)\n    *\n    * Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).\n    */\n  def moveEvenOdd(nums: Array[Int]): Array[Int] = ", "canonical_solution": "  {\n\n       // Separate the even and odd numbers using two ArrayBuffer instances\n    val evens = ArrayBuffer[Int]()\n    val odds =  ArrayBuffer[Int]()\n\n    // Iterate through the numbers and add them to the respective ArrayBuffer\n    nums.foreach { num =>\n      if (num % 2 == 0) evens += num else odds += num\n    }\n\n    // Concatenate the even and odd numbers\n    (evens ++ odds).toArray\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(moveEvenOdd(Array(5, 8, 3, 6)).sameElements(Array(8, 6, 5, 3)))\n\n    // Test case 2\n    assert(moveEvenOdd(Array(7, 2)).sameElements(Array(2, 7)))\n\n    // Test case 3\n    assert(moveEvenOdd(Array(9, 1, 4, 7, 6)).sameElements(Array(4, 6, 9, 1, 7)))\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "moveEvenOdd", "signature": "def moveEvenOdd(nums: Array[Int]): Array[Int] =", "docstring": "Move all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "instruction": "Write a Scala function `def moveEvenOdd(nums: Array[Int]): Array[Int] =` to solve the following problem:\nMove all even elements to the front of the array, followed by all odd elements.\n\n @param nums An array of integers.\n @return The modified array with even elements in the front and odd elements at the end.\n\n Example:\n moveEvenOdd(Array(3, 1, 2, 4))\n Output: Array(2, 4, 3, 1)\n\n Note: Other valid outputs include Array(4, 2, 3, 1), Array(2, 4, 1, 3), and Array(4, 2, 1, 3).", "level": "easy"}
{"task_id": "Scala/44", "prompt": "// Necessary imports\nimport scala.annotation.tailrec\n\nobject Solution {\n  /**\n     * Returns the least common multiple of 2 and n.\n     *\n     * @param n A positive integer.\n     * @return The least common multiple of 2 and n.\n     *\n     * Example:\n     * leastCommonMultiple(5)\n     * Output: 10\n     *\n     * Example:\n     * leastCommonMultiple(6)\n     * Output: 6\n     */\n  def leastCommonMultiple(n: Int): Int = ", "canonical_solution": "  {\n\n    (2 * n) / gcd(2, n)\n  }\n\n  @tailrec\n  private def gcd(a: Int, b: Int): Int = {\n    if (b == 0) a else gcd(b, a % b)\n  }", "test": "    def main(args: Array[String]): Unit = {\n    // Unit tests for the leastCommonMultiple function\n    assert(leastCommonMultiple(3) == 6, \"Test case 1 failed\")\n    assert(leastCommonMultiple(7) == 14, \"Test case 2 failed\")\n    assert(leastCommonMultiple(10) == 10, \"Test case 3 failed\")\n    \n    println(\"All tests passed\")\n  }\n}", "entry_point": "leastCommonMultiple", "signature": "def leastCommonMultiple(n: Int): Int =", "docstring": "Returns the least common multiple of 2 and n.\n\n @param n A positive integer.\n @return The least common multiple of 2 and n.\n\n Example:\n leastCommonMultiple(5)\n Output: 10\n\n Example:\n leastCommonMultiple(6)\n Output: 6", "instruction": "Write a Scala function `def leastCommonMultiple(n: Int): Int =` to solve the following problem:\nReturns the least common multiple of 2 and n.\n\n @param n A positive integer.\n @return The least common multiple of 2 and n.\n\n Example:\n leastCommonMultiple(5)\n Output: 10\n\n Example:\n leastCommonMultiple(6)\n Output: 6", "level": "easy"}
{"task_id": "Scala/45", "prompt": "object Solution {\n    /**\n       * Calculate the Hamming distance between two integers.\n       *\n       * @param x The first integer.\n       * @param y The second integer.\n       * @return The Hamming distance between x and y.\n       *\n       * Example:\n       * hammingDistance(1, 4)\n       * Output: 2\n       *\n       * hammingDistance(3, 1)\n       * Output: 1\n       */\n  def hammingDistance(x: Int, y: Int): Int = ", "canonical_solution": "  {\n\n      (x ^ y).toBinaryString.count(_ == '1')\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(hammingDistance(5, 9) == 2) // 0101 vs 1001 -> 3 differences\n    assert(hammingDistance(10, 20) == 4) // 01010 vs 10100 -> 4 differences\n    assert(hammingDistance(17, 34) == 4) // 010001 vs 100010 -> 3 differences\n    println(\"All tests passed\")\n  }\n}", "entry_point": "hammingDistance", "signature": "def hammingDistance(x: Int, y: Int): Int =", "docstring": "Calculate the Hamming distance between two integers.\n\n @param x The first integer.\n @param y The second integer.\n @return The Hamming distance between x and y.\n\n Example:\n hammingDistance(1, 4)\n Output: 2\n\n hammingDistance(3, 1)\n Output: 1", "instruction": "Write a Scala function `def hammingDistance(x: Int, y: Int): Int =` to solve the following problem:\nCalculate the Hamming distance between two integers.\n\n @param x The first integer.\n @param y The second integer.\n @return The Hamming distance between x and y.\n\n Example:\n hammingDistance(1, 4)\n Output: 2\n\n hammingDistance(3, 1)\n Output: 1", "level": "easy"}
{"task_id": "Scala/46", "prompt": "import scala.collection.mutable.ListBuffer\n\nobject Solution {\n  /**\n  * Generate all unique permutations of a sequence of numbers.\n  *\n  * @param nums The sequence of numbers.\n  * @return A list of all unique permutations.\n  *\n  * Example:\n  * permute(Array(1, 1, 2))\n  * Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))\n  */\n  def permute(nums: Array[Int]): List[List[Int]] = ", "canonical_solution": "  {\n    val results = ListBuffer[List[Int]]()\n    val used = Array.fill(nums.length)(false)\n    val tempList = ListBuffer[Int]()\n\n    def backtrack(): Unit = {\n      if (tempList.size == nums.length) {\n        results += tempList.toList\n      } else {\n        for (i <- nums.indices) {\n          if (!used(i)) {\n            used(i) = true\n            tempList += nums(i)\n            backtrack()\n            used(i) = false\n            tempList.remove(tempList.size - 1)\n          }\n        }\n      }\n    }\n\n    backtrack()\n    results.toList\n  }\n", "test": "  def main(args: Array[String]): Unit = {\n    // Test case 1\n    assert(permute(Array(2, 3, 5)).toSet == Set(\n      List(2, 3, 5), List(2, 5, 3), List(3, 2, 5),\n      List(3, 5, 2), List(5, 2, 3), List(5, 3, 2)\n    ))\n\n    // Test case 2\n    assert(permute(Array(0, -1, 1)).toSet == Set(\n      List(0, -1, 1), List(0, 1, -1), List(-1, 0, 1),\n      List(-1, 1, 0), List(1, 0, -1), List(1, -1, 0)\n    ))\n\n    // Test case 3\n    assert(permute(Array(1, 2)).toSet == Set(\n      List(1, 2), List(2, 1)\n    ))\n\n    println(\"All tests passed\")\n  }\n}\n", "entry_point": "permute", "signature": "def permute(nums: Array[Int]): List[List[Int]] =", "docstring": "Generate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "instruction": "Write a Scala function `def permute(nums: Array[Int]): List[List[Int]] =` to solve the following problem:\nGenerate all unique permutations of a sequence of numbers.\n\n @param nums The sequence of numbers.\n @return A list of all unique permutations.\n\n Example:\n permute(Array(1, 1, 2))\n Output: List(List(1, 1, 2), List(1, 2, 1), List(2, 1, 1))", "level": "hard"}
{"task_id": "Scala/47", "prompt": "\nobject Solution {\n      /**\n       * Reverse the first k characters of every 2k characters in the given string.\n       *\n       * @param s The input string.\n       * @param k The integer k.\n       * @return The modified string.\n       *\n       * Example:\n       * reverseString(\"abcdefg\", 2)\n       * Output: \"bacdfeg\"\n       *\n       * reverseString(\"abcd\", 2)\n       * Output: \"bacd\"\n       */\n  def reverseString(s: String, k: Int): String = ", "canonical_solution": "  {\n\n    s.grouped(2 * k).map {\n      case sub if sub.length < k => sub.reverse\n      case sub => sub.substring(0, k).reverse + sub.substring(k)\n    }.mkString\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(reverseString(\"example\", 3) == \"axemple\")\n    assert(reverseString(\"helloScala\", 4) == \"llehoScaal\")\n    assert(reverseString(\"scalaisfun\", 5) == \"alacsisfun\")\n\n    println(\"All tests passed\")\n  }\n}", "entry_point": "reverseString", "signature": "def reverseString(s: String, k: Int): String =", "docstring": "Reverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "instruction": "Write a Scala function `def reverseString(s: String, k: Int): String =` to solve the following problem:\nReverse the first k characters of every 2k characters in the given string.\n\n @param s The input string.\n @param k The integer k.\n @return The modified string.\n\n Example:\n reverseString(\"abcdefg\", 2)\n Output: \"bacdfeg\"\n\n reverseString(\"abcd\", 2)\n Output: \"bacd\"", "level": "easy"}
{"task_id": "Scala/48", "prompt": "object Solution {\n  /**\n   * Calculate the time needed to obtain the reverse seating order.\n   * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n   * \n   * @param N the number of people\n   * @return the time needed in minutes\n   * \n   * Example:\n   * >>> calculateTimeNeeded(4)\n   * 2\n   * >>> calculateTimeNeeded(5)\n   * 4\n   * >>> calculateTimeNeeded(6)\n   * 6\n   */\n  def calculateTimeNeeded(N: Int): Int = ", "canonical_solution": "  {\n    N / 2\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test the function with different test cases\n    assert(calculateTimeNeeded(7) == 3)\n    assert(calculateTimeNeeded(8) == 4)\n    assert(calculateTimeNeeded(9) == 4)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "calculateTimeNeeded", "signature": "def calculateTimeNeeded(N: Int): Int =", "docstring": "Calculate the time needed to obtain the reverse seating order.\n For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n \n @param N the number of people\n @return the time needed in minutes\n \n Example:\n >>> calculateTimeNeeded(4)\n 2\n >>> calculateTimeNeeded(5)\n 4\n >>> calculateTimeNeeded(6)\n 6", "instruction": "Write a Scala function `def calculateTimeNeeded(N: Int): Int =` to solve the following problem:\nCalculate the time needed to obtain the reverse seating order.\n For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n \n @param N the number of people\n @return the time needed in minutes\n \n Example:\n >>> calculateTimeNeeded(4)\n 2\n >>> calculateTimeNeeded(5)\n 4\n >>> calculateTimeNeeded(6)\n 6", "level": "easy"}
{"task_id": "Scala/49", "prompt": "object Solution {\n  \n  /**\n   * Count the number of words in the given word list that have the given prefix.\n   *\n   * @param wordList a list of words\n   * @param prefix the prefix string\n   * @return the number of words with the given prefix\n   *\n   * Example:\n   *\n   * {{{\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n   * assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n   * }}}\n   */\n  def countPrefixWords(wordList: List[String], prefix: String): Int = ", "canonical_solution": "  {\n    wordList.count(_.startsWith(prefix))\n  }", "test": "  def main(args: Array[String]): Unit = {\n    // Test the function with different test cases\n    assert(countPrefixWords(List(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3)\n    assert(countPrefixWords(List(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4)\n    assert(countPrefixWords(List(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4)\n    println(\"All tests passed\")\n  }\n}", "entry_point": "countPrefixWords", "signature": "def countPrefixWords(wordList: List[String], prefix: String): Int =", "docstring": "Count the number of words in the given word list that have the given prefix.\n\n @param wordList a list of words\n @param prefix the prefix string\n @return the number of words with the given prefix\n\n Example:\n\n {{{\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n }}}", "instruction": "Write a Scala function `def countPrefixWords(wordList: List[String], prefix: String): Int =` to solve the following problem:\nCount the number of words in the given word list that have the given prefix.\n\n @param wordList a list of words\n @param prefix the prefix string\n @return the number of words with the given prefix\n\n Example:\n\n {{{\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\") == 2)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\") == 3)\n assert(countPrefixWords(List(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\") == 1)\n }}}", "level": "easy"}
{"task_id": "Scala/50", "prompt": "object Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  def minPerfectSquareSum(n: Int): Int = ", "canonical_solution": "  {\n    val dp = Array.fill(n + 1)(Int.MaxValue)\n    dp(0) = 0\n\n    for (i <- 1 to n) {\n      var j = 1\n      while (j * j <= i) {\n        dp(i) = Math.min(dp(i), dp(i - j * j) + 1)\n        j += 1\n      }\n    }\n    dp(n)\n  }", "test": "  def main(args: Array[String]): Unit = {\n    assert(minPerfectSquareSum(26) == 2, \"Test case 1 failed\")\n    assert(minPerfectSquareSum(17) == 2, \"Test case 2 failed\")\n    assert(minPerfectSquareSum(99) == 3, \"Test case 3 failed\")\n    println(\"All tests passed\")\n  }\n}", "entry_point": "minPerfectSquareSum", "signature": "def minPerfectSquareSum(n: Int): Int =", "docstring": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "instruction": "Write a Scala function `def minPerfectSquareSum(n: Int): Int =` to solve the following problem:\nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n\n @param n The target integer.\n @return The minimum number of perfect square numbers.\n\n Example:\n minPerfectSquareSum(12)\n Output: 3\n\n Example:\n minPerfectSquareSum(13)\n Output: 2", "level": "easy"}
