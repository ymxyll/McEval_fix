{"task_id": "R/1", "prompt": "#   Check if in given list of numbers, are any two numbers closer to each other than\n#   given threshold.\n#   >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#   False\n#   >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#   True\nhas_close_elements <- function(numbers, threshold) ", "canonical_solution": "{n <- length(numbers)\n  for (i in 1:(n-1)) {\n    for (j in (i+1):n) {\n      if (abs(numbers[i] - numbers[j]) < threshold) {\n        return(TRUE)\n      }\n    }\n  }\n  return(FALSE)\n}", "test": "# Test cases\ntest_has_close_elements <- function() {\n  stopifnot(has_close_elements(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == TRUE)\n  stopifnot(has_close_elements(c(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == FALSE)\n  stopifnot(has_close_elements(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == TRUE)\n  stopifnot(has_close_elements(c(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == FALSE)\n  stopifnot(has_close_elements(c(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == TRUE)\n  stopifnot(has_close_elements(c(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == TRUE)\n  stopifnot(has_close_elements(c(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == FALSE)\n  \n  cat(\"All tests passed!\\n\")\n}\n\n# Run tests\ntest_has_close_elements()", "entry_point": "has_close_elements", "signature": "has_close_elements <- function(numbers, threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Write a R function `has_close_elements <- function(numbers, threshold)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "level": "easy"}
{"task_id": "R/2", "prompt": "\n# This function finds the top 'm' largest elements from a given list of unique integers.\n# The integers in the list should be within the range [-500000, 500000].\n# Args:\n#   numbers: A vector of integers.\n#   m: An integer indicating the number of top elements to retrieve.\n# Returns:\n#   A vector of top 'm' largest elements sorted in descending order.\n# Examples:\n#   >>> top_n_elements(c(10, 3, 5, 20, -4), 2)\n#   [1] 20 10\n#   >>> top_n_elements(c(-1, -3, -2, -5, -4), 3)\n#   [1] -1 -2 -3\n\ntop_n_elements <- function(numbers, m) ", "canonical_solution": "{\n    if (length(unique(numbers)) != length(numbers)) {\n        stop(\"All elements in the list must be unique.\")\n    }\n\n    if (any(numbers > 500000) || any(numbers < -500000)) {\n        stop(\"Elements must be in the range [-500000, 500000].\")\n    }\n\n    sorted_numbers <- sort(numbers, decreasing = TRUE)\n    return(head(sorted_numbers, m))\n}", "test": "# Test cases\nmain <- function() {\n  stopifnot(identical(top_n_elements(c(10, 3, 5, 20, -4), 2), c(20, 10)))\n  stopifnot(identical(top_n_elements(c(-1, -3, -2, -5, -4), 3), c(-1, -2, -3)))\n  stopifnot(identical(top_n_elements(c(100, 200, 300, 400, 500), 3), c(500, 400, 300)))\n  stopifnot(identical(top_n_elements(c(0, -100, -200, -300, -400), 4), c(0, -100, -200, -300)))\n  stopifnot(identical(top_n_elements(c(1500, 1000, 500, -1000, -1500), 5), c(1500, 1000, 500, -1000, -1500)))\n\n}\n\n# Run tests\nmain()", "entry_point": "top_n_elements", "signature": "top_n_elements <- function(numbers, m)", "docstring": "This function finds the top 'm' largest elements from a given list of unique integers.\nThe integers in the list should be within the range [-500000, 500000].\nArgs:\nnumbers: A vector of integers.\nm: An integer indicating the number of top elements to retrieve.\nReturns:\nA vector of top 'm' largest elements sorted in descending order.\nExamples:\n>>> top_n_elements(c(10, 3, 5, 20, -4), 2)\n[1] 20 10\n>>> top_n_elements(c(-1, -3, -2, -5, -4), 3)\n[1] -1 -2 -3", "instruction": "Write a R function `top_n_elements <- function(numbers, m)` to solve the following problem:\nThis function finds the top 'm' largest elements from a given list of unique integers.\nThe integers in the list should be within the range [-500000, 500000].\nArgs:\nnumbers: A vector of integers.\nm: An integer indicating the number of top elements to retrieve.\nReturns:\nA vector of top 'm' largest elements sorted in descending order.\nExamples:\n>>> top_n_elements(c(10, 3, 5, 20, -4), 2)\n[1] 20 10\n>>> top_n_elements(c(-1, -3, -2, -5, -4), 3)\n[1] -1 -2 -3", "level": "easy"}
{"task_id": "R/3", "prompt": "# This function minimum_voter_support calculates the minimum number of voters needed to win a majority of states in an election. Given a vector representing the number of voters in each state, the function returns the smallest number of voters required to secure a majority of the states, assuming that winning over half the voters in a state secures it.\n\n# Examples:\n# minimum_voter_support(c(10, 20, 15)): In this case, the function returns 14.\n\nminimum_voter_support <- function(states_voters) ", "canonical_solution": "{\n    n <- length(states_voters)\n    sorted_voters <- sort(states_voters)\n    total_states_needed <- (n %/% 2) + 1\n    total_voters_needed <- 0\n    for (i in 1:total_states_needed) {\n        total_voters_needed <- total_voters_needed + (sorted_voters[i] %/% 2) + 1\n    }\n    return(total_voters_needed)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(minimum_voter_support(c(10, 20, 15)) == 14)\n    stopifnot(minimum_voter_support(c(5, 7, 5)) == 6)\n    stopifnot(minimum_voter_support(c(6, 6, 6, 6)) == 12)\n    stopifnot(minimum_voter_support(c(10, 10, 10, 10, 10, 11)) == 24)\n    stopifnot(minimum_voter_support(c(1, 1, 1, 1, 100)) == 3)\n    stopifnot(minimum_voter_support(c(50, 50, 50, 51)) == 78)\n\n}\n\n# Run tests\nmain()", "entry_point": "minimum_voter_support", "signature": "minimum_voter_support <- function(states_voters)", "docstring": "This function minimum_voter_support calculates the minimum number of voters needed to win a majority of states in an election. Given a vector representing the number of voters in each state, the function returns the smallest number of voters required to secure a majority of the states, assuming that winning over half the voters in a state secures it.\nExamples:\nminimum_voter_support(c(10, 20, 15)): In this case, the function returns 14.", "instruction": "Write a R function `minimum_voter_support <- function(states_voters)` to solve the following problem:\nThis function minimum_voter_support calculates the minimum number of voters needed to win a majority of states in an election. Given a vector representing the number of voters in each state, the function returns the smallest number of voters required to secure a majority of the states, assuming that winning over half the voters in a state secures it.\nExamples:\nminimum_voter_support(c(10, 20, 15)): In this case, the function returns 14.", "level": "easy"}
{"task_id": "R/4", "prompt": "\n# This function second_smallest_number computes the second smallest unique number in a given vector of integers, considering each integer separately, even if there are duplicates. The function iterates through the vector, identifying the smallest and the second smallest numbers. Sorting of integers is not allowed !\n# For example:\n# >> second_smallest_number(c(1, 1, 3))\n#    1\n   \nsecond_smallest_number <- function(numbers) ", "canonical_solution": "{\n    if(length(numbers) < 2) {\n        stop(\"The vector must contain at least two numbers.\")\n    }\n\n    if(numbers[1] < numbers[2]) {\n        smallest <- numbers[1]\n        second_smallest <- numbers[2]\n    } else {\n        smallest <- numbers[2]\n        second_smallest <- numbers[1]\n    }\n\n    if (length(numbers) >=3){\n        for (i in 3:length(numbers)) {\n            number <- numbers[i]\n            if (number < smallest) {\n                second_smallest <- smallest\n                smallest <- number\n            } else if (number < second_smallest && number != smallest) {\n                second_smallest <- number\n            }\n        }\n    }\n\n    return(second_smallest)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(second_smallest_number(c(1, 1, 3)) == 1)\n    stopifnot(second_smallest_number(c(2, 3, 4)) == 3)\n    stopifnot(second_smallest_number(c(5, 7, 8, 9)) == 7)\n    stopifnot(second_smallest_number(c(3, 3, 3, 3)) == 3)\n    stopifnot(second_smallest_number(c(15, 10)) == 15)\n\n}\n\n# Run tests\nmain()", "entry_point": "second_smallest_number", "signature": "second_smallest_number <- function(numbers)", "docstring": "This function second_smallest_number computes the second smallest unique number in a given vector of integers, considering each integer separately, even if there are duplicates. The function iterates through the vector, identifying the smallest and the second smallest numbers. Sorting of integers is not allowed !\nFor example:\n>> second_smallest_number(c(1, 1, 3))\n1", "instruction": "Write a R function `second_smallest_number <- function(numbers)` to solve the following problem:\nThis function second_smallest_number computes the second smallest unique number in a given vector of integers, considering each integer separately, even if there are duplicates. The function iterates through the vector, identifying the smallest and the second smallest numbers. Sorting of integers is not allowed !\nFor example:\n>> second_smallest_number(c(1, 1, 3))\n1", "level": "hard"}
{"task_id": "R/5", "prompt": "\n# This function 'teach_cooking_skills' is designed to calculate the minimum number of members who need to be taught a specific skill (e.g., cooking a dish) directly by an expert, so that the skill can be disseminated to all members of a group through peer teaching. \n# The input is a list where each element represents a member and contains the members they can teach. \n# The function returns the minimum number of direct teachings required for all members to learn the skill.\n# Examples:\n# teach_cooking_skills(list(c(2, 4, 3), c(4, 5), c(), c(), c(1))): This would return 1, as teaching member 1 is sufficient for all members to learn the skill.\n\nteach_cooking_skills <- function(member_teaching_preferences) ", "canonical_solution": "{\n    n <- length(member_teaching_preferences)\n    # Initialize the path matrix\n    path <- matrix(0, n, n)\n  \n    # Fill in the direct teaching preferences\n    for (i in 1:n) {\n        for (teachable in member_teaching_preferences[[i]]) {\n            path[i, teachable] <- 1\n        }\n    }\n\n    # Apply the Floyd-Warshall algorithm to find transitive closure\n    for (i in 1:n) {\n        for (j in 1:n) {\n            for (k in 1:n) {\n                if (path[i, k] == 1 && path[k, j] == 1) {\n                    path[i, j] <- 1\n                }\n            }\n        }\n    }\n\n    # Determine the minimum number of direct teachings needed\n    direct_teachings_needed <- rep(TRUE, n)\n    for (i in 1:n) {\n        for (j in 1:n) {\n            if (i != j && path[i, j] == 1 && direct_teachings_needed[i]==TRUE) {\n                direct_teachings_needed[j] <- FALSE\n                # break\n            }\n        }\n    }\n\n    # Count the number of members who need to be taught directly\n    sum(direct_teachings_needed)\n    return (sum(direct_teachings_needed))\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(teach_cooking_skills(list(c(2, 4, 3), c(4, 5), c(), c(), c(1))) == 1)\n    stopifnot(teach_cooking_skills(list(c(2), c(3), c(), c(), c())) == 3)\n    stopifnot(teach_cooking_skills(list(c(), c(), c(), c(), c())) == 5)\n    stopifnot(teach_cooking_skills(list(c(2, 3, 4, 5), c(3, 4, 5), c(4, 5), c(5), c())) == 1)\n    stopifnot(teach_cooking_skills(list(c(2, 3), c(3), c())) == 1)\n\n\n}\n\n# Run tests\nmain()", "entry_point": "teach_cooking_skills", "signature": "teach_cooking_skills <- function(member_teaching_preferences)", "docstring": "This function 'teach_cooking_skills' is designed to calculate the minimum number of members who need to be taught a specific skill (e.g., cooking a dish) directly by an expert, so that the skill can be disseminated to all members of a group through peer teaching.\nThe input is a list where each element represents a member and contains the members they can teach.\nThe function returns the minimum number of direct teachings required for all members to learn the skill.\nExamples:\nteach_cooking_skills(list(c(2, 4, 3), c(4, 5), c(), c(), c(1))): This would return 1, as teaching member 1 is sufficient for all members to learn the skill.", "instruction": "Write a R function `teach_cooking_skills <- function(member_teaching_preferences)` to solve the following problem:\nThis function 'teach_cooking_skills' is designed to calculate the minimum number of members who need to be taught a specific skill (e.g., cooking a dish) directly by an expert, so that the skill can be disseminated to all members of a group through peer teaching.\nThe input is a list where each element represents a member and contains the members they can teach.\nThe function returns the minimum number of direct teachings required for all members to learn the skill.\nExamples:\nteach_cooking_skills(list(c(2, 4, 3), c(4, 5), c(), c(), c(1))): This would return 1, as teaching member 1 is sufficient for all members to learn the skill.", "level": "hard"}
{"task_id": "R/6", "prompt": "# This function hex_to_octal takes a vector of hexadecimal numbers (as strings) and converts each to its corresponding octal representation. The function returns a vector of octal numbers as strings. Each hexadecimal number is composed of characters ranging from 0 to 9 and A to F, representing values from 10 to 15 respectively. The input vector can contain up to 10 hexadecimal numbers, each up to 100000 characters long.\n\n# Examples:\n\n# hex_to_octal(c(\"1A\", \"2B\")): This would return c(\"32\", \"53\") as the octal representations of 1A and 2B in hexadecimal.\n# hex_to_octal(c(\"FF\")): This would return c(\"377\") as the octal representation of FF in hexadecimal.\n\nhex_to_octal <- function(hex_numbers) ", "canonical_solution": "{\n    # Initialize an empty vector to store the octal numbers\n    octal_numbers <- vector(\"character\", length(hex_numbers))\n    \n    # Iterate over each hexadecimal number\n    for (i in seq_along(hex_numbers)) {\n        # Convert the hexadecimal to decimal\n        decimal_number <- strtoi(hex_numbers[i], base=16)\n        \n        # Convert the decimal to octal and store in the vector\n        octal_numbers[i] <- sprintf(\"%o\", decimal_number)\n    }\n    \n    return(octal_numbers)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(identical(hex_to_octal(c(\"1A\", \"2B\")), c(\"32\", \"53\")))\n    stopifnot(identical(hex_to_octal(c(\"FF\")), c(\"377\")))\n    stopifnot(identical(hex_to_octal(c(\"ABC\")), c(\"5274\")))\n    stopifnot(identical(hex_to_octal(c(\"0\")), c(\"0\")))\n    stopifnot(identical(hex_to_octal(c(\"10\", \"20\", \"30\")), c(\"20\", \"40\", \"60\")))\n\n\n}\n\n# Run tests\nmain()", "entry_point": "hex_to_octal", "signature": "hex_to_octal <- function(hex_numbers)", "docstring": "This function hex_to_octal takes a vector of hexadecimal numbers (as strings) and converts each to its corresponding octal representation. The function returns a vector of octal numbers as strings. Each hexadecimal number is composed of characters ranging from 0 to 9 and A to F, representing values from 10 to 15 respectively. The input vector can contain up to 10 hexadecimal numbers, each up to 100000 characters long.\nExamples:\nhex_to_octal(c(\"1A\", \"2B\")): This would return c(\"32\", \"53\") as the octal representations of 1A and 2B in hexadecimal.\nhex_to_octal(c(\"FF\")): This would return c(\"377\") as the octal representation of FF in hexadecimal.", "instruction": "Write a R function `hex_to_octal <- function(hex_numbers)` to solve the following problem:\nThis function hex_to_octal takes a vector of hexadecimal numbers (as strings) and converts each to its corresponding octal representation. The function returns a vector of octal numbers as strings. Each hexadecimal number is composed of characters ranging from 0 to 9 and A to F, representing values from 10 to 15 respectively. The input vector can contain up to 10 hexadecimal numbers, each up to 100000 characters long.\nExamples:\nhex_to_octal(c(\"1A\", \"2B\")): This would return c(\"32\", \"53\") as the octal representations of 1A and 2B in hexadecimal.\nhex_to_octal(c(\"FF\")): This would return c(\"377\") as the octal representation of FF in hexadecimal.", "level": "middle"}
{"task_id": "R/7", "prompt": "# This function decimal_to_hexadecimal converts a given non-negative integer from its decimal form to its hexadecimal representation. Hexadecimal numbers use 16 symbols: 0-9 and A-F, where A-F represent decimal numbers 10-15 respectively. In hexadecimal, the counting method is base 16.\n# Examples:\n# decimal_to_hexadecimal(30): returns '1E'.\n# decimal_to_hexadecimal(17): returns '11'.\n\n\ndecimal_to_hexadecimal <- function(decimal_number) ", "canonical_solution": "{\n    if (decimal_number == 0) {\n        return(\"0\")\n    }\n    \n    hex_digits = c('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')\n    hex_result = \"\"\n    while (decimal_number > 0) {\n        remainder = decimal_number %% 16\n        hex_result = paste0(hex_digits[remainder + 1], hex_result)\n        decimal_number = decimal_number %/% 16\n    }\n    return(hex_result)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(decimal_to_hexadecimal(30) == '1E')\n    stopifnot(decimal_to_hexadecimal(17) == '11')\n    stopifnot(decimal_to_hexadecimal(256) == '100')\n    stopifnot(decimal_to_hexadecimal(0) == '0')\n    stopifnot(decimal_to_hexadecimal(2147483647) == '7FFFFFFF')\n    stopifnot(decimal_to_hexadecimal(45) == '2D')\n}\n\n# Run tests\nmain()", "entry_point": "decimal_to_hexadecimal", "signature": "decimal_to_hexadecimal <- function(decimal_number)", "docstring": "This function decimal_to_hexadecimal converts a given non-negative integer from its decimal form to its hexadecimal representation. Hexadecimal numbers use 16 symbols: 0-9 and A-F, where A-F represent decimal numbers 10-15 respectively. In hexadecimal, the counting method is base 16.\nExamples:\ndecimal_to_hexadecimal(30): returns '1E'.\ndecimal_to_hexadecimal(17): returns '11'.", "instruction": "Write a R function `decimal_to_hexadecimal <- function(decimal_number)` to solve the following problem:\nThis function decimal_to_hexadecimal converts a given non-negative integer from its decimal form to its hexadecimal representation. Hexadecimal numbers use 16 symbols: 0-9 and A-F, where A-F represent decimal numbers 10-15 respectively. In hexadecimal, the counting method is base 16.\nExamples:\ndecimal_to_hexadecimal(30): returns '1E'.\ndecimal_to_hexadecimal(17): returns '11'.", "level": "easy"}
{"task_id": "R/8", "prompt": "\n\n# This function `find_palindromic_numbers` identifies all five-digit and six-digit palindromic numbers for which the sum of the digits equals a given number 'sum_digits'.\n# A palindromic number is a number that remains the same when its digits are reversed. The function takes a single argument 'sum_digits', which is a positive integer, and returns a vector of all such palindromic numbers.\n# Examples:\n# find_palindromic_numbers(10): This will return all five-digit and six-digit palindromic numbers whose digits sum up to 10.\n\nfind_palindromic_numbers <- function(sum_digits) ", "canonical_solution": "{\n    result <- c()\n    # Check for five-digit numbers\n    for (i in 1:9) {\n        for (j in 0:9) {\n            for (k in 0:9) {\n                if (i + j + k + j + i == sum_digits) {\n                    result <- c(result, as.numeric(paste0(i, j, k, j, i)))\n                }\n            }\n        }\n    }\n    # Check for six-digit numbers\n    for (i in 1:9) {\n        for (j in 0:9) {\n            for (k in 0:9) {\n                if (i + j + k + k + j + i == sum_digits) {\n                    result <- c(result, as.numeric(paste0(i, j, k, k, j, i)))\n                }\n            }\n        }\n    }\n\n    return(result)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(all(find_palindromic_numbers(10) == c(10801,11611,12421,13231,14041 , 20602 , 21412  ,22222  ,23032  ,30403, 31213, 32023,  40204,  41014  ,50005 ,104401 ,113311, 122221, 131131 ,140041,203302, 212212 ,221122 ,230032, 302203, 311113 ,320023, 401104, 410014 ,500005)))\n \n    stopifnot(all(find_palindromic_numbers(50) == c(799997, 889988, 898898 ,979979, 988889, 997799)) ) # Expect no palindromic numbers with digit sum 50\n\n\n}\n\n# Run tests\nmain()", "entry_point": "find_palindromic_numbers", "signature": "find_palindromic_numbers <- function(sum_digits)", "docstring": "This function `find_palindromic_numbers` identifies all five-digit and six-digit palindromic numbers for which the sum of the digits equals a given number 'sum_digits'.\nA palindromic number is a number that remains the same when its digits are reversed. The function takes a single argument 'sum_digits', which is a positive integer, and returns a vector of all such palindromic numbers.\nExamples:\nfind_palindromic_numbers(10): This will return all five-digit and six-digit palindromic numbers whose digits sum up to 10.", "instruction": "Write a R function `find_palindromic_numbers <- function(sum_digits)` to solve the following problem:\nThis function `find_palindromic_numbers` identifies all five-digit and six-digit palindromic numbers for which the sum of the digits equals a given number 'sum_digits'.\nA palindromic number is a number that remains the same when its digits are reversed. The function takes a single argument 'sum_digits', which is a positive integer, and returns a vector of all such palindromic numbers.\nExamples:\nfind_palindromic_numbers(10): This will return all five-digit and six-digit palindromic numbers whose digits sum up to 10.", "level": "middle"}
{"task_id": "R/9", "prompt": "# This function detect_anagram_keywords is designed to identify keywords in a sentence even if their letters have been rearranged. The function takes two arguments: a vector of keywords and a sentence. The sentence and keywords are both strings. The function returns a vector containing the rearranged keywords found in the sentence.\n# The keywords and sentence are assumed to be lowercase and separated by spaces. The function does not consider word boundaries when searching for anagrams.\n# Examples:\n# detect_anagram_keywords(c(\"apple\", \"banana\", \"cherry\"), \"elppa is delicious and so is nanaab\"): This should return c(\"apple\", \"banana\").\n\ndetect_anagram_keywords <- function(keywords, sentence) ", "canonical_solution": "{\n    sorted_keywords <- sapply(keywords, function(keyword) paste(sort(unlist(strsplit(keyword, \"\"))), collapse = \"\"))\n    words <- unlist(strsplit(sentence, \" \"))\n    found_keywords <- c()\n    for (word in words) {\n        sorted_word <- paste(sort(unlist(strsplit(word, \"\"))), collapse = \"\")\n        if (sorted_word %in% sorted_keywords) {\n            original_keyword <- keywords[sorted_keywords == sorted_word]\n            found_keywords <- c(found_keywords, original_keyword)\n        }\n    }\n    return(found_keywords)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(identical(detect_anagram_keywords(c(\"apple\", \"banana\", \"cherry\"), \"elppa is delicious and so is nanaab\"), c(\"apple\", \"banana\")))\n    stopifnot(identical(detect_anagram_keywords(c(\"cat\", \"dog\", \"bird\"), \"tac and god are friends\"), c(\"cat\", \"dog\")))\n    stopifnot(identical(detect_anagram_keywords(c(\"moon\", \"star\", \"sun\"), \"noom lights the night sky\"), c(\"moon\")))\n    stopifnot(identical(detect_anagram_keywords(c(\"blue\", \"green\", \"red\"), \"eelb sky and nedreg grass\"), c()))\n    stopifnot(identical(detect_anagram_keywords(c(\"fish\", \"shark\", \"whale\"), \"hsif in the sea\"), c(\"fish\")))\n\n}\n\n# Run tests\nmain()", "entry_point": "detect_anagram_keywords", "signature": "detect_anagram_keywords <- function(keywords, sentence)", "docstring": "This function detect_anagram_keywords is designed to identify keywords in a sentence even if their letters have been rearranged. The function takes two arguments: a vector of keywords and a sentence. The sentence and keywords are both strings. The function returns a vector containing the rearranged keywords found in the sentence.\nThe keywords and sentence are assumed to be lowercase and separated by spaces. The function does not consider word boundaries when searching for anagrams.\nExamples:\ndetect_anagram_keywords(c(\"apple\", \"banana\", \"cherry\"), \"elppa is delicious and so is nanaab\"): This should return c(\"apple\", \"banana\").", "instruction": "Write a R function `detect_anagram_keywords <- function(keywords, sentence)` to solve the following problem:\nThis function detect_anagram_keywords is designed to identify keywords in a sentence even if their letters have been rearranged. The function takes two arguments: a vector of keywords and a sentence. The sentence and keywords are both strings. The function returns a vector containing the rearranged keywords found in the sentence.\nThe keywords and sentence are assumed to be lowercase and separated by spaces. The function does not consider word boundaries when searching for anagrams.\nExamples:\ndetect_anagram_keywords(c(\"apple\", \"banana\", \"cherry\"), \"elppa is delicious and so is nanaab\"): This should return c(\"apple\", \"banana\").", "level": "middle"}
{"task_id": "R/10", "prompt": "# This function longest_common_subsequence computes the length of the longest common subsequence between two strings. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n# Examples:\n# longest_common_subsequence(\"abcde\", \"ace\"): In this case, the function returns 3 (the longest common subsequence is \"ace\").\n# longest_common_subsequence(\"abc\", \"abc\"): In this case, the function returns 3.\n# longest_common_subsequence(\"abc\", \"def\"): In this case, the function returns 0 (no common subsequence).\n\n\n\nlongest_common_subsequence <- function(string1, string2) ", "canonical_solution": "{\n    if (nchar(string1) == 0 ||  nchar(string2) == 0){\n        return (0)\n    }\n    len1 <- nchar(string1)\n    len2 <- nchar(string2)\n    dp_matrix <- matrix(0, nrow = len1 + 1, ncol = len2 + 1)\n\n    for (i in 1:len1) {\n        for (j in 1:len2) {\n            if (substring(string1, i, i) == substring(string2, j, j)) {\n                dp_matrix[i + 1, j + 1] <- dp_matrix[i, j] + 1\n            } else {\n                dp_matrix[i + 1, j + 1] <- max(dp_matrix[i + 1, j], dp_matrix[i, j + 1])\n            }\n        }\n    }\n\n    return(dp_matrix[len1 + 1, len2 + 1])\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(longest_common_subsequence(\"abcde\", \"ace\") == 3)\n    stopifnot(longest_common_subsequence(\"abc\", \"abc\") == 3)\n    stopifnot(longest_common_subsequence(\"abc\", \"def\") == 0)\n    stopifnot(longest_common_subsequence(\"abcdgh\", \"aedfhb\") == 3)\n    stopifnot(longest_common_subsequence(\"programming\", \"gaming\") == 6)\n    stopifnot(longest_common_subsequence(\"\", \"abc\") == 0)\n\n}\n\n# Run tests\nmain()", "entry_point": "longest_common_subsequence", "signature": "longest_common_subsequence <- function(string1, string2)", "docstring": "This function longest_common_subsequence computes the length of the longest common subsequence between two strings. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nExamples:\nlongest_common_subsequence(\"abcde\", \"ace\"): In this case, the function returns 3 (the longest common subsequence is \"ace\").\nlongest_common_subsequence(\"abc\", \"abc\"): In this case, the function returns 3.\nlongest_common_subsequence(\"abc\", \"def\"): In this case, the function returns 0 (no common subsequence).", "instruction": "Write a R function `longest_common_subsequence <- function(string1, string2)` to solve the following problem:\nThis function longest_common_subsequence computes the length of the longest common subsequence between two strings. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nExamples:\nlongest_common_subsequence(\"abcde\", \"ace\"): In this case, the function returns 3 (the longest common subsequence is \"ace\").\nlongest_common_subsequence(\"abc\", \"abc\"): In this case, the function returns 3.\nlongest_common_subsequence(\"abc\", \"def\"): In this case, the function returns 0 (no common subsequence).", "level": "middle"}
{"task_id": "R/11", "prompt": "\n# This function modular_exponentiation computes the modular exponentiation of two numbers. It calculates (A^B) mod P, where A and B are non-negative integers and P is a non-negative integer representing the modulus. This function returns the result of the modular exponentiation.\n\n# Examples:\n# modular_exponentiation(2, 5, 3): In this case, the function returns 2.\n# modular_exponentiation(3, 4, 5): Here, the function returns 1.\n\nmodular_exponentiation <- function(A, B, P) ", "canonical_solution": "{\n    result <- 1\n    A <- A %% P\n    while (B > 0) {\n        if (B %% 2 == 1) {\n            result <- (result * A) %% P\n        }\n        B <- B %/% 2\n        A <- (A * A) %% P\n    }\n    return(result)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(modular_exponentiation(2, 5, 3) == 2)\n    stopifnot(modular_exponentiation(3, 4, 5) == 1)\n    stopifnot(modular_exponentiation(7, 3, 13) == 5)\n    stopifnot(modular_exponentiation(10, 11, 19) == 14)\n    stopifnot(modular_exponentiation(17, 13, 31) == 3)\n}\n\n# Run tests\nmain()", "entry_point": "modular_exponentiation", "signature": "modular_exponentiation <- function(A, B, P)", "docstring": "This function modular_exponentiation computes the modular exponentiation of two numbers. It calculates (A^B) mod P, where A and B are non-negative integers and P is a non-negative integer representing the modulus. This function returns the result of the modular exponentiation.\nExamples:\nmodular_exponentiation(2, 5, 3): In this case, the function returns 2.\nmodular_exponentiation(3, 4, 5): Here, the function returns 1.", "instruction": "Write a R function `modular_exponentiation <- function(A, B, P)` to solve the following problem:\nThis function modular_exponentiation computes the modular exponentiation of two numbers. It calculates (A^B) mod P, where A and B are non-negative integers and P is a non-negative integer representing the modulus. This function returns the result of the modular exponentiation.\nExamples:\nmodular_exponentiation(2, 5, 3): In this case, the function returns 2.\nmodular_exponentiation(3, 4, 5): Here, the function returns 1.", "level": "easy"}
{"task_id": "R/12", "prompt": "# This function first_ten_digits_of_power_of_two calculates the first ten digits of 2 raised to the power of n. Given a natural number n, the function returns the first ten digits of 2^n.\n# It handles cases where 0 <= n <= 10000000.\n# Examples:\n# first_ten_digits_of_power_of_two(60): This returns 1152921504, which are the first ten digits of 2^60.\n# first_ten_digits_of_power_of_two(10): Returns 1024, as 2^10 is 1024, which is less than ten digits and hence, the function returns the number itself.\n\nfirst_ten_digits_of_power_of_two <- function(n) ", "canonical_solution": "{\n  if (n == 0) {\n    return(1)\n  }\n\n  # Calculate 2^n\n  power_of_two = 2^n\n\n  # Convert the number to a string to count digits\n  power_of_two_str = as.character(power_of_two)\n\n  # If the number of digits is 10 or less, return the number itself\n  if (nchar(power_of_two_str) <= 10) {\n    return(power_of_two)\n  }\n\n  # If the number of digits is more than 10, return the first ten digits\n  return(as.numeric(substr(power_of_two_str, 1, 10)))\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(first_ten_digits_of_power_of_two(60) == 1152921504)\n    stopifnot(first_ten_digits_of_power_of_two(10) == 1024)\n    stopifnot(first_ten_digits_of_power_of_two(0) == 1)\n    stopifnot(first_ten_digits_of_power_of_two(3) == 8)\n    stopifnot(first_ten_digits_of_power_of_two(20) == 1048576)\n    stopifnot(first_ten_digits_of_power_of_two(50) == 1125899906)\n}\n\n# Run tests\nmain()", "entry_point": "first_ten_digits_of_power_of_two", "signature": "first_ten_digits_of_power_of_two <- function(n)", "docstring": "This function first_ten_digits_of_power_of_two calculates the first ten digits of 2 raised to the power of n. Given a natural number n, the function returns the first ten digits of 2^n.\nIt handles cases where 0 <= n <= 10000000.\nExamples:\nfirst_ten_digits_of_power_of_two(60): This returns 1152921504, which are the first ten digits of 2^60.\nfirst_ten_digits_of_power_of_two(10): Returns 1024, as 2^10 is 1024, which is less than ten digits and hence, the function returns the number itself.", "instruction": "Write a R function `first_ten_digits_of_power_of_two <- function(n)` to solve the following problem:\nThis function first_ten_digits_of_power_of_two calculates the first ten digits of 2 raised to the power of n. Given a natural number n, the function returns the first ten digits of 2^n.\nIt handles cases where 0 <= n <= 10000000.\nExamples:\nfirst_ten_digits_of_power_of_two(60): This returns 1152921504, which are the first ten digits of 2^60.\nfirst_ten_digits_of_power_of_two(10): Returns 1024, as 2^10 is 1024, which is less than ten digits and hence, the function returns the number itself.", "level": "easy"}
{"task_id": "R/13", "prompt": "\n# This function 'calculate_total_amount' calculates the total amount after one year for a given principal amount and an annual interest rate. The function takes into account a 5% tax on the interest earned.\n# The principal amount is in RMB and the interest rate is given as a percentage (without the percent sign).\n# The result is rounded to the nearest cent.\n# Examples:\n# calculate_total_amount(5000.00, 5.00): This should return 5237.50, representing the total amount after one year including taxed interest.\n# calculate_total_amount(10000.00, 3.50): This should return 10347.25.\n\n\ncalculate_total_amount <- function(principal, interest_rate) ", "canonical_solution": "{\n    interest_earned = principal * (interest_rate / 100)\n    tax_on_interest = interest_earned * 0.05\n    net_interest = interest_earned - tax_on_interest\n    total_amount = principal + net_interest\n    return(round(total_amount, 2))\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(calculate_total_amount(5000.00, 5.00) == 5237.50)\n    stopifnot(calculate_total_amount(10000.00, 3.50) == 10332.50)\n    stopifnot(calculate_total_amount(15000.00, 4.00) == 15570.00)\n    stopifnot(calculate_total_amount(20000.00, 6.00) == 21140.00)\n    stopifnot(calculate_total_amount(30000.00, 1.00) == 30285.00)\n\n}\n\n# Run tests\nmain()", "entry_point": "calculate_total_amount", "signature": "calculate_total_amount <- function(principal, interest_rate)", "docstring": "This function 'calculate_total_amount' calculates the total amount after one year for a given principal amount and an annual interest rate. The function takes into account a 5% tax on the interest earned.\nThe principal amount is in RMB and the interest rate is given as a percentage (without the percent sign).\nThe result is rounded to the nearest cent.\nExamples:\ncalculate_total_amount(5000.00, 5.00): This should return 5237.50, representing the total amount after one year including taxed interest.\ncalculate_total_amount(10000.00, 3.50): This should return 10347.25.", "instruction": "Write a R function `calculate_total_amount <- function(principal, interest_rate)` to solve the following problem:\nThis function 'calculate_total_amount' calculates the total amount after one year for a given principal amount and an annual interest rate. The function takes into account a 5% tax on the interest earned.\nThe principal amount is in RMB and the interest rate is given as a percentage (without the percent sign).\nThe result is rounded to the nearest cent.\nExamples:\ncalculate_total_amount(5000.00, 5.00): This should return 5237.50, representing the total amount after one year including taxed interest.\ncalculate_total_amount(10000.00, 3.50): This should return 10347.25.", "level": "easy"}
{"task_id": "R/14", "prompt": "# This function calculate_word_score computes the total score of a given word based on the position of its letters in the alphabet. Each letter's score is its position in the alphabet (A/a = 1, B/b = 2, ..., Z/z = 26), and the function sums these values to get the total score of the word.\n# The word should contain only uppercase and lowercase letters.\n# Examples:\n# calculate_word_score(\"Hello\"): This should return 52, as H(8) + e(5) + l(12) + l(12) + o(15) = 52.\n\n\ncalculate_word_score <- function(word) ", "canonical_solution": "{\n    score <- 0\n    for (char in strsplit(word, \"\")[[1]]) {\n        if (char %in% letters) {\n            score <- score + which(letters == char)\n        } else if (char %in% LETTERS) {\n            score <- score + which(LETTERS == char)\n        }\n    }\n    return(score)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(calculate_word_score(\"Hello\") == 52)\n    stopifnot(calculate_word_score(\"abcABC\") == 12)\n    stopifnot(calculate_word_score(\"Zz\") == 52)\n    stopifnot(calculate_word_score(\"R\") == 18)\n    stopifnot(calculate_word_score(\"AttiTude\") == 100)\n}\n\n# Run tests\nmain()", "entry_point": "calculate_word_score", "signature": "calculate_word_score <- function(word)", "docstring": "This function calculate_word_score computes the total score of a given word based on the position of its letters in the alphabet. Each letter's score is its position in the alphabet (A/a = 1, B/b = 2, ..., Z/z = 26), and the function sums these values to get the total score of the word.\nThe word should contain only uppercase and lowercase letters.\nExamples:\ncalculate_word_score(\"Hello\"): This should return 52, as H(8) + e(5) + l(12) + l(12) + o(15) = 52.", "instruction": "Write a R function `calculate_word_score <- function(word)` to solve the following problem:\nThis function calculate_word_score computes the total score of a given word based on the position of its letters in the alphabet. Each letter's score is its position in the alphabet (A/a = 1, B/b = 2, ..., Z/z = 26), and the function sums these values to get the total score of the word.\nThe word should contain only uppercase and lowercase letters.\nExamples:\ncalculate_word_score(\"Hello\"): This should return 52, as H(8) + e(5) + l(12) + l(12) + o(15) = 52.", "level": "easy"}
{"task_id": "R/15", "prompt": "\n# This function 'calculate_game_points' calculates the total points scored in a series of game rounds. In each round, a player is given n integers. The player scores a point in a round if they can select two numbers from these integers whose sum equals k. The function takes the total number of rounds n, the target sum k, and a list of vectors, where each vector represents the integers given in each round.\n# Examples:\n# calculate_game_points(3, 20, list(c(1, 3, 5), c(9, 15, 5), c(1, 10, 10))): This returns 2, as in two of the rounds, the player can find pairs that sum up to 20.\n\n\ncalculate_game_points <- function(n, k, game_rounds) ", "canonical_solution": "{\n    score <- 0\n    for (round in game_rounds) {\n        found_pair <- FALSE\n        for (i in 1:(length(round) - 1)) {\n            for (j in (i + 1):length(round)) {\n                if (round[i] + round[j] == k) {\n                    found_pair <- TRUE\n                    break\n                }\n            }\n            if (found_pair) {\n                break\n            }\n        }\n        if (found_pair) {\n            score <- score + 1\n        }\n    }\n    return(score)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(calculate_game_points(3, 20, list(c(1, 3, 5), c(9, 15, 5), c(1, 10, 10))) == 2)\n    stopifnot(calculate_game_points(2, 10, list(c(2, 5, 3), c(1, 9, 4))) == 1)\n    stopifnot(calculate_game_points(4, 15, list(c(4, 11, 7), c(2, 6, 9), c(8, 5, 2), c(3, 12, 6))) == 3)\n    stopifnot(calculate_game_points(3, 8, list(c(1, 2, 5), c(3, 4, 1), c(6, 2, 0))) == 1)\n    stopifnot(calculate_game_points(2, 5, list(c(1, 1, 1), c(2, 2, 1))) == 0)\n}\n\n# Run tests\nmain()", "entry_point": "calculate_game_points", "signature": "calculate_game_points <- function(n, k, game_rounds)", "docstring": "This function 'calculate_game_points' calculates the total points scored in a series of game rounds. In each round, a player is given n integers. The player scores a point in a round if they can select two numbers from these integers whose sum equals k. The function takes the total number of rounds n, the target sum k, and a list of vectors, where each vector represents the integers given in each round.\nExamples:\ncalculate_game_points(3, 20, list(c(1, 3, 5), c(9, 15, 5), c(1, 10, 10))): This returns 2, as in two of the rounds, the player can find pairs that sum up to 20.", "instruction": "Write a R function `calculate_game_points <- function(n, k, game_rounds)` to solve the following problem:\nThis function 'calculate_game_points' calculates the total points scored in a series of game rounds. In each round, a player is given n integers. The player scores a point in a round if they can select two numbers from these integers whose sum equals k. The function takes the total number of rounds n, the target sum k, and a list of vectors, where each vector represents the integers given in each round.\nExamples:\ncalculate_game_points(3, 20, list(c(1, 3, 5), c(9, 15, 5), c(1, 10, 10))): This returns 2, as in two of the rounds, the player can find pairs that sum up to 20.", "level": "easy"}
{"task_id": "R/16", "prompt": "# This function `maximize_shortest_hop` is designed to determine the maximum possible minimum distance for a series of hops across a river, given a set of stones and the option to remove some of them. The river has stones placed at various distances from the start, and the goal is to ensure that the smallest hop distance between any two stones (including start and end) is as large as possible after removing up to M stones.\n# Args:\n#   L: The total length of the river (an integer).\n#   N: The number of stones in the river (an integer).\n#   M: The maximum number of stones that can be removed (an integer).\n#   distances: A vector of integers representing the distances of each stone from the start.\n# Returns:\n#   An integer representing the longest possible minimum distance between any two stones after removing up to M stones.\n# Examples:\n#   maximize_shortest_hop(25, 5, 2, c(2, 11, 14, 17, 21)): In this case, the function should return 9.\n\nmaximize_shortest_hop <- function(L, N, M, distances) ", "canonical_solution": "{\n    distances <- c(0, sort(distances), L) # Add start and end points\n    left <- 0\n    right <- L\n    best_distance <- 0\n\n    while (left <= right) {\n        mid <- (left + right) %/% 2\n        last <- 1 # Start from the first stone (including the start point)\n        removed <- 0\n\n        for (i in 2:(N+2)) { # Iterate through all stones including the end point\n            if (distances[i] - distances[last] < mid) {\n                removed <- removed + 1\n            } else {\n                last <- i\n            }\n        }\n\n        if (removed <= M) {\n            best_distance <- mid\n            left <- mid + 1\n        } else {\n            right <- mid - 1\n        }\n    }\n\n    return(best_distance)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(maximize_shortest_hop(25, 5, 2, c(2, 11, 14, 17, 21)) == 4)\n    stopifnot(maximize_shortest_hop(100, 10, 3, c(5, 15, 20, 30, 40, 50, 60, 70, 80, 90)) == 10)\n    stopifnot(maximize_shortest_hop(50, 4, 1, c(10, 20, 30, 40)) == 10)\n    stopifnot(maximize_shortest_hop(30, 3, 1, c(5, 15, 25)) == 5)\n    stopifnot(maximize_shortest_hop(200, 8, 3, c(20, 40, 60, 80, 120, 140, 160, 180)) == 20)\n}\n\n# Run tests\nmain()", "entry_point": "maximize_shortest_hop", "signature": "maximize_shortest_hop <- function(L, N, M, distances)", "docstring": "This function `maximize_shortest_hop` is designed to determine the maximum possible minimum distance for a series of hops across a river, given a set of stones and the option to remove some of them. The river has stones placed at various distances from the start, and the goal is to ensure that the smallest hop distance between any two stones (including start and end) is as large as possible after removing up to M stones.\nArgs:\nL: The total length of the river (an integer).\nN: The number of stones in the river (an integer).\nM: The maximum number of stones that can be removed (an integer).\ndistances: A vector of integers representing the distances of each stone from the start.\nReturns:\nAn integer representing the longest possible minimum distance between any two stones after removing up to M stones.\nExamples:\nmaximize_shortest_hop(25, 5, 2, c(2, 11, 14, 17, 21)): In this case, the function should return 9.", "instruction": "Write a R function `maximize_shortest_hop <- function(L, N, M, distances)` to solve the following problem:\nThis function `maximize_shortest_hop` is designed to determine the maximum possible minimum distance for a series of hops across a river, given a set of stones and the option to remove some of them. The river has stones placed at various distances from the start, and the goal is to ensure that the smallest hop distance between any two stones (including start and end) is as large as possible after removing up to M stones.\nArgs:\nL: The total length of the river (an integer).\nN: The number of stones in the river (an integer).\nM: The maximum number of stones that can be removed (an integer).\ndistances: A vector of integers representing the distances of each stone from the start.\nReturns:\nAn integer representing the longest possible minimum distance between any two stones after removing up to M stones.\nExamples:\nmaximize_shortest_hop(25, 5, 2, c(2, 11, 14, 17, 21)): In this case, the function should return 9.", "level": "hard"}
{"task_id": "R/17", "prompt": "# Assume that the nascent resources on Earth grow at a constant rate. According to this calculation, the existing resources on the earth plus new resources can support x billion people for a year, or y billion people for b years.\n\n# In order to achieve sustainable development and avoid resource depletion, how many billion people can the earth support?\n# Examples:\n# sustainable_population_limit(110, 90, 90, 210): In this case, the function returns 75.00.\nsustainable_population_limit <- function(x, a, y, b)", "canonical_solution": "{\n    # Calculate the total resource availability\n    total_resource_x <- x * a\n    total_resource_y <- y * b\n    max_population <- (total_resource_x - total_resource_y )/(a-b)\n\n    # Round the result to two decimal places\n    return(round(max_population, 2))\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(sustainable_population_limit(110, 90, 90, 210) == 75.00)\n    stopifnot(sustainable_population_limit(100, 50, 50, 150) == 25.00)\n    stopifnot(sustainable_population_limit(200, 100, 100, 300) == 50.00)\n    stopifnot(sustainable_population_limit(120, 60, 80, 240) == 66.67)\n\n}\n\n# Run tests\nmain()", "entry_point": "sustainable_population_limit", "signature": "sustainable_population_limit <- function(x, a, y, b)", "docstring": "Assume that the nascent resources on Earth grow at a constant rate. According to this calculation, the existing resources on the earth plus new resources can support x billion people for a year, or y billion people for b years.\nIn order to achieve sustainable development and avoid resource depletion, how many billion people can the earth support?\nExamples:\nsustainable_population_limit(110, 90, 90, 210): In this case, the function returns 75.00.", "instruction": "Write a R function `sustainable_population_limit <- function(x, a, y, b)` to solve the following problem:\nAssume that the nascent resources on Earth grow at a constant rate. According to this calculation, the existing resources on the earth plus new resources can support x billion people for a year, or y billion people for b years.\nIn order to achieve sustainable development and avoid resource depletion, how many billion people can the earth support?\nExamples:\nsustainable_population_limit(110, 90, 90, 210): In this case, the function returns 75.00.", "level": "easy"}
{"task_id": "R/18", "prompt": "# This function 'quick_sort' implements the quick sort algorithm recursively. The algorithm sorts an array by selecting a 'pivot' element (initially the first element) and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. Then it recursively applies the same strategy to the sub-arrays.\n# Examples:\n# quick_sort(c(3, 1, 4, 1, 5, 9, 2, 6)): This would return the sorted array c(1, 1, 2, 3, 4, 5, 6, 9).\n# quick_sort(c(5, 2, 9, 3, 7)): This would return c(2, 3, 5, 7, 9).\n\nquick_sort <- function(arr) ", "canonical_solution": "{\n    if (length(arr) <= 1) {\n        return(arr)\n    }\n\n    pivot <- arr[1]\n    left <- arr[arr < pivot]\n    middle <- arr[arr == pivot]\n    right <- arr[arr > pivot]\n\n    return(c(quick_sort(left), middle, quick_sort(right)))\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(identical(quick_sort(c(3, 1, 4, 1, 5, 9, 2, 6)), c(1, 1, 2, 3, 4, 5, 6, 9)))\n    stopifnot(identical(quick_sort(c(5, 2, 9, 3, 7)), c(2, 3, 5, 7, 9)))\n    stopifnot(identical(quick_sort(c(10, 7, 8, 9, 1, 5)), c(1, 5, 7, 8, 9, 10)))\n    stopifnot(identical(quick_sort(c(1, 2, 3, 4, 5)), c(1, 2, 3, 4, 5)))\n    stopifnot(identical(quick_sort(c(9, 8, 7, 6, 5, 4, 3, 2, 1)), c(1, 2, 3, 4, 5, 6, 7, 8, 9)))\n    stopifnot(identical(quick_sort(c()), c()))\n\n}\n\n# Run tests\nmain()", "entry_point": "quick_sort", "signature": "quick_sort <- function(arr)", "docstring": "This function 'quick_sort' implements the quick sort algorithm recursively. The algorithm sorts an array by selecting a 'pivot' element (initially the first element) and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. Then it recursively applies the same strategy to the sub-arrays.\nExamples:\nquick_sort(c(3, 1, 4, 1, 5, 9, 2, 6)): This would return the sorted array c(1, 1, 2, 3, 4, 5, 6, 9).\nquick_sort(c(5, 2, 9, 3, 7)): This would return c(2, 3, 5, 7, 9).", "instruction": "Write a R function `quick_sort <- function(arr)` to solve the following problem:\nThis function 'quick_sort' implements the quick sort algorithm recursively. The algorithm sorts an array by selecting a 'pivot' element (initially the first element) and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. Then it recursively applies the same strategy to the sub-arrays.\nExamples:\nquick_sort(c(3, 1, 4, 1, 5, 9, 2, 6)): This would return the sorted array c(1, 1, 2, 3, 4, 5, 6, 9).\nquick_sort(c(5, 2, 9, 3, 7)): This would return c(2, 3, 5, 7, 9).", "level": "easy"}
{"task_id": "R/19", "prompt": "# This function, next_perfect_square, calculates the smallest perfect square number that is greater than or equal to a given integer n. A perfect square is a number that can be expressed as the square of an integer. \n# Examples:\n# next_perfect_square(71711): In this case, the function returns 71824, as it is the smallest perfect square greater than 71711.\n\n\nnext_perfect_square <- function(n) ", "canonical_solution": "{\n    # Calculate the square root of n\n    sqrt_n <- sqrt(n)\n    \n    # Round up to the nearest whole number\n    rounded_sqrt_n <- ceiling(sqrt_n)\n    \n    # Return the square of the rounded square root\n    return(rounded_sqrt_n^2)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(next_perfect_square(71711) == 71824)\n    stopifnot(next_perfect_square(16) == 16)\n    stopifnot(next_perfect_square(15) == 16)\n    stopifnot(next_perfect_square(1) == 1)\n    stopifnot(next_perfect_square(26) == 36)\n    stopifnot(next_perfect_square(100000) == 100489)\n\n}\n# Run tests\nmain()", "entry_point": "next_perfect_square", "signature": "next_perfect_square <- function(n)", "docstring": "This function, next_perfect_square, calculates the smallest perfect square number that is greater than or equal to a given integer n. A perfect square is a number that can be expressed as the square of an integer.\nExamples:\nnext_perfect_square(71711): In this case, the function returns 71824, as it is the smallest perfect square greater than 71711.", "instruction": "Write a R function `next_perfect_square <- function(n)` to solve the following problem:\nThis function, next_perfect_square, calculates the smallest perfect square number that is greater than or equal to a given integer n. A perfect square is a number that can be expressed as the square of an integer.\nExamples:\nnext_perfect_square(71711): In this case, the function returns 71824, as it is the smallest perfect square greater than 71711.", "level": "easy"}
{"task_id": "R/20", "prompt": "\n# This function, most_frequent_value, identifies the most frequently occurring value in a sorted vector of integers. If there are multiple values with the same highest frequency, it returns the smallest of these values. The input is a sorted vector of integers, and the function returns the integer that appears most frequently.\n\n# Examples:\n\n# most_frequent_value(c(3, 3, 4, 4, 4, 5)): Returns 4.\n# most_frequent_value(c(10, 20, 20, 20, 30)): Returns 20.\n# most_frequent_value(c(1, 1, 2, 2, 3)): Returns 1.\n\nmost_frequent_value <- function(sorted_values) ", "canonical_solution": "{\n    n <- length(sorted_values)\n    if (n == 0) return(NULL)\n\n    most_frequent <- sorted_values[1]\n    max_count <- 1\n    current_count <- 1\n\n    for (i in 2:n) {\n        if (sorted_values[i] == sorted_values[i-1]) {\n            current_count <- current_count + 1\n        } else {\n            if (current_count > max_count) {\n                max_count <- current_count\n                most_frequent <- sorted_values[i-1]\n            }\n            current_count <- 1\n        }\n    }\n\n    # Check the last element\n    if (current_count > max_count) {\n        most_frequent <- sorted_values[n]\n    }\n\n    return(most_frequent)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(most_frequent_value(c(3, 3, 4, 4, 4, 5)) == 4)\n    stopifnot(most_frequent_value(c(10, 20, 20, 20, 30)) == 20)\n    stopifnot(most_frequent_value(c(1, 1, 2, 2, 3)) == 1)\n    stopifnot(most_frequent_value(c(100, 150, 150, 200, 250)) == 150)\n    stopifnot(most_frequent_value(c(7, 8, 8, 9)) == 8)\n    stopifnot(most_frequent_value(c()) == NULL)\n\n}\n\n# Run tests\nmain()", "entry_point": "most_frequent_value", "signature": "most_frequent_value <- function(sorted_values)", "docstring": "This function, most_frequent_value, identifies the most frequently occurring value in a sorted vector of integers. If there are multiple values with the same highest frequency, it returns the smallest of these values. The input is a sorted vector of integers, and the function returns the integer that appears most frequently.\nExamples:\nmost_frequent_value(c(3, 3, 4, 4, 4, 5)): Returns 4.\nmost_frequent_value(c(10, 20, 20, 20, 30)): Returns 20.\nmost_frequent_value(c(1, 1, 2, 2, 3)): Returns 1.", "instruction": "Write a R function `most_frequent_value <- function(sorted_values)` to solve the following problem:\nThis function, most_frequent_value, identifies the most frequently occurring value in a sorted vector of integers. If there are multiple values with the same highest frequency, it returns the smallest of these values. The input is a sorted vector of integers, and the function returns the integer that appears most frequently.\nExamples:\nmost_frequent_value(c(3, 3, 4, 4, 4, 5)): Returns 4.\nmost_frequent_value(c(10, 20, 20, 20, 30)): Returns 20.\nmost_frequent_value(c(1, 1, 2, 2, 3)): Returns 1.", "level": "middle"}
{"task_id": "R/21", "prompt": "# count_chess_placements calculates the total number of ways to place 'k' chess pieces on a given 'n x n' board in such a way that no two pieces are in the same row or column. The board is represented as a matrix of characters, where '#' indicates a part of the chessboard and '.' indicates an empty space. The function returns the total number of placement configurations.\n# Examples:\n# count_chess_placements(2, 1, matrix(c('#', '.', '.', '#'), nrow = 2, byrow = TRUE))\n#     2\n\ncount_chess_placements <- function(n, k, board) ", "canonical_solution": "{\n    if (k == 0) return(1)\n    if (n <= 0) return(0)\n\n    # Helper function to count placements in a sub-board\n    count_placements_helper <- function(row, k, used_columns) {\n        if (k == 0) return(1)\n        if (row > n) return(0)\n\n        count <- 0\n        for (col in 1:n) {\n            if (board[row, col] == '#' && !used_columns[col]) {\n                used_columns[col] <- TRUE\n                count <- count + count_placements_helper(row + 1, k - 1, used_columns)\n                used_columns[col] <- FALSE\n            }\n        }\n        count <- count + count_placements_helper(row + 1, k, used_columns)\n        return(count)\n    }\n\n    # Initialize a boolean array to track used columns\n    used_columns <- rep(FALSE, n)\n    return(count_placements_helper(1, k, used_columns))\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(count_chess_placements(2, 1, matrix(c('#', '.', '.', '#'), nrow = 2, byrow = TRUE)) == 2)\n    stopifnot(count_chess_placements(4, 4, matrix(c('.', '.', '.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.'), nrow = 4, byrow = TRUE)) == 1)\n    stopifnot(count_chess_placements(3, 2, matrix(c('#', '#', '.', '.', '#', '.', '.', '.', '#'), nrow = 3, byrow = TRUE)) == 4)\n\n}\n\n\n# Run tests\nmain()", "entry_point": "count_chess_placements", "signature": "count_chess_placements <- function(n, k, board)", "docstring": "count_chess_placements calculates the total number of ways to place 'k' chess pieces on a given 'n x n' board in such a way that no two pieces are in the same row or column. The board is represented as a matrix of characters, where '' indicates a part of the chessboard and '.' indicates an empty space. The function returns the total number of placement configurations.\nExamples:\ncount_chess_placements(2, 1, matrix(c('', '.', '.', ''), nrow = 2, byrow = TRUE))\n2", "instruction": "Write a R function `count_chess_placements <- function(n, k, board)` to solve the following problem:\ncount_chess_placements calculates the total number of ways to place 'k' chess pieces on a given 'n x n' board in such a way that no two pieces are in the same row or column. The board is represented as a matrix of characters, where '' indicates a part of the chessboard and '.' indicates an empty space. The function returns the total number of placement configurations.\nExamples:\ncount_chess_placements(2, 1, matrix(c('', '.', '.', ''), nrow = 2, byrow = TRUE))\n2", "level": "hard"}
{"task_id": "R/22", "prompt": "# This function calculates the number of ways a knight (\u9a6c) in Chinese chess can traverse a given n x m chessboard, starting from position (x, y), without revisiting any point. The knight moves in an \"L\" shape, similar to the knight in international chess.\n# The function takes four arguments: n (number of rows), m (number of columns), and the starting coordinates x and y (1-indexed). The function returns the total number of unique paths the knight can take to cover every point on the board exactly once.\n# Examples:\n# >>> knight_tour_paths(5, 4, 1, 1)\n#     32\n# >>> knight_tour_paths(3, 3, 1, 1)\n#     0   \n\nknight_tour_paths <- function(n, m, sta_x, sta_y) ", "canonical_solution": "{\n  # Define the moves of a knight in terms of row and column changes\n  dx <- c(1, 1, -2, -1, -2, -1, 2, 2)\n  dy <- c(2, -2, 1, 2, -1, -2, 1, -1)\n  count = 0\n  # Initialize the board with FALSE indicating unvisited positions\n  f <- matrix(0, nrow = n, ncol = m)\n\n  # Function to perform DFS\n  dfs <- function(x, y, sum) {\n    if (sum == n * m) {\n      count <<- count+1\n    } \n    else {\n      for (i in 1:8) {\n        xx <- x + dx[i]\n        yy <- y + dy[i]\n        \n        if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && f[xx, yy] == 0) {\n          f[xx, yy] <<- 1\n          dfs(xx, yy, sum + 1)\n          f[xx, yy] <<- 0\n        }\n      }\n    }\n  }\n\n  # Mark the starting position as visited and start DFS\n  f[sta_x, sta_y] <- 1  # Adjusting for 1-based indexing in R\n  dfs(sta_x, sta_y, 1)\n  return(count)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(knight_tour_paths(5, 4, 1, 1) == 32)\n    stopifnot(knight_tour_paths(3, 3, 1, 1) == 0)\n    stopifnot(knight_tour_paths(3, 4, 1, 1) == 2)\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "knight_tour_paths", "signature": "knight_tour_paths <- function(n, m, sta_x, sta_y)", "docstring": "This function calculates the number of ways a knight (\u9a6c) in Chinese chess can traverse a given n x m chessboard, starting from position (x, y), without revisiting any point. The knight moves in an \"L\" shape, similar to the knight in international chess.\nThe function takes four arguments: n (number of rows), m (number of columns), and the starting coordinates x and y (1-indexed). The function returns the total number of unique paths the knight can take to cover every point on the board exactly once.\nExamples:\n>>> knight_tour_paths(5, 4, 1, 1)\n32\n>>> knight_tour_paths(3, 3, 1, 1)\n0", "instruction": "Write a R function `knight_tour_paths <- function(n, m, sta_x, sta_y)` to solve the following problem:\nThis function calculates the number of ways a knight (\u9a6c) in Chinese chess can traverse a given n x m chessboard, starting from position (x, y), without revisiting any point. The knight moves in an \"L\" shape, similar to the knight in international chess.\nThe function takes four arguments: n (number of rows), m (number of columns), and the starting coordinates x and y (1-indexed). The function returns the total number of unique paths the knight can take to cover every point on the board exactly once.\nExamples:\n>>> knight_tour_paths(5, 4, 1, 1)\n32\n>>> knight_tour_paths(3, 3, 1, 1)\n0", "level": "hard"}
{"task_id": "R/23", "prompt": "\n# This function `next_binary_number_with_same_ones` finds the smallest positive integer greater than N, which has the same number of 1s in its binary representation as N. \n# It takes an integer N as input and returns the next integer that meets the criteria.\n# Examples:\n# >>> next_binary_number_with_same_ones(1)\n#     2\n# >>> next_binary_number_with_same_ones(78)\n#     83\n\n\nnext_binary_number_with_same_ones <- function(N) ", "canonical_solution": "{\n    original_ones <- sum(as.integer(intToBits(N)) == 1)\n    next_number <- N + 1\n    while (sum(as.integer(intToBits(next_number)) == 1) != original_ones) {\n        next_number <- next_number + 1\n    }\n    return(next_number)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(next_binary_number_with_same_ones(1) == 2)\n    stopifnot(next_binary_number_with_same_ones(2) == 4)\n    stopifnot(next_binary_number_with_same_ones(3) == 5)\n    stopifnot(next_binary_number_with_same_ones(4) == 8)\n    stopifnot(next_binary_number_with_same_ones(78) == 83)\n\n}\n\n\n# Run tests\nmain()", "entry_point": "next_binary_number_with_same_ones", "signature": "next_binary_number_with_same_ones <- function(N)", "docstring": "This function `next_binary_number_with_same_ones` finds the smallest positive integer greater than N, which has the same number of 1s in its binary representation as N.\nIt takes an integer N as input and returns the next integer that meets the criteria.\nExamples:\n>>> next_binary_number_with_same_ones(1)\n2\n>>> next_binary_number_with_same_ones(78)\n83", "instruction": "Write a R function `next_binary_number_with_same_ones <- function(N)` to solve the following problem:\nThis function `next_binary_number_with_same_ones` finds the smallest positive integer greater than N, which has the same number of 1s in its binary representation as N.\nIt takes an integer N as input and returns the next integer that meets the criteria.\nExamples:\n>>> next_binary_number_with_same_ones(1)\n2\n>>> next_binary_number_with_same_ones(78)\n83", "level": "easy"}
{"task_id": "R/24", "prompt": "\n# This function longest_increasing_subsequence takes a vector sequence representing a sequence of integers and returns the length of the longest increasing subsequence within it. An increasing subsequence is defined as a set of numbers in the sequence that are in increasing order and are taken from the original sequence without changing their order. The length of the subsequence is the number of elements it contains.\n\n# Example 1:\n# Input: c(1, 7, 3, 5, 9, 4, 8)\n# Output: 4 (The longest increasing subsequence is 1, 3, 5, 8)\n\n# Example 2:\n# Input: c(10, 22, 9, 33, 21, 50, 41, 60)\n# Output: 5 (The longest increasing subsequence is 10, 22, 33, 50, 60)\n\nlongest_increasing_subsequence <- function(sequence) ", "canonical_solution": "{\n    n <- length(sequence)\n    lis <- numeric(n)\n    lis[1] <- 1\n\n    for (i in 2:n) {\n        max_val <- 0\n        for (j in 1:(i-1)) {\n            if (sequence[i] > sequence[j] && lis[j] > max_val) {\n                max_val <- lis[j]\n            }\n        }\n        lis[i] <- max_val + 1\n    }\n\n    max(lis)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(longest_increasing_subsequence(c(1, 7, 3, 5, 9, 4, 8)) == 4)\n    stopifnot(longest_increasing_subsequence(c(10, 22, 9, 33, 21, 50, 41, 60)) == 5)\n    stopifnot(longest_increasing_subsequence(c(5, 3, 4, 8, 6, 7)) == 4)\n\n}\n\n\n# Run tests\nmain()", "entry_point": "longest_increasing_subsequence", "signature": "longest_increasing_subsequence <- function(sequence)", "docstring": "This function longest_increasing_subsequence takes a vector sequence representing a sequence of integers and returns the length of the longest increasing subsequence within it. An increasing subsequence is defined as a set of numbers in the sequence that are in increasing order and are taken from the original sequence without changing their order. The length of the subsequence is the number of elements it contains.\nExample 1:\nInput: c(1, 7, 3, 5, 9, 4, 8)\nOutput: 4 (The longest increasing subsequence is 1, 3, 5, 8)\nExample 2:\nInput: c(10, 22, 9, 33, 21, 50, 41, 60)\nOutput: 5 (The longest increasing subsequence is 10, 22, 33, 50, 60)", "instruction": "Write a R function `longest_increasing_subsequence <- function(sequence)` to solve the following problem:\nThis function longest_increasing_subsequence takes a vector sequence representing a sequence of integers and returns the length of the longest increasing subsequence within it. An increasing subsequence is defined as a set of numbers in the sequence that are in increasing order and are taken from the original sequence without changing their order. The length of the subsequence is the number of elements it contains.\nExample 1:\nInput: c(1, 7, 3, 5, 9, 4, 8)\nOutput: 4 (The longest increasing subsequence is 1, 3, 5, 8)\nExample 2:\nInput: c(10, 22, 9, 33, 21, 50, 41, 60)\nOutput: 5 (The longest increasing subsequence is 10, 22, 33, 50, 60)", "level": "easy"}
{"task_id": "R/25", "prompt": "\n# This function max_scenic_views determines the maximum number of scenic spots that can be visited under certain conditions. Given n as the number of scenic spots and a vector altitudes representing the altitude of each spot, the function returns the maximum number of spots that can be visited. The rules are:\n\n# The spots must be visited in increasing order of their IDs (i.e., visit a spot with a higher ID than the previous).\n# Consecutive spots with the same altitude cannot be visited.\n# Once the descent starts (visiting a spot at a lower altitude), it's not allowed to go back up.\n# Examples:\n\n# max_scenic_views(8, c(186, 186, 150, 200, 160, 130, 197, 220)) should return 4.\n\n\nmax_scenic_views <- function(n, altitudes) ", "canonical_solution": "{\n  # Create vectors to store the longest increasing subsequence values\n  f <- rep(1, n)\n  g <- rep(1, n)\n  \n  # Calculating f: LIS from the start to each element\n  for (i in 2:n) {\n    for (j in 1:(i-1)) {\n    \n      if (altitudes[j] < altitudes[i] ) {\n        f[i] <- max(f[i], f[j] + 1)\n      }\n    }\n  }\n  \n  # Calculating g: LIS from the end to each element\n  for (i in (n-1):1) {\n    for (j in n:(i+1)) {\n      if (altitudes[j] < altitudes[i] ) {\n        g[i] <- max(g[i], g[j] + 1)\n      }\n    }\n  }\n  \n  # Calculating the result\n  res <- 0\n  for (i in 1:n) {\n    res <- max(res, f[i] + g[i] - 1)\n  }\n#   print(res)\n  return(res)\n}", "test": "# Test cases\nmain <- function() {\n\n  stopifnot(max_scenic_views(8, c(186, 186, 150, 200, 160, 130, 197, 220)) == 4)\n  stopifnot(max_scenic_views(5, c(100, 120, 110, 130, 140)) == 4)\n  stopifnot(max_scenic_views(4, c(100, 100, 100, 100)) == 1)\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "max_scenic_views", "signature": "max_scenic_views <- function(n, altitudes)", "docstring": "This function max_scenic_views determines the maximum number of scenic spots that can be visited under certain conditions. Given n as the number of scenic spots and a vector altitudes representing the altitude of each spot, the function returns the maximum number of spots that can be visited. The rules are:\nThe spots must be visited in increasing order of their IDs (i.e., visit a spot with a higher ID than the previous).\nConsecutive spots with the same altitude cannot be visited.\nOnce the descent starts (visiting a spot at a lower altitude), it's not allowed to go back up.\nExamples:\nmax_scenic_views(8, c(186, 186, 150, 200, 160, 130, 197, 220)) should return 4.", "instruction": "Write a R function `max_scenic_views <- function(n, altitudes)` to solve the following problem:\nThis function max_scenic_views determines the maximum number of scenic spots that can be visited under certain conditions. Given n as the number of scenic spots and a vector altitudes representing the altitude of each spot, the function returns the maximum number of spots that can be visited. The rules are:\nThe spots must be visited in increasing order of their IDs (i.e., visit a spot with a higher ID than the previous).\nConsecutive spots with the same altitude cannot be visited.\nOnce the descent starts (visiting a spot at a lower altitude), it's not allowed to go back up.\nExamples:\nmax_scenic_views(8, c(186, 186, 150, 200, 160, 130, 197, 220)) should return 4.", "level": "hard"}
{"task_id": "R/26", "prompt": "\n# This function max_ascending_subseq_sum calculates the maximum sum of an ascending subsequence within a given sequence of integers. An ascending subsequence is defined as a sequence where each subsequent number is greater than the previous one. The function takes a numeric vector as input and returns the maximum sum of any ascending subsequence within this vector.\n# Examples:\n# >>> max_ascending_subseq_sum(c(1, 7, 3, 5, 9, 4, 8))\n#     18\n# >>> max_ascending_subseq_sum(c(100, 1, 2, 3))\n#     100\n\nmax_ascending_subseq_sum <- function(sequence) ", "canonical_solution": "{\n    n <- length(sequence)\n    if (n == 0) return(0)\n    max_sums <- rep(0, n)\n    max_sums[1] <- sequence[1]\n    \n    for (i in 2:n) {\n        for (j in 1:(i-1)) {\n            if (sequence[j] < sequence[i] && max_sums[j] + sequence[i] > max_sums[i]) {\n                max_sums[i] <- max_sums[j] + sequence[i]\n            }\n        }\n        if (max_sums[i] == 0) max_sums[i] <- sequence[i] # For standalone element\n    }\n    \n    return(max(max_sums))\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(max_ascending_subseq_sum(c(1, 7, 3, 5, 9, 4, 8)) == 18)\n    stopifnot(max_ascending_subseq_sum(c(100, 1, 2, 3)) == 100)\n    stopifnot(max_ascending_subseq_sum(c(10, 20, 30, 5, 6)) == 60)\n\n\n}\n\n# Run tests\nmain()", "entry_point": "max_ascending_subseq_sum", "signature": "max_ascending_subseq_sum <- function(sequence)", "docstring": "This function max_ascending_subseq_sum calculates the maximum sum of an ascending subsequence within a given sequence of integers. An ascending subsequence is defined as a sequence where each subsequent number is greater than the previous one. The function takes a numeric vector as input and returns the maximum sum of any ascending subsequence within this vector.\nExamples:\n>>> max_ascending_subseq_sum(c(1, 7, 3, 5, 9, 4, 8))\n18\n>>> max_ascending_subseq_sum(c(100, 1, 2, 3))\n100", "instruction": "Write a R function `max_ascending_subseq_sum <- function(sequence)` to solve the following problem:\nThis function max_ascending_subseq_sum calculates the maximum sum of an ascending subsequence within a given sequence of integers. An ascending subsequence is defined as a sequence where each subsequent number is greater than the previous one. The function takes a numeric vector as input and returns the maximum sum of any ascending subsequence within this vector.\nExamples:\n>>> max_ascending_subseq_sum(c(1, 7, 3, 5, 9, 4, 8))\n18\n>>> max_ascending_subseq_sum(c(100, 1, 2, 3))\n100", "level": "easy"}
{"task_id": "R/27", "prompt": "\n# The function `minimum_cost_path` calculates the minimum cost needed for a merchant to traverse from the top-left corner to the bottom-right corner of an N\u00d7N square grid within (2N-1) time units, where each cell of the grid has a specific cost associated with passing through it. The merchant can only move left, right, up, or down, but cannot move diagonally or leave the grid.\n# The function accepts a matrix 'grid' where each element represents the cost of traversing that cell.\n# Examples:\n# >>> minimum_cost_path(matrix(c(1, 2, 6, 10, 20, 4, 5, 8, 11, 23, 6, 7, 9, 12, 25, 8, 15, 18, 19, 29, 10, 17, 20, 21, 33), nrow = 5, ncol = 5, byrow = TRUE))\n#     109\n\n\nminimum_cost_path <- function(grid) ", "canonical_solution": "{\n  # Get the dimensions of the grid\n  n <- nrow(grid)\n\n  # Initialize the cost matrix with maximum possible values\n  cost_matrix <- matrix(rep(Inf, n * n), nrow = n)\n\n  # Set the starting point cost\n  cost_matrix[1, 1] <- grid[1, 1]\n\n  # Compute the minimum cost path for each cell\n  for (i in 1:n) {\n    for (j in 1:n) {\n      # Update from top cell if not on the first row\n      if (i > 1) {\n        cost_matrix[i, j] <- min(cost_matrix[i, j], cost_matrix[i-1, j] + grid[i, j])\n      }\n      # Update from left cell if not on the first column\n      if (j > 1) {\n        cost_matrix[i, j] <- min(cost_matrix[i, j], cost_matrix[i, j-1] + grid[i, j])\n      }\n      # Update from bottom cell if not on the last row\n      if (i < n) {\n        cost_matrix[i+1, j] <- min(cost_matrix[i+1, j], cost_matrix[i, j] + grid[i+1, j])\n      }\n      # Update from right cell if not on the last column\n      if (j < n) {\n        cost_matrix[i, j+1] <- min(cost_matrix[i, j+1], cost_matrix[i, j] + grid[i, j+1])\n      }\n    }\n  }\n\n  # Return the cost to reach the bottom-right corner\n  return(cost_matrix[n, n])\n}", "test": "# Test cases\nmain <- function() {\n\n  stopifnot(minimum_cost_path(matrix(c(1, 2, 6, 10, 20, 4, 5, 8, 11, 23, 6, 7, 9, 12, 25, 8, 15, 18, 19, 29, 10, 17, 20, 21, 33), nrow = 5, ncol = 5, byrow = TRUE)) == 109)\n\n  stopifnot(minimum_cost_path(matrix(c(1, 2, 6, 10), nrow = 2, ncol = 2, byrow = TRUE)) == 13)\n}\n\n\n# Run tests\nmain()", "entry_point": "minimum_cost_path", "signature": "minimum_cost_path <- function(grid)", "docstring": "The function `minimum_cost_path` calculates the minimum cost needed for a merchant to traverse from the top-left corner to the bottom-right corner of an N\u00d7N square grid within (2N-1) time units, where each cell of the grid has a specific cost associated with passing through it. The merchant can only move left, right, up, or down, but cannot move diagonally or leave the grid.\nThe function accepts a matrix 'grid' where each element represents the cost of traversing that cell.\nExamples:\n>>> minimum_cost_path(matrix(c(1, 2, 6, 10, 20, 4, 5, 8, 11, 23, 6, 7, 9, 12, 25, 8, 15, 18, 19, 29, 10, 17, 20, 21, 33), nrow = 5, ncol = 5, byrow = TRUE))\n109", "instruction": "Write a R function `minimum_cost_path <- function(grid)` to solve the following problem:\nThe function `minimum_cost_path` calculates the minimum cost needed for a merchant to traverse from the top-left corner to the bottom-right corner of an N\u00d7N square grid within (2N-1) time units, where each cell of the grid has a specific cost associated with passing through it. The merchant can only move left, right, up, or down, but cannot move diagonally or leave the grid.\nThe function accepts a matrix 'grid' where each element represents the cost of traversing that cell.\nExamples:\n>>> minimum_cost_path(matrix(c(1, 2, 6, 10, 20, 4, 5, 8, 11, 23, 6, 7, 9, 12, 25, 8, 15, 18, 19, 29, 10, 17, 20, 21, 33), nrow = 5, ncol = 5, byrow = TRUE))\n109", "level": "hard"}
{"task_id": "R/28", "prompt": "# This function max_path_sum calculates the maximum sum of numbers along a path from the top to the bottom of a triangle represented by a matrix. Each step can only move to the number directly below or to the number to the immediate right below the current number. The input is a matrix where each row represents a level of the triangle.\n\n# Examples:\n\n# # Example 1\n# triangle_matrix <- matrix(c(7, NA, NA, NA,\n#                             3, 8, NA, NA,\n#                             8, 1, 0, NA,\n#                             2, 7, 4, 4),\n#                           nrow = 4, byrow = TRUE)\n# max_path_sum(triangle_matrix)\n# # Output: 25\n\n# # Example 2\n# triangle_matrix <- matrix(c(7, NA, NA,\n#                             3, 8, NA,\n#                             8, 1, 0),\n#                           nrow = 3, byrow = TRUE)\n# max_path_sum(triangle_matrix)\n# # Output: 18\n\n\nmax_path_sum <- function(triangle_matrix) ", "canonical_solution": "{\n    # Remove NA values from the matrix\n    triangle_matrix[is.na(triangle_matrix)] <- 0\n    n <- nrow(triangle_matrix)\n    for (row in (n-1):1) {\n        for (col in 1:row) {\n            triangle_matrix[row, col] <- triangle_matrix[row, col] + \n                                         max(triangle_matrix[row + 1, col], \n                                             triangle_matrix[row + 1, col + 1])\n        }\n    }\n    return(triangle_matrix[1, 1])\n}", "test": "# Test cases\nmain <- function() {\n\n\ntriangle_matrix <- matrix(c(7, NA, NA, NA, NA,\n                            3, 8, NA, NA, NA,\n                            8, 1, 0, NA, NA,\n                            2, 7, 4, 4, NA, \n                            4, 5, 2, 6, 5),\n                          nrow = 5, byrow = TRUE)\nstopifnot(max_path_sum(triangle_matrix) == 30)\n\n# Test case 1\ntriangle_matrix <- matrix(c(7, NA, NA, NA,\n                            3, 8, NA, NA,\n                            8, 1, 0, NA,\n                            2, 7, 4, 4),\n                          nrow = 4, byrow = TRUE)\nstopifnot(max_path_sum(triangle_matrix) == 25)\n\n# Test case 2\ntriangle_matrix <- matrix(c(7, NA, NA,\n                            3, 8, NA,\n                            8, 1, 0),\n                          nrow = 3, byrow = TRUE)\nstopifnot(max_path_sum(triangle_matrix) == 18)\n\n# Test case 3\ntriangle_matrix <- matrix(c(1, NA, NA, NA,\n                            2, 3, NA, NA,\n                            4, 5, 6, NA,\n                            7, 8, 9, 10),\n                          nrow = 4, byrow = TRUE)\nstopifnot(max_path_sum(triangle_matrix) == 20)\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "max_path_sum", "signature": "max_path_sum <- function(triangle_matrix)", "docstring": "This function max_path_sum calculates the maximum sum of numbers along a path from the top to the bottom of a triangle represented by a matrix. Each step can only move to the number directly below or to the number to the immediate right below the current number. The input is a matrix where each row represents a level of the triangle.\nExamples:\nExample 1\ntriangle_matrix <- matrix(c(7, NA, NA, NA,\n3, 8, NA, NA,\n8, 1, 0, NA,\n2, 7, 4, 4),\nnrow = 4, byrow = TRUE)\nmax_path_sum(triangle_matrix)\nOutput: 25\nExample 2\ntriangle_matrix <- matrix(c(7, NA, NA,\n3, 8, NA,\n8, 1, 0),\nnrow = 3, byrow = TRUE)\nmax_path_sum(triangle_matrix)\nOutput: 18", "instruction": "Write a R function `max_path_sum <- function(triangle_matrix)` to solve the following problem:\nThis function max_path_sum calculates the maximum sum of numbers along a path from the top to the bottom of a triangle represented by a matrix. Each step can only move to the number directly below or to the number to the immediate right below the current number. The input is a matrix where each row represents a level of the triangle.\nExamples:\nExample 1\ntriangle_matrix <- matrix(c(7, NA, NA, NA,\n3, 8, NA, NA,\n8, 1, 0, NA,\n2, 7, 4, 4),\nnrow = 4, byrow = TRUE)\nmax_path_sum(triangle_matrix)\nOutput: 25\nExample 2\ntriangle_matrix <- matrix(c(7, NA, NA,\n3, 8, NA,\n8, 1, 0),\nnrow = 3, byrow = TRUE)\nmax_path_sum(triangle_matrix)\nOutput: 18", "level": "easy"}
{"task_id": "R/29", "prompt": "\n# This function, calculate_string_distance, computes the \"distance\" between two strings. The distance is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into the other. \n# This kind of measurement is often known as Levenshtein distance.\n# Examples:\n# >>> calculate_string_distance(\"abcdefg\", \"abcdef\")\n#     1\n# >>> calculate_string_distance(\"ab\", \"ab\")\n#     0\n# >>> calculate_string_distance(\"mnklj\", \"jlknm\")\n#     4\n\ncalculate_string_distance <- function(string1, string2) ", "canonical_solution": "{\n    len1 <- nchar(string1)\n    len2 <- nchar(string2)\n    dp_matrix <- matrix(0, nrow = len1 + 1, ncol = len2 + 1)\n\n    for (i in 1:(len1 + 1)) {\n        for (j in 1:(len2 + 1)) {\n            if (i == 1) {\n                dp_matrix[i, j] <- j - 1\n            } else if (j == 1) {\n                dp_matrix[i, j] <- i - 1\n            } else {\n                insert_cost <- dp_matrix[i, j - 1] + 1\n                delete_cost <- dp_matrix[i - 1, j] + 1\n                sub_cost <- dp_matrix[i - 1, j - 1] + as.integer(substr(string1, i - 1, i - 1) != substr(string2, j - 1, j - 1))\n                dp_matrix[i, j] <- min(insert_cost, delete_cost, sub_cost)\n            }\n        }\n    }\n\n    return(dp_matrix[len1 + 1, len2 + 1])\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(calculate_string_distance(\"abcdefg\", \"abcdef\") == 1)\n    stopifnot(calculate_string_distance(\"abcfbc\", \"abfcab\") == 3)\n    stopifnot(calculate_string_distance(\"programming\", \"contest\") == 10)\n    stopifnot(calculate_string_distance(\"ab\", \"ab\") == 0)\n    stopifnot(calculate_string_distance(\"mnklj\", \"jlknm\") == 4)\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "calculate_string_distance", "signature": "calculate_string_distance <- function(string1, string2)", "docstring": "This function, calculate_string_distance, computes the \"distance\" between two strings. The distance is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into the other.\nThis kind of measurement is often known as Levenshtein distance.\nExamples:\n>>> calculate_string_distance(\"abcdefg\", \"abcdef\")\n1\n>>> calculate_string_distance(\"ab\", \"ab\")\n0\n>>> calculate_string_distance(\"mnklj\", \"jlknm\")\n4", "instruction": "Write a R function `calculate_string_distance <- function(string1, string2)` to solve the following problem:\nThis function, calculate_string_distance, computes the \"distance\" between two strings. The distance is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into the other.\nThis kind of measurement is often known as Levenshtein distance.\nExamples:\n>>> calculate_string_distance(\"abcdefg\", \"abcdef\")\n1\n>>> calculate_string_distance(\"ab\", \"ab\")\n0\n>>> calculate_string_distance(\"mnklj\", \"jlknm\")\n4", "level": "hard"}
{"task_id": "R/30", "prompt": "\n# This function, minimum_score_merge, calculates the minimum score required to merge N piles of stones into a single pile. The score for each merge is the sum of the stones in the two piles being merged. The function takes a vector representing the number of stones in each pile and returns the minimum total score needed for all merges.\n# Examples:\n# >>> minimum_score_merge(c(13, 7, 8, 16, 21, 4, 18))\n#     239\n\nminimum_score_merge <- function(stone_piles) ", "canonical_solution": "{\n    n <- length(stone_piles)\n    dp <- matrix(0, n, n)\n    sum <- cumsum(c(0, stone_piles))\n\n    for (len in 2:n) {\n        for (i in 1:(n - len + 1)) {\n            j <- i + len - 1\n            dp[i, j] <- min(sapply(1:(len - 1), function(k) dp[i, i + k - 1] + dp[i + k, j]))\n            dp[i, j] <- dp[i, j] + sum[j + 1] - sum[i]\n        }\n    }\n\n    return(dp[1, n])\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(minimum_score_merge(c(13, 7, 8, 16, 21, 4, 18)) == 239)\n    stopifnot(minimum_score_merge(c(10, 20, 30)) == 90)\n    stopifnot(minimum_score_merge(c(1, 2, 3, 4)) == 19)\n}\n\n\n# Run tests\nmain()", "entry_point": "minimum_score_merge", "signature": "minimum_score_merge <- function(stone_piles)", "docstring": "This function, minimum_score_merge, calculates the minimum score required to merge N piles of stones into a single pile. The score for each merge is the sum of the stones in the two piles being merged. The function takes a vector representing the number of stones in each pile and returns the minimum total score needed for all merges.\nExamples:\n>>> minimum_score_merge(c(13, 7, 8, 16, 21, 4, 18))\n239", "instruction": "Write a R function `minimum_score_merge <- function(stone_piles)` to solve the following problem:\nThis function, minimum_score_merge, calculates the minimum score required to merge N piles of stones into a single pile. The score for each merge is the sum of the stones in the two piles being merged. The function takes a vector representing the number of stones in each pile and returns the minimum total score needed for all merges.\nExamples:\n>>> minimum_score_merge(c(13, 7, 8, 16, 21, 4, 18))\n239", "level": "easy"}
{"task_id": "R/31", "prompt": "# This function book_purchase_options calculates the number of different ways Xiao Ming can purchase books with a given amount of money. \n# The available book prices are 10, 20, 50, and 100 yuan. Xiao Ming can purchase any number of books of any type as long as he does not exceed the total money he has.\n# Examples:\n# >>> book_purchase_options(20)\n#     2\n# >>> book_purchase_options(30)\n#     3\n\nbook_purchase_options <- function(money) ", "canonical_solution": "{\n  # Define the available book prices\n  book_prices <- c(10, 20, 50, 100)\n  \n  # Recursive function to calculate the number of purchase options\n  calculate_options <- function(money, n) {\n    # Base case: when money is 0, there is one way to purchase (buy nothing)\n    if (money == 0) {\n      return(1)\n    }\n    # No way to purchase if money is negative or no books are left\n    if (money < 0 || n <= 0) {\n      return(0)\n    }\n    # Calculate options by including the nth book or excluding it\n    return(calculate_options(money - book_prices[n], n) + calculate_options(money, n - 1))\n  }\n  \n  # Call the recursive function\n  return(calculate_options(money, length(book_prices)))\n}", "test": "# Test cases\nmain <- function() {\nstopifnot(book_purchase_options(20) == 2)\nstopifnot(book_purchase_options(30) == 2)\nstopifnot(book_purchase_options(0) == 1)\nstopifnot(book_purchase_options(100) == 11)\n\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "book_purchase_options", "signature": "book_purchase_options <- function(money)", "docstring": "This function book_purchase_options calculates the number of different ways Xiao Ming can purchase books with a given amount of money.\nThe available book prices are 10, 20, 50, and 100 yuan. Xiao Ming can purchase any number of books of any type as long as he does not exceed the total money he has.\nExamples:\n>>> book_purchase_options(20)\n2\n>>> book_purchase_options(30)\n3", "instruction": "Write a R function `book_purchase_options <- function(money)` to solve the following problem:\nThis function book_purchase_options calculates the number of different ways Xiao Ming can purchase books with a given amount of money.\nThe available book prices are 10, 20, 50, and 100 yuan. Xiao Ming can purchase any number of books of any type as long as he does not exceed the total money he has.\nExamples:\n>>> book_purchase_options(20)\n2\n>>> book_purchase_options(30)\n3", "level": "middle"}
{"task_id": "R/32", "prompt": "# This function, maximum_profit, calculates the maximum profit that can be obtained by buying and selling a stock at most twice. The input is a vector representing the stock prices over a number of days.\n# The function returns the maximum profit that can be achieved under the constraint that the second buy can only happen after the first sell.\n# The stock can be bought and sold on the same day.\n# Examples:\n# >>> maximum_profit(c(5, 14, -2, 4, 9, 3, 17))\n#     28\n# >>> maximum_profit(c(6, 8, 7, 4, 1, -2))\n#     2\n# >>> maximum_profit(c(18, 9, 5, 2))\n#     0\n\nmaximum_profit <- function(price_sequence) ", "canonical_solution": "{\n    n <- length(price_sequence)\n    if (n <= 1) {\n        return(0)\n    }\n    \n    profit_one_transaction <- numeric(n)\n    profit_two_transactions <- numeric(n)\n    \n    min_price <- price_sequence[1]\n    max_profit_one <- 0\n    \n    for (i in 2:n) {\n        min_price <- min(min_price, price_sequence[i])\n        max_profit_one <- max(max_profit_one, price_sequence[i] - min_price)\n        profit_one_transaction[i] <- max_profit_one\n    }\n    \n    max_price <- price_sequence[n]\n    max_profit_two <- 0\n    \n    for (i in (n-1):1) {\n        max_price <- max(max_price, price_sequence[i])\n        max_profit_two <- max(max_profit_two, max_price - price_sequence[i])\n        profit_two_transactions[i] <- max_profit_two + profit_one_transaction[i]\n    }\n    \n    max(profit_two_transactions)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(maximum_profit(c(5, 14, -2, 4, 9, 3, 17)) == 28)\n    stopifnot(maximum_profit(c(6, 8, 7, 4, 1, -2)) == 2)\n    stopifnot(maximum_profit(c(18, 9, 5, 2)) == 0)\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "maximum_profit", "signature": "maximum_profit <- function(price_sequence)", "docstring": "This function, maximum_profit, calculates the maximum profit that can be obtained by buying and selling a stock at most twice. The input is a vector representing the stock prices over a number of days.\nThe function returns the maximum profit that can be achieved under the constraint that the second buy can only happen after the first sell.\nThe stock can be bought and sold on the same day.\nExamples:\n>>> maximum_profit(c(5, 14, -2, 4, 9, 3, 17))\n28\n>>> maximum_profit(c(6, 8, 7, 4, 1, -2))\n2\n>>> maximum_profit(c(18, 9, 5, 2))\n0", "instruction": "Write a R function `maximum_profit <- function(price_sequence)` to solve the following problem:\nThis function, maximum_profit, calculates the maximum profit that can be obtained by buying and selling a stock at most twice. The input is a vector representing the stock prices over a number of days.\nThe function returns the maximum profit that can be achieved under the constraint that the second buy can only happen after the first sell.\nThe stock can be bought and sold on the same day.\nExamples:\n>>> maximum_profit(c(5, 14, -2, 4, 9, 3, 17))\n28\n>>> maximum_profit(c(6, 8, 7, 4, 1, -2))\n2\n>>> maximum_profit(c(18, 9, 5, 2))\n0", "level": "hard"}
{"task_id": "R/33", "prompt": "# The function maximum_theft_profit calculates the maximum amount of cash that can be stolen without triggering the alarm system. Given a vector representing the amount of cash in each shop on a street, it returns the maximum cash that can be stolen without robbing two adjacent shops, as robbing adjacent shops would trigger the alarm.\n# Examples:\n# >>> maximum_theft_profit(c(1, 8, 2))\n#     8\n# >>> maximum_theft_profit(c(10, 7, 6, 14))\n#     24\n\nmaximum_theft_profit <- function(shop_cash) ", "canonical_solution": "{\n    n <- length(shop_cash)\n    if (n == 0) return(0)\n    if (n == 1) return(shop_cash[1])\n\n    dp <- numeric(n)\n    dp[1] <- shop_cash[1]\n    dp[2] <- max(shop_cash[1], shop_cash[2])\n\n    for (i in 3:n) {\n        dp[i] <- max(dp[i - 1], dp[i - 2] + shop_cash[i])\n    }\n\n    return(dp[n])\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(maximum_theft_profit(c(1, 8, 2)) == 8)\n    stopifnot(maximum_theft_profit(c(10, 7, 6, 14)) == 24)\n    stopifnot(maximum_theft_profit(c(0, 0, 0, 0)) == 0)\n    stopifnot(maximum_theft_profit(c(5)) == 5)\n}\n\n\n# Run tests\nmain()", "entry_point": "maximum_theft_profit", "signature": "maximum_theft_profit <- function(shop_cash)", "docstring": "The function maximum_theft_profit calculates the maximum amount of cash that can be stolen without triggering the alarm system. Given a vector representing the amount of cash in each shop on a street, it returns the maximum cash that can be stolen without robbing two adjacent shops, as robbing adjacent shops would trigger the alarm.\nExamples:\n>>> maximum_theft_profit(c(1, 8, 2))\n8\n>>> maximum_theft_profit(c(10, 7, 6, 14))\n24", "instruction": "Write a R function `maximum_theft_profit <- function(shop_cash)` to solve the following problem:\nThe function maximum_theft_profit calculates the maximum amount of cash that can be stolen without triggering the alarm system. Given a vector representing the amount of cash in each shop on a street, it returns the maximum cash that can be stolen without robbing two adjacent shops, as robbing adjacent shops would trigger the alarm.\nExamples:\n>>> maximum_theft_profit(c(1, 8, 2))\n8\n>>> maximum_theft_profit(c(10, 7, 6, 14))\n24", "level": "easy"}
{"task_id": "R/34", "prompt": "# This function calculates the number of different ways Naruto can distribute his chakra energy (M) across a maximum number of shadow clones (N).\n# The number of ways is denoted by K. A shadow clone can be allocated zero or more units of chakra energy.\n# The function takes two arguments: chakra_energy (M) and max_clones (N), and returns the number of distribution methods (K).\n# Examples:\n# >>> shadow_clone_variations(7, 3)\n#     8\n# >>> shadow_clone_variations(5, 2)\n#     6\n\nshadow_clone_variations <- function(chakra_energy, max_clones) ", "canonical_solution": "{\n  # Create a matrix to store intermediate results\n  f <- matrix(0, nrow = chakra_energy + 1, ncol = max_clones + 1)\n\n  # Base case: 0 energy with 0 clones\n  f[1, 1] <- 1\n\n  # Iterate over each energy level\n  for (j in 1:(chakra_energy + 1)) {\n    # Iterate over each possible number of clones\n    for (k in 2:(max_clones + 1)) {\n      # Apply the dynamic programming formula\n      f[j, k] <- f[j, k - 1]\n      if (j >= k) {\n        f[j, k] <- f[j, k] + f[j - k + 1, k]\n      }\n    }\n  }\n\n  # Return the final result\n  return(f[chakra_energy + 1, max_clones + 1])\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(shadow_clone_variations(7, 3) == 8)\n    stopifnot(shadow_clone_variations(5, 2) == 3)\n    stopifnot(shadow_clone_variations(3, 3) == 3)\n\n}\n\n\n# Run tests\nmain()", "entry_point": "shadow_clone_variations", "signature": "shadow_clone_variations <- function(chakra_energy, max_clones)", "docstring": "This function calculates the number of different ways Naruto can distribute his chakra energy (M) across a maximum number of shadow clones (N).\nThe number of ways is denoted by K. A shadow clone can be allocated zero or more units of chakra energy.\nThe function takes two arguments: chakra_energy (M) and max_clones (N), and returns the number of distribution methods (K).\nExamples:\n>>> shadow_clone_variations(7, 3)\n8\n>>> shadow_clone_variations(5, 2)\n6", "instruction": "Write a R function `shadow_clone_variations <- function(chakra_energy, max_clones)` to solve the following problem:\nThis function calculates the number of different ways Naruto can distribute his chakra energy (M) across a maximum number of shadow clones (N).\nThe number of ways is denoted by K. A shadow clone can be allocated zero or more units of chakra energy.\nThe function takes two arguments: chakra_energy (M) and max_clones (N), and returns the number of distribution methods (K).\nExamples:\n>>> shadow_clone_variations(7, 3)\n8\n>>> shadow_clone_variations(5, 2)\n6", "level": "middle"}
{"task_id": "R/35", "prompt": "\n# This function check_parentheses_balance checks if the parentheses in a given mathematical expression are balanced. A balanced expression has matching opening and closing parentheses for every pair. The function takes a single string argument, expression, which consists of lowercase English letters, operators (+, -, *, /), and parentheses. It returns \"YES\" if the parentheses are balanced, and \"NO\" otherwise. The length of the expression is less than 255 characters, and there are fewer than 20 opening parentheses.\n# Examples:\n\n\n# # Balanced parentheses\n# check_parentheses_balance(\"2*(x+y)/(1-x)\") # Returns \"YES\"\n\n# # Unbalanced parentheses\n# check_parentheses_balance(\"(x+y)*(2/(3*4)))\") # Returns \"NO\"\n\n\ncheck_parentheses_balance <- function(expression) ", "canonical_solution": "{\n    stack <- character(0)  # Initializing an empty stack\n    for (char in strsplit(expression, \"\")[[1]]) {\n        if (char == \"(\") {\n            stack <- c(stack, char)  # Push onto stack\n        } else if (char == \")\") {\n            if (length(stack) == 0 || tail(stack, 1) != \"(\") {\n                return(\"NO\")  # Unbalanced\n            }\n            stack <- head(stack, -1)  # Pop from stack\n        }\n    }\n    return(ifelse(length(stack) == 0, \"YES\", \"NO\"))\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(check_parentheses_balance(\"2*(x+y)/(1-x)\") == \"YES\")\n    stopifnot(check_parentheses_balance(\"(x+y)*(2/(3*4)))\") == \"NO\")\n    stopifnot(check_parentheses_balance(\"((a+b)*(c-d))\") == \"YES\")\n    stopifnot(check_parentheses_balance(\")(\") == \"NO\")\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "check_parentheses_balance", "signature": "check_parentheses_balance <- function(expression)", "docstring": "This function check_parentheses_balance checks if the parentheses in a given mathematical expression are balanced. A balanced expression has matching opening and closing parentheses for every pair. The function takes a single string argument, expression, which consists of lowercase English letters, operators (+, -, *, /), and parentheses. It returns \"YES\" if the parentheses are balanced, and \"NO\" otherwise. The length of the expression is less than 255 characters, and there are fewer than 20 opening parentheses.\nExamples:\nBalanced parentheses\ncheck_parentheses_balance(\"2*(x+y)/(1-x)\")  Returns \"YES\"\nUnbalanced parentheses\ncheck_parentheses_balance(\"(x+y)*(2/(3*4)))\")  Returns \"NO\"", "instruction": "Write a R function `check_parentheses_balance <- function(expression)` to solve the following problem:\nThis function check_parentheses_balance checks if the parentheses in a given mathematical expression are balanced. A balanced expression has matching opening and closing parentheses for every pair. The function takes a single string argument, expression, which consists of lowercase English letters, operators (+, -, *, /), and parentheses. It returns \"YES\" if the parentheses are balanced, and \"NO\" otherwise. The length of the expression is less than 255 characters, and there are fewer than 20 opening parentheses.\nExamples:\nBalanced parentheses\ncheck_parentheses_balance(\"2*(x+y)/(1-x)\")  Returns \"YES\"\nUnbalanced parentheses\ncheck_parentheses_balance(\"(x+y)*(2/(3*4)))\")  Returns \"NO\"", "level": "easy"}
{"task_id": "R/36", "prompt": "# This function 'evaluate_expression' takes a mathematical expression as input and evaluates it to produce the result. The expression may contain parentheses, digits from 0 to 9, and operators: addition (+), subtraction (-), multiplication (*), division (/ using integer division), and exponentiation (^). The function returns the calculated value of the expression.\n# Examples:\n# >>> evaluate_expression(\"1+(3+2)*(8^2+6*9)/(2)\")\n#     296\n# >>> evaluate_expression(\"2*3+4\")\n#     10\n\nevaluate_expression <- function(expression) ", "canonical_solution": "{\n    # Replace the division symbol with integer division\n    expression <- gsub(\"/\", \"%/%\", expression)\n    # Evaluate the expression\n    result <- eval(parse(text=expression))\n    return(result)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(evaluate_expression(\"1+(3+2)*(8^2+6*9)/(2)\") == 296)\n    stopifnot(evaluate_expression(\"2*3+4\") == 10)\n    stopifnot(evaluate_expression(\"5^2-3\") == 22)\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "evaluate_expression", "signature": "evaluate_expression <- function(expression)", "docstring": "This function 'evaluate_expression' takes a mathematical expression as input and evaluates it to produce the result. The expression may contain parentheses, digits from 0 to 9, and operators: addition (+), subtraction (-), multiplication (*), division (/ using integer division), and exponentiation (^). The function returns the calculated value of the expression.\nExamples:\n>>> evaluate_expression(\"1+(3+2)*(8^2+6*9)/(2)\")\n296\n>>> evaluate_expression(\"2*3+4\")\n10", "instruction": "Write a R function `evaluate_expression <- function(expression)` to solve the following problem:\nThis function 'evaluate_expression' takes a mathematical expression as input and evaluates it to produce the result. The expression may contain parentheses, digits from 0 to 9, and operators: addition (+), subtraction (-), multiplication (*), division (/ using integer division), and exponentiation (^). The function returns the calculated value of the expression.\nExamples:\n>>> evaluate_expression(\"1+(3+2)*(8^2+6*9)/(2)\")\n296\n>>> evaluate_expression(\"2*3+4\")\n10", "level": "easy"}
{"task_id": "R/37", "prompt": "# This function dance_partner_matching simulates the pairing of dance partners at a ballroom dance. \n# Given the number of men and women entering the ballroom and the number of dances to be held, \n# it returns the pairing sequence for each dance. Each dance pairs one man with one woman. \n# If there are more participants in one group, those without a partner wait for the next dance.\n# The function returns a matrix, where each row represents a dance and the columns represent the paired man and woman.\n# Examples:\n# >>> dance_partner_matching(4, 6, 7)\n#       [,1] [,2]\n# [1,]    1    1\n# [2,]    2    2\n# [3,]    3    3\n# [4,]    4    4\n# [5,]    1    5\n# [6,]    2    6\n# [7,]    3    1\n\ndance_partner_matching <- function(men_count, women_count, dance_count) ", "canonical_solution": "{\n    pairings <- matrix(nrow = dance_count, ncol = 2)\n    man_index <- 1\n    woman_index <- 1\n\n    for (i in 1:dance_count) {\n        pairings[i, ] <- c(man_index, woman_index)\n        \n        man_index <- ifelse(man_index < men_count, man_index + 1, 1)\n        woman_index <- ifelse(woman_index < women_count, woman_index + 1, 1)\n    }\n    \n    return(pairings)\n}", "test": "# Test cases\nmain <- function() {\n    # Testcase\n    test_pairing <- dance_partner_matching(4, 6, 7)\n    expected_pairing <- matrix(c(1, 1, 2, 2, 3, 3, 4, 4, 1, 5, 2, 6, 3, 1), ncol = 2, byrow = TRUE)\n    stopifnot(identical(test_pairing, expected_pairing))\n\n}\n\n\n# Run tests\nmain()", "entry_point": "dance_partner_matching", "signature": "dance_partner_matching <- function(men_count, women_count, dance_count)", "docstring": "This function dance_partner_matching simulates the pairing of dance partners at a ballroom dance.\nGiven the number of men and women entering the ballroom and the number of dances to be held,\nit returns the pairing sequence for each dance. Each dance pairs one man with one woman.\nIf there are more participants in one group, those without a partner wait for the next dance.\nThe function returns a matrix, where each row represents a dance and the columns represent the paired man and woman.\nExamples:\n>>> dance_partner_matching(4, 6, 7)\n[,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    3    3\n[4,]    4    4\n[5,]    1    5\n[6,]    2    6\n[7,]    3    1", "instruction": "Write a R function `dance_partner_matching <- function(men_count, women_count, dance_count)` to solve the following problem:\nThis function dance_partner_matching simulates the pairing of dance partners at a ballroom dance.\nGiven the number of men and women entering the ballroom and the number of dances to be held,\nit returns the pairing sequence for each dance. Each dance pairs one man with one woman.\nIf there are more participants in one group, those without a partner wait for the next dance.\nThe function returns a matrix, where each row represents a dance and the columns represent the paired man and woman.\nExamples:\n>>> dance_partner_matching(4, 6, 7)\n[,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    3    3\n[4,]    4    4\n[5,]    1    5\n[6,]    2    6\n[7,]    3    1", "level": "easy"}
{"task_id": "R/38", "prompt": "# This function remove_spaces takes a vector of strings as input and returns a new vector where all spaces have been removed from each string.\n# The function operates on each string individually, removing any spaces it contains. gsub() is not allowed ! \n# Examples:\n# >>> remove_spaces(c(\"Hello World\", \"1 2 3\", \"Nice to meet you\", \"abc\"))\n#     c(\"HelloWorld\", \"123\", \"Nicetomeetyou\", \"abc\")\n\nremove_spaces <- function(input_strings)", "canonical_solution": "{\n  # Create an empty vector to store the results\n  result <- character(length(input_strings))\n\n  # Loop through each input string\n  for (i in seq_along(input_strings)) {\n    # Remove spaces from the current string and store it in the result vector\n    result[i] <- paste(strsplit(input_strings[i], \" \")[[1]], collapse = \"\")\n  }\n\n  return(result)\n}", "test": "# Test cases\nmain <- function() {\n    # Testcase\n    stopifnot(identical(remove_spaces(c(\"Hello World\", \"1 2 3\", \"Nice to meet you\", \"abc\")), \n                        c(\"HelloWorld\", \"123\", \"Nicetomeetyou\", \"abc\")))\n    stopifnot(identical(remove_spaces(c(\"Test Case\", \"With  Spaces\", \"NoSpaces\")), \n                        c(\"TestCase\", \"WithSpaces\", \"NoSpaces\")))\n    stopifnot(identical(remove_spaces(c(\"  Leading\", \"Trailing \", \" Both \")), \n                        c(\"Leading\", \"Trailing\", \"Both\")))\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "remove_spaces", "signature": "remove_spaces <- function(input_strings)", "docstring": "This function remove_spaces takes a vector of strings as input and returns a new vector where all spaces have been removed from each string.\nThe function operates on each string individually, removing any spaces it contains. gsub() is not allowed !\nExamples:\n>>> remove_spaces(c(\"Hello World\", \"1 2 3\", \"Nice to meet you\", \"abc\"))\nc(\"HelloWorld\", \"123\", \"Nicetomeetyou\", \"abc\")", "instruction": "Write a R function `remove_spaces <- function(input_strings)` to solve the following problem:\nThis function remove_spaces takes a vector of strings as input and returns a new vector where all spaces have been removed from each string.\nThe function operates on each string individually, removing any spaces it contains. gsub() is not allowed !\nExamples:\n>>> remove_spaces(c(\"Hello World\", \"1 2 3\", \"Nice to meet you\", \"abc\"))\nc(\"HelloWorld\", \"123\", \"Nicetomeetyou\", \"abc\")", "level": "easy"}
{"task_id": "R/39", "prompt": "# This function, decimal_to_binary, takes a vector of decimal integers and converts each to its corresponding binary representation. The function returns a list where each element is a string showing the decimal number followed by \"-->\", and then its binary representation.\n# Negative numbers are handled by converting their absolute value to binary and then prefixing the result with a '-'.\n# Examples:\n# >>> decimal_to_binary(c(2, 0, -12, 1))\n#     [1] \"2-->10\" \"0-->0\" \"-12-->-1100\" \"1-->1\"\n\ndecimal_to_binary <- function(decimal_numbers) ", "canonical_solution": "{\n    convert_to_binary <- function(n) {\n        if (n == 0) {\n            return(\"0\")\n        }\n        binary <- \"\"\n        is_negative <- n < 0\n        n <- abs(n)\n        while (n > 0) {\n            binary <- paste(n %% 2, binary, sep=\"\")\n            n <- n %/% 2\n        }\n        if (is_negative) {\n            binary <- paste(\"-\", binary, sep=\"\")\n        }\n        \n        return(binary)\n    }\n    sapply(decimal_numbers, function(n) paste(n, \"-->\", convert_to_binary(n), sep=''))\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(all.equal(decimal_to_binary(c(2, 0, -12, 1)), c(\"2-->10\", \"0-->0\", \"-12-->-1100\", \"1-->1\")))\n    stopifnot(decimal_to_binary(c(3)) == \"3-->11\")\n    stopifnot(decimal_to_binary(c(-5)) == \"-5-->-101\")\n}\n\n\n# Run tests\nmain()", "entry_point": "decimal_to_binary", "signature": "decimal_to_binary <- function(decimal_numbers)", "docstring": "This function, decimal_to_binary, takes a vector of decimal integers and converts each to its corresponding binary representation. The function returns a list where each element is a string showing the decimal number followed by \"-->\", and then its binary representation.\nNegative numbers are handled by converting their absolute value to binary and then prefixing the result with a '-'.\nExamples:\n>>> decimal_to_binary(c(2, 0, -12, 1))\n[1] \"2-->10\" \"0-->0\" \"-12-->-1100\" \"1-->1\"", "instruction": "Write a R function `decimal_to_binary <- function(decimal_numbers)` to solve the following problem:\nThis function, decimal_to_binary, takes a vector of decimal integers and converts each to its corresponding binary representation. The function returns a list where each element is a string showing the decimal number followed by \"-->\", and then its binary representation.\nNegative numbers are handled by converting their absolute value to binary and then prefixing the result with a '-'.\nExamples:\n>>> decimal_to_binary(c(2, 0, -12, 1))\n[1] \"2-->10\" \"0-->0\" \"-12-->-1100\" \"1-->1\"", "level": "middle"}
{"task_id": "R/40", "prompt": "# The function 'find_mode_and_frequency' calculates the mode and its frequency in a given vector of natural numbers.\n# It takes a vector 'numbers' as input and returns a list with two elements: the mode and its frequency.\n# The mode is defined as the number that appears most frequently in the vector. \n# If there are multiple modes, the function returns the smallest one.\n# Examples:\n# >>> find_mode_and_frequency(c(1, 2, 2, 2, 3, 5))\n#     $mode\n#     [1] 2\n#     $frequency\n#     [1] 3\n# >>> find_mode_and_frequency(c(4, 4, 5, 5, 6))\n#     $mode\n#     [1] 4\n#     $frequency\n#     [1] 2\n\n\nfind_mode_and_frequency <- function(numbers) ", "canonical_solution": "{\n    frequency_table <- table(numbers)\n    max_frequency <- max(frequency_table)\n    modes <- as.integer(names(frequency_table[frequency_table == max_frequency]))\n    mode <- min(modes)\n    return(list(mode = mode, frequency = max_frequency))\n}", "test": "# Test cases\nmain <- function() {\n\n    # Test case 1\n    test_data_1 <- c(1, 2, 2, 2, 3, 5)\n    result_1 <- find_mode_and_frequency(test_data_1)\n    stopifnot(result_1$mode == 2)\n    stopifnot(result_1$frequency == 3)\n\n    # Test case 2\n    test_data_2 <- c(4, 4, 5, 5, 6)\n    result_2 <- find_mode_and_frequency(test_data_2)\n    stopifnot(result_2$mode == 4)\n    stopifnot(result_2$frequency == 2)\n\n    # Test case 3\n    test_data_3 <- c(7, 8, 8, 9, 9, 9)\n    result_3 <- find_mode_and_frequency(test_data_3)\n    stopifnot(result_3$mode == 9)\n    stopifnot(result_3$frequency == 3)\n\n}\n\n\n# Run tests\nmain()", "entry_point": "find_mode_and_frequency", "signature": "find_mode_and_frequency <- function(numbers)", "docstring": "The function 'find_mode_and_frequency' calculates the mode and its frequency in a given vector of natural numbers.\nIt takes a vector 'numbers' as input and returns a list with two elements: the mode and its frequency.\nThe mode is defined as the number that appears most frequently in the vector.\nIf there are multiple modes, the function returns the smallest one.\nExamples:\n>>> find_mode_and_frequency(c(1, 2, 2, 2, 3, 5))\n$mode\n[1] 2\n$frequency\n[1] 3\n>>> find_mode_and_frequency(c(4, 4, 5, 5, 6))\n$mode\n[1] 4\n$frequency\n[1] 2", "instruction": "Write a R function `find_mode_and_frequency <- function(numbers)` to solve the following problem:\nThe function 'find_mode_and_frequency' calculates the mode and its frequency in a given vector of natural numbers.\nIt takes a vector 'numbers' as input and returns a list with two elements: the mode and its frequency.\nThe mode is defined as the number that appears most frequently in the vector.\nIf there are multiple modes, the function returns the smallest one.\nExamples:\n>>> find_mode_and_frequency(c(1, 2, 2, 2, 3, 5))\n$mode\n[1] 2\n$frequency\n[1] 3\n>>> find_mode_and_frequency(c(4, 4, 5, 5, 6))\n$mode\n[1] 4\n$frequency\n[1] 2", "level": "easy"}
{"task_id": "R/41", "prompt": "\n# This function find_comparable_opponents calculates the number of pairs of students who are considered \"comparable opponents\". Two students are \"comparable opponents\" if the difference in each of their subject scores (Math, English, Chinese) does not exceed 5 points and the total score difference does not exceed 10 points.\n# The function takes a matrix as input where each row represents a student and each column represents their scores in Chinese, Math, and English, respectively.\n# Examples:\n# >>> find_comparable_opponents(matrix(c(90, 90, 90, 85, 95, 90, 80, 100, 91), nrow = 3, byrow = TRUE))\n#     2\nfind_comparable_opponents <- function(student_scores) ", "canonical_solution": "{\n  # Number of students\n  num_students <- nrow(student_scores)\n  \n  # Initialize a counter for comparable opponents\n  comparable_count <- 0\n  \n  # Iterate through each pair of students\n  for (i in 1:(num_students - 1)) {\n    for (j in (i + 1):num_students) {\n      # Calculate differences in scores for each subject\n      differences <- abs(student_scores[i, ] - student_scores[j, ])\n      \n      # Calculate total score for each student and then their difference\n      total_score_difference <- abs(sum(student_scores[i, ]) - sum(student_scores[j, ]))\n      \n      # Check if the pair is a comparable opponent\n      if (all(differences <= 5) && total_score_difference <= 10) {\n        comparable_count <- comparable_count + 1\n      }\n    }\n  }\n  \n  return(comparable_count)\n}", "test": "# Test cases\nmain <- function() {\n    # Test case 1\n    stopifnot(find_comparable_opponents(matrix(c(90, 90, 90, 85, 95, 90, 80, 100, 91), nrow = 3, byrow = TRUE)) == 2)\n\n    # Test case 2\n    stopifnot(find_comparable_opponents(matrix(c(100, 100, 100, 95, 95, 95, 90, 90, 90), nrow = 3, byrow = TRUE)) == 0)\n\n    # Test case 3\n    stopifnot(find_comparable_opponents(matrix(c(50, 60, 70, 55, 65, 70, 80, 80, 80), nrow = 3, byrow = TRUE)) == 1)\n\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "find_comparable_opponents", "signature": "find_comparable_opponents <- function(student_scores)", "docstring": "This function find_comparable_opponents calculates the number of pairs of students who are considered \"comparable opponents\". Two students are \"comparable opponents\" if the difference in each of their subject scores (Math, English, Chinese) does not exceed 5 points and the total score difference does not exceed 10 points.\n The function takes a matrix as input where each row represents a student and each column represents their scores in Chinese, Math, and English, respectively.\n Examples:\n >>> find_comparable_opponents(matrix(c(90, 90, 90, 85, 95, 90, 80, 100, 91), nrow = 3, byrow = TRUE))\n     2", "instruction": "Write a R function `find_comparable_opponents <- function(student_scores)` to solve the following problem:\nThis function find_comparable_opponents calculates the number of pairs of students who are considered \"comparable opponents\". Two students are \"comparable opponents\" if the difference in each of their subject scores (Math, English, Chinese) does not exceed 5 points and the total score difference does not exceed 10 points.\n The function takes a matrix as input where each row represents a student and each column represents their scores in Chinese, Math, and English, respectively.\n Examples:\n >>> find_comparable_opponents(matrix(c(90, 90, 90, 85, 95, 90, 80, 100, 91), nrow = 3, byrow = TRUE))\n     2", "level": "middle"}
{"task_id": "R/42", "prompt": "# This function calculates the maximum number of cigarettes Peter can smoke.\n# Given the initial number of cigarettes 'n' and the number 'k' of cigarette butts required to exchange for one new cigarette,\n# the function returns the total number of cigarettes Peter can smoke.\n# It includes the initial cigarettes and those obtained by exchanging butts.\n# Examples:\n# >>> maximum_smokable_cigarettes(4, 3)\n#     5\n# >>> maximum_smokable_cigarettes(10, 3)\n#     14\n\nmaximum_smokable_cigarettes <- function(n, k) ", "canonical_solution": "{\n    total_smoked = n\n    current_butts = n\n    \n    while (current_butts >= k) {\n        # Calculate how many new cigarettes can be obtained.\n        new_cigarettes = current_butts %/% k\n        total_smoked = total_smoked + new_cigarettes\n        # Update the count of butts: subtract those used for exchanges, add new from smoked cigarettes.\n        current_butts = (current_butts %% k) + new_cigarettes\n    }\n    \n    return(total_smoked)\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(maximum_smokable_cigarettes(4, 3) == 5)\n    stopifnot(maximum_smokable_cigarettes(10, 3) == 14)\n    stopifnot(maximum_smokable_cigarettes(1, 2) == 1) # Case where no exchanges can occur\n}\n\n\n# Run tests\nmain()", "entry_point": "maximum_smokable_cigarettes", "signature": "maximum_smokable_cigarettes <- function(n, k)", "docstring": "This function calculates the maximum number of cigarettes Peter can smoke.\n Given the initial number of cigarettes 'n' and the number 'k' of cigarette butts required to exchange for one new cigarette,\n the function returns the total number of cigarettes Peter can smoke.\n It includes the initial cigarettes and those obtained by exchanging butts.\n Examples:\n >>> maximum_smokable_cigarettes(4, 3)\n     5\n >>> maximum_smokable_cigarettes(10, 3)\n     14", "instruction": "Write a R function `maximum_smokable_cigarettes <- function(n, k)` to solve the following problem:\nThis function calculates the maximum number of cigarettes Peter can smoke.\n Given the initial number of cigarettes 'n' and the number 'k' of cigarette butts required to exchange for one new cigarette,\n the function returns the total number of cigarettes Peter can smoke.\n It includes the initial cigarettes and those obtained by exchanging butts.\n Examples:\n >>> maximum_smokable_cigarettes(4, 3)\n     5\n >>> maximum_smokable_cigarettes(10, 3)\n     14", "level": "easy"}
{"task_id": "R/43", "prompt": "\n# This function `longest_consecutive_sequence` calculates the length of the longest consecutive numbers sequence within a given vector of positive integers. A consecutive sequence is defined as a series of numbers in which each number is one more than the previous number.\n# Examples:\n# >>> longest_consecutive_sequence(c(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n#     6  # Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence(c(10, 11, 12, 14, 15))\n#     3  # Because the longest consecutive sequence is 10, 11, 12\n\nlongest_consecutive_sequence <- function(numbers) ", "canonical_solution": "{\n    if (length(numbers) == 0) return(0)\n    if (length(numbers) == 1) return(1)\n\n    numbers <- sort(unique(numbers))  # Sort and remove duplicates\n    max_length <- 1\n    current_length <- 1\n    \n    for (i in 2:length(numbers)) {\n        if (numbers[i] == numbers[i-1] + 1) {\n            current_length <- current_length + 1\n            max_length <- max(max_length, current_length)\n        } else {\n            current_length <- 1\n        }\n    }\n    \n    return(max_length)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(longest_consecutive_sequence(c(1, 5, 6, 2, 3, 4, 5, 6, 8, 9)) == 6)\n    stopifnot(longest_consecutive_sequence(c(10, 11, 12, 14, 15)) == 3)\n    stopifnot(longest_consecutive_sequence(c(4, 2, 1, 6, 5)) == 3)\n    stopifnot(longest_consecutive_sequence(c()) == 0)  # Empty vector\n    stopifnot(longest_consecutive_sequence(c(7)) == 1)  # Single element\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "longest_consecutive_sequence", "signature": "longest_consecutive_sequence <- function(numbers)", "docstring": "This function `longest_consecutive_sequence` calculates the length of the longest consecutive numbers sequence within a given vector of positive integers. A consecutive sequence is defined as a series of numbers in which each number is one more than the previous number.\n Examples:\n >>> longest_consecutive_sequence(c(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n     6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence(c(10, 11, 12, 14, 15))\n     3   Because the longest consecutive sequence is 10, 11, 12", "instruction": "Write a R function `longest_consecutive_sequence <- function(numbers)` to solve the following problem:\nThis function `longest_consecutive_sequence` calculates the length of the longest consecutive numbers sequence within a given vector of positive integers. A consecutive sequence is defined as a series of numbers in which each number is one more than the previous number.\n Examples:\n >>> longest_consecutive_sequence(c(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n     6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence(c(10, 11, 12, 14, 15))\n     3   Because the longest consecutive sequence is 10, 11, 12", "level": "easy"}
{"task_id": "R/44", "prompt": "# This function compare_area determines who has the larger area between Alice's square and Bob's rectangle. \n# Alice has a square with side length 'a', and Bob has a rectangle with length 'b' and width 'c'. \n# The function returns \"Alice\" if the area of the square is greater than that of the rectangle, \n# and \"Bob\" if the rectangle's area is greater. If the areas are equal, it returns \"Equal\".\n# Examples:\n# >>> compare_area(5, 4, 6)\n#     \"Alice\"\n# >>> compare_area(7, 5, 10)\n#     \"Bob\"\ncompare_area <- function(a, b, c) ", "canonical_solution": "{\n    square_area <- a^2\n    rectangle_area <- b * c\n    if (square_area > rectangle_area) {\n        return(\"Alice\")\n    } else if (rectangle_area > square_area) {\n        return(\"Bob\")\n    } else {\n        return(\"Equal\")\n    }\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(compare_area(5, 4, 6) == \"Alice\")\n    stopifnot(compare_area(7, 5, 10) == \"Bob\")\n    stopifnot(compare_area(5, 5, 5) == \"Equal\")\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "compare_area", "signature": "compare_area <- function(a, b, c)", "docstring": "This function compare_area determines who has the larger area between Alice's square and Bob's rectangle. \n Alice has a square with side length 'a', and Bob has a rectangle with length 'b' and width 'c'. \n The function returns \"Alice\" if the area of the square is greater than that of the rectangle, \n and \"Bob\" if the rectangle's area is greater. If the areas are equal, it returns \"Equal\".\n Examples:\n >>> compare_area(5, 4, 6)\n     \"Alice\"\n >>> compare_area(7, 5, 10)\n     \"Bob\"", "instruction": "Write a R function `compare_area <- function(a, b, c)` to solve the following problem:\nThis function compare_area determines who has the larger area between Alice's square and Bob's rectangle. \n Alice has a square with side length 'a', and Bob has a rectangle with length 'b' and width 'c'. \n The function returns \"Alice\" if the area of the square is greater than that of the rectangle, \n and \"Bob\" if the rectangle's area is greater. If the areas are equal, it returns \"Equal\".\n Examples:\n >>> compare_area(5, 4, 6)\n     \"Alice\"\n >>> compare_area(7, 5, 10)\n     \"Bob\"", "level": "easy"}
{"task_id": "R/45", "prompt": "# This function max_product_distribution finds M positive integers that sum up to N, with the objective of maximizing their product. The function returns a vector of these integers, arranged in non-decreasing order (to ensure the lexicographically smallest sequence if multiple solutions exist).\n\n# Examples:\n# max_product_distribution(6, 3) should return c(2, 2, 2), because 2 * 2 * 2 = 8 is the maximum product achievable with three numbers that sum to 6.\n# max_product_distribution(8, 3) should return c(2, 3, 3), because 2 * 3 * 3 = 18 is the maximum product achievable with three numbers that sum to 8.\n\nmax_product_distribution <- function(N, M) ", "canonical_solution": "{\n  # Initialize the vector with 1s to ensure all parts are positive integers\n  parts <- rep(1, M)\n  \n  # Remaining value to be distributed\n  remaining <- N - M\n  \n  # Distribute the remaining value as evenly as possible\n  while(remaining > 0) {\n    for(i in 1:M) {\n      if(remaining > 0) {\n        parts[i] <- parts[i] + 1\n        remaining <- remaining - 1\n      } else {\n        break\n      }\n    }\n  }\n  \n  # To maximize product, distribute the excess above 3 equally\n  # This corrects the distribution towards 2s and 3s, maximizing the product\n  for(i in 1:M) {\n    if(parts[i] > 3 && remaining > 0) {\n      parts[i] <- parts[i] - 1\n      remaining <- remaining + 1\n    }\n  }\n  \n  while(remaining > 0) {\n    for(i in 1:M) {\n      if(parts[i] < 3 && remaining > 0) {\n        parts[i] <- parts[i] + 1\n        remaining <- remaining - 1\n      }\n    }\n  }\n  \n  return(sort(parts))\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(all.equal(max_product_distribution(6, 3), c(2, 2, 2)))\n    stopifnot(all.equal(max_product_distribution(8, 3), c(2, 3, 3)))\n    stopifnot(all.equal(max_product_distribution(7, 2), c(3, 4)))\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "max_product_distribution", "signature": "max_product_distribution <- function(N, M)", "docstring": "This function max_product_distribution finds M positive integers that sum up to N, with the objective of maximizing their product. The function returns a vector of these integers, arranged in non-decreasing order (to ensure the lexicographically smallest sequence if multiple solutions exist).\n\n Examples:\n max_product_distribution(6, 3) should return c(2, 2, 2), because 2 * 2 * 2 = 8 is the maximum product achievable with three numbers that sum to 6.\n max_product_distribution(8, 3) should return c(2, 3, 3), because 2 * 3 * 3 = 18 is the maximum product achievable with three numbers that sum to 8.", "instruction": "Write a R function `max_product_distribution <- function(N, M)` to solve the following problem:\nThis function max_product_distribution finds M positive integers that sum up to N, with the objective of maximizing their product. The function returns a vector of these integers, arranged in non-decreasing order (to ensure the lexicographically smallest sequence if multiple solutions exist).\n\n Examples:\n max_product_distribution(6, 3) should return c(2, 2, 2), because 2 * 2 * 2 = 8 is the maximum product achievable with three numbers that sum to 6.\n max_product_distribution(8, 3) should return c(2, 3, 3), because 2 * 3 * 3 = 18 is the maximum product achievable with three numbers that sum to 8.", "level": "hard"}
{"task_id": "R/46", "prompt": "# This function count_composition_title_characters calculates the number of characters in the title of a composition, excluding spaces and newline characters. The input is a string representing the title, and the output is an integer representing the count of characters that are not spaces or newline characters.\n# Example 1:\n# Input: \"234\"\n# Output: 3\n\n# Example 2:\n# Input: \"Ca 45\"\n# Output: 4\n\ncount_composition_title_characters <- function(title)", "canonical_solution": "{\n    # Remove spaces and newline characters\n    title_no_spaces <- gsub(\" |\\n\", \"\", title)\n    # Count the remaining characters\n    return(nchar(title_no_spaces))\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(count_composition_title_characters(\"234\") == 3)\n    stopifnot(count_composition_title_characters(\"Ca 45\") == 4)\n    stopifnot(count_composition_title_characters(\"Hello World\\n\") == 10)\n    stopifnot(count_composition_title_characters(\" 123 \") == 3)\n\n}\n\n\n# Run tests\nmain()", "entry_point": "count_composition_title_characters", "signature": "count_composition_title_characters <- function(title)", "docstring": "This function count_composition_title_characters calculates the number of characters in the title of a composition, excluding spaces and newline characters. The input is a string representing the title, and the output is an integer representing the count of characters that are not spaces or newline characters.\n Example 1:\n Input: \"234\"\n Output: 3\n\n Example 2:\n Input: \"Ca 45\"\n Output: 4", "instruction": "Write a R function `count_composition_title_characters <- function(title)` to solve the following problem:\nThis function count_composition_title_characters calculates the number of characters in the title of a composition, excluding spaces and newline characters. The input is a string representing the title, and the output is an integer representing the count of characters that are not spaces or newline characters.\n Example 1:\n Input: \"234\"\n Output: 3\n\n Example 2:\n Input: \"Ca 45\"\n Output: 4", "level": "easy"}
{"task_id": "R/47", "prompt": "\n# This function count_common_students calculates the number of students who have enrolled in both courses A and B.\n# Given two vectors: course_a representing the student IDs enrolled in course A, and course_b representing the student IDs enrolled in course B,\n# the function returns the count of students who are enrolled in both courses.\n# The student IDs in each course are unique.\n# Examples:\n# >>> count_common_students(c(1, 2, 3, 4, 5), c(1, 3, 4, 5, 6))\n#     4\n# >>> count_common_students(c(2, 4, 6, 8), c(1, 3, 5, 7))\n#     0\ncount_common_students <- function(course_a, course_b) ", "canonical_solution": "{\n    common_students <- intersect(course_a, course_b)\n    return(length(common_students))\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(count_common_students(c(1, 2, 3, 4, 5), c(1, 3, 4, 5, 6)) == 4)\n    stopifnot(count_common_students(c(2, 4, 6, 8), c(1, 3, 5, 7)) == 0)\n    stopifnot(count_common_students(c(10, 12, 14, 16), c(14, 16, 18, 20)) == 2)\n}\n\n# Run tests\nmain()", "entry_point": "count_common_students", "signature": "count_common_students <- function(course_a, course_b)", "docstring": "This function count_common_students calculates the number of students who have enrolled in both courses A and B.\n Given two vectors: course_a representing the student IDs enrolled in course A, and course_b representing the student IDs enrolled in course B,\n the function returns the count of students who are enrolled in both courses.\n The student IDs in each course are unique.\n Examples:\n >>> count_common_students(c(1, 2, 3, 4, 5), c(1, 3, 4, 5, 6))\n     4\n >>> count_common_students(c(2, 4, 6, 8), c(1, 3, 5, 7))\n     0", "instruction": "Write a R function `count_common_students <- function(course_a, course_b)` to solve the following problem:\nThis function count_common_students calculates the number of students who have enrolled in both courses A and B.\n Given two vectors: course_a representing the student IDs enrolled in course A, and course_b representing the student IDs enrolled in course B,\n the function returns the count of students who are enrolled in both courses.\n The student IDs in each course are unique.\n Examples:\n >>> count_common_students(c(1, 2, 3, 4, 5), c(1, 3, 4, 5, 6))\n     4\n >>> count_common_students(c(2, 4, 6, 8), c(1, 3, 5, 7))\n     0", "level": "easy"}
{"task_id": "R/48", "prompt": "\n# This function calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money, and for each failed delivery, it loses 10 units. If the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives an additional bonus of 500 units.\n# Arguments:\n# - delivered: The number of successfully delivered packages (integer, 0 <= delivered <= 100).\n# - failed: The number of failed deliveries (integer, 0 <= failed <= 100).\n# Returns:\n# - The total earnings of Deliv-e-droid (integer), which can be negative if losses from failed deliveries outweigh gains from successful ones.\n# Examples:\n# >>> calculate_droid_earnings(5, 2)\n#     730\n# >>> calculate_droid_earnings(0, 10)\n#     -100\n\ncalculate_droid_earnings <- function(delivered, failed) ", "canonical_solution": "{\n    earnings <- delivered * 50 - failed * 10\n    if (delivered > failed) {\n        earnings <- earnings + 500\n    }\n    return(earnings)\n}", "test": "# Test cases\nmain <- function() {\n\n    stopifnot(calculate_droid_earnings(5, 2) == 730)\n    stopifnot(calculate_droid_earnings(0, 10) == -100)\n    stopifnot(calculate_droid_earnings(10, 0) == 1000)\n    stopifnot(calculate_droid_earnings(3, 3) == 120)\n\n}\n\n\n# Run tests\nmain()", "entry_point": "calculate_droid_earnings", "signature": "calculate_droid_earnings <- function(delivered, failed)", "docstring": "This function calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money, and for each failed delivery, it loses 10 units. If the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives an additional bonus of 500 units.\n Arguments:\n - delivered: The number of successfully delivered packages (integer, 0 <= delivered <= 100).\n - failed: The number of failed deliveries (integer, 0 <= failed <= 100).\n Returns:\n - The total earnings of Deliv-e-droid (integer), which can be negative if losses from failed deliveries outweigh gains from successful ones.\n Examples:\n >>> calculate_droid_earnings(5, 2)\n     730\n >>> calculate_droid_earnings(0, 10)\n     -100", "instruction": "Write a R function `calculate_droid_earnings <- function(delivered, failed)` to solve the following problem:\nThis function calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money, and for each failed delivery, it loses 10 units. If the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives an additional bonus of 500 units.\n Arguments:\n - delivered: The number of successfully delivered packages (integer, 0 <= delivered <= 100).\n - failed: The number of failed deliveries (integer, 0 <= failed <= 100).\n Returns:\n - The total earnings of Deliv-e-droid (integer), which can be negative if losses from failed deliveries outweigh gains from successful ones.\n Examples:\n >>> calculate_droid_earnings(5, 2)\n     730\n >>> calculate_droid_earnings(0, 10)\n     -100", "level": "easy"}
{"task_id": "R/49", "prompt": "# This function find_missing_and_duplicate_id identifies the missing and duplicate ID numbers from a list of ID sequences. Given an integer N representing the number of ID sequences and a list of ID sequences, the function returns a vector containing two integers: the missing ID and the duplicate ID.\n# The input is an integer N and a list where each element is a vector representing an ID sequence.\n# The output is a vector with two integers: the first is the missing ID, and the second is the duplicate ID.\n# Examples:\n# >>> find_missing_and_duplicate_id(2, list(c(5, 6, 8, 11, 9), c(10, 12, 9)))\n#     c(7, 9)\n\nfind_missing_and_duplicate_id <- function(N, id_lists) ", "canonical_solution": "{\n    # Flatten the list of ID sequences into a single vector and sort it\n    all_ids <- sort(unlist(id_lists))\n    missing_id <- NA\n    duplicate_id <- NA\n    \n    for (i in 1:(length(all_ids) - 1)) {\n        if (all_ids[i] == all_ids[i + 1]) {\n            duplicate_id <- all_ids[i]\n        } else if (all_ids[i] + 1 != all_ids[i + 1]) {\n            missing_id <- all_ids[i] + 1\n        }\n    }\n    \n    return(c(missing_id, duplicate_id))\n}", "test": "# Test cases\nmain <- function() {\n\nstopifnot(all(find_missing_and_duplicate_id(2, list(c(5, 6, 8, 11, 9), c(10, 12, 9))) == c(7, 9)))\nstopifnot(all(find_missing_and_duplicate_id(3, list(c(1, 2, 4, 9), c(5, 6, 7, 8, 10), c(9, 11))) == c(3, 9)))\n\n\n}\n\n\n# Run tests\nmain()", "entry_point": "find_missing_and_duplicate_id", "signature": "find_missing_and_duplicate_id <- function(N, id_lists)", "docstring": "This function find_missing_and_duplicate_id identifies the missing and duplicate ID numbers from a list of ID sequences. Given an integer N representing the number of ID sequences and a list of ID sequences, the function returns a vector containing two integers: the missing ID and the duplicate ID.\n The input is an integer N and a list where each element is a vector representing an ID sequence.\n The output is a vector with two integers: the first is the missing ID, and the second is the duplicate ID.\n Examples:\n >>> find_missing_and_duplicate_id(2, list(c(5, 6, 8, 11, 9), c(10, 12, 9)))\n     c(7, 9)", "instruction": "Write a R function `find_missing_and_duplicate_id <- function(N, id_lists)` to solve the following problem:\nThis function find_missing_and_duplicate_id identifies the missing and duplicate ID numbers from a list of ID sequences. Given an integer N representing the number of ID sequences and a list of ID sequences, the function returns a vector containing two integers: the missing ID and the duplicate ID.\n The input is an integer N and a list where each element is a vector representing an ID sequence.\n The output is a vector with two integers: the first is the missing ID, and the second is the duplicate ID.\n Examples:\n >>> find_missing_and_duplicate_id(2, list(c(5, 6, 8, 11, 9), c(10, 12, 9)))\n     c(7, 9)", "level": "easy"}
{"task_id": "R/50", "prompt": "# This function count_chars_types analyzes a given string of length 8, counting the occurrences of digits, lowercase letters, and uppercase letters within it. The function returns a list with three elements corresponding to the counts of digits, lowercase letters, and uppercase letters, respectively.\n\n# # Example 1\n# count_chars_types(\"yLOI2022\")\n# # Returns: list(digits = 4, lowercase = 1, uppercase = 3)\n\n# # Example 2\n# count_chars_types(\"IAKIOIOI\")\n# # Returns: list(digits = 0, lowercase = 0, uppercase = 8)\n\n# # Example 3\n# count_chars_types(\"1n2s0e1s\")\n# # Returns: list(digits = 4, lowercase = 4, uppercase = 0)\n\n\ncount_chars_types <- function(s) ", "canonical_solution": "{\n  # Ensure the string is exactly 8 characters\n  if (nchar(s) != 8) {\n    stop(\"The input string must be exactly 8 characters long.\")\n  }\n  \n  # Count digits\n  digits_cnt <- as.numeric(length(unlist(regmatches(s, gregexpr(\"[0-9]\", s)))))\n  \n  # Count lowercase letters\n  lowercase <- as.numeric(length(unlist(regmatches(s, gregexpr(\"[a-z]\", s)))))\n  \n  # Count uppercase letters\n  uppercase <- as.numeric(length(unlist(regmatches(s, gregexpr(\"[A-Z]\", s)))))\n  \n  # Return the counts as a list\n  return(list(digits = digits_cnt, lowercase = lowercase, uppercase = uppercase))\n#   return(list(digits = digits_cnt, lowercase = lowercase, uppercase = uppercase))\n}", "test": "# Test cases\nmain <- function() {\n    stopifnot(identical(count_chars_types(\"yLOI2022\"), list(digits = 4, lowercase = 1, uppercase = 3)))\n    stopifnot(identical(count_chars_types(\"IAKIOIOI\"), list(digits = 0, lowercase = 0, uppercase = 8)))\n    stopifnot(identical(count_chars_types(\"1n2s0e1s\"), list(digits = 4, lowercase = 4, uppercase = 0)))\n\n}\n\n\n# Run tests\nmain()", "entry_point": "count_chars_types", "signature": "count_chars_types <- function(s)", "docstring": "This function count_chars_types analyzes a given string of length 8, counting the occurrences of digits, lowercase letters, and uppercase letters within it. The function returns a list with three elements corresponding to the counts of digits, lowercase letters, and uppercase letters, respectively.\n\n  Example 1\n count_chars_types(\"yLOI2022\")\n  Returns: list(digits = 4, lowercase = 1, uppercase = 3)\n\n  Example 2\n count_chars_types(\"IAKIOIOI\")\n  Returns: list(digits = 0, lowercase = 0, uppercase = 8)\n\n  Example 3\n count_chars_types(\"1n2s0e1s\")\n  Returns: list(digits = 4, lowercase = 4, uppercase = 0)", "instruction": "Write a R function `count_chars_types <- function(s)` to solve the following problem:\nThis function count_chars_types analyzes a given string of length 8, counting the occurrences of digits, lowercase letters, and uppercase letters within it. The function returns a list with three elements corresponding to the counts of digits, lowercase letters, and uppercase letters, respectively.\n\n  Example 1\n count_chars_types(\"yLOI2022\")\n  Returns: list(digits = 4, lowercase = 1, uppercase = 3)\n\n  Example 2\n count_chars_types(\"IAKIOIOI\")\n  Returns: list(digits = 0, lowercase = 0, uppercase = 8)\n\n  Example 3\n count_chars_types(\"1n2s0e1s\")\n  Returns: list(digits = 4, lowercase = 4, uppercase = 0)", "level": "middle"}
