{"task_id": "C#/1", "prompt": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)", "canonical_solution": "    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }", "test": "static void Main()\n    {\n\n        // Test cases\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.3) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.05) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.95) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.8) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 }, 0.1) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 1.0) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 0.5) == false);\n    }\n}", "entry_point": "HasCloseElements", "signature": "static bool HasCloseElements(List<double> numbers, double threshold)", "docstring": "Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true", "instruction": "Write a C# function `static bool HasCloseElements(List<double> numbers, double threshold)` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true", "level": "easy"}
{"task_id": "C#/2", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Converts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)", "canonical_solution": "{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}", "test": "    static void Main()\n    {\n        Debug.Assert(ConvertFahrenheitToCelsius(32) == \"c=0.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(212) == \"c=100.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(-40) == \"c=-40.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(98.6) == \"c=37.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(0) == \"c=-17.78\");\n\n    }\n}", "entry_point": "ConvertFahrenheitToCelsius", "signature": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)", "docstring": "Converts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"", "instruction": "Write a C# function `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` to solve the following problem:\nConverts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"", "level": "easy"}
{"task_id": "C#/3", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Encodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)", "canonical_solution": "{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}", "test": "    static void Main()\n    {\n        Debug.Assert(EncodeString(\"China\", 4) == \"Glmre\");\n        Debug.Assert(EncodeString(\"apple\", 2) == \"crrng\");\n        Debug.Assert(EncodeString(\"hello\", 5) == \"mjqqt\");\n        Debug.Assert(EncodeString(\"xyz\", 3) == \"abc\");\n        Debug.Assert(EncodeString(\"AbCdE\", 1) == \"BcDeF\");\n        Debug.Assert(EncodeString(\"Java\", 10) == \"Tkfk\");\n        Debug.Assert(EncodeString(\"OpenAI\", 4) == \"StirEM\");\n        Debug.Assert(EncodeString(\"\", 5) == \"\");\n\n    }\n}\n", "entry_point": "EncodeString", "signature": "static string EncodeString(string input, int shift)", "docstring": "Encodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"", "instruction": "Write a C# function `static string EncodeString(string input, int shift)` to solve the following problem:\nEncodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"", "level": "middle"}
{"task_id": "C#/4", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Computes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)", "canonical_solution": "{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}", "test": "    static void Main()\n    {\n        Debug.Assert(ComputeValue(0.5) == 0.5);\n        Debug.Assert(ComputeValue(2) == 3);\n        Debug.Assert(ComputeValue(5) == 9);\n        Debug.Assert(ComputeValue(10) == 19);\n        Debug.Assert(ComputeValue(15) == 34);\n        Debug.Assert(ComputeValue(0) == 0);\n        Debug.Assert(ComputeValue(1) == 1);\n\n    }\n}", "entry_point": "ComputeValue", "signature": "static double ComputeValue(double x)", "docstring": "Computes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19", "instruction": "Write a C# function `static double ComputeValue(double x)` to solve the following problem:\nComputes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19", "level": "easy"}
{"task_id": "C#/5", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)", "canonical_solution": "{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}", "test": "    static void Main()\n    {\n \n        Debug.Assert(FindNarcissisticNumbers(100, 170).SequenceEqual(new List<int> { 153 }));\n        Debug.Assert(FindNarcissisticNumbers(100, 500).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(1, 100).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(370, 380).SequenceEqual(new List<int> { 370, 371 }));\n        Debug.Assert(FindNarcissisticNumbers(0, 999).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(900, 1000).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(10, 15).SequenceEqual(new List<int> { }));\n\n    }\n}", "entry_point": "FindNarcissisticNumbers", "signature": "static List<int> FindNarcissisticNumbers(int start, int end)", "docstring": "This function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]", "instruction": "Write a C# function `static List<int> FindNarcissisticNumbers(int start, int end)` to solve the following problem:\nThis function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]", "level": "middle"}
{"task_id": "C#/6", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)", "canonical_solution": "{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(SortIntegersAscending(3, 1, 2).SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(SortIntegersAscending(5, 7, 2).SequenceEqual(new List<int> { 2, 5, 7 }));\n        Debug.Assert(SortIntegersAscending(-1, 0, -3).SequenceEqual(new List<int> { -3, -1, 0 }));\n        Debug.Assert(SortIntegersAscending(10, 10, 10).SequenceEqual(new List<int> { 10, 10, 10 }));\n        Debug.Assert(SortIntegersAscending(0, -1, 1).SequenceEqual(new List<int> { -1, 0, 1 }));\n        Debug.Assert(SortIntegersAscending(100, 50, 75).SequenceEqual(new List<int> { 50, 75, 100 }));\n        Debug.Assert(SortIntegersAscending(-5, -10, -7).SequenceEqual(new List<int> { -10, -7, -5 }));\n\n\n    }\n}", "entry_point": "SortIntegersAscending", "signature": "static List<int> SortIntegersAscending(int num1, int num2, int num3)", "docstring": "Sorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]", "instruction": "Write a C# function `static List<int> SortIntegersAscending(int num1, int num2, int num3)` to solve the following problem:\nSorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]", "level": "easy"}
{"task_id": "C#/7", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Copies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)", "canonical_solution": "{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}", "test": "static void Main()\n    {\n        Debug.Assert(CopySubstringFromIndex(\"Hello World\", 6) == \"World\");\n        Debug.Assert(CopySubstringFromIndex(\"Example\", 3) == \"mple\");\n        Debug.Assert(CopySubstringFromIndex(\"Short\", 10) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"AnotherExample\", 0) == \"AnotherExample\");\n        Debug.Assert(CopySubstringFromIndex(\"Test\", 4) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"\", 0) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"LastOne\", 7) == \"\");\n\n    }\n}", "entry_point": "CopySubstringFromIndex", "signature": "static string CopySubstringFromIndex(string input, int startIndex)", "docstring": "Copies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"", "instruction": "Write a C# function `static string CopySubstringFromIndex(string input, int startIndex)` to solve the following problem:\nCopies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"", "level": "easy"}
{"task_id": "C#/8", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Converts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)", "canonical_solution": "{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}", "test": "    static void Main()\n    {\n        Debug.Assert(FormatTime(0) == \"0:0:0\");\n        Debug.Assert(FormatTime(3661) == \"1:1:1\");\n        Debug.Assert(FormatTime(5436) == \"1:30:36\");\n        Debug.Assert(FormatTime(3600) == \"1:0:0\");\n        Debug.Assert(FormatTime(7200) == \"2:0:0\");\n        Debug.Assert(FormatTime(86399) == \"23:59:59\");\n        Debug.Assert(FormatTime(12345) == \"3:25:45\");\n\n    }\n}", "entry_point": "FormatTime", "signature": "static string FormatTime(int seconds)", "docstring": "Converts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"", "instruction": "Write a C# function `static string FormatTime(int seconds)` to solve the following problem:\nConverts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"", "level": "easy"}
{"task_id": "C#/9", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Calculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)", "canonical_solution": "{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}", "test": "    static void Main()\n    {\n\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5) - 2.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3) - 0.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 4, 4, 3, 3, 6, 6) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 3, 3, 1, 1, 2, 2) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(2, 2, 5, 5, 3, 3, 6, 6) - 4.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 3, 3, 5, 5) - 0.00) < 0.01);\n\n    }\n}", "entry_point": "CalculateIntersectionArea", "signature": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)", "docstring": "Calculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)", "instruction": "Write a C# function `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` to solve the following problem:\nCalculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)", "level": "easy"}
{"task_id": "C#/10", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Solves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)", "canonical_solution": "{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}", "test": "    static void Main()\n    {\n        Debug.Assert(SolveLinearEquation(1, -3) == 3.00);\n        Debug.Assert(SolveLinearEquation(4, 8) == -2.00);\n        Debug.Assert(SolveLinearEquation(-2, 6) == 3.00);\n        Debug.Assert(SolveLinearEquation(3, -9) == 3.00);\n        Debug.Assert(SolveLinearEquation(0.5, -1.5) == 3.00);\n        Debug.Assert(SolveLinearEquation(-5, 10) == 2.00);\n        Debug.Assert(SolveLinearEquation(10, -20) == 2.00);\n\n    }\n}", "entry_point": "SolveLinearEquation", "signature": "static double SolveLinearEquation(double a, double b)", "docstring": "Solves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00", "instruction": "Write a C# function `static double SolveLinearEquation(double a, double b)` to solve the following problem:\nSolves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00", "level": "easy"}
{"task_id": "C#/11", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Calculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)", "canonical_solution": "{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}", "test": "    static void Main()\n    {\n        Debug.Assert(TotalCows(1) == 1);\n        Debug.Assert(TotalCows(2) == 1);\n        Debug.Assert(TotalCows(3) == 1);\n        Debug.Assert(TotalCows(4) == 2);\n        Debug.Assert(TotalCows(5) == 3);\n        Debug.Assert(TotalCows(6) == 4);\n        Debug.Assert(TotalCows(7) == 6);\n        Debug.Assert(TotalCows(8) == 9);\n        Debug.Assert(TotalCows(10) == 19);\n    }\n}\n", "entry_point": "TotalCows", "signature": "static int TotalCows(int years)", "docstring": "Calculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4", "instruction": "Write a C# function `static int TotalCows(int years)` to solve the following problem:\nCalculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4", "level": "easy"}
{"task_id": "C#/12", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)", "canonical_solution": "{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(CountReachableApples(new List<int> {150, 190, 300, 210, 220}, 200) == 2);\n        Debug.Assert(CountReachableApples(new List<int> {120, 180, 260, 310, 150}, 250) == 3);\n        Debug.Assert(CountReachableApples(new List<int> {100, 200, 300, 400, 500}, 350) == 3);\n\n    }\n}", "entry_point": "CountReachableApples", "signature": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)", "docstring": "This function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2", "instruction": "Write a C# function `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` to solve the following problem:\nThis function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2", "level": "easy"}
{"task_id": "C#/13", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Calculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)", "canonical_solution": "{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}", "test": "static void Main()\n    {\n        Debug.Assert(MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350}) == 650);\n        Debug.Assert(MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300}) == 450);\n        Debug.Assert(MaxHerbValue(7, 3, new int[] {2, 3, 5}, new int[] {100, 200, 300}) == 400);\n        Debug.Assert(MaxHerbValue(12, 4, new int[] {2, 4, 6, 3}, new int[] {100, 200, 300, 150}) == 600);\n        Debug.Assert(MaxHerbValue(8, 3, new int[] {1, 3, 4}, new int[] {150, 250, 350}) == 750);\n        Debug.Assert(MaxHerbValue(15, 5, new int[] {3, 5, 7, 4, 2}, new int[] {120, 280, 350, 220, 180}) == 810);\n\n\n    }\n}", "entry_point": "MaxHerbValue", "signature": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)", "docstring": "Calculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450", "instruction": "Write a C# function `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` to solve the following problem:\nCalculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450", "level": "middle"}
{"task_id": "C#/14", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    This function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)", "canonical_solution": "{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}", "test": "static void Main()\n    {\n        Debug.Assert(UniqueAndSorted(new List<int> { 3, 1, 2, 1 }) .SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 5, 4, 5, 4, 5 }) .SequenceEqual(new List<int> { 4, 5 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 8, 7, 9, 6, 10 }) .SequenceEqual(new List<int> { 6, 7, 8, 9, 10 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 11, 11, 11 }) .SequenceEqual(new List<int> { 11 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 15, 14, 13, 12, 11, 15, 14 }) .SequenceEqual(new List<int> { 11, 12, 13, 14, 15 }));\n\n    }\n}", "entry_point": "UniqueAndSorted", "signature": "static List<int> UniqueAndSorted(List<int> numbers)", "docstring": "This function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]", "instruction": "Write a C# function `static List<int> UniqueAndSorted(List<int> numbers)` to solve the following problem:\nThis function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]", "level": "easy"}
{"task_id": "C#/15", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)", "canonical_solution": "{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}", "test": "    static void Main()\n    {\n        // Test Case 1\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80) }).SequenceEqual(new List<(int, int)> { (3, 255), (2, 255), (1, 255) }));\n\n        // Test Case 2\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (4, 88, 75, 95), (5, 95, 88, 75) }).SequenceEqual(new List<(int, int)> { (5, 258), (4, 258) }));\n\n        // Test Case 3\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (6, 75, 85, 90), (7, 90, 75, 85) }).SequenceEqual(new List<(int, int)> { (7, 250), (6, 250) }));\n\n        // Test Case 4\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (8, 80, 90, 80), (9, 90, 80, 80) }).SequenceEqual(new List<(int, int)> { (9, 250), (8, 250) }));\n\n        // Test Case 5\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (10, 85, 85, 85), (11, 86, 85, 84), (12, 84, 86, 85) }).SequenceEqual(new List<(int, int)> { (11, 255), (10, 255), (12, 255) }));\n        }\n}\n", "entry_point": "AwardTopStudents", "signature": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)", "docstring": "This function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]", "instruction": "Write a C# function `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` to solve the following problem:\nThis function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]", "level": "easy"}
{"task_id": "C#/16", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Determine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)", "canonical_solution": "{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30) == 2);\n        Debug.Assert(MinimumGroups(new List<int> { 10, 20, 30, 40, 50 }, 60) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 25, 30, 35, 5, 15, 20 }, 40) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 32, 42, 52, 12, 22 }, 70) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 30, 35, 40, 10, 15, 20, 25}, 45) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 10, 15, 20, 25 }, 30) == 3);\n\n    }\n}\n", "entry_point": "MinimumGroups", "signature": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)", "docstring": "Determine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2", "instruction": "Write a C# function `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` to solve the following problem:\nDetermine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2", "level": "easy"}
{"task_id": "C#/17", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)", "canonical_solution": "{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(InitialPeachesCount(1) == 1);\n        Debug.Assert(InitialPeachesCount(2) == 4);\n        Debug.Assert(InitialPeachesCount(3) == 10);\n        Debug.Assert(InitialPeachesCount(4) == 22);\n\n\n    }\n}", "entry_point": "InitialPeachesCount", "signature": "static int InitialPeachesCount(int days)", "docstring": "Calculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10", "instruction": "Write a C# function `static int InitialPeachesCount(int days)` to solve the following problem:\nCalculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10", "level": "easy"}
{"task_id": "C#/18", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)", "canonical_solution": "{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(FindAmicableNumbers(300).SequenceEqual(new List<(int, int)> { (220, 284) }));\n        Debug.Assert(FindAmicableNumbers(2000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) }));\n        Debug.Assert(FindAmicableNumbers(500).Count == 1);\n        Debug.Assert(FindAmicableNumbers(100).Count == 0);\n        Debug.Assert(FindAmicableNumbers(3000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) ,(2620,2924)}));\n\n    }\n}\n\n\n\n", "entry_point": "FindAmicableNumbers", "signature": "static List<(int, int)> FindAmicableNumbers(int limit)", "docstring": "FindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)", "instruction": "Write a C# function `static List<(int, int)> FindAmicableNumbers(int limit)` to solve the following problem:\nFindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)", "level": "hard"}
{"task_id": "C#/19", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)", "canonical_solution": "{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}", "test": "    static void Main()\n    {\n        Debug.Assert(ReverseAndConcatenate(\"abc\") == \"abccba\");\n        Debug.Assert(ReverseAndConcatenate(\"test\") == \"testtset\");\n        Debug.Assert(ReverseAndConcatenate(\"\") == \"\");\n        Debug.Assert(ReverseAndConcatenate(\"12345\") == \"1234554321\");\n\n    }\n}", "entry_point": "ReverseAndConcatenate", "signature": "static string ReverseAndConcatenate(string input)", "docstring": "This function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"", "instruction": "Write a C# function `static string ReverseAndConcatenate(string input)` to solve the following problem:\nThis function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"", "level": "easy"}
{"task_id": "C#/20", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)", "canonical_solution": "   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }", "test": "    static void Main()\n    {\n        Debug.Assert(CountUniquePostageCombinations(4, 3) == 19); \n        Debug.Assert(CountUniquePostageCombinations(2, 2) == 8); \n        Debug.Assert(CountUniquePostageCombinations(3, 1) == 7);\n        Debug.Assert(CountUniquePostageCombinations(1, 3) == 7); \n\n    }\n}\n", "entry_point": "CountUniquePostageCombinations", "signature": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)", "docstring": "Calculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8", "instruction": "Write a C# function `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` to solve the following problem:\nCalculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8", "level": "easy"}
{"task_id": "C#/21", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Determines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)", "canonical_solution": "{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }", "test": "    static void Main()\n    {\n\n        Debug.Assert(IsSequenceJolly(new int[] {1, 4, 2, 3}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {1, 3}) == \"Not Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {5}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {10, 7, 8, 9}) == \"Not Jolly\");\n\n    }\n}", "entry_point": "IsSequenceJolly", "signature": "static string IsSequenceJolly(int[] sequence)", "docstring": "Determines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"", "instruction": "Write a C# function `static string IsSequenceJolly(int[] sequence)` to solve the following problem:\nDetermines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"", "level": "middle"}
{"task_id": "C#/22", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Determines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)", "canonical_solution": "    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }", "test": "    static void Main()\n    {\n        Debug.Assert(DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(5, new List<int> {0, 0, 0}, new List<int> {2, 2, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2}) == \"draw\");\n    }\n}", "entry_point": "DetermineWinner", "signature": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)", "docstring": "Determines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"", "instruction": "Write a C# function `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` to solve the following problem:\nDetermines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"", "level": "hard"}
{"task_id": "C#/23", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Calculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)", "canonical_solution": "{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1}) == 3);\n        Debug.Assert(CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8}) == 92);\n        Debug.Assert(CalculateDotProduct(new List<int> {0, 0, 0}, new List<int> {0, 0, 0}) == 0);\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 2}, new List<int> {3, 4}) == 11);\n\n    }\n}", "entry_point": "CalculateDotProduct", "signature": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)", "docstring": "Calculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100", "instruction": "Write a C# function `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` to solve the following problem:\nCalculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100", "level": "easy"}
{"task_id": "C#/24", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Calculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)", "canonical_solution": "    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }", "test": "    static void Main()\n    {           \n        Debug.Assert(CalculatePowerOfTwo(3).Equals(new BigInteger(8)));\n        Debug.Assert(CalculatePowerOfTwo(10).Equals(new BigInteger(1024)));\n        Debug.Assert(CalculatePowerOfTwo(15).Equals(new BigInteger(32768)));\n        Debug.Assert(CalculatePowerOfTwo(0).Equals(new BigInteger(1)));\n\n    }\n}\n", "entry_point": "CalculatePowerOfTwo", "signature": "static BigInteger CalculatePowerOfTwo(int n)", "docstring": "Calculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1", "instruction": "Write a C# function `static BigInteger CalculatePowerOfTwo(int n)` to solve the following problem:\nCalculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1", "level": "easy"}
{"task_id": "C#/25", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.\n*/\n    static char FirstUniqueChar(string str)", "canonical_solution": "    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }", "test": "    static void Main()\n    {\n        Debug.Assert(FirstUniqueChar(\"aabbcdde\") == 'c');\n        Debug.Assert(FirstUniqueChar(\"aabbcc\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"xxyyazz\") == 'a');\n        Debug.Assert(FirstUniqueChar(\"\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"aabbcceeddf\") == 'f');\n\n    }\n}", "entry_point": "FirstUniqueChar", "signature": "static char FirstUniqueChar(string str)", "docstring": "Finds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.", "instruction": "Write a C# function `static char FirstUniqueChar(string str)` to solve the following problem:\nFinds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.", "level": "middle"}
{"task_id": "C#/26", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)", "canonical_solution": "    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }", "test": "    static void Main()\n    {\n\n        Debug.Assert(AreDNAsRelated(\"ATCGCCGTAAGTAACGGTTTTAAATAGGCC\", \"ATCGCCGGAAGTAACGGTCTTAAATAGGCC\", 0.85) == true);\n        Debug.Assert(AreDNAsRelated(\"GGCATGAC\", \"TGACATGC\", 0.50) == false);\n        Debug.Assert(AreDNAsRelated(\"AAAA\", \"AAAA\", 1.00) == true);\n        Debug.Assert(AreDNAsRelated(\"CCCC\", \"GGTT\", 0.25) == false);\n\n    }\n}", "entry_point": "AreDNAsRelated", "signature": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)", "docstring": "Determines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true", "instruction": "Write a C# function `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` to solve the following problem:\nDetermines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true", "level": "middle"}
{"task_id": "C#/27", "prompt": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* This function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)", "canonical_solution": "    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }", "test": "    static void Main()\n    {\n        Debug.Assert(GenerateCloseFriendString(\"1234\") == \"cege\");\n        Debug.Assert(GenerateCloseFriendString(\"4312\") == \"gdcf\");\n\n    }\n}", "entry_point": "GenerateCloseFriendString", "signature": "static string GenerateCloseFriendString(string inputString)", "docstring": "This function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"", "instruction": "Write a C# function `static string GenerateCloseFriendString(string inputString)` to solve the following problem:\nThis function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"", "level": "hard"}
{"task_id": "C#/28", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Decrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)", "canonical_solution": "    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }", "test": "static void Main()\n    {\n        Debug.Assert(DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n        Debug.Assert(DecryptCaesarCipher(\"F XYWNFYNTS YT XJHWJY\") == \"A STRIATION TO SECRET\");\n        Debug.Assert(DecryptCaesarCipher(\"YMJ VZNHP TS X HNUMJW\") == \"THE QUICK ON S CIPHER\");\n        Debug.Assert(DecryptCaesarCipher(\"JXU UQFSI QDT TZW YMZXW\") == \"ESP PLAND LYO OUR THUSR\");\n    }\n}", "entry_point": "DecryptCaesarCipher", "signature": "static string DecryptCaesarCipher(string cipherText)", "docstring": "Decrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "instruction": "Write a C# function `static string DecryptCaesarCipher(string cipherText)` to solve the following problem:\nDecrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"", "level": "easy"}
{"task_id": "C#/29", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Determines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)", "canonical_solution": "    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }", "test": "    static void Main()\n    {\n        Debug.Assert(CheckSubstring(\"apple\", \"pineapple\") == \"\\\"apple\\\" is substring of \\\"pineapple\\\"\");\n        Debug.Assert(CheckSubstring(\"star\", \"astrophysics\") == \"No substring\");\n        Debug.Assert(CheckSubstring(\"sun\", \"sunset\") == \"\\\"sun\\\" is substring of \\\"sunset\\\"\");\n        Debug.Assert(CheckSubstring(\"moon\", \"moonlight\") == \"\\\"moon\\\" is substring of \\\"moonlight\\\"\");\n\n\n    }\n}", "entry_point": "CheckSubstring", "signature": "static string CheckSubstring(string str1, string str2)", "docstring": "Determines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"", "instruction": "Write a C# function `static string CheckSubstring(string str1, string str2)` to solve the following problem:\nDetermines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"", "level": "easy"}
{"task_id": "C#/30", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Removes a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)", "canonical_solution": "{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(RemoveSuffix(\"happily\") == \"happi\");\n        Debug.Assert(RemoveSuffix(\"dancing\") == \"danc\");\n        Debug.Assert(RemoveSuffix(\"flower\") == \"flow\");\n        Debug.Assert(RemoveSuffix(\"computer\") == \"comput\");\n        Debug.Assert(RemoveSuffix(\"flying\") == \"fly\");\n        Debug.Assert(RemoveSuffix(\"ing\") == \"ing\");\n        Debug.Assert(RemoveSuffix(\"er\") == \"er\");\n    }\n}", "entry_point": "RemoveSuffix", "signature": "static string RemoveSuffix(string word)", "docstring": "Removes a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"", "instruction": "Write a C# function `static string RemoveSuffix(string word)` to solve the following problem:\nRemoves a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"", "level": "easy"}
{"task_id": "C#/31", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Finds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)", "canonical_solution": "    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }", "test": "    static void Main()\n    {\n        Debug.Assert(FindLongestAndShortestWord(\"Fast cars, smooth drives\") == (\"smooth\", \"Fast\"));\n        Debug.Assert(FindLongestAndShortestWord(\"Sunshine brings happiness\") == (\"happiness\", \"brings\"));\n        Debug.Assert(FindLongestAndShortestWord(\"A\") == (\"A\", \"A\")); // Edge case: Only one word\n        Debug.Assert(FindLongestAndShortestWord(\"Every cloud has a silver lining\") == (\"silver\", \"a\"));\n\n\n    }\n}", "entry_point": "FindLongestAndShortestWord", "signature": "static (string, string) FindLongestAndShortestWord(string sentence)", "docstring": "Finds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")", "instruction": "Write a C# function `static (string, string) FindLongestAndShortestWord(string sentence)` to solve the following problem:\nFinds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")", "level": "hard"}
{"task_id": "C#/32", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)", "canonical_solution": "{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(CalculateSpeedAndNextPalindrome(12321, 2) == (50, 12421));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(11111, 1) == (100, 11211));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(23332, 2) == (50, 23432));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(45654, 4) == (25, 45754));\n\n    }\n}", "entry_point": "CalculateSpeedAndNextPalindrome", "signature": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)", "docstring": "Calculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)", "instruction": "Write a C# function `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` to solve the following problem:\nCalculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)", "level": "middle"}
{"task_id": "C#/33", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)", "canonical_solution": "{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}", "test": "    static void Main()\n    {\n     Debug.Assert(FindAutomorphicNumbers(100).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76 }));\n    Debug.Assert(FindAutomorphicNumbers(500).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376 }));\n    Debug.Assert(FindAutomorphicNumbers(1000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625 }));\n    Debug.Assert(FindAutomorphicNumbers(200000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625,9376, 90625, 109376 }));\n\n    }\n}", "entry_point": "FindAutomorphicNumbers", "signature": "static List<int> FindAutomorphicNumbers(int limit)", "docstring": "Finds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]", "instruction": "Write a C# function `static List<int> FindAutomorphicNumbers(int limit)` to solve the following problem:\nFinds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]", "level": "easy"}
{"task_id": "C#/34", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)", "canonical_solution": "{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}", "test": "static void Main()\n    {\n        Debug.Assert(LastRemainingPerson(5, 2) == 3);\n        Debug.Assert(LastRemainingPerson(6, 4) == 5);\n        Debug.Assert(LastRemainingPerson(10, 3) == 4);\n        Debug.Assert(LastRemainingPerson(7, 2) == 7);\n\n    }\n}", "entry_point": "LastRemainingPerson", "signature": "static int LastRemainingPerson(int totalPeople, int countNumber)", "docstring": "Determine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5", "instruction": "Write a C# function `static int LastRemainingPerson(int totalPeople, int countNumber)` to solve the following problem:\nDetermine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5", "level": "easy"}
{"task_id": "C#/35", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Determines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)", "canonical_solution": "    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }", "test": "    static void Main()\n    {\n\n        Debug.Assert(StepsToPalindrome(10, \"56\") == \"STEP=1\");\n        Debug.Assert(StepsToPalindrome(9, \"87\") == \"STEP=6\");\n        Debug.Assert(StepsToPalindrome(10, \"87\") == \"STEP=4\");\n        Debug.Assert(StepsToPalindrome(2, \"1001\") == \"STEP=0\"); // Already a palindrome\n        Debug.Assert(StepsToPalindrome(16, \"1A3\") == \"STEP=2\");\n\n\n    }\n}", "entry_point": "StepsToPalindrome", "signature": "public static string StepsToPalindrome(int baseNum, string num)", "docstring": "Determines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"", "instruction": "Write a C# function `public static string StepsToPalindrome(int baseNum, string num)` to solve the following problem:\nDetermines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"", "level": "hard"}
{"task_id": "C#/36", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)", "canonical_solution": "{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}", "test": "    static void Main()\n    {\n\n        Debug.Assert(IsPasswordSecure(\"Password123!\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"short\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"Good@Pass1\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"1234567890\") == \"NO\");\n\n    }\n}", "entry_point": "IsPasswordSecure", "signature": "static string IsPasswordSecure(string password)", "docstring": "Determines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"", "instruction": "Write a C# function `static string IsPasswordSecure(string password)` to solve the following problem:\nDetermines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"", "level": "hard"}
{"task_id": "C#/37", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Counts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)", "canonical_solution": "    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n", "test": "    static void Main()\n    {\n        Debug.Assert(CountQueueArrangements(4, 2, 2) == 8);\n        Debug.Assert(CountQueueArrangements(5, 3, 2) == 60); // Expected output: True\n        Debug.Assert(CountQueueArrangements(6, 4, 2) == 432); // Expected output: True\n\n    }\n}\n", "entry_point": "CountQueueArrangements", "signature": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)", "docstring": "Counts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8", "instruction": "Write a C# function `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` to solve the following problem:\nCounts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8", "level": "hard"}
{"task_id": "C#/38", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)", "canonical_solution": "{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}", "test": "    static void Main()\n    {\n\n        Debug.Assert(MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6}) == 1);\n        Debug.Assert(MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35}) == 5);\n\n    }\n}", "entry_point": "MinArrayDistance", "signature": "static int MinArrayDistance(int[] array1, int[] array2)", "docstring": "Determines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5", "instruction": "Write a C# function `static int MinArrayDistance(int[] array1, int[] array2)` to solve the following problem:\nDetermines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5", "level": "easy"}
{"task_id": "C#/39", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Sort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)", "canonical_solution": "{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 3, -4, 2 }).SequenceEqual(new List<int> { -4, 3, 2 }));\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 }).SequenceEqual(new List<int> { -3, 2, 1, 0 }));\n\n\n    }\n}", "entry_point": "SortByAbsoluteDescending", "signature": "static List<int> SortByAbsoluteDescending(List<int> numbers)", "docstring": "Sort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]", "instruction": "Write a C# function `static List<int> SortByAbsoluteDescending(List<int> numbers)` to solve the following problem:\nSort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]", "level": "easy"}
{"task_id": "C#/40", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)", "canonical_solution": "{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}", "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) }) == 2200);\n        Debug.Assert(MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) }) == 1700);\n\n    }\n}\n", "entry_point": "MaxValueOfPurchases", "signature": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)", "docstring": "Calculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700", "instruction": "Write a C# function `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` to solve the following problem:\nCalculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700", "level": "hard"}
{"task_id": "C#/41", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)", "canonical_solution": "{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}", "test": "static void Main()\n    {\n        Debug.Assert(TotalSmokedCigarettes(4, 3) == 5);\n        Debug.Assert(TotalSmokedCigarettes(10, 3) == 14);\n        Debug.Assert(TotalSmokedCigarettes(1, 2) == 1); // No conversion possible, should return initial cigarettes\n        Debug.Assert(TotalSmokedCigarettes(20, 4) ==26); // Additional case to test\n\n    }\n}", "entry_point": "TotalSmokedCigarettes", "signature": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)", "docstring": "Calculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14", "instruction": "Write a C# function `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14", "level": "easy"}
{"task_id": "C#/42", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)", "canonical_solution": "{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) }) == 2);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(92, 95, 98), Tuple.Create(85, 90, 95) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 95, 90), Tuple.Create(95, 90, 85), Tuple.Create(90, 85, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(80, 80, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(100, 100, 99), Tuple.Create(101, 100, 99) }) == 3);\n\n    }\n}\n", "entry_point": "FindEqualOpponents", "signature": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)", "docstring": "Determines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2", "instruction": "Write a C# function `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` to solve the following problem:\nDetermines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2", "level": "hard"}
{"task_id": "C#/43", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)", "canonical_solution": "{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9}) == 6);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {100, 4, 200, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 1}) == 1);\n\n    }\n}\n\n", "entry_point": "LongestConsecutiveSequence", "signature": "static int LongestConsecutiveSequence(List<int> sequence)", "docstring": "Finds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4", "instruction": "Write a C# function `static int LongestConsecutiveSequence(List<int> sequence)` to solve the following problem:\nFinds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4", "level": "middle"}
{"task_id": "C#/44", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)", "canonical_solution": "{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}", "test": "    static void Main()\n    {\n        Debug.Assert(CompareArea(5, 4, 6) == \"Alice\");\n        Debug.Assert(CompareArea(7, 5, 10) == \"Bob\");\n        Debug.Assert(CompareArea(2, 2, 8) == \"Bob\"); // Testing with a square of side 2 and a rectangle 2x8\n        Debug.Assert(CompareArea(10, 5, 5) == \"Alice\"); // Testing with a square of side 10 and a rectangle 5x5\n\n\n    }\n}\n\n", "entry_point": "CompareArea", "signature": "static string CompareArea(int a, int b, int c)", "docstring": "Determines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"", "instruction": "Write a C# function `static string CompareArea(int a, int b, int c)` to solve the following problem:\nDetermines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"", "level": "easy"}
{"task_id": "C#/45", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)", "canonical_solution": "    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }", "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxProductPartition(6, 3).SequenceEqual(new List<int> { 2, 2, 2 }));\n        Debug.Assert(MaxProductPartition(8, 3).SequenceEqual(new List<int> { 2, 3, 3 }));\n        Debug.Assert(MaxProductPartition(10, 2).SequenceEqual(new List<int> { 5, 5 }));\n        Debug.Assert(MaxProductPartition(7, 3).SequenceEqual(new List<int> { 2, 2, 3 }));\n\n    }\n}\n", "entry_point": "MaxProductPartition", "signature": "public static List<int> MaxProductPartition(int N, int M)", "docstring": "Finds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]", "instruction": "Write a C# function `public static List<int> MaxProductPartition(int N, int M)` to solve the following problem:\nFinds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]", "level": "hard"}
{"task_id": "C#/46", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Counts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)", "canonical_solution": "{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(CountTitleCharacters(\"234\") == 3);\n        Debug.Assert(CountTitleCharacters(\"Ca 45\") == 4);\n        Debug.Assert(CountTitleCharacters(\"Hello World\\n\") == 10);\n        Debug.Assert(CountTitleCharacters(\" 123 \") == 3);\n        Debug.Assert(CountTitleCharacters(\"\\nNew\\tLine\") == 7);\n\n    }\n}", "entry_point": "CountTitleCharacters", "signature": "static int CountTitleCharacters(string title)", "docstring": "Counts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3", "instruction": "Write a C# function `static int CountTitleCharacters(string title)` to solve the following problem:\nCounts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3", "level": "easy"}
{"task_id": "C#/47", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)", "canonical_solution": "{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 2, 3, 4, 5 }, new List<int> { 1, 3, 4, 5, 6 }) == 4);\n        Debug.Assert(CountCommonStudents(new List<int> { 7, 8, 9 }, new List<int> { 10, 11, 12 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 3, 5, 7, 9 }, new List<int> { 2, 4, 6, 8, 10 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 2, 4, 6, 8 }, new List<int> { 1, 3, 5, 7, 8 }) == 1);\n\n\n    }\n}", "entry_point": "CountCommonStudents", "signature": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)", "docstring": "Determines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0", "instruction": "Write a C# function `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` to solve the following problem:\nDetermines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0", "level": "easy"}
{"task_id": "C#/48", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)", "canonical_solution": "{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}", "test": "    static void Main()\n    {\n        Debug.Assert(RemainingApples(50, 10, 200) == 30);\n        Debug.Assert(RemainingApples(10, 2, 5) == 7);\n        Debug.Assert(RemainingApples(5, 15, 10) == 4);\n        Debug.Assert(RemainingApples(20, 0, 100) == 0); // Case to test division by zero handling\n        Debug.Assert(RemainingApples(3, 10, 130) == 0); // Case where all apples are eaten\n\n    }\n}", "entry_point": "RemainingApples", "signature": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)", "docstring": "Calculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30", "instruction": "Write a C# function `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` to solve the following problem:\nCalculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30", "level": "middle"}
{"task_id": "C#/49", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Finds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)", "canonical_solution": "    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }", "test": "static void Main()\n    {\n\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} }) == (7, 9));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4, 6}, new List<int> {3, 3} }) == (5, 3));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> { 110, 112, 108 }, new List<int> { 107, 109, 108 } }) == (111, 108));\n\n    }\n}", "entry_point": "FindErrorIds", "signature": "static (int, int) FindErrorIds(List<List<int>> ids)", "docstring": "Finds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)", "instruction": "Write a C# function `static (int, int) FindErrorIds(List<List<int>> ids)` to solve the following problem:\nFinds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)", "level": "middle"}
{"task_id": "C#/50", "prompt": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Counts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)", "canonical_solution": "    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }", "test": "    static void Main()\n    {\n        Debug.Assert(CountCharacters(\"yLAX2022\") == (4, 1, 3));\n        Debug.Assert(CountCharacters(\"MBKKOKOK\") == (0, 0, 8));\n        Debug.Assert(CountCharacters(\"1n2s0e1s\") == (4, 4, 0));\n        Debug.Assert(CountCharacters(\"1234ABCD\") == (4, 0, 4));\n\n\n    }\n}", "entry_point": "CountCharacters", "signature": "static (int, int, int) CountCharacters(string s)", "docstring": "Counts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)", "instruction": "Write a C# function `static (int, int, int) CountCharacters(string s)` to solve the following problem:\nCounts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)", "level": "easy"}
