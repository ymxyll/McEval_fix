{"task_id": "F#/1", "prompt": "open System\n\nlet hasCloseElements (numbers: float list) (threshold: float) =\n    (*\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    *)", "canonical_solution": "    let rec checkCloseElements = function\n        | [], _ -> false\n        | x::xs, y ->\n            if List.exists (fun elem -> abs (x - elem) < y) xs then\n                true\n            else\n                checkCloseElements (xs, y)\n    \n    checkCloseElements (numbers, threshold)", "test": "// Test cases\nlet check () =\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.3 <> true then\n        failwith \"Test Case 1 failed\"\n    if hasCloseElements [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.05 <> false then\n        failwith \"Test Case 2 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.95 <> true then\n        failwith \"Test Case 3 failed\"\n    if hasCloseElements [1.0; 2.0; 5.9; 4.0; 5.0] 0.8 <> false then\n        failwith \"Test Case 4 failed\"\n    if hasCloseElements [1.0; 2.0; 3.0; 4.0; 5.0; 2.0] 0.1 <> true then\n        failwith \"Test Case 5 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 1.0 <> true then\n        failwith \"Test Case 6 failed\"\n    if hasCloseElements [1.1; 2.2; 3.1; 4.1; 5.1] 0.5 <> false then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "hasCloseElements", "signature": "let hasCloseElements (numbers: float list) (threshold: float) =", "docstring": "\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "instruction": "Write a F# function `let hasCloseElements (numbers: float list) (threshold: float) =` to solve the following problem:\n\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ", "level": "middle"}
{"task_id": "F#/2", "prompt": "open System\n\nlet existsDouble (arr: int list) =\n    (*\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    *)", "canonical_solution": "    let checkForDouble = function\n        | [] -> false\n        | xs ->\n            List.exists (fun x -> List.exists (fun y -> x = 2 * y || y = 2 * x) xs) xs\n\n    checkForDouble arr", "test": "let test () =\n    if existsDouble [1; 2; 3; 4] <> true then\n        failwith \"Test Case 1 failed\"\n    if existsDouble [1; 3; 5; 7] <> false then\n        failwith \"Test Case 2 failed\"\n    if existsDouble [10; 5; 3; 2] <> true then\n        failwith \"Test Case 3 failed\"\n    if existsDouble [6; 7; 9; 12] <> true then\n        failwith \"Test Case 4 failed\"\n    if existsDouble [20; 5; 10; 15] <> true then\n        failwith \"Test Case 5 failed\"\n    if existsDouble [4; 2; 1; 8] <> true then\n        failwith \"Test Case 6 failed\"\n    if existsDouble [11; 22; 33; 44] <> true then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "existsDouble", "signature": "let existsDouble (arr: int list) =", "docstring": "\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    ", "instruction": "Write a F# function `let existsDouble (arr: int list) =` to solve the following problem:\n\n    Checks if there exists two integers N and M in the array `arr` such that N is twice M.\n    >>> existsDouble([1, 2, 3, 4])\n    True\n    >>> existsDouble([1, 3, 5, 7])\n    False\n    ", "level": "easy"}
{"task_id": "F#/3", "prompt": "open System\n\nlet countNegatives (grid: int list list) =\n    (*\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    *)", "canonical_solution": "    let countRowNegatives row =\n        row |> List.filter (fun x -> x < 0) |> List.length\n\n    grid |> List.map countRowNegatives |> List.sum", "test": "let test () =\n    if countNegatives [[4; 3; 2; -1]; [3; 2; 1; -1]; [1; 1; -1; -2]; [-1; -1; -2; -3]] <> 8 then\n        failwith \"Test Case 1 failed\"\n    if countNegatives [[3; 2]; [1; 0]] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countNegatives [[-1]] <> 1 then\n        failwith \"Test Case 3 failed\"\n    if countNegatives [[5; 4; -1]; [3; 2; -2]; [1; 0; -3]] <> 3 then\n        failwith \"Test Case 4 failed\"\n    if countNegatives [[-5; -4; -3]; [-2; -2; -1]; [-1; -1; -1]] <> 9 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "countNegatives", "signature": "let countNegatives (grid: int list list) =", "docstring": "\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    ", "instruction": "Write a F# function `let countNegatives (grid: int list list) =` to solve the following problem:\n\n    Counts the number of negative numbers in an m x n matrix `grid`, where elements are non-increasing both row-wise and column-wise.\n    >>> countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])\n    8\n    >>> countNegatives([[3, 2], [1, 0]])\n    0\n    ", "level": "easy"}
{"task_id": "F#/4", "prompt": "open System\n\nlet sortByBinaryOnes (arr: int list) =\n    (*\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    *)", "canonical_solution": "    let countBinaryOnes (n:int) =\n        Convert.ToString(n, 2) |> Seq.filter (fun x -> x = '1') |> Seq.length\n\n    arr |> List.sortWith (fun x y -> \n        let onesX, onesY = countBinaryOnes x, countBinaryOnes y\n        if onesX = onesY then compare x y\n        else compare onesX onesY)", "test": "let test () =\n    if sortByBinaryOnes [0; 1; 2; 3; 4; 5; 6; 7; 8] <> [0; 1; 2; 4; 8; 3; 5; 6; 7] then\n        failwith \"Test Case 1 failed\"\n    if sortByBinaryOnes [1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1] <> [1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024] then\n        failwith \"Test Case 2 failed\"\n    if sortByBinaryOnes [10; 100; 1000; 10000] <> [10; 100; 10000; 1000] then\n        failwith \"Test Case 3 failed\"\n    if sortByBinaryOnes [3; 7; 15; 31; 63] <> [3; 7; 15; 31; 63] then\n        failwith \"Test Case 4 failed\"\n    if sortByBinaryOnes [5; 9; 17; 33; 65] <> [5;9;17; 33; 65;] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "sortByBinaryOnes", "signature": "let sortByBinaryOnes (arr: int list) =", "docstring": "\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    ", "instruction": "Write a F# function `let sortByBinaryOnes (arr: int list) =` to solve the following problem:\n\n    Sorts an array of integers based on the number of 1s in their binary representation. In case of a tie, sorts by their value.\n    >>> sortByBinaryOnes([0, 1, 2, 3, 4, 5, 6, 7, 8])\n    [0, 1, 2, 4, 8, 3, 5, 6, 7]\n    >>> sortByBinaryOnes([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1])\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n    ", "level": "middle"}
{"task_id": "F#/5", "prompt": "open System\n\nlet smallerNumbersThanCurrent (nums: int list) =\n    (*\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    *)", "canonical_solution": "    let countSmaller n =\n        nums |> List.filter (fun x -> x < n) |> List.length\n\n    nums |> List.map countSmaller", "test": "let test () =\n    if smallerNumbersThanCurrent [8; 1; 2; 2; 3] <> [4; 0; 1; 1; 3] then\n        failwith \"Test Case 1 failed\"\n    if smallerNumbersThanCurrent [6; 5; 4; 8] <> [2; 1; 0; 3] then\n        failwith \"Test Case 2 failed\"\n    if smallerNumbersThanCurrent [7; 7; 7; 7] <> [0; 0; 0; 0] then\n        failwith \"Test Case 3 failed\"\n    if smallerNumbersThanCurrent [1; 2; 3; 4; 5] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 4 failed\"\n    if smallerNumbersThanCurrent [5; 4; 3; 2; 1] <> [4; 3; 2; 1; 0] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "smallerNumbersThanCurrent", "signature": "let smallerNumbersThanCurrent (nums: int list) =", "docstring": "\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    ", "instruction": "Write a F# function `let smallerNumbersThanCurrent (nums: int list) =` to solve the following problem:\n\n    Counts the number of elements smaller than each element in the array `nums`.\n    >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3])\n    [4, 0, 1, 1, 3]\n    >>> smallerNumbersThanCurrent([6, 5, 4, 8])\n    [2, 1, 0, 3]\n    ", "level": "easy"}
{"task_id": "F#/6", "prompt": "open System\n\nlet findLuckyNumbers (matrix: int list list) =\n    (*\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    *)", "canonical_solution": "    let rowMins = matrix |> List.map List.min\n    let colMaxs = \n        [for colIdx in 0 .. (List.head matrix |> List.length) - 1 do\n            yield matrix |> List.map (fun row -> row.[colIdx]) |> List.max]\n\n    [for rowIdx in 0 .. matrix.Length - 1 do\n        for colIdx in 0 .. (matrix.[rowIdx] |> List.length) - 1 do\n            let value = matrix.[rowIdx].[colIdx]\n            if value = rowMins.[rowIdx] && value = colMaxs.[colIdx] then\n                yield value]", "test": "let test () =\n    if findLuckyNumbers [[3; 7; 8]; [9; 11; 13]; [15; 16; 17]] <> [15] then\n        failwith \"Test Case 1 failed\"\n    if findLuckyNumbers [[1; 10; 4; 2]; [9; 3; 8; 7]; [15; 16; 17; 12]] <> [12] then\n        failwith \"Test Case 2 failed\"\n    if findLuckyNumbers [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] <> [7] then\n        failwith \"Test Case 3 failed\"\n    if findLuckyNumbers [[7; 8]; [1; 6]] <> [7] then\n        failwith \"Test Case 4 failed\"\n    if findLuckyNumbers [[11; 17; 4; 3]; [9; 5; 8; 7]; [15; 2; 16; 12]] <> [] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findLuckyNumbers", "signature": "let findLuckyNumbers (matrix: int list list) =", "docstring": "\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    ", "instruction": "Write a F# function `let findLuckyNumbers (matrix: int list list) =` to solve the following problem:\n\n    Finds all lucky numbers in an m x n matrix. A lucky number is the smallest in its row and the largest in its column.\n    >>> findLuckyNumbers([[3, 7, 8], [9, 11, 13], [15, 16, 17]])\n    [15]\n    >>> findLuckyNumbers([[1, 10, 4, 2], [9, 3, 8, 7], [15, 16, 17, 12]])\n    [12]\n    ", "level": "hard"}
{"task_id": "F#/7", "prompt": "open System\n\nlet findDistanceValue (arr1: int list) (arr2: int list) (d: int) =\n    (*\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    *)", "canonical_solution": "    let isDistanceValid a1 a2 =\n        not (List.exists (fun x -> abs (a1 - x) <= d) a2)\n\n    arr1 |> List.filter (fun x -> isDistanceValid x arr2) |> List.length", "test": "let test () =\n    if findDistanceValue [4; 5; 8] [10; 9; 1; 8] 2 <> 2 then\n        failwith \"Test Case 1 failed\"\n    if findDistanceValue [1; 4; 2; 3] [-4; -3; 6; 10; 20; 30] 3 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if findDistanceValue [2; 1; 100; 3] [10; 9; 8; 7] 6 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if findDistanceValue [-2; -1; -3; 0] [1; 2; 3; 4] 1 <> 3 then\n        failwith \"Test Case 4 failed\"\n    if findDistanceValue [0; 0; 0; 0] [5; 6; 7; 8] 4 <> 4 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "findDistanceValue", "signature": "let findDistanceValue (arr1: int list) (arr2: int list) (d: int) =", "docstring": "\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    ", "instruction": "Write a F# function `let findDistanceValue (arr1: int list) (arr2: int list) (d: int) =` to solve the following problem:\n\n    Calculates the 'distance value' between two arrays `arr1` and `arr2` given a distance threshold `d`.\n    The 'distance value' is defined as the count of elements in `arr1` for which there is no element in `arr2` such that the absolute difference is less than or equal to `d`.\n    >>> findDistanceValue([4, 5, 8], [10, 9, 1, 8], 2)\n    2\n    >>> findDistanceValue([1, 4, 2, 3], [-4, -3, 6, 10, 20, 30], 3)\n    2\n    ", "level": "easy"}
{"task_id": "F#/8", "prompt": "open System\n\nlet createTargetArray (nums: int list) (index: int list) =\n    (*\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    *)", "canonical_solution": "    let rec insertAt idx x lst =\n        match idx, lst with\n        | _, [] -> [x]  // \u5f53\u5217\u8868\u4e3a\u7a7a\u65f6\uff0c\u76f4\u63a5\u8fd4\u56de\u5305\u542b x \u7684\u65b0\u5217\u8868\n        | 0, _ -> x :: lst\n        | i, h :: t when i = List.length lst -> lst @ [x]  // \u5982\u679c\u7d22\u5f15\u7b49\u4e8e\u5217\u8868\u957f\u5ea6\uff0c\u5219\u5728\u672b\u5c3e\u6dfb\u52a0\u5143\u7d20\n        | _, h :: t -> h :: (insertAt (idx - 1) x t)\n\n    let target = List.fold2 (fun acc n i -> insertAt i n acc) [] nums index\n    target", "test": "let test () =\n    if createTargetArray [0; 1; 2; 3; 4] [0; 1; 2; 2; 1] <> [0; 4; 1; 3; 2] then\n        failwith \"Test Case 1 failed\"\n    if createTargetArray [1; 2; 3; 4; 0] [0; 1; 2; 3; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 2 failed\"\n    if createTargetArray [4; 3; 2; 1; 0] [0; 0; 0; 0; 0] <> [0; 1; 2; 3; 4] then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "createTargetArray", "signature": "let createTargetArray (nums: int list) (index: int list) =", "docstring": "\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    ", "instruction": "Write a F# function `let createTargetArray (nums: int list) (index: int list) =` to solve the following problem:\n\n    Creates a target array based on arrays `nums` and `index`. Elements from `nums` are inserted into the target array at positions specified by `index`.\n    >>> createTargetArray([0, 1, 2, 3, 4], [0, 1, 2, 2, 1])\n    [0, 4, 1, 3, 2]\n    >>> createTargetArray([1, 2, 3, 4, 0], [0, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    ", "level": "hard"}
{"task_id": "F#/9", "prompt": "open System\n\nlet kidsWithCandies (candies: int list) (extraCandies: int) =\n    (*\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    *)", "canonical_solution": "    let maxCandies = List.max candies\n    candies |> List.map (fun x -> x + extraCandies >= maxCandies)", "test": "let test () =\n    if kidsWithCandies [2; 3; 5; 1; 3] 3 <> [true; true; true; false; true] then\n        failwith \"Test Case 1 failed\"\n    if kidsWithCandies [4; 2; 1; 1; 2] 1 <> [true; false; false; false; false] then\n        failwith \"Test Case 2 failed\"\n    if kidsWithCandies [1; 1; 1; 1; 1] 5 <> [true; true; true; true; true] then\n        failwith \"Test Case 3 failed\"\n    if kidsWithCandies [5; 10; 5; 10; 10] 5 <> [true; true; true; true; true] then\n        failwith \"Test Case 4 failed\"\n    if kidsWithCandies [10; 5; 3; 2; 1] 2 <> [true; false; false; false; false] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "kidsWithCandies", "signature": "let kidsWithCandies (candies: int list) (extraCandies: int) =", "docstring": "\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    ", "instruction": "Write a F# function `let kidsWithCandies (candies: int list) (extraCandies: int) =` to solve the following problem:\n\n    Checks for each child if they can have the most candies by adding `extraCandies`. \n    Returns a list of boolean values where each value corresponds to whether the child can have the most candies.\n    >>> kidsWithCandies([2, 3, 5, 1, 3], 3)\n    [True, True, True, False, True]\n    >>> kidsWithCandies([4, 2, 1, 1, 2], 1)\n    [True, False, False, False, False]\n    ", "level": "easy"}
{"task_id": "F#/10", "prompt": "open System\nopen System.Collections.Generic\n\nlet findDestination (paths: (string * string) list) =\n    (*\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    *)", "canonical_solution": "    let startCities = paths |> List.map fst |> HashSet\n    paths |> List.tryFind (fun (_, cityB) -> not (startCities.Contains(cityB))) |> Option.map snd", "test": "let test () =\n    if findDestination [(\"London\", \"New York\"); (\"New York\", \"Tokyo\"); (\"Tokyo\", \"Berlin\")] <> Some \"Berlin\" then\n        failwith \"Test Case 1 failed\"\n    if findDestination [(\"Chicago\", \"Winnipeg\"); (\"Halifax\", \"Montreal\"); (\"Montreal\", \"Toronto\"); (\"Toronto\", \"Chicago\")] <> Some \"Winnipeg\" then\n        failwith \"Test Case 2 failed\"\n    if findDestination [(\"A\", \"B\"); (\"B\", \"C\"); (\"C\", \"D\")] <> Some \"D\" then\n        failwith \"Test Case 3 failed\"\n    if findDestination [(\"Paris\", \"Lyon\"); (\"Lyon\", \"Marseille\")] <> Some \"Marseille\" then\n        failwith \"Test Case 4 failed\"\n\ntest ()", "entry_point": "findDestination", "signature": "let findDestination (paths: (string * string) list) =", "docstring": "\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    ", "instruction": "Write a F# function `let findDestination (paths: (string * string) list) =` to solve the following problem:\n\n    Finds the destination city in a travel itinerary, where each path is represented by a tuple (cityAi, cityBi).\n    The destination city is the one that doesn't appear as cityAi in any path.\n    >>> findDestination([(\"London\", \"New York\"), (\"New York\", \"Tokyo\"), (\"Tokyo\", \"Berlin\")])\n    \"Berlin\"\n    >>> findDestination([(\"Chicago\", \"Winnipeg\"), (\"Halifax\", \"Montreal\"), (\"Montreal\", \"Toronto\"), (\"Toronto\", \"Chicago\")])\n    \"Winnipeg\"\n    ", "level": "easy"}
{"task_id": "F#/11", "prompt": "open System\n\nlet homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =\n    (*\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    *)", "canonical_solution": "    List.zip startTime endTime\n    |> List.countBy (fun (start, end_) -> queryTime >= start && queryTime <= end_)\n    |> List.tryFind (fun (doingHomework, count) -> doingHomework)\n    |> function\n       | Some (_, count) -> count\n       | None -> 0", "test": "// Test cases\nlet test () =\n    if homeworkAtQueryTime [1; 2; 3] [3; 2; 7] 4 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if homeworkAtQueryTime [4; 2; 2; 1] [4; 3; 7; 8] 3 <> 3 then\n        failwith \"Test Case 2 failed\"\n    if homeworkAtQueryTime [5; 1; 1; 1] [10; 3; 2; 2] 5 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if homeworkAtQueryTime [1; 1; 1; 1] [4; 4; 4; 4] 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if homeworkAtQueryTime [2; 2; 2] [3; 3; 3] 1 <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "homeworkAtQueryTime", "signature": "let homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =", "docstring": "\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    ", "instruction": "Write a F# function `let homeworkAtQueryTime (startTime: int list) (endTime: int list) (queryTime: int) =` to solve the following problem:\n\n    Counts the number of students doing homework at a given `queryTime`.\n    A student is considered doing homework if `queryTime` falls within their start and end time inclusive.\n    >>> homeworkAtQueryTime([1, 2, 3], [3, 2, 7], 4)\n    1\n    >>> homeworkAtQueryTime([4, 2, 2, 1], [4, 3, 7, 8], 3)\n    3\n    ", "level": "middle"}
{"task_id": "F#/12", "prompt": "open System\n\nlet canMakeSameAsTarget (target: int list) (arr: int list) =\n    (*\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    *)", "canonical_solution": "    let sortedTarget = List.sort target\n    let sortedArr = List.sort arr\n    sortedTarget = sortedArr", "test": "let test () =\n    if canMakeSameAsTarget [1; 2; 3; 4] [2; 4; 1; 3] <> true then\n        failwith \"Test Case 1 failed\"\n    if canMakeSameAsTarget [7; 7; 7] [7; 7; 7] <> true then\n        failwith \"Test Case 2 failed\"\n    if canMakeSameAsTarget [5; 1; 3] [1; 3; 5] <> true then\n        failwith \"Test Case 3 failed\"\n    if canMakeSameAsTarget [1; 4; 3; 2] [2; 3; 4; 1] <> true then\n        failwith \"Test Case 4 failed\"\n    if canMakeSameAsTarget [1; 2; 1; 2] [2; 1; 2; 1] <> true then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "canMakeSameAsTarget", "signature": "let canMakeSameAsTarget (target: int list) (arr: int list) =", "docstring": "\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    ", "instruction": "Write a F# function `let canMakeSameAsTarget (target: int list) (arr: int list) =` to solve the following problem:\n\n    Checks if array `arr` can be made identical to array `target` by reversing any number of non-empty subarrays in `arr`.\n    >>> canMakeSameAsTarget([1, 2, 3, 4], [2, 4, 1, 3])\n    True\n    >>> canMakeSameAsTarget([7, 7, 7], [7, 7, 7])\n    True\n    ", "level": "easy"}
{"task_id": "F#/13", "prompt": "open System\n\nlet maxProduct (nums: int list) =\n    (*\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    *)", "canonical_solution": "    let sorted = List.sortDescending nums\n    match sorted with\n    | x1 :: x2 :: _ -> (x1 - 1) * (x2 - 1)\n    | _ -> 0", "test": "let test () =\n    if maxProduct [3; 4; 5; 2] <> 12 then\n        failwith \"Test Case 1 failed\"\n    if maxProduct [1; 5; 4; 5] <> 16 then\n        failwith \"Test Case 2 failed\"\n    if maxProduct [1; 2; 3] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxProduct [10; 2; 5; 2] <> 36 then\n        failwith \"Test Case 4 failed\"\n    if maxProduct [1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "maxProduct", "signature": "let maxProduct (nums: int list) =", "docstring": "\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    ", "instruction": "Write a F# function `let maxProduct (nums: int list) =` to solve the following problem:\n\n    Finds the maximum value of (nums[i]-1)*(nums[j]-1) by choosing two different indices i and j.\n    >>> maxProduct([3, 4, 5, 2])\n    12\n    >>> maxProduct([1, 5, 4, 5])\n    16\n    ", "level": "easy"}
{"task_id": "F#/14", "prompt": "open System\n\nlet shuffleArray (nums: int list) =\n    (*\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    *)", "canonical_solution": "    let n = List.length nums / 2\n    List.init n (fun i -> [nums.[i]; nums.[i + n]]) |> List.concat", "test": "let test () =\n    if shuffleArray [2; 5; 1; 3; 4; 7] <> [2; 3; 5; 4; 1; 7] then\n        failwith \"Test Case 1 failed\"\n    if shuffleArray [1; 2; 3; 4; 4; 3; 2; 1] <> [1; 4; 2; 3; 3; 2; 4; 1] then\n        failwith \"Test Case 2 failed\"\n    if shuffleArray [1; 3; 5; 7; 2; 4; 6; 8] <> [1; 2; 3; 4; 5; 6; 7; 8] then\n        failwith \"Test Case 3 failed\"\n    if shuffleArray [10; 20; 30; 40; 11; 21; 31; 41] <> [10; 11; 20; 21; 30; 31; 40; 41] then\n        failwith \"Test Case 4 failed\"\n    if shuffleArray [9; 7; 5; 3; 8; 6; 4; 2] <> [9; 8; 7; 6; 5; 4; 3; 2] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "shuffleArray", "signature": "let shuffleArray (nums: int list) =", "docstring": "\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    ", "instruction": "Write a F# function `let shuffleArray (nums: int list) =` to solve the following problem:\n\n    Rearranges an array `nums` of 2n elements from the format [x1,x2,...,xn,y1,y2,...,yn] to [x1,y1,x2,y2,...,xn,yn].\n    >>> shuffleArray([2, 5, 1, 3, 4, 7], 3)\n    [2, 3, 5, 4, 1, 7]\n    >>> shuffleArray([1, 2, 3, 4, 4, 3, 2, 1], 4)\n    [1, 4, 2, 3, 3, 2, 4, 1]\n    ", "level": "easy"}
{"task_id": "F#/15", "prompt": "open System\n\nlet finalPrices (prices: int list) =\n    (*\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let findDiscount i price =\n        prices.[i+1..]\n        |> List.tryFindIndex (fun p -> p <= price)\n        |> function\n        | Some index -> price - prices.[i + 1 + index]\n        | None -> price\n\n    List.mapi findDiscount prices", "test": "let test () =\n    if finalPrices [8; 4; 6; 2; 3] <> [4; 2; 4; 2; 3] then\n        failwith \"Test Case 1 failed\"\n    if finalPrices [1; 2; 3; 4; 5] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if finalPrices [10; 1; 1; 6] <> [9; 0; 1; 6] then\n        failwith \"Test Case 3 failed\"\n    if finalPrices [4; 2; 4; 2; 3] <> [2; 0; 2; 2; 3] then\n        failwith \"Test Case 4 failed\"\n    if finalPrices [7; 7; 7; 7; 7] <> [0; 0; 0; 0; 7] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "finalPrices", "signature": "let finalPrices (prices: int list) =", "docstring": "\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Write a F# function `let finalPrices (prices: int list) =` to solve the following problem:\n\n    Calculates the final price for each item in `prices`, considering a discount equal to the price of the next item with a lower or equal price.\n    >>> finalPrices([8, 4, 6, 2, 3])\n    [4, 2, 4, 2, 3]\n    >>> finalPrices([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    ", "level": "easy"}
{"task_id": "F#/16", "prompt": "open System\n\nlet runningSum (nums: int list) =\n    (*\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    *)", "canonical_solution": "    let rec calcRunningSum acc sumSoFar =\n        match acc with\n        | [] -> []\n        | h :: t -> (sumSoFar + h) :: calcRunningSum t (sumSoFar + h)\n\n    calcRunningSum nums 0", "test": "let test () =\n    if runningSum [1; 2; 3; 4] <> [1; 3; 6; 10] then\n        failwith \"Test Case 1 failed\"\n    if runningSum [1; 1; 1; 1; 1] <> [1; 2; 3; 4; 5] then\n        failwith \"Test Case 2 failed\"\n    if runningSum [3; 1; 2; 10; 1] <> [3; 4; 6; 16; 17] then\n        failwith \"Test Case 3 failed\"\n    if runningSum [0; 0; 0; 0] <> [0; 0; 0; 0] then\n        failwith \"Test Case 4 failed\"\n    if runningSum [5; -1; -2; 3] <> [5; 4; 2; 5] then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "runningSum", "signature": "let runningSum (nums: int list) =", "docstring": "\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    ", "instruction": "Write a F# function `let runningSum (nums: int list) =` to solve the following problem:\n\n    Calculates the running sum of the array `nums`.\n    >>> runningSum([1, 2, 3, 4])\n    [1, 3, 6, 10]\n    >>> runningSum([1, 1, 1, 1, 1])\n    [1, 2, 3, 4, 5]\n    ", "level": "easy"}
{"task_id": "F#/17", "prompt": "open System\n\nlet averageSalaryExcludingMinMax (salary: int list) =\n    (*\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    *)", "canonical_solution": "    let sorted = List.sort salary\n    let filtered = sorted.Tail |> List.take (List.length sorted - 2)\n    List.averageBy float filtered", "test": "let test () =\n    if averageSalaryExcludingMinMax [4000; 3000; 1000; 2000] <> 2500.0 then\n        failwith \"Test Case 1 failed\"\n    if averageSalaryExcludingMinMax [6000; 5000; 4000; 3000; 2000; 1000] <> 3500.0 then\n        failwith \"Test Case 2 failed\"\n    if averageSalaryExcludingMinMax [8000; 7000; 6000; 5000; 4000] <> 6000.0 then\n        failwith \"Test Case 3 failed\"\n    if averageSalaryExcludingMinMax [3000; 2000; 1000] <> 2000.0 then\n        failwith \"Test Case 4 failed\"\n    if averageSalaryExcludingMinMax [5000; 3000; 2000; 1000; 4000] <> 3000.0 then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "averageSalaryExcludingMinMax", "signature": "let averageSalaryExcludingMinMax (salary: int list) =", "docstring": "\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    ", "instruction": "Write a F# function `let averageSalaryExcludingMinMax (salary: int list) =` to solve the following problem:\n\n    Calculates the average salary after excluding the minimum and maximum salaries.\n    >>> averageSalaryExcludingMinMax([4000, 3000, 1000, 2000])\n    2500.0\n    >>> averageSalaryExcludingMinMax([6000, 5000, 4000, 3000, 2000, 1000])\n    3500.0\n    ", "level": "easy"}
{"task_id": "F#/18", "prompt": "open System\n\nlet rearrangeString (s: string) (indices: int list) =\n    (*\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    *)", "canonical_solution": "    let combined = List.zip indices (s.ToCharArray() |> Array.toList)\n    let sorted = List.sortBy fst combined\n    sorted |> List.map snd |> String.Concat", "test": "let test () =\n    if rearrangeString \"codeleet\" [4; 5; 6; 7; 0; 2; 1; 3] <> \"leetcode\" then\n        failwith \"Test Case 1 failed\"\n    if rearrangeString \"abc\" [0; 1; 2] <> \"abc\" then\n        failwith \"Test Case 2 failed\"\n    if rearrangeString \"aiohn\" [3; 1; 4; 2; 0] <> \"nihao\" then\n        failwith \"Test Case 3 failed\"\n    if rearrangeString \"aaiougrt\" [4; 0; 2; 6; 7; 3; 1; 5] <> \"arigatou\" then\n        failwith \"Test Case 4 failed\"\n    if rearrangeString \"art\" [1; 0; 2] <> \"rat\" then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "rearrangeString", "signature": "let rearrangeString (s: string) (indices: int list) =", "docstring": "\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    ", "instruction": "Write a F# function `let rearrangeString (s: string) (indices: int list) =` to solve the following problem:\n\n    Rearranges the string `s` based on the array `indices`.\n    Each character in `s` is moved to the position indicated by `indices[i]`.\n    >>> rearrangeString(\"codeleet\", [4, 5, 6, 7, 0, 2, 1, 3])\n    \"leetcode\"\n    >>> rearrangeString(\"abc\", [0, 1, 2])\n    \"abc\"\n    ", "level": "easy"}
{"task_id": "F#/19", "prompt": "open System\n\nlet countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =\n    (*\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    *)", "canonical_solution": "    let isGoodTriplet i j k =\n        abs (arr.[i] - arr.[j]) <= a &&\n        abs (arr.[j] - arr.[k]) <= b &&\n        abs (arr.[i] - arr.[k]) <= c\n\n    let rec countTriplets i j k count =\n        match i, j, k with\n        | _, _, _ when i >= List.length arr - 2 -> count\n        | _, _, _ when j >= List.length arr - 1 -> countTriplets (i + 1) (i + 2) (i + 3) count\n        | _, _, _ when k >= List.length arr -> countTriplets i (j + 1) (j + 2) count\n        | _, _, _ ->\n            let newCount = if isGoodTriplet i j k then count + 1 else count\n            countTriplets i j (k + 1) newCount\n\n    countTriplets 0 1 2 0", "test": "let test () =\n    if countGoodTriplets [3; 0; 1; 1; 9; 7] 7 2 3 <> 4 then\n        failwith \"Test Case 1 failed\"\n    if countGoodTriplets [1; 1; 2; 2; 3] 0 0 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if countGoodTriplets [1; 2; 3; 4; 5] 1 1 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n\ntest ()", "entry_point": "countGoodTriplets", "signature": "let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =", "docstring": "\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    ", "instruction": "Write a F# function `let countGoodTriplets (arr: int list) (a: int) (b: int) (c: int) =` to solve the following problem:\n\n    Counts the number of good triplets in the array `arr`.\n    A good triplet (arr[i], arr[j], arr[k]) satisfies certain conditions based on the absolute differences and indices.\n    >>> countGoodTriplets([3, 0, 1, 1, 9, 7], 7, 2, 3)\n    4\n    >>> countGoodTriplets([1, 1, 2, 2, 3], 0, 0, 1)\n    0\n    ", "level": "hard"}
{"task_id": "F#/20", "prompt": "open System\n\nlet hasThreeConsecutiveOdds (arr: int list) =\n    (*\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    *)", "canonical_solution": "    let rec checkConsecutive idx =\n        if idx > List.length arr - 3 then\n            false\n        elif arr.[idx] % 2 <> 0 && arr.[idx + 1] % 2 <> 0 && arr.[idx + 2] % 2 <> 0 then\n            true\n        else\n            checkConsecutive (idx + 1)\n\n    checkConsecutive 0", "test": "let test () =\n    if hasThreeConsecutiveOdds [2; 6; 4; 1] <> false then\n        failwith \"Test Case 1 failed\"\n    if hasThreeConsecutiveOdds [1; 2; 34; 3; 4; 5; 7; 23; 12] <> true then\n        failwith \"Test Case 2 failed\"\n    if hasThreeConsecutiveOdds [1; 3; 5; 7; 9] <> true then\n        failwith \"Test Case 3 failed\"\n    if hasThreeConsecutiveOdds [2; 4; 6; 8; 10] <> false then\n        failwith \"Test Case 4 failed\"\n    if hasThreeConsecutiveOdds [1; 1; 2; 3; 5] <> false then\n        failwith \"Test Case 5 failed\"\n\ntest ()", "entry_point": "hasThreeConsecutiveOdds", "signature": "let hasThreeConsecutiveOdds (arr: int list) =", "docstring": "\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    ", "instruction": "Write a F# function `let hasThreeConsecutiveOdds (arr: int list) =` to solve the following problem:\n\n    Checks if there are any three consecutive odd numbers in the array `arr`.\n    >>> hasThreeConsecutiveOdds([2, 6, 4, 1])\n    False\n    >>> hasThreeConsecutiveOdds([1, 2, 34, 3, 4, 5, 7, 23, 12])\n    True\n    ", "level": "middle"}
{"task_id": "F#/21", "prompt": "open System\n\nlet calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =\n(*\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n*)", "canonical_solution": "    let start = new TimeSpan(startHour, startMinute, 0)\n    let end_ = new TimeSpan(endHour, endMinute, 0)\n    let duration = if end_ < start then end_.Add(new TimeSpan(24, 0, 0)) - start else end_ - start\n    (duration.Hours, duration.Minutes)", "test": "let check () =\n    if calculateSwimmingTime 9 30 10 45 <> (1, 15) then\n        failwith \"Test Case 1 failed\"\n    if calculateSwimmingTime 23 15 1 30 <> (2, 15) then\n        failwith \"Test Case 2 failed\"\n    if calculateSwimmingTime 5 0 5 30 <> (0, 30) then\n        failwith \"Test Case 3 failed\"\n    if calculateSwimmingTime 11 20 13 45 <> (2, 25) then\n        failwith \"Test Case 4 failed\"\n    if calculateSwimmingTime 16 50 16 50 <> (0, 0) then\n        failwith \"Test Case 5 failed\"\n    if calculateSwimmingTime 0 0 23 59 <> (23, 59) then\n        failwith \"Test Case 6 failed\"\n    if calculateSwimmingTime 22 15 3 10 <> (4, 55) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateSwimmingTime", "signature": "let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =", "docstring": "\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n", "instruction": "Write a F# function `let calculateSwimmingTime (startHour: int) (startMinute: int) (endHour: int) (endMinute: int) =` to solve the following problem:\n\n    Calculates the total time spent swimming by a fish, given the start and end times.\n    Time is provided in a 24-hour format.\n\n    Parameters:\n    startHour (int): The hour when the fish started swimming (0-23).\n    startMinute (int): The minute when the fish started swimming (0-59).\n    endHour (int): The hour when the fish stopped swimming (0-23).\n    endMinute (int): The minute when the fish stopped swimming (0-59).\n\n    Returns:\n    Tuple of (int, int): Total hours and minutes spent swimming.\n\n    Examples:\n    >>> calculateSwimmingTime(9, 30, 10, 45)\n    (1, 15)\n\n    >>> calculateSwimmingTime(23, 15, 1, 30)\n    (2, 15)\n\n    >>> calculateSwimmingTime(5, 0, 5, 30)\n    (0, 30)\n", "level": "middle"}
{"task_id": "F#/22", "prompt": "open System\n\nlet reorderNumbers (nums: int list) (order: string) =\n(*\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n*)", "canonical_solution": "    let sortedNums = List.sort nums\n    let mapping = Map.ofList [('A', sortedNums.[0]); ('B', sortedNums.[1]); ('C', sortedNums.[2])]\n    String.Join(\" \", order |> Seq.map (fun c -> mapping.[c].ToString()))", "test": "let check () =\n    if reorderNumbers [1; 3; 5] \"ABC\" <> \"1 3 5\" then\n        failwith \"Test Case 1 failed\"\n    if reorderNumbers [6; 2; 4] \"BCA\" <> \"4 6 2\" then\n        failwith \"Test Case 2 failed\"\n    if reorderNumbers [8; 10; 9] \"CAB\" <> \"10 8 9\" then\n        failwith \"Test Case 3 failed\"\n    if reorderNumbers [15; 20; 17] \"ACB\" <> \"15 20 17\" then\n        failwith \"Test Case 4 failed\"\n    if reorderNumbers [21; 19; 23] \"BAC\" <> \"21 19 23\" then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "reorderNumbers", "signature": "let reorderNumbers (nums: int list) (order: string) =", "docstring": "\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n", "instruction": "Write a F# function `let reorderNumbers (nums: int list) (order: string) =` to solve the following problem:\n\n    Reorder a list of three numbers (A, B, and C) according to a specified order.\n    Each of the numbers A, B, and C are distinct and follow the rule A < B < C.\n    The order is given as a string of three characters 'A', 'B', and 'C' representing the desired order.\n\n    Examples:\n    >>> reorderNumbers [1, 3, 5] \"ABC\"\n    \"1 3 5\"\n    >>> reorderNumbers [6, 2, 4] \"BCA\"\n    \"4 6 2\"\n", "level": "easy"}
{"task_id": "F#/23", "prompt": "open System\n\nlet mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =\n(*\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n*)", "canonical_solution": "    let totalHours = List.map2 (+) schoolHours extraHours\n    let daysUnhappy = List.map (fun h -> if h > 8 then h - 8 else 0) totalHours\n    let maxUnhappy = List.max daysUnhappy\n\n    if maxUnhappy = 0 then 0\n    else \n        let index = List.findIndex (fun h -> h = maxUnhappy) daysUnhappy\n        index + 1", "test": "let check () =\n    if mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0] <> 0 then\n        failwith \"Test Case 2 failed\"\n    if mostUnhappyDay [1; 2; 3; 4; 5; 6; 7] [7; 6; 5; 4; 3; 2; 1] <> 0 then\n        failwith \"Test Case 3 failed\"\n    if mostUnhappyDay [2; 3; 4; 5; 6; 7; 1] [3; 2; 1; 1; 2; 2; 5] <> 6 then\n        failwith \"Test Case 4 failed\"\n    if mostUnhappyDay [3; 3; 3; 3; 3; 3; 3] [1; 1; 1; 1; 1; 1; 1] <> 0 then\n        failwith \"Test Case 5 failed\"\n    if mostUnhappyDay [0; 0; 0; 0; 0; 0; 9] [0; 0; 0; 0; 0; 0; 0] <> 7 then\n        failwith \"Test Case 6 failed\"\n    if mostUnhappyDay [5; 5; 5; 5; 5; 5; 5] [4; 4; 4; 4; 4; 4; 4] <> 1 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "mostUnhappyDay", "signature": "let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =", "docstring": "\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n", "instruction": "Write a F# function `let mostUnhappyDay (schoolHours: int list) (extraHours: int list) : int =` to solve the following problem:\n\n    Determines the day of the week on which Jinjin is most unhappy. Jinjin becomes unhappy if her total daily hours (school plus extra classes) exceed 8 hours. \n    The function takes two lists of integers representing the hours spent in school and in extra classes for each day of the week, respectively. \n    It returns the day of the week (1 for Monday, 2 for Tuesday, etc.) on which she is most unhappy. If she is not unhappy any day, it returns 0. \n    If there are multiple days with the same level of unhappiness, it returns the earliest day.\n\n    Example:\n    >>> mostUnhappyDay [5; 6; 7; 5; 5; 0; 0] [3; 2; 2; 3; 4; 4; 6]\n    3\n    >>> mostUnhappyDay [4; 4; 4; 4; 4; 0; 0] [3; 3; 3; 3; 3; 0; 0]\n    0\n", "level": "middle"}
{"task_id": "F#/24", "prompt": "open System\n\nlet findLargerPrimeFactor (n: int) =\n(*\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n*)", "canonical_solution": "    let rec findFactor i =\n        if i * i > n then\n            n\n        elif n % i = 0 then\n            max i (n / i)\n        else\n            findFactor (i + 1)\n\n    findFactor 2", "test": "let testFindLargerPrimeFactor () =\n    if findLargerPrimeFactor 15 <> 5 then\n        failwith \"Test Case 1 failed\"\n    if findLargerPrimeFactor 35 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if findLargerPrimeFactor 77 <> 11 then\n        failwith \"Test Case 3 failed\"\n    if findLargerPrimeFactor 143 <> 13 then\n        failwith \"Test Case 4 failed\"\n    if findLargerPrimeFactor 221 <> 17 then\n        failwith \"Test Case 5 failed\"\n    if findLargerPrimeFactor 323 <> 19 then\n        failwith \"Test Case 6 failed\"\n    if findLargerPrimeFactor 437 <> 23 then\n        failwith \"Test Case 7 failed\"\n\ntestFindLargerPrimeFactor ()", "entry_point": "findLargerPrimeFactor", "signature": "let findLargerPrimeFactor (n: int) =", "docstring": "\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n", "instruction": "Write a F# function `let findLargerPrimeFactor (n: int) =` to solve the following problem:\n\n    Finds the larger of the two prime factors of a given positive integer 'n',\n    where 'n' is the product of exactly two distinct prime numbers.\n    Note: The function assumes that 'n' is always a product of two distinct primes.\n\n    Example:\n    >>> findLargerPrimeFactor 15\n    5\n    >>> findLargerPrimeFactor 35\n    7\n", "level": "easy"}
{"task_id": "F#/25", "prompt": "open System\nlet longestConsecutiveSequence (numbers: int list) =\n  (*\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  *)", "canonical_solution": "        let numbersSet = Set.ofList numbers\n        numbersSet |> Seq.fold (fun maxLen n ->\n            if Set.contains (n - 1) numbersSet then\n                maxLen\n            else\n                let mutable len = 1\n                while Set.contains (n + len) numbersSet do\n                    len <- len + 1\n                max maxLen len) 0", "test": "let check () =\n    if longestConsecutiveSequence [5; 4; 3; 2; 1; 6; 10; 11] <> 6 then\n        failwith \"Test Case 1 failed\"\n    if longestConsecutiveSequence [8; 9; 1; 2; 3; 7; 6; 10] <> 5 then\n        failwith \"Test Case 2 failed\"\n    if longestConsecutiveSequence [15; 5; 1; 2; 12; 3; 10; 4] <> 5 then\n        failwith \"Test Case 3 failed\"\n    if longestConsecutiveSequence [1; 2; 3; 4; 5; 9; 10; 11; 12] <> 5 then\n        failwith \"Test Case 4 failed\"\n    if longestConsecutiveSequence [1; 3; 5; 7; 9; 2; 4; 6; 8; 10] <> 10 then\n        failwith \"Test Case 5 failed\"\n    if longestConsecutiveSequence [1] <> 1 then\n        failwith \"Test Case 6 failed\"\n    if longestConsecutiveSequence [100; 101; 102; 103; 105; 106; 107] <> 4 then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "longestConsecutiveSequence", "signature": "let longestConsecutiveSequence (numbers: int list) =", "docstring": "\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  ", "instruction": "Write a F# function `let longestConsecutiveSequence (numbers: int list) =` to solve the following problem:\n\n      This function finds the length of the longest consecutive sequence of natural numbers in a given list of integers.\n      It assumes the list may not be sorted and can contain duplicates.\n\n      Example:\n      >>> longestConsecutiveSequence([10, 1, 2, 3, 4, 6, 7])\n      4  // The longest consecutive sequence is 1, 2, 3, 4\n\n      >>> longestConsecutiveSequence([4, 2, 1, 6, 5])\n      3  // The longest consecutive sequence is 4, 5, 6\n  ", "level": "middle"}
{"task_id": "F#/26", "prompt": "open System\nlet reverseDigits (n: int) =\n(*\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n*)", "canonical_solution": "    let reversedStr =\n        string n\n        |> Seq.rev\n        |> Seq.toArray\n        |> System.String\n    let reversedInt =\n        if reversedStr.EndsWith('-') then\n            -(int (reversedStr.Substring(0, reversedStr.Length - 1)))\n        else\n            int reversedStr\n    reversedInt", "test": "let testReverseDigits () =\n    if reverseDigits 123 <> 321 then\n        failwith \"Test Case 1 failed\"\n    if reverseDigits -380 <> -83 then\n        failwith \"Test Case 2 failed\"\n    if reverseDigits 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if reverseDigits 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if reverseDigits -100 <> -1 then\n        failwith \"Test Case 5 failed\"\n    if reverseDigits 123456789 <> 987654321 then\n        failwith \"Test Case 6 failed\"\n    if reverseDigits -987654321 <> -123456789 then\n        failwith \"Test Case 7 failed\"\n\ntestReverseDigits ()", "entry_point": "reverseDigits", "signature": "let reverseDigits (n: int) =", "docstring": "\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n", "instruction": "Write a F# function `let reverseDigits (n: int) =` to solve the following problem:\n\n    Reverse the digits of an integer.\n    >>> reverseDigits(123)\n    321\n    >>> reverseDigits(-380)\n    -83\n    >>> reverseDigits(0)\n    0\n    >>> reverseDigits(100)\n    1\n", "level": "middle"}
{"task_id": "F#/27", "prompt": "open System\nlet rec calculateBessieScore (n: int) : int =\n(*\n    This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)\n*)", "canonical_solution": "    match n with\n    | 1 -> 0\n    | _ when n % 2 = 0 -> 1 + calculateBessieScore (n / 2)\n    | _ -> 1 + calculateBessieScore (3 * n + 1)", "test": "let test () =\n    if calculateBessieScore 6 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if calculateBessieScore 1 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if calculateBessieScore 7 <> 16 then\n        failwith \"Test Case 3 failed\"\n    if calculateBessieScore 15 <> 17 then\n        failwith \"Test Case 4 failed\"\n    if calculateBessieScore 22 <> 15 then\n        failwith \"Test Case 5 failed\"\n    if calculateBessieScore 2 <> 1 then\n        failwith \"Test Case 6 failed\"\n    if calculateBessieScore 10 <> 6 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "signature": "let rec calculateBessieScore (n: int) : int =", "docstring": "This function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)", "entry_point": "calculateBessieScore", "instruction": "Write a F# function `let rec calculateBessieScore (n: int) : int =` to solve the following problem:\nThis function calculates the score of a game where the score increases with each transformation of the number N.\n    The rules are:\n    - If N is odd, multiply it by 3 and add 1.\n    - If N is even, divide it by 2.\n    The game ends when N becomes 1, and the score is the number of transformations made.\n\n    Examples:\n    - calculateBessieScore 6\n      Returns: 8 (Sequence: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1)\n    - calculateBessieScore 1\n      Returns: 0 (Sequence: 1)", "level": "easy"}
{"task_id": "F#/28", "prompt": "open System\n\nlet calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =\n(*\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n*)", "canonical_solution": "    let totalQuota = monthlyQuota * (monthsUsed + 1)\n    let totalUsed = List.sum dataUsedPerMonth\n    totalQuota - totalUsed", "test": "let test () =\n    if calculateAvailableData 10 3 [4; 6; 2] <> 28 then\n        failwith \"Test Case 1 failed\"\n    if calculateAvailableData 15 2 [10; 12] <> 23 then\n        failwith \"Test Case 2 failed\"\n    if calculateAvailableData 12 4 [3; 6; 9; 4] <> 38 then\n        failwith \"Test Case 3 failed\"\n    if calculateAvailableData 10 2 [5; 5; 5] <> 15 then\n        failwith \"Test Case 4 failed\"\n    if calculateAvailableData 20 1 [15] <> 25 then\n        failwith \"Test Case 5 failed\"\n    if calculateAvailableData 8 3 [2; 4; 3] <> 23 then\n        failwith \"Test Case 6 failed\"\n    if calculateAvailableData 5 0 [] <> 5 then\n        failwith \"Test Case 7 failed\"\n\ntest ()", "entry_point": "calculateAvailableData", "signature": "let calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =", "docstring": "\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n", "instruction": "Write a F# function `let calculateAvailableData (monthlyQuota: int) (monthsUsed: int) (dataUsedPerMonth: int list) =` to solve the following problem:\n\n    Calculates the available mobile data for the next month based on a monthly data quota, the number of months used, and the data used each month.\n    \n    Arguments:\n    monthlyQuota - the monthly data quota in MB.\n    monthsUsed - the number of months the data plan has been used.\n    dataUsedPerMonth - a list of integers representing the data used each month in MB.\n\n    Returns:\n    An integer representing the available data for the next month in MB.\n\n    Example:\n    >>> calculateAvailableData 10 3 [4; 6; 2]\n    28\n    >>> calculateAvailableData 15 2 [10; 12]\n    23\n    >>> calculateAvailableData 12 4 [3; 6; 9; 4]\n    38\n", "level": "easy"}
{"task_id": "F#/29", "prompt": "open System\n\nlet canMatchFit (n: int) (w: int) (h: int) (matches: int list) =\n(*\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n*)", "canonical_solution": "    let diagonal = Math.Sqrt(float(w * w + h * h))\n    matches |> List.map (fun matchLength ->\n        if float(matchLength) <= diagonal then \"DA\" else \"NE\"\n    )", "test": "let check () =\n    let test1 = canMatchFit 3 3 4 [2; 5; 6]\n    let expected1 = [\"DA\"; \"DA\"; \"NE\"]\n    if test1 <> expected1 then\n        failwith \"Test Case 1 failed\"\n\n    let test2 = canMatchFit 2 5 5 [7; 3]\n    let expected2 = [\"DA\"; \"DA\"]\n    if test2 <> expected2 then\n        failwith \"Test Case 2 failed\"\n\n    let test3 = canMatchFit 4 10 10 [5; 12; 8; 15]\n    let expected3 = [\"DA\"; \"DA\"; \"DA\"; \"NE\"]\n    if test3 <> expected3 then\n        failwith \"Test Case 3 failed\"\n\n    let test4 = canMatchFit 3 6 8 [10; 6; 7]\n    let expected4 = [\"DA\"; \"DA\"; \"DA\"]\n    if test4 <> expected4 then\n        failwith \"Test Case 4 failed\"\n\n    printfn \"All tests passed!\"\n\ncheck ()", "entry_point": "canMatchFit", "signature": "let canMatchFit (n: int) (w: int) (h: int) (matches: int list) =", "docstring": "\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n", "instruction": "Write a F# function `let canMatchFit (n: int) (w: int) (h: int) (matches: int list) =` to solve the following problem:\n\n    Determines if each match from a list of match lengths can fit inside a w x h rectangular box.\n    A match fits if its length is less than or equal to the diagonal of the box.\n\n    Args:\n    n: The number of matches.\n    w: The width of the box.\n    h: The height of the box.\n    matches: A list of integers representing the lengths of the matches.\n\n    Returns:\n    A list of strings, each either \"DA\" (if the match fits) or \"NE\" (if the match does not fit).\n\n    Example:\n    >>> canMatchFit(3, 3, 4, [2, 5, 6])\n    [\"DA\", \"DA\", \"NE\"]\n", "level": "easy"}
{"task_id": "F#/30", "prompt": "open System\n\nlet findFourthVertex (coordinates: (int * int) list) : int * int =\n(*\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n*)", "canonical_solution": "    let (xList, yList) = List.unzip coordinates\n    let findFourthCoordinate (coordList: int list) =\n        match List.distinct coordList with\n        | [a; b] -> if List.filter ((=) a) coordList |> List.length = 1 then a else b\n        | _ -> failwith \"Invalid input\"\n\n    let fourthX = findFourthCoordinate xList\n    let fourthY = findFourthCoordinate yList\n    (fourthX, fourthY)", "test": "let check () =\n    if findFourthVertex [(5, 5); (5, 7); (7, 5)] <> (7, 7) then\n        failwith \"Test Case 1 failed\"\n    if findFourthVertex [(10, 20); (30, 10); (10, 10)] <> (30, 20) then\n        failwith \"Test Case 2 failed\"\n    if findFourthVertex [(2, 2); (2, 4); (4, 2)] <> (4, 4) then\n        failwith \"Test Case 3 failed\"\n    if findFourthVertex [(3, 3); (6, 3); (3, 6)] <> (6, 6) then\n        failwith \"Test Case 4 failed\"\n    if findFourthVertex [(8, 10); (5, 10); (5, 7)] <> (8, 7) then\n        failwith \"Test Case 5 failed\"\n    if findFourthVertex [(12, 15); (9, 12); (12, 12)] <> (9, 15) then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "findFourthVertex", "signature": "let findFourthVertex (coordinates: (int * int) list) : int * int =", "docstring": "\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n", "instruction": "Write a F# function `let findFourthVertex (coordinates: (int * int) list) : int * int =` to solve the following problem:\n\n    Given the coordinates of three vertices of a rectangle, this function computes \n    the coordinates of the fourth vertex. The rectangle is assumed to have sides \n    parallel to the coordinate axes.\n    \n    Example:\n    >>> findFourthVertex [(5, 5); (5, 7); (7, 5)]\n    (7, 7)\n    \n    >>> findFourthVertex [(10, 20);(30, 10); (10, 10)]\n    (30, 20)\n", "level": "hard"}
{"task_id": "F#/31", "prompt": "open System\n\nlet calculateDepartureTime (distance: int) (speed: int) : string =\n(*\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n*)", "canonical_solution": "    let timeToSchool = (distance + speed - 1) / speed // Ceiling of division\n    let totalMinutes = timeToSchool + 10 // Additional 10 minutes for garbage sorting\n    let departureTime = DateTime(1, 1, 1, 8, 0, 0).AddMinutes(-totalMinutes)\n    departureTime.ToString(\"HH:mm\")", "test": "let check () =\n    if calculateDepartureTime 500 50 <> \"07:40\" then\n        failwith \"Test Case 1 failed\"\n    if calculateDepartureTime 300 30 <> \"07:40\" then\n        failwith \"Test Case 2 failed\"\n    if calculateDepartureTime 600 60 <> \"07:40\" then\n        failwith \"Test Case 3 failed\"\n    if calculateDepartureTime 720 80 <> \"07:41\" then\n        failwith \"Test Case 4 failed\"\n    if calculateDepartureTime 100 10 <> \"07:40\" then\n        failwith \"Test Case 5 failed\"\n    if calculateDepartureTime 1000 100 <> \"07:40\" then\n        failwith \"Test Case 6 failed\"\n    if calculateDepartureTime 150 25 <> \"07:44\" then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "calculateDepartureTime", "signature": "let calculateDepartureTime (distance: int) (speed: int) : string =", "docstring": "\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n", "instruction": "Write a F# function `let calculateDepartureTime (distance: int) (speed: int) : string =` to solve the following problem:\n\n    Calculate the latest time yyy can leave home to reach school at 8:00 AM, \n    considering the distance to school and walking speed. yyy also spends an \n    additional 10 minutes for garbage sorting.\n\n    Args:\n    distance: The distance from home to school in meters.\n    speed: Walking speed in meters per minute.\n\n    Returns:\n    A string representing the latest departure time in 24-hour format (HH:MM).\n\n    Examples:\n    >>> calculateDepartureTime 500 50\n    \"07:40\"\n", "level": "middle"}
{"task_id": "F#/32", "prompt": "open System\nlet validateISBN (isbnInput: string) : string =\n(*\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n*)", "canonical_solution": "    let digits = isbnInput.Replace(\"-\", \"\").ToCharArray() |> Array.map (fun c -> if c = 'X' then 10 else int(c) - int('0'))\n    let sum = Array.mapi (fun i x -> x * (i + 1)) digits.[0..8] |> Array.sum\n    let calculatedCheckDigit = sum % 11\n    let checkDigitChar = \n        if calculatedCheckDigit = 10 then 'X'\n        else char(calculatedCheckDigit + int('0'))\n    \n    let actualCheckDigitChar = isbnInput.[isbnInput.Length - 1]\n    if actualCheckDigitChar = checkDigitChar then\n        \"Right\"\n    else\n        isbnInput.Substring(0, isbnInput.Length - 1) + checkDigitChar.ToString()", "test": "let checkISBNValidation () =\n    assert (validateISBN(\"0-670-82162-4\") = \"Right\")\n    assert (validateISBN(\"0-123-45678-9\") = \"Right\")\n    assert (validateISBN(\"0-670-82162-0\") = \"0-670-82162-4\")\n    assert (validateISBN(\"1-234-56789-5\") = \"1-234-56789-X\")\n    assert (validateISBN(\"9-876-54321-1\") = \"9-876-54321-0\")\n    assert (validateISBN(\"5-555-55555-5\") = \"Right\")\n\ncheckISBNValidation()", "entry_point": "validateISBN", "signature": "let validateISBN (isbnInput: string) : string =", "docstring": "\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n", "instruction": "Write a F# function `let validateISBN (isbnInput: string) : string =` to solve the following problem:\n\n    Validates the given ISBN number. An ISBN is composed of 9 digits, a check digit, and 3 separators in the format x-xxx-xxxxx-x.\n    The check digit is calculated as the sum of the first 9 digits each multiplied by its position index (1 to 9), modulo 11. \n    If the check digit is 10, it is replaced by 'X'. This function checks the provided ISBN and returns 'Right' if valid,\n    or the correct ISBN if the check digit is wrong.\n\n    Example usage:\n    >>> validateISBN(\"0-123-45678-9\")\n    \"Right\"\n    \n    >>> validateISBN(\"0-670-82162-0\")\n    \"0-670-82162-4\"\n", "level": "hard"}
{"task_id": "F#/33", "prompt": "open System\nlet calculateFinalScore (scores: int list) =\n(*\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n*)", "canonical_solution": "    let sortedScores = List.sort scores\n    let trimmedScores = sortedScores |> List.skip 1 |> List.rev |> List.skip 1 |> List.rev\n    let sum = List.sum trimmedScores\n    let count = List.length trimmedScores\n    let average = float sum / float count\n    System.Math.Round(average, 2)", "test": "let testCalculateFinalScore () =\n    if calculateFinalScore [9; 5; 6; 8; 9] <> 7.67 then\n        failwith \"Test Case 1 failed\"\n    if calculateFinalScore [10; 10; 10; 10; 10] <> 10.00 then\n        failwith \"Test Case 2 failed\"\n    if calculateFinalScore [0; 0; 0; 0; 0] <> 0.00 then\n        failwith \"Test Case 3 failed\"\n    if calculateFinalScore [5; 6; 7; 8; 9] <> 7.00 then\n        failwith \"Test Case 4 failed\"\n    if calculateFinalScore [1; 2; 3; 4; 5] <> 3.00 then\n        failwith \"Test Case 5 failed\"\n\ntestCalculateFinalScore ()", "entry_point": "calculateFinalScore", "signature": "let calculateFinalScore (scores: int list) =", "docstring": "\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n", "instruction": "Write a F# function `let calculateFinalScore (scores: int list) =` to solve the following problem:\n\n    This function calculates the final score of a contestant by removing the highest and lowest scores\n    from a list of scores, and then calculating the average of the remaining scores.\n\n    Example:\n    >>> calculateFinalScore [9; 5; 6; 8; 9]\n    7.67\n    >>> calculateFinalScore [10; 10; 10; 10; 10]\n    10.00\n    >>> calculateFinalScore [0; 0; 0; 0; 0]\n    0.00\n", "level": "middle"}
{"task_id": "F#/34", "prompt": "open System\n\nlet finalPosition (commands: string) (time: int) : (int * int) =\n    (*\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    *)", "canonical_solution": "    let move (x, y) (command: char) =\n        match command with\n        | 'E' -> (x + 1, y)\n        | 'S' -> (x, y - 1)\n        | 'W' -> (x - 1, y)\n        | 'N' -> (x, y + 1)\n        | _ -> (x, y)\n\n    let rec moveRobot (x, y) (commands: string) (time: int) =\n        if time <= 0 then (x, y)\n        else\n            let newCommands = if commands.Length > 1 then commands.[1..] + commands.[0].ToString() else commands\n            moveRobot (move (x, y) commands.[0]) newCommands (time - 1)\n\n    moveRobot (0, 0) commands time", "test": "let check () =\n    if finalPosition \"ENWS\" 5 <> (1, 0) then\n        failwith \"Test Case 1 failed\"\n    if finalPosition \"NNSS\" 3 <> (0, 1) then\n        failwith \"Test Case 2 failed\"\n    if finalPosition \"SWNE\" 4 <> (0, 0) then\n        failwith \"Test Case 3 failed\"\n    if finalPosition \"EESSWWNN\" 8 <> (0, 0) then\n        failwith \"Test Case 4 failed\"\n    if finalPosition \"W\" 10 <> (-10, 0) then\n        failwith \"Test Case 5 failed\"\n    if finalPosition \"NESW\" 2 <> (1, 1) then\n        failwith \"Test Case 6 failed\"\n    if finalPosition \"SSSEEE\" 6 <> (3, -3) then\n        failwith \"Test Case 7 failed\"\n\ncheck ()", "entry_point": "finalPosition", "signature": "let finalPosition (commands: string) (time: int) : (int * int) =", "docstring": "\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    ", "instruction": "Write a F# function `let finalPosition (commands: string) (time: int) : (int * int) =` to solve the following problem:\n\n        Calculates the final position of a robot after executing a given command string for a specified duration.\n        The command string consists of characters 'E', 'S', 'W', 'N', representing movements east, south, west, and north, respectively.\n        The robot repeats the command string from the beginning if it reaches the end before the time is up.\n\n        Examples:\n        - finalPosition \"ENWS\" 5 results in (1, 0)\n          (Moves: E -> N -> W -> S -> E)\n    ", "level": "hard"}
{"task_id": "F#/35", "prompt": "open System\n\n// Function to calculate the maximum value with group constraints\nlet maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =\n(*\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n*)", "canonical_solution": "    let groups = items |> List.map (fun (_, _, g) -> g) |> Set.ofList\n    let dp = Array.init (totalWeight + 1) (fun _ -> Array.zeroCreate (Set.count groups + 1))\n\n    for i in 1 .. totalWeight do\n        for j in groups do\n            dp.[i].[j] <- dp.[i - 1].[j]\n            for weight, value, group in items do\n                if group = j && weight <= i then\n                    dp.[i].[j] <- max dp.[i].[j] (dp.[i - weight].[j - 1] + value)\n\n    Seq.fold max 0 (dp.[totalWeight])", "test": "let test () =\n    let test1 = maxGroupedKnapsackValue 50 [(10, 10, 1); (20, 20, 1); (30, 35, 2)]\n    if test1 <> 55 then\n        failwithf \"Test Case 1 failed: Expected 55, got %d\" test1\n\n    let test2 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 1); (30, 120, 2)]\n    if test2 <> 220 then\n        failwithf \"Test Case 2 failed: Expected 220, got %d\" test2\n\n    let test3 = maxGroupedKnapsackValue 50 [(10, 60, 1); (20, 100, 2); (30, 120, 2)]\n    if test3 <> 180 then\n        failwithf \"Test Case 3 failed: Expected 180, got %d\" test3\n\n    let test4 = maxGroupedKnapsackValue 50 [(10, 40, 1); (15, 60, 1); (25, 90, 2); (35, 120, 3)]\n    if test4 <> 150 then\n        failwithf \"Test Case 4 failed: Expected 150, got %d\" test4\n\n    let test5 = maxGroupedKnapsackValue 30 [(5, 10, 1); (10, 20, 1); (15, 30, 2)]\n    if test5 <> 50 then\n        failwithf \"Test Case 5 failed: Expected 50, got %d\" test5\n\ntest ()", "entry_point": "maxGroupedKnapsackValue", "signature": "let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =", "docstring": "\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n", "instruction": "Write a F# function `let maxGroupedKnapsackValue (totalWeight: int) (items: (int * int * int) list) =` to solve the following problem:\n\n    Calculates the maximum total value of items that can be put into a knapsack of a given total weight,\n    considering that items are grouped and within each group, items are mutually exclusive.\n\n    Args:\n    totalWeight: An integer representing the total weight capacity of the knapsack.\n    items: A list of tuples, each representing an item. Each tuple contains three integers:\n           - The weight of the item.\n           - The value of the item.\n           - The group number to which the item belongs.\n\n    Returns:\n    An integer representing the maximum total value that can be achieved within the given constraints.\n\n    Example:\n    >>> maxGroupedKnapsackValue 50 [(10, 60, 1), (20, 100, 1), (30, 120, 2)]\n    220\n", "level": "hard"}
{"task_id": "F#/36", "prompt": "open System\nlet hanoiTowerSteps (n: int) =\n(*\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n*)", "canonical_solution": "    let rec solveHanoi n a b c =\n        match n with\n        | 0 -> 0\n        | _ -> solveHanoi (n - 1) a c b + 1 + solveHanoi (n - 1) b a c\n    solveHanoi n \"A\" \"B\" \"C\"", "test": "let checkHanoi () =\n    if hanoiTowerSteps 1 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if hanoiTowerSteps 3 <> 7 then\n        failwith \"Test Case 2 failed\"\n    if hanoiTowerSteps 4 <> 15 then\n        failwith \"Test Case 3 failed\"\n    if hanoiTowerSteps 5 <> 31 then\n        failwith \"Test Case 4 failed\"\n    if hanoiTowerSteps 6 <> 63 then\n        failwith \"Test Case 5 failed\"\n    if hanoiTowerSteps 10 <> 1023 then\n        failwith \"Test Case 6 failed\"\n    if hanoiTowerSteps 0 <> 0 then\n        failwith \"Test Case 7 failed\"\n\ncheckHanoi ()", "entry_point": "hanoiTowerSteps", "signature": "let hanoiTowerSteps (n: int) =", "docstring": "\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "instruction": "Write a F# function `let hanoiTowerSteps (n: int) =` to solve the following problem:\n\n    Calculates the number of steps required to solve a Hanoi Tower puzzle with 'n' disks. \n    According to the rules of the game, only one disk can be moved at a time, and a disk can only be placed on top of a larger one or on an empty rod.\n\n    Example:\n    >>> hanoiTowerSteps(1)\n    1\n    >>> hanoiTowerSteps(3)\n    7\n    >>> hanoiTowerSteps(4)\n    15\n", "level": "easy"}
{"task_id": "F#/37", "prompt": "open System\n\nlet maxContests (contests: (int * int) list) =\n(*\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n*)", "canonical_solution": "    let sortedContests = List.sortBy snd contests\n\n    let rec countMaxContests lastEnd remainingContests count =\n        match remainingContests with\n        | [] -> count\n        | (start, end_)::tail ->\n            if start >= lastEnd then\n                countMaxContests end_ tail (count + 1)\n            else\n                countMaxContests lastEnd tail count\n\n    countMaxContests Int32.MinValue sortedContests 0", "test": "let check () =\n    if maxContests [(1, 3); (2, 5); (4, 6)] <> 2 then\n        failwith \"Test Case 1 failed\"\n    if maxContests [(0, 2); (1, 3); (3, 5)] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maxContests [(5, 7); (1, 3); (2, 4)] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maxContests [(1, 4); (2, 5); (6, 8)] <> 2 then\n        failwith \"Test Case 4 failed\"\n    if maxContests [(0, 1); (1, 2); (2, 3)] <> 3 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maxContests", "signature": "let maxContests (contests: (int * int) list) =", "docstring": "\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n", "instruction": "Write a F# function `let maxContests (contests: (int * int) list) =` to solve the following problem:\n\n    This function calculates the maximum number of contests one can participate in, given each contest's start and end times.\n    The contests are represented as a list of tuples, where each tuple contains two integers representing the start and end times of a contest.\n    The function returns the maximum number of contests that can be attended without overlapping.\n\n    Example:\n    >>> maxContests [(1, 4), (2, 5), (6, 8)]\n    2\n\n    In this example, the participant can attend the contests (1, 4) and (6, 8), but not (2, 5) as it overlaps with (1, 4).\n", "level": "hard"}
{"task_id": "F#/38", "prompt": "open System\nopen System.Collections.Generic\n\nlet countWordClasses (words: string list) =\n(*\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n*)", "canonical_solution": "    let getLetterFrequency word =\n        word \n        |> Seq.groupBy id\n        |> Seq.map (fun (ch, seq) -> ch, Seq.length seq)\n        |> Map.ofSeq\n\n    words\n    |> List.map getLetterFrequency\n    |> Set.ofList\n    |> Set.count", "test": "let testCountWordClasses () =\n    if countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"] <> 3 then\n        failwith \"Test Case 1 failed\"\n    if countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"] <> 2 then\n        failwith \"Test Case 2 failed\"\n    if countWordClasses [\"APPLE\"; \"PPALE\"; \"BYTE\"; \"BETY\"] <> 2 then\n        failwith \"Test Case 3 failed\"\n    if countWordClasses [] <> 0 then\n        failwith \"Test Case 4 failed\"\n    if countWordClasses [\"SINGLE\"] <> 1 then\n        failwith \"Test Case 5 failed\"\n\ntestCountWordClasses ()", "entry_point": "countWordClasses", "signature": "let countWordClasses (words: string list) =", "docstring": "\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n", "instruction": "Write a F# function `let countWordClasses (words: string list) =` to solve the following problem:\n\n    Counts the number of unique classes of words in a list where two words belong \n    to the same class if they consist of the same letters in any order.\n\n    Parameters:\n    words: A list of words consisting of uppercase letters.\n\n    Returns: \n    The number of unique word classes.\n\n    Example:\n    >>> countWordClasses [\"ABAC\"; \"BAAC\"; \"XYZ\"; \"ZYX\"; \"ABC\"]\n    3\n    >>> countWordClasses [\"AAAA\"; \"AAAB\"; \"BAAA\"]\n    2\n", "level": "easy"}
{"task_id": "F#/39", "prompt": "open System\n\nlet maximumMinimumDistance (stalls: int list) (cows: int) : int =\n(*\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n*)", "canonical_solution": "    let sortedStalls = List.sort stalls\n\n    let canPlaceCows distance =\n        let rec helper placedCows lastStall remainingStalls =\n            match remainingStalls with\n            | [] -> placedCows >= cows\n            | stall::tail ->\n                if stall - lastStall >= distance then\n                    helper (placedCows + 1) stall tail\n                else\n                    helper placedCows lastStall tail\n\n        helper 1 (List.head sortedStalls) (List.tail sortedStalls)\n\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = low + (high - low) / 2\n            if canPlaceCows mid then\n                binarySearch (mid + 1) high\n            else\n                binarySearch low (mid - 1)\n\n    binarySearch 0 (List.max sortedStalls)", "test": "let check () =\n    if maximumMinimumDistance [1; 2; 4; 8; 9] 3 <> 3 then\n        failwith \"Test Case 1 failed\"\n    if maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4 <> 2 then\n        failwith \"Test Case 2 failed\"\n    if maximumMinimumDistance [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 5 <> 2 then\n        failwith \"Test Case 3 failed\"\n    if maximumMinimumDistance [10; 20; 30; 40; 50] 2 <> 40 then\n        failwith \"Test Case 4 failed\"\n    if maximumMinimumDistance [5; 15; 25; 35; 45; 55; 65; 75; 85; 95] 3 <> 40 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "maximumMinimumDistance", "signature": "let maximumMinimumDistance (stalls: int list) (cows: int) : int =", "docstring": "\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n", "instruction": "Write a F# function `let maximumMinimumDistance (stalls: int list) (cows: int) : int =` to solve the following problem:\n\n    Determines the largest minimum distance between any two cows in a given set of stalls.\n\n    Parameters:\n    stalls - A list of integers representing the coordinates of the stalls.\n    cows - An integer representing the number of cows to be placed in the stalls.\n\n    The function finds the largest minimum distance that can be maintained between any two cows,\n    given the constraints of the stall positions.\n\n    Example:\n    >>> maximumMinimumDistance [1; 2; 4; 8; 9] 3\n    3\n    >>> maximumMinimumDistance [1; 3; 5; 7; 9; 11] 4\n    2\n", "level": "hard"}
{"task_id": "F#/40", "prompt": "let maxPens (a: int) (b: int): int =\n(*\n    This function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \n    Each pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\n    It is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\n    Example:\n    >>> maxPens 20 5\n    10\n\n    >>> maxPens 0 9\n    0\n\n    Note: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n*)", "canonical_solution": "    let totalJiao = a * 10 + b\n    let pricePerPenJiao = 19\n    totalJiao / pricePerPenJiao", "test": "let check () =\n    if maxPens 20 5 <> 10 then\n        failwith \"Test Case 1 failed\"\n    if maxPens 0 9 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if maxPens 3 1 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if maxPens 57 0 <> 30 then\n        failwith \"Test Case 4 failed\"\n\ncheck ()", "entry_point": "maxPens", "signature": "let maxPens (a: int) (b: int): int =", "docstring": "\nThis function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \nEach pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\nIt is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\nExample:\n>>> maxPens 20 5\n10\n\n>>> maxPens 0 9\n0\n\nNote: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n", "instruction": "Write a F# function `let maxPens (a: int) (b: int): int =` to solve the following problem:\nThis function calculates the maximum number of pens Xiao Yu can buy with a given amount of money. \nEach pen costs 1 Yuan and 9 Jiao (1.9 Yuan), and Xiao Yu has a Yuan and b Jiao. \n\nIt is assumed that the inputs a and b will satisfy the conditions 0 <= a <= 10^4 and 0 <= b <= 9.\n\nExample:\n>>> maxPens 20 5\n10\n\n>>> maxPens 0 9\n0\n\nNote: The function converts the total money into Jiao to simplify calculations and ensure that division by the pen's cost is handled correctly.\n", "level": "easy"}
{"task_id": "F#/41", "prompt": "let calculateExpression (a: int) (b: int) (c: int): int =\n(*\n    This function calculates the value of the expression (a + b) * c given three integers a, b, and c.\n    It is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\n    Example:\n    >>> calculateExpression 1 2 3\n    9\n\n    >>> calculateExpression -1 2 -3\n    -3\n\n    Note: The function performs simple arithmetic operations and handles negative numbers correctly.\n*)", "canonical_solution": "    (a + b) * c", "test": "\nlet check () =\n    if calculateExpression 1 2 3 <> 9 then\n        failwith \"Test Case 1 failed\"\n    if calculateExpression -1 2 -3 <> -3 then\n        failwith \"Test Case 2 failed\"\n    if calculateExpression 0 0 1 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if calculateExpression 100 -50 2 <> 100 then\n        failwith \"Test Case 4 failed\"\n    if calculateExpression -100 50 -2 <> 100 then\n        failwith \"Test Case 5 failed\"\n\ncheck ()", "entry_point": "calculateExpression", "signature": "let calculateExpression (a: int) (b: int) (c: int): int =", "docstring": "\nThis function calculates the value of the expression (a + b) * c given three integers a, b, and c.\nIt is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\nExample:\n>>> calculateExpression 1 2 3\n9\n\n>>> calculateExpression -1 2 -3\n-3\n\nNote: The function performs simple arithmetic operations and handles negative numbers correctly.\n", "instruction": "Write a F# function `let calculateExpression (a: int) (b: int) (c: int): int =` to solve the following problem:\nThis function calculates the value of the expression (a + b) * c given three integers a, b, and c.\nIt is assumed that all inputs and the result will be within the range of -10,000 to 10,000.\n\nExample:\n>>> calculateExpression 1 2 3\n9\n\n>>> calculateExpression -1 2 -3\n-3\n\nNote: The function performs simple arithmetic operations and handles negative numbers correctly.\n", "level": "easy"}
{"task_id": "F#/42", "prompt": "let getAsciiCode (character: char): int =\n(*\n    This function receives a character (excluding spaces) and returns its ASCII code as an integer.\n    The character must be a visible character according to the ASCII standard, excluding control characters and space.\n\n    Example:\n    >>> getAsciiCode 'B'\n    66\n\n    >>> getAsciiCode '#'\n    35\n\n    Note: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n*)", "canonical_solution": "    int character", "test": "let check () =\n    if getAsciiCode 'B' <> 66 then\n        failwith \"Test Case 1 failed\"\n    if getAsciiCode '#' <> 35 then\n        failwith \"Test Case 2 failed\"\n    if getAsciiCode '0' <> 48 then\n        failwith \"Test Case 3 failed\"\n    if getAsciiCode '9' <> 57 then\n        failwith \"Test Case 4 failed\"\n    if getAsciiCode 'a' <> 97 then\n        failwith \"Test Case 5 failed\"\n    if getAsciiCode 'z' <> 122 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "getAsciiCode", "signature": "let getAsciiCode (character: char): int =", "docstring": "\nThis function receives a character (excluding spaces) and returns its ASCII code as an integer.\nThe character must be a visible character according to the ASCII standard, excluding control characters and space.\n\nExample:\n>>> getAsciiCode 'B'\n66\n\n>>> getAsciiCode '#'\n35\n\nNote: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n", "instruction": "Write a F# function `let getAsciiCode (character: char): int =` to solve the following problem:\nThis function receives a character (excluding spaces) and returns its ASCII code as an integer.\nThe character must be a visible character according to the ASCII standard, excluding control characters and space.\n\nExample:\n>>> getAsciiCode 'B'\n66\n\n>>> getAsciiCode '#'\n35\n\nNote: The function is designed to work with any printable ASCII character, providing a straightforward way to retrieve the ASCII value.\n", "level": "easy"}
{"task_id": "F#/43", "prompt": "let asciiToChar (asciiCode: int): char =\n(*\n    This function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\n    Example:\n    >>> asciiToChar 66\n    'B'\n\n    >>> asciiToChar 35\n    '#'\n\n    Note: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n*)", "canonical_solution": "    char asciiCode", "test": "let check () =\n    if asciiToChar 66 <> 'B' then\n        failwith \"Test Case 1 failed\"\n    if asciiToChar 35 <> '#' then\n        failwith \"Test Case 2 failed\"\n    if asciiToChar 48 <> '0' then\n        failwith \"Test Case 3 failed\"\n    if asciiToChar 57 <> '9' then\n        failwith \"Test Case 4 failed\"\n    if asciiToChar 97 <> 'a' then\n        failwith \"Test Case 5 failed\"\n    if asciiToChar 122 <> 'z' then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "asciiToChar", "signature": "let asciiToChar (asciiCode: int): char =", "docstring": "\nThis function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\nExample:\n>>> asciiToChar 66\n'B'\n\n>>> asciiToChar 35\n'#'\n\nNote: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n", "instruction": "Write a F# function `let asciiToChar (asciiCode: int): char =` to solve the following problem:\nThis function converts an ASCII code into its corresponding character. The ASCII code must be a positive integer less than 128, ensuring it represents a printable character.\n\nExample:\n>>> asciiToChar 66\n'B'\n\n>>> asciiToChar 35\n'#'\n\nNote: This function is designed to work with ASCII codes for printable characters only, providing a direct way to retrieve the character representation of an ASCII code.\n", "level": "easy"}
{"task_id": "F#/44", "prompt": "let intBoolIntConversion (intValue: int): int =\n(*\n    This function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\n    Example:\n    >>> intBoolIntConversion 5\n    1\n\n    >>> intBoolIntConversion 0\n    0\n\n    Note: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n*)", "canonical_solution": "    if intValue = 0 then 0 else 1", "test": "let check () =\n    if intBoolIntConversion 5 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if intBoolIntConversion 0 <> 0 then\n        failwith \"Test Case 2 failed\"\n    if intBoolIntConversion -1 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if intBoolIntConversion 100 <> 1 then\n        failwith \"Test Case 4 failed\"\n    if intBoolIntConversion 127 <> 1 then\n        failwith \"Test Case 5 failed\"\n    if intBoolIntConversion -127 <> 1 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "intBoolIntConversion", "signature": "let intBoolIntConversion (intValue: int): int =", "docstring": "\nThis function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\nExample:\n>>> intBoolIntConversion 5\n1\n\n>>> intBoolIntConversion 0\n0\n\nNote: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n", "instruction": "Write a F# function `let intBoolIntConversion (intValue: int): int =` to solve the following problem:\nThis function takes an integer value, converts it to a boolean value, and then converts it back to an integer. In F#, any non-zero integer converted to boolean will be true, and converting true back to an integer will result in 1. Conversely, 0 converts to false, and false converts back to 0.\n\nExample:\n>>> intBoolIntConversion 5\n1\n\n>>> intBoolIntConversion 0\n0\n\nNote: The function is designed to illustrate type conversion peculiarities in F# and similar programming languages where true is typically represented by 1, and false by 0.\n", "level": "easy"}
{"task_id": "F#/45", "prompt": "let reverseThreeDigitNumber (n: int): int =\n(*\n    This function reverses a three-digit number. For example, if the input is 358, the output will be 853. \n    The function is designed to work with numbers ranging from 100 to 999, inclusive. \n    It handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\n    Example:\n    >>> reverseThreeDigitNumber 100\n    1\n\n    >>> reverseThreeDigitNumber 250\n    52\n\n    Note: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n*)", "canonical_solution": "    let reversedString = n.ToString() |> Array.ofSeq |> Array.rev |> Array.map string |> String.concat \"\"\n    int reversedString", "test": "let check () =\n    if reverseThreeDigitNumber 100 <> 1 then\n        failwith \"Test Case 1 failed\"\n    if reverseThreeDigitNumber 250 <> 52 then\n        failwith \"Test Case 2 failed\"\n    if reverseThreeDigitNumber 678 <> 876 then\n        failwith \"Test Case 3 failed\"\n    if reverseThreeDigitNumber 321 <> 123 then\n        failwith \"Test Case 4 failed\"\n    if reverseThreeDigitNumber 909 <> 909 then\n        failwith \"Test Case 5 failed\"\n    if reverseThreeDigitNumber 111 <> 111 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "reverseThreeDigitNumber", "signature": "let reverseThreeDigitNumber (n: int): int =", "docstring": "\nThis function reverses a three-digit number. For example, if the input is 358, the output will be 853. \nThe function is designed to work with numbers ranging from 100 to 999, inclusive. \nIt handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\nExample:\n>>> reverseThreeDigitNumber 100\n1\n\n>>> reverseThreeDigitNumber 250\n52\n\nNote: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n", "instruction": "Write a F# function `let reverseThreeDigitNumber (n: int): int =` to solve the following problem:\nThis function reverses a three-digit number. For example, if the input is 358, the output will be 853. \nThe function is designed to work with numbers ranging from 100 to 999, inclusive. \nIt handles leading zeros in the reversed number by ensuring the output is still treated as an integer.\n\nExample:\n>>> reverseThreeDigitNumber 100\n1\n\n>>> reverseThreeDigitNumber 250\n52\n\nNote: The reversal process treats the number as a sequence of digits, reversing their order without considering numerical value implications of leading zeros in the output.\n", "level": "easy"}
{"task_id": "F#/46", "prompt": "let nthTerm (a1: int) (a2: int) (n: int): int =\n(*\n    Calculates the nth term of an arithmetic sequence given its first two terms and the term's position.\n    An arithmetic sequence is characterized by a constant difference between consecutive terms.\n\n    Example:\n    >>> nthTerm 2 5 3\n    8\n\n    >>> nthTerm 10 13 5\n    22\n\n    Note: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\n    and n is the position of the term in the sequence to be found.\n*)", "canonical_solution": "    let difference = a2 - a1\n    a1 + (n - 1) * difference", "test": "let check () =\n    if nthTerm 2 5 3 <> 8 then\n        failwith \"Test Case 1 failed\"\n    if nthTerm 10 13 5 <> 22 then\n        failwith \"Test Case 2 failed\"\n    if nthTerm 3 6 10 <> 30 then\n        failwith \"Test Case 3 failed\"\n    if nthTerm -5 -2 4 <> 4 then\n        failwith \"Test Case 4 failed\"\n    if nthTerm 7 10 20 <> 64 then\n        failwith \"Test Case 5 failed\"\n    if nthTerm 0 4 50 <> 196 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "nthTerm", "signature": "let nthTerm (a1: int) (a2: int) (n: int): int =", "docstring": "\nCalculates the nth term of an arithmetic sequence given its first two terms and the term's position.\nAn arithmetic sequence is characterized by a constant difference between consecutive terms.\n\nExample:\n>>> nthTerm 2 5 3\n8\n\n>>> nthTerm 10 13 5\n22\n\nNote: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\nand n is the position of the term in the sequence to be found.\n", "instruction": "Write a F# function `let nthTerm (a1: int) (a2: int) (n: int): int =` to solve the following problem:\nCalculates the nth term of an arithmetic sequence given its first two terms and the term's position.\nAn arithmetic sequence is characterized by a constant difference between consecutive terms.\n\nExample:\n>>> nthTerm 2 5 3\n8\n\n>>> nthTerm 10 13 5\n22\n\nNote: The input follows the format a1 a2 n, where a1 and a2 are the first two terms of the sequence,\nand n is the position of the term in the sequence to be found.\n", "level": "easy"}
{"task_id": "F#/47", "prompt": "let multiply (a: int) (b: int): int =\n(*\n    Calculates the product of two positive integers, A and B. This function is designed \n    to handle inputs within the range of 1 to 50,000. Careful consideration is given \n    to the data type to accommodate the maximum possible product without overflow.\n\n    Example:\n    >>> multiply 2 3\n    6\n\n    >>> multiply 100 200\n    20000\n\n    Note: The function takes two arguments, a and b, which represent the integers A and B, \n    respectively, and returns their product.\n*)", "canonical_solution": "    a * b", "test": "let check () =\n    if multiply 2 3 <> 6 then\n        failwith \"Test Case 1 failed\"\n    if multiply 100 200 <> 20000 then\n        failwith \"Test Case 2 failed\"\n    if multiply 1 50000 <> 50000 then\n        failwith \"Test Case 3 failed\"\n    if multiply 250 200 <> 50000 then\n        failwith \"Test Case 4 failed\"\n    if multiply 123 456 <> 56088 then\n        failwith \"Test Case 5 failed\"\n    if multiply 500 100 <> 50000 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "multiply", "signature": "let multiply (a: int) (b: int): int =", "docstring": "\nCalculates the product of two positive integers, A and B. This function is designed \nto handle inputs within the range of 1 to 50,000. Careful consideration is given \nto the data type to accommodate the maximum possible product without overflow.\n\nExample:\n>>> multiply 2 3\n6\n\n>>> multiply 100 200\n20000\n\nNote: The function takes two arguments, a and b, which represent the integers A and B, \nrespectively, and returns their product.\n", "instruction": "Write a F# function `let multiply (a: int) (b: int): int =` to solve the following problem:\nCalculates the product of two positive integers, A and B. This function is designed \nto handle inputs within the range of 1 to 50,000. Careful consideration is given \nto the data type to accommodate the maximum possible product without overflow.\n\nExample:\n>>> multiply 2 3\n6\n\n>>> multiply 100 200\n20000\n\nNote: The function takes two arguments, a and b, which represent the integers A and B, \nrespectively, and returns their product.\n", "level": "easy"}
{"task_id": "F#/48", "prompt": "let powerOfTwo (n: int): int =\n(*\n    Calculates 2 raised to the power of a given non-negative integer n. This function is designed \n    to work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \n    represented as an integer without overflow.\n\n    Example:\n    >>> powerOfTwo 4\n    16\n\n    >>> powerOfTwo 5\n    32\n\n    Note: The function takes a single argument, n, which represents the exponent, and returns \n    the result of 2^n.\n*)", "canonical_solution": "    1 <<< n", "test": "let check () =\n    if powerOfTwo 4 <> 16 then\n        failwith \"Test Case 1 failed\"\n    if powerOfTwo 5 <> 32 then\n        failwith \"Test Case 2 failed\"\n    if powerOfTwo 0 <> 1 then\n        failwith \"Test Case 3 failed\"\n    if powerOfTwo 10 <> 1024 then\n        failwith \"Test Case 4 failed\"\n    if powerOfTwo 15 <> 32768 then\n        failwith \"Test Case 5 failed\"\n    if powerOfTwo 20 <> 1048576 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "powerOfTwo", "signature": "let powerOfTwo (n: int): int =", "docstring": "\nCalculates 2 raised to the power of a given non-negative integer n. This function is designed \nto work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \nrepresented as an integer without overflow.\n\nExample:\n>>> powerOfTwo 4\n16\n\n>>> powerOfTwo 5\n32\n\nNote: The function takes a single argument, n, which represents the exponent, and returns \nthe result of 2^n.\n", "instruction": "Write a F# function `let powerOfTwo (n: int): int =` to solve the following problem:\nCalculates 2 raised to the power of a given non-negative integer n. This function is designed \nto work with values of n in the range of 0 to 30, inclusive, to ensure the result can be \nrepresented as an integer without overflow.\n\nExample:\n>>> powerOfTwo 4\n16\n\n>>> powerOfTwo 5\n32\n\nNote: The function takes a single argument, n, which represents the exponent, and returns \nthe result of 2^n.\n", "level": "easy"}
{"task_id": "F#/49", "prompt": "let determineSign (n: int): string =\n(*\n    Determines the sign of a given integer N. The function returns \"positive\" if N is greater \n    than zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \n    provides a straightforward way to categorize an integer according to its sign.\n\n    Example:\n    >>> determineSign 10\n    \"positive\"\n\n    >>> determineSign 0\n    \"zero\"\n\n    >>> determineSign -5\n    \"negative\"\n\n    Note: The function takes a single argument, n, which represents the integer whose sign \n    is to be determined, and returns a string indicating the sign of the integer.\n*)", "canonical_solution": "    match n with\n    | _ when n > 0 -> \"positive\"\n    | 0 -> \"zero\"\n    | _ -> \"negative\"", "test": "let check () =\n    if determineSign 10 <> \"positive\" then\n        failwith \"Test Case 1 failed\"\n    if determineSign 0 <> \"zero\" then\n        failwith \"Test Case 2 failed\"\n    if determineSign -5 <> \"negative\" then\n        failwith \"Test Case 3 failed\"\n    if determineSign 100 <> \"positive\" then\n        failwith \"Test Case 4 failed\"\n    if determineSign -100 <> \"negative\" then\n        failwith \"Test Case 5 failed\"\n    if determineSign 1 <> \"positive\" then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "determineSign", "signature": "let determineSign (n: int): string =", "docstring": "\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n", "instruction": "Write a F# function `let determineSign (n: int): string =` to solve the following problem:\nDetermines the sign of a given integer N. The function returns \"positive\" if N is greater \nthan zero, \"zero\" if N is equal to zero, and \"negative\" if N is less than zero. This \nprovides a straightforward way to categorize an integer according to its sign.\n\nExample:\n>>> determineSign 10\n\"positive\"\n\n>>> determineSign 0\n\"zero\"\n\n>>> determineSign -5\n\"negative\"\n\nNote: The function takes a single argument, n, which represents the integer whose sign \nis to be determined, and returns a string indicating the sign of the integer.\n", "level": "easy"}
{"task_id": "F#/50", "prompt": "let absoluteValue (n: int): int =\n(*\n    Computes the absolute value of an integer n. This function returns the non-negative value of n, \n    effectively removing any negative sign from n. It is designed to handle integers whose absolute \n    values do not exceed 10,000.\n\n    Example:\n    >>> absoluteValue -10\n    10\n\n    >>> absoluteValue 5\n    5\n\n    Note: The function takes a single argument, n, which represents the integer whose absolute value \n    is to be computed, and returns the absolute value of n.\n*)", "canonical_solution": "    if n < 0 then -n else n", "test": "let check () =\n    if absoluteValue -10 <> 10 then\n        failwith \"Test Case 1 failed\"\n    if absoluteValue 5 <> 5 then\n        failwith \"Test Case 2 failed\"\n    if absoluteValue 0 <> 0 then\n        failwith \"Test Case 3 failed\"\n    if absoluteValue -10000 <> 10000 then\n        failwith \"Test Case 4 failed\"\n    if absoluteValue 9999 <> 9999 then\n        failwith \"Test Case 5 failed\"\n    if absoluteValue -1 <> 1 then\n        failwith \"Test Case 6 failed\"\n\ncheck ()", "entry_point": "absoluteValue", "signature": "let absoluteValue (n: int): int =", "docstring": "\nComputes the absolute value of an integer n. This function returns the non-negative value of n, \neffectively removing any negative sign from n. It is designed to handle integers whose absolute \nvalues do not exceed 10,000.\n\nExample:\n>>> absoluteValue -10\n10\n\n>>> absoluteValue 5\n5\n\nNote: The function takes a single argument, n, which represents the integer whose absolute value \nis to be computed, and returns the absolute value of n.\n", "instruction": "Write a F# function `let absoluteValue (n: int): int =` to solve the following problem:\nComputes the absolute value of an integer n. This function returns the non-negative value of n, \neffectively removing any negative sign from n. It is designed to handle integers whose absolute \nvalues do not exceed 10,000.\n\nExample:\n>>> absoluteValue -10\n10\n\n>>> absoluteValue 5\n5\n\nNote: The function takes a single argument, n, which represents the integer whose absolute value \nis to be computed, and returns the absolute value of n.\n", "level": "easy"}
