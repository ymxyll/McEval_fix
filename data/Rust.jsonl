{"task_id": "Rust/1", "prompt": "\n /*\n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n ", "canonical_solution": "\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n ", "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_has_close_elements() {\n  assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n  }\n \n }\n ", "entry_point": "has_close_elements", "signature": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.", "instruction": "Write a Rust function `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\n  given threshold.", "level": "easy"}
{"task_id": "Rust/2", "prompt": "\n /*\n  Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n ", "canonical_solution": "\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n ", "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_separate_paren_groups() {\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()()) ((())) () ((())()())\")),\n  vec![\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"() (()) ((())) (((())))\")),\n  vec![\"()\", \"(())\", \"((()))\", \"(((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()(())((())))\")),\n  vec![\"(()(())((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"( ) (( )) (( )( ))\")),\n  vec![\"()\", \"(())\", \"(()())\"]\n  );\n  }\n \n }\n ", "entry_point": "separate_paren_groups", "signature": "fn separate_paren_groups(paren_string: String) -> Vec<String>{", "docstring": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.", "instruction": "Write a Rust function `fn separate_paren_groups(paren_string: String) -> Vec<String>{` to solve the following problem:\nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.", "level": "middle"}
{"task_id": "Rust/3", "prompt": "\n /*\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n ", "canonical_solution": "\n  return number % 1.0;\n }\n ", "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_truncate_number() {\n  assert_eq!(truncate_number(&3.5), 0.5);\n  let t1: f32 = 1.33 - 0.33;\n  assert!(truncate_number(&t1) < 0.000001);\n  let t2: f32 = 123.456 - 0.456;\n  assert!(truncate_number(&t2) < 0.000001);\n  }\n \n }\n ", "entry_point": "truncate_number", "signature": "fn truncate_number(number: &f32) -> f32{", "docstring": "Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.", "instruction": "Write a Rust function `fn truncate_number(number: &f32) -> f32{` to solve the following problem:\nGiven a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.", "level": "easy"}
{"task_id": "Rust/4", "prompt": " /*\n  You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n ", "canonical_solution": "\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n ", "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_below_zero() {\n  assert_eq!(below_zero(vec![]), false);\n  assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);\n  assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n  assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n  }\n \n }\n ", "entry_point": "below_zero", "signature": "fn below_zero(operations:Vec<i32>) -> bool{", "docstring": "You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.", "instruction": "Write a Rust function `fn below_zero(operations:Vec<i32>) -> bool{` to solve the following problem:\nYou're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.", "level": "easy"}
{"task_id": "Rust/5", "prompt": "\n /*\n  For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n ", "canonical_solution": "\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n ", "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_mean_absolute_deviation() {\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);\n  }\n \n }\n ", "entry_point": "mean_absolute_deviation", "signature": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{", "docstring": "For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |", "instruction": "Write a Rust function `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` to solve the following problem:\nFor a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |", "level": "easy"}
{"task_id": "Rust/6", "prompt": "/*\n  Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ", "canonical_solution": "{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_contained_sequence(\"ABCDEABCD\", \"AABZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"XYZ\", \"XYZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"ABCDEF\", \"FED\"), 1);\n        assert_eq!(longest_contained_sequence(\"ABCD\", \"BCD\"), 3);\n    }\n    \n\n}", "entry_point": "longest_contained_sequence", "signature": "fn longest_contained_sequence(source: &str, target: &str) -> usize", "docstring": "Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0", "instruction": "Write a Rust function `fn longest_contained_sequence(source: &str, target: &str) -> usize` to solve the following problem:\nDetermines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0", "level": "easy"}
{"task_id": "Rust/7", "prompt": "/*\n  Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)", "canonical_solution": "{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]), (99, 10, 71.29));\n        assert_eq!(exam_statistics(vec![100, 85, 76, 90]), (100, 76, 87.75));\n        assert_eq!(exam_statistics(vec![50, 50, 50, 50]), (50, 50, 50.00));\n    }\n}", "entry_point": "exam_statistics", "signature": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)", "docstring": "Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)", "instruction": "Write a Rust function `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` to solve the following problem:\nCalculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)", "level": "easy"}
{"task_id": "Rust/8", "prompt": "/*\n  Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ", "canonical_solution": "{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(sum_of_unique_chars_scores(\"abc\"), 10); // a=1, b=1, c=1, ab=2, bc=2, abc=3\n        assert_eq!(sum_of_unique_chars_scores(\"aab\"), 6);  // a=1, a=1, b=1, aa=0, ab=2, aab=1\n        assert_eq!(sum_of_unique_chars_scores(\"ababc\"), 21);\n    }\n\n\n}", "entry_point": "sum_of_unique_chars_scores", "signature": "fn sum_of_unique_chars_scores(s: &str) -> i32", "docstring": "Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)", "instruction": "Write a Rust function `fn sum_of_unique_chars_scores(s: &str) -> i32` to solve the following problem:\nCalculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)", "level": "hard"}
{"task_id": "Rust/9", "prompt": "/*\n  Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>", "canonical_solution": "{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}", "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(generate_dividing_sequence(20), vec![20, 10, 5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(5), vec![5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(1), vec![1]);\n        assert_eq!(generate_dividing_sequence(15), vec![15, 7, 3, 1]);        \n    }\n    \n\n}\n ", "entry_point": "generate_dividing_sequence", "signature": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>", "docstring": "Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]", "instruction": "Write a Rust function `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` to solve the following problem:\nGenerates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]", "level": "easy"}
{"task_id": "Rust/10", "prompt": "/*\n  Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ", "canonical_solution": "{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(expand_compressed_string(\"a3b2c\"), \"aaabbc\");\n        assert_eq!(expand_compressed_string(\"H3el5o2\"), \"HHHellllloo\");\n        assert_eq!(expand_compressed_string(\"x9y1z2\"), \"xxxxxxxxxyzz\");\n        assert_eq!(expand_compressed_string(\"r4s\"), \"rrrrs\");\n        \n    }\n    \n\n}\n ", "entry_point": "expand_compressed_string", "signature": "fn expand_compressed_string(compressed: &str) -> String", "docstring": "Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"", "instruction": "Write a Rust function `fn expand_compressed_string(compressed: &str) -> String` to solve the following problem:\nExpands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"", "level": "middle"}
{"task_id": "Rust/11", "prompt": "/*\n  Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ", "canonical_solution": "{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(count_walking_paths(3, 4), 2);\n        assert_eq!(count_walking_paths(2, 2), 0);\n        assert_eq!(count_walking_paths(4, 5), 3);\n        assert_eq!(count_walking_paths(1, 1), 1);        \n    }\n    \n\n}", "entry_point": "count_walking_paths", "signature": "fn count_walking_paths(rows: i32, cols: i32) -> i32", "docstring": "Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3", "instruction": "Write a Rust function `fn count_walking_paths(rows: i32, cols: i32) -> i32` to solve the following problem:\nCalculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3", "level": "middle"}
{"task_id": "Rust/12", "prompt": "/*\n  Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)", "canonical_solution": "{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_character_types(\"Rust3IsFun!\"), (3, 6, 1));\n        assert_eq!(count_character_types(\"1234\"), (0, 0, 4));\n        assert_eq!(count_character_types(\"HelloWorld!\"), (2, 8, 0));\n        assert_eq!(count_character_types(\"NoDigitsHere\"), (3, 9, 0));        \n    }\n    \n\n}", "entry_point": "count_character_types", "signature": "fn count_character_types(input: &str) -> (usize, usize, usize)", "docstring": "Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)", "instruction": "Write a Rust function `fn count_character_types(input: &str) -> (usize, usize, usize)` to solve the following problem:\nCounts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)", "level": "easy"}
{"task_id": "Rust/13", "prompt": "\n/*\n  Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ", "canonical_solution": "{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}", "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_lexicographic_string(\"123242526\"), \"LCXYZ\");\n        assert_eq!(max_lexicographic_string(\"231819\"), \"WRS\");\n        assert_eq!(max_lexicographic_string(\"102\"), \"JB\");\n        assert_eq!(max_lexicographic_string(\"26\"), \"Z\");   \n    }\n    \n\n}", "entry_point": "max_lexicographic_string", "signature": "fn max_lexicographic_string(encoded_sequence: &str) -> String", "docstring": "Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"", "instruction": "Write a Rust function `fn max_lexicographic_string(encoded_sequence: &str) -> String` to solve the following problem:\nConverts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"", "level": "hard"}
{"task_id": "Rust/14", "prompt": "/*\n    Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ", "canonical_solution": "{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]), 27);\n        assert_eq!(max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]), 8);      \n    }\n    \n\n}", "entry_point": "max_triangle_path_sum", "signature": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32", "docstring": "Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11", "instruction": "Write a Rust function `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` to solve the following problem:\nCalculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11", "level": "hard"}
{"task_id": "Rust/15", "prompt": "\n/*\n    Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ", "canonical_solution": "{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_plane_sections(&[(1, 1), (2, 2), (3, 3)]), 6);\n        assert_eq!(count_plane_sections(&[(0, 1), (0, 2)]), 3);\n    }\n    \n\n}\n ", "entry_point": "count_plane_sections", "signature": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize", "docstring": "Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)", "instruction": "Write a Rust function `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` to solve the following problem:\nCalculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)", "level": "hard"}
{"task_id": "Rust/16", "prompt": "\n/*\n  Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ", "canonical_solution": "{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(distinct_weights_count(&[1, 4, 6]), 10);\n        assert_eq!(distinct_weights_count(&[2, 3]), 4);\n        assert_eq!(distinct_weights_count(&[]), 0);\n        assert_eq!(distinct_weights_count(&[1, 2, 2]), 5);  \n        \n    }\n    \n\n}", "entry_point": "distinct_weights_count", "signature": "fn distinct_weights_count(weights: &[i32]) -> i32", "docstring": "Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)", "instruction": "Write a Rust function `fn distinct_weights_count(weights: &[i32]) -> i32` to solve the following problem:\nCalculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)", "level": "hard"}
{"task_id": "Rust/17", "prompt": "/*\n  Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ", "canonical_solution": "{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_dream_within_ability(&[50, 69, 240, 135, 98], 100), 98);\n        assert_eq!(max_dream_within_ability(&[20, 40, 60], 50), 40);\n        assert_eq!(max_dream_within_ability(&[10, 20, 30], 5), 0); // No dream within ability\n        assert_eq!(max_dream_within_ability(&[120, 200, 300, 400], 350), 300);\n    \n    }\n    \n\n}", "entry_point": "max_dream_within_ability", "signature": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32", "docstring": "Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)", "instruction": "Write a Rust function `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` to solve the following problem:\nFinds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)", "level": "easy"}
{"task_id": "Rust/18", "prompt": "/*\n  Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ", "canonical_solution": "{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert!((polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) - 33.0838692).abs() < 1e-7);\n        assert!((polynomial_value(0.0, 1.0, 1.0, 1.0, 1.0) - 1.0).abs() < 1e-7);\n        assert!((polynomial_value(1.0, 1.0, 1.0, 1.0, 1.0) - 4.0).abs() < 1e-7);\n    }\n    \n\n}", "entry_point": "polynomial_value", "signature": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64", "docstring": "Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692", "instruction": "Write a Rust function `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` to solve the following problem:\nCalculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692", "level": "easy"}
{"task_id": "Rust/19", "prompt": "/*\n  Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ", "canonical_solution": "{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(min_buckets_needed(23, 11), 3);\n        assert_eq!(min_buckets_needed(30, 10), 3);\n        assert_eq!(min_buckets_needed(50, 5), 6);\n        assert_eq!(min_buckets_needed(40, 8), 3);    \n    }\n    \n\n}", "entry_point": "min_buckets_needed", "signature": "fn min_buckets_needed(height: i32, radius: i32) -> i32", "docstring": "Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3", "instruction": "Write a Rust function `fn min_buckets_needed(height: i32, radius: i32) -> i32` to solve the following problem:\nCalculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3", "level": "easy"}
{"task_id": "Rust/20", "prompt": "/*\n  Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ", "canonical_solution": "{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0), 6.00);\n        assert_eq!(triangle_area(1.0, 2.0, 4.0, 5.0, 6.0, 3.0), 6.00); // Example test case, replace with correct area\n        assert_eq!(triangle_area(0.0, 0.0, 7.0, 8.0, 9.0, 10.0), 1.00); \n    }\n    \n\n}", "entry_point": "triangle_area", "signature": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32", "docstring": "Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00", "instruction": "Write a Rust function `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` to solve the following problem:\nCalculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00", "level": "easy"}
{"task_id": "Rust/21", "prompt": "\n/*\n  Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ", "canonical_solution": "{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_postage(1200, 'y'), 17);\n        assert_eq!(calculate_postage(1000, 'n'), 8);\n        assert_eq!(calculate_postage(1500, 'y'), 17);\n        assert_eq!(calculate_postage(2000, 'n'), 16);\n        \n    }\n    \n\n}", "entry_point": "calculate_postage", "signature": "fn calculate_postage(weight: u32, express: char) -> u32", "docstring": "Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.", "instruction": "Write a Rust function `fn calculate_postage(weight: u32, express: char) -> u32` to solve the following problem:\nCalculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.", "level": "easy"}
{"task_id": "Rust/22", "prompt": "\n/*\n  Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ", "canonical_solution": "{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]), 2);\n        assert_eq!(count_unserved_patients(50, 4, &[10, 15, 10, 20]), 1);\n        assert_eq!(count_unserved_patients(10, 3, &[5, 10, 5]), 1);\n        assert_eq!(count_unserved_patients(20, 5, &[4, 5, 7, 3, 2]), 1);\n        \n    }\n    \n\n}", "entry_point": "count_unserved_patients", "signature": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize", "docstring": "Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1", "instruction": "Write a Rust function `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` to solve the following problem:\nCalculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1", "level": "easy"}
{"task_id": "Rust/23", "prompt": "/*\n  Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ", "canonical_solution": "{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_jolly_jumper(&[1, 4, 2, 3]), true);\n        assert_eq!(is_jolly_jumper(&[1, 3]), false);\n        assert_eq!(is_jolly_jumper(&[5]), true);\n        assert_eq!(is_jolly_jumper(&[10, 7, 8, 9]), false);\n    }\n    \n\n}", "entry_point": "is_jolly_jumper", "signature": "fn is_jolly_jumper(sequence: &[i32]) -> bool", "docstring": "Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.", "instruction": "Write a Rust function `fn is_jolly_jumper(sequence: &[i32]) -> bool` to solve the following problem:\nDetermines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.", "level": "hard"}
{"task_id": "Rust/24", "prompt": "/*\n  Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ", "canonical_solution": "{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![3, 4]]),\n            vec![vec![1, 3], vec![2, 4]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]),\n            vec![vec![1, 4, 7], vec![2, 5, 8], vec![3, 6, 9]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![1, 2]]),\n            vec![vec![1, 1], vec![2, 2]]\n        );\n    }\n    \n\n}", "entry_point": "transpose_matrix", "signature": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>", "docstring": "Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]", "instruction": "Write a Rust function `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` to solve the following problem:\nComputes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]", "level": "easy"}
{"task_id": "Rust/25", "prompt": "/*\n    Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ", "canonical_solution": "{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(transform_password(\"YUANzi1987\"), \"zvbo941987\");\n        assert_eq!(transform_password(\"ABcdE\"), \"bc23f\");\n        assert_eq!(transform_password(\"Zebra123!\"), \"a3272123!\");\n    }\n    \n\n}", "entry_point": "transform_password", "signature": "fn transform_password(input: &str) -> String", "docstring": "Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"", "instruction": "Write a Rust function `fn transform_password(input: &str) -> String` to solve the following problem:\nTransforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"", "level": "hard"}
{"task_id": "Rust/26", "prompt": "\n/*\n  Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ", "canonical_solution": "{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_arithmetic_sequence(&[5, 7, 9, 11]), true);  // True, as 2 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[1, 2, 4, 8]), false);  // False, as difference changes\n        assert_eq!(is_arithmetic_sequence(&[10, 10, 10]), true);   // True, as 0 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[3, 6, 9, 12, 16]), false); // False, last difference is not 3\n    }\n}", "entry_point": "is_arithmetic_sequence", "signature": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool", "docstring": "Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)", "instruction": "Write a Rust function `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` to solve the following problem:\nDetermines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)", "level": "easy"}
{"task_id": "Rust/27", "prompt": "\n/*\n  Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ", "canonical_solution": "{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(day_of_year(\"1985/1/20\"), Ok(20));\n        assert_eq!(day_of_year(\"2006/3/12\"), Ok(71));\n        assert_eq!(day_of_year(\"2024/2/30\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/13/10\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/2/29\"), Ok(60)); // Leap year case\n\n    }\n    \n\n}", "entry_point": "day_of_year", "signature": "fn day_of_year(date: &str) -> Result<usize, String>", "docstring": "Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")", "instruction": "Write a Rust function `fn day_of_year(date: &str) -> Result<usize, String>` to solve the following problem:\nCalculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")", "level": "hard"}
{"task_id": "Rust/28", "prompt": "/*\n  Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ", "canonical_solution": "{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(dedup_and_sort(vec![10, 20, 20, 10, 30]), vec![10, 20, 30]);\n        assert_eq!(dedup_and_sort(vec![5, 4, 3, 2, 1]), vec![1, 2, 3, 4, 5]);\n        assert_eq!(dedup_and_sort(vec![1, 1, 1, 1, 1]), vec![1]);\n        assert_eq!(dedup_and_sort(vec![50]), vec![50]);\n    }\n    \n\n}", "entry_point": "dedup_and_sort", "signature": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>", "docstring": "Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]", "instruction": "Write a Rust function `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` to solve the following problem:\nRemoves duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]", "level": "easy"}
{"task_id": "Rust/29", "prompt": "/*\n  Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n \u2264 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m \u2264 n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ", "canonical_solution": "{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_combinations(5, 2), 10);\n        assert_eq!(calculate_combinations(18, 13), 8568);\n        assert_eq!(calculate_combinations(10, 0), 1);\n        assert_eq!(calculate_combinations(20, 20), 1);\n        assert_eq!(calculate_combinations(15, 5), 3003);\n    }\n    \n\n}", "entry_point": "calculate_combinations", "signature": "fn calculate_combinations(n: u32, m: u32) -> u64", "docstring": "Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n \u2264 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m \u2264 n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568", "instruction": "Write a Rust function `fn calculate_combinations(n: u32, m: u32) -> u64` to solve the following problem:\nComputes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n \u2264 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m \u2264 n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568", "level": "easy"}
{"task_id": "Rust/30", "prompt": "/*\n  Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ", "canonical_solution": "{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]), true);\n        assert_eq!(can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]), false);\n    }\n    \n\n}", "entry_point": "can_win_horse_race", "signature": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool", "docstring": "Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false", "instruction": "Write a Rust function `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` to solve the following problem:\nDetermines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false", "level": "middle"}
{"task_id": "Rust/31", "prompt": "/*\n  Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ", "canonical_solution": "{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n  \n    #[test]\n    fn main() {\n      \n        assert_eq!(count_ways_to_climb(2), 2); // 2 ways: (1+1), (2)\n        assert_eq!(count_ways_to_climb(3), 3); // 3 ways: (1+1+1), (1+2), (2+1)\n        assert_eq!(count_ways_to_climb(4), 5); // 5 ways: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)\n        assert_eq!(count_ways_to_climb(10), 89); \n        assert_eq!(count_ways_to_climb(24), 75025); \n        println!(\"All test cases passed.\");\n    }\n    \n\n}", "entry_point": "count_ways_to_climb", "signature": "fn count_ways_to_climb(stairs: i32) -> i32", "docstring": "Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)", "instruction": "Write a Rust function `fn count_ways_to_climb(stairs: i32) -> i32` to solve the following problem:\nCalculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)", "level": "easy"}
{"task_id": "Rust/32", "prompt": "\n/*\n  Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ", "canonical_solution": "{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_sum_sequence_ranges(10000), vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]);\n        assert_eq!(find_sum_sequence_ranges(15), vec![(1, 5), (4, 6), (7, 8)]);\n        assert_eq!(find_sum_sequence_ranges(28), vec![(1, 7)]);\n        assert_eq!(find_sum_sequence_ranges(21334), vec![(5332, 5335)]);\n        println!(\"All test cases passed!\");\n    }\n    \n\n}", "entry_point": "find_sum_sequence_ranges", "signature": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>", "docstring": "Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]", "instruction": "Write a Rust function `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` to solve the following problem:\nFinds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]", "level": "middle"}
{"task_id": "Rust/33", "prompt": "/*\n  Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ", "canonical_solution": "{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n   \n        assert_eq!(invert_binary_string(\"0110100100100\"), \"1001011011011\");\n        assert_eq!(invert_binary_string(\"1000000010000000000\"), \"0111111101111111111\");\n        assert_eq!(invert_binary_string(\"11110000\"), \"00001111\");\n        assert_eq!(invert_binary_string(\"0000\"), \"1111\");\n        println!(\"All test cases passed!\");\n        \n        \n    }\n    \n\n}", "entry_point": "invert_binary_string", "signature": "fn invert_binary_string(input: &str) -> String", "docstring": "Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"", "instruction": "Write a Rust function `fn invert_binary_string(input: &str) -> String` to solve the following problem:\nConverts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"", "level": "easy"}
{"task_id": "Rust/34", "prompt": "/*\n  Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ", "canonical_solution": "{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]), 10);\n        assert_eq!(minimum_distance_to_post_office(&[(0, 0), (1, 1)]), 2);\n    \n    }\n\n}", "entry_point": "minimum_distance_to_post_office", "signature": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32", "docstring": "Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2", "instruction": "Write a Rust function `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` to solve the following problem:\nCalculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2", "level": "middle"}
{"task_id": "Rust/35", "prompt": "/*\n  Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ", "canonical_solution": "{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]), 5);\n        assert_eq!(max_missiles_intercepted(&[500, 400, 300, 200, 100]), 5);\n        assert_eq!(max_missiles_intercepted(&[100, 200, 300, 400, 500]), 1);\n    }\n    \n\n}", "entry_point": "max_missiles_intercepted", "signature": "fn max_missiles_intercepted(heights: &[i32]) -> i32", "docstring": "Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1", "instruction": "Write a Rust function `fn max_missiles_intercepted(heights: &[i32]) -> i32` to solve the following problem:\nCalculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1", "level": "easy"}
{"task_id": "Rust/36", "prompt": "/*\n  Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ", "canonical_solution": "{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_paths(6, 6, 3, 3), 6);\n        assert_eq!(count_paths(5, 5, 1, 1), 10);\n        assert_eq!(count_paths(7, 7, 2, 2), 0);\n    }\n    \n\n}", "entry_point": "count_paths", "signature": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize", "docstring": "Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28", "instruction": "Write a Rust function `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` to solve the following problem:\nCalculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28", "level": "hard"}
{"task_id": "Rust/37", "prompt": "\n/*\n  Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ", "canonical_solution": "{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n     \n        assert_eq!(kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2), Some(4)); // 5 - 1 = 4\n        assert_eq!(kth_largest_minus_kth_smallest(vec![10, 20, 30], 4), None);\n        assert_eq!(kth_largest_minus_kth_smallest(vec![7, 7, 7, 7], 1), Some(0)); // 7 - 7 = 0\n        \n        \n    }\n    \n\n}", "entry_point": "kth_largest_minus_kth_smallest", "signature": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>", "docstring": "Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None", "instruction": "Write a Rust function `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` to solve the following problem:\nCalculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None", "level": "easy"}
{"task_id": "Rust/38", "prompt": "/*\n  Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ", "canonical_solution": "{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]), 3);\n        assert_eq!(max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]), 110);\n        assert_eq!(max_herbs_value(5, &[(2, 20), (3, 30)]), 50);\n    }\n    \n\n}", "entry_point": "max_herbs_value", "signature": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32", "docstring": "Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30", "instruction": "Write a Rust function `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` to solve the following problem:\nCalculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30", "level": "middle"}
{"task_id": "Rust/39", "prompt": "/*\n  Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ", "canonical_solution": "{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(validate_isbn(\"0-670-82162-4\"), \"Right\");\n        assert_eq!(validate_isbn(\"0-670-82162-0\"), \"0-670-82162-4\");\n        assert_eq!(validate_isbn(\"0-123-45678-9\"), \"Right\");\n        assert_eq!(validate_isbn(\"1-234-56789-X\"), \"Right\");\n    }\n    \n\n}", "entry_point": "validate_isbn", "signature": "fn validate_isbn(isbn: &str) -> String", "docstring": "Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"", "instruction": "Write a Rust function `fn validate_isbn(isbn: &str) -> String` to solve the following problem:\nValidates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"", "level": "hard"}
{"task_id": "Rust/40", "prompt": "/*\n  Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ", "canonical_solution": "{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_passing_ways(3, 3), 2);\n        assert_eq!(count_passing_ways(4, 2), 2);\n        assert_eq!(count_passing_ways(5, 5), 2);    \n        assert_eq!(count_passing_ways(10, 3), 0);    \n        assert_eq!(count_passing_ways(30, 10), 252);    \n    }\n    \n\n}", "entry_point": "count_passing_ways", "signature": "fn count_passing_ways(n: i32, m: i32) -> i32", "docstring": "Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6", "instruction": "Write a Rust function `fn count_passing_ways(n: i32, m: i32) -> i32` to solve the following problem:\nCalculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6", "level": "middle"}
{"task_id": "Rust/41", "prompt": "\n/*\n  Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ", "canonical_solution": "{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]), 14);\n        assert_eq!(max_pairing_difference(&[1, 2], &[3, 4]), 4);\n        assert_eq!(max_pairing_difference(&[10, 20, 30], &[30, 20, 10]), 40);\n    }\n    \n}", "entry_point": "max_pairing_difference", "signature": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64", "docstring": "Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.", "instruction": "Write a Rust function `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` to solve the following problem:\nCalculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.", "level": "middle"}
{"task_id": "Rust/42", "prompt": "/*\n  Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32", "canonical_solution": "{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_prime_factor_in_list(&[36, 38, 40, 42]), 38);\n        assert_eq!(max_prime_factor_in_list(&[10, 15, 21, 22]), 22);\n        assert_eq!(max_prime_factor_in_list(&[7, 11, 13, 19]), 19);\n        assert_eq!(max_prime_factor_in_list(&[2, 3, 5, 7]), 7);\n    }\n    \n\n}", "entry_point": "max_prime_factor_in_list", "signature": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32", "docstring": "Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19", "instruction": "Write a Rust function `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` to solve the following problem:\nFinds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19", "level": "hard"}
{"task_id": "Rust/43", "prompt": "/*\n  Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ", "canonical_solution": "{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![1, 2, 3]), 3);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![]), 0);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![10]), 1);        \n    }\n    \n\n}", "entry_point": "longest_non_decreasing_subsequence_length", "signature": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize", "docstring": "Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4", "instruction": "Write a Rust function `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` to solve the following problem:\nCalculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4", "level": "easy"}
{"task_id": "Rust/44", "prompt": "/*\n  Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ", "canonical_solution": "{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]), 2);\n        assert_eq!(count_comparable_pairs(vec![(100, 100, 100), (95, 95, 95), (90, 90, 90)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 85, 80), (80, 85, 90), (70, 75, 80)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90)]), 0);\n    }\n    \n\n}", "entry_point": "count_comparable_pairs", "signature": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32", "docstring": "Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2", "instruction": "Write a Rust function `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` to solve the following problem:\nCounts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2", "level": "hard"}
{"task_id": "Rust/45", "prompt": "/*\n  Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ", "canonical_solution": "{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(total_smoked_cigarettes(4, 3), 5);\n        assert_eq!(total_smoked_cigarettes(10, 3), 14);\n        assert_eq!(total_smoked_cigarettes(1, 2), 1); // Edge case: Not enough to exchange\n        assert_eq!(total_smoked_cigarettes(100, 5), 124); // Larger numbers\n    }\n    \n\n}", "entry_point": "total_smoked_cigarettes", "signature": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32", "docstring": "Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14", "instruction": "Write a Rust function `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14", "level": "easy"}
{"task_id": "Rust/46", "prompt": "/*\n  Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ", "canonical_solution": "{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]), 5);\n        assert_eq!(longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[6, 6, 2, 3, 1, 4, 5, 7]), 7);\n    }\n    \n\n}", "entry_point": "longest_consecutive_sequence", "signature": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize", "docstring": "Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)", "instruction": "Write a Rust function `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` to solve the following problem:\nFinds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)", "level": "hard"}
{"task_id": "Rust/47", "prompt": "/*\n  Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ", "canonical_solution": "{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(compare_area(5, 4, 6), \"Alice\");\n        assert_eq!(compare_area(7, 5, 10), \"Bob\");\n        assert_eq!(compare_area(6, 3, 8), \"Alice\");\n        assert_eq!(compare_area(9, 4, 5), \"Alice\");\n    }\n    \n\n}", "entry_point": "compare_area", "signature": "fn compare_area(a: usize, b: usize, c: usize) -> String", "docstring": "Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"", "instruction": "Write a Rust function `fn compare_area(a: usize, b: usize, c: usize) -> String` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"", "level": "easy"}
{"task_id": "Rust/48", "prompt": "/*\n  Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ", "canonical_solution": "{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_product_partition(6, 3), vec![2, 2, 2]);\n        assert_eq!(max_product_partition(8, 3), vec![2, 3, 3]);\n        assert_eq!(max_product_partition(10, 2), vec![5, 5]);\n        assert_eq!(max_product_partition(7, 3), vec![2, 2, 3]);\n    }\n    \n\n}", "entry_point": "max_product_partition", "signature": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>", "docstring": "Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]", "instruction": "Write a Rust function `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` to solve the following problem:\nFinds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]", "level": "easy"}
{"task_id": "Rust/49", "prompt": "/*\n  Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ", "canonical_solution": "{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_title_chars(\"234\"), 3);\n        assert_eq!(count_title_chars(\"Ca 45\"), 4);\n        assert_eq!(count_title_chars(\"Hello\\nWorld\"), 10);\n    }\n    \n\n}", "entry_point": "count_title_chars", "signature": "fn count_title_chars(title: &str) -> usize", "docstring": "Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10", "instruction": "Write a Rust function `fn count_title_chars(title: &str) -> usize` to solve the following problem:\nCalculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10", "level": "easy"}
{"task_id": "Rust/50", "prompt": "/*\n  Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ", "canonical_solution": "{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]), 4);\n        assert_eq!(count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]), 0);\n        assert_eq!(count_students_enrolled_in_both(4, 4, vec![1, 3, 5, 7], vec![2, 4, 1, 3]), 2);\n    \n    }\n\n}", "entry_point": "count_students_enrolled_in_both", "signature": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize", "docstring": "Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0", "instruction": "Write a Rust function `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` to solve the following problem:\nCounts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0", "level": "easy"}
{"task_id": "Rust/51", "prompt": "/*\n  Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ", "canonical_solution": "{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_droid_earnings(5, 2), 730);\n        assert_eq!(calculate_droid_earnings(0, 10), -100);\n        assert_eq!(calculate_droid_earnings(10, 5), 950);\n        assert_eq!(calculate_droid_earnings(3, 3), 120);\n    }\n    \n\n}", "entry_point": "calculate_droid_earnings", "signature": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32", "docstring": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.", "instruction": "Write a Rust function `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` to solve the following problem:\nCalculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.", "level": "easy"}
{"task_id": "Rust/52", "prompt": "/*\n  Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ", "canonical_solution": "{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]), (7, 9));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 2, 4, 7], vec![5, 3, 3]]), (6, 3));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 1, 3, 4, 5]]), (2, 1)); // Edge case with minimal input\n    \n    }\n    \n\n}", "entry_point": "find_missing_and_duplicate_ids", "signature": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)", "docstring": "Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)", "instruction": "Write a Rust function `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` to solve the following problem:\nFinds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)", "level": "middle"}
{"task_id": "Rust/53", "prompt": "/*\n  Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ", "canonical_solution": "{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_chars_types(\"yLOI2022\"), (4, 1, 3));\n        assert_eq!(count_chars_types(\"IAKIOIOI\"), (0, 0, 8));\n        assert_eq!(count_chars_types(\"1n2s0e1s\"), (4, 4, 0));\n    }\n    \n\n}", "entry_point": "count_chars_types", "signature": "fn count_chars_types(s: &str) -> (usize, usize, usize)", "docstring": "Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)", "instruction": "Write a Rust function `fn count_chars_types(s: &str) -> (usize, usize, usize)` to solve the following problem:\nCounts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)", "level": "easy"}
