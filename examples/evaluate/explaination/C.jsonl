{"task_id": "C/1", "prompt": "#include <assert.h>\n#include <string.h>\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()", "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}", "test": "int main()\n{\n    assert(strcmp(hello_mmcodeeval(), \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\") == 0);\n    return 0;\n}", "entry_point": "hello_mmcodeeval", "signature": "char *hello_mmcodeeval()", "docstring": "Return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"", "instruction": "Write a C function `char *hello_mmcodeeval()` to solve the following problem:\nThis C code defines a function named `hello_mmcodeeval` that returns a string containing the message \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\".", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <string.h>\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()\n```", "stage1_instruction": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function named `hello_mmcodeeval` that returns a string containing the message \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"."], "raw_generation": ["```c\n#include <stdio.h>\n#include <stdlib.h>\n\nchar *hello_mmcodeeval() {\n    char *message = (char *)malloc(sizeof(char) * 40);\n    if (message == NULL) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    strcpy(message, \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n    return message;\n}\n\nint main() {\n    char *greeting = hello_mmcodeeval();\n    printf(\"%s\\n\", greeting);\n    free(greeting); // Don't forget to free the allocated memory\n    return 0;\n}\n```"]}
{"task_id": "C/2", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its three sides.\n​    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n​    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)", "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}", "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = calculate_triangle_area(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculate_triangle_area(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculate_triangle_area(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}", "entry_point": "calculate_triangle_area", "signature": "double calculate_triangle_area(double a, double b, double c)", "docstring": "Calculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n", "instruction": "Write a C function `double calculate_triangle_area(double a, double b, double c)` to solve the following problem:\nCalculates the area of a triangle given the lengths of its three sides. Returns the area if the sides form a valid triangle, otherwise returns -1.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its three sides.\n​    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n​    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)\n```", "stage1_instruction": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["Calculates the area of a triangle given the lengths of its three sides. Returns the area if the sides form a valid triangle, otherwise returns -1."], "raw_generation": ["```c\n#include <stdio.h>\n#include <math.h>\n\n// Function to calculate the area of a triangle given the lengths of its sides\ndouble calculate_triangle_area(double a, double b, double c) {\n    // Check if the sides form a valid triangle\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n    // Calculate the semi-perimeter\n    double s = (a + b + c) / 2;\n    // Calculate the area using Heron's formula\n    double area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return area;\n}\n\n// Function to check the correctness of the calculate_triangle_area function\nvoid check_triangle_area() {\n    printf(\"Area of triangle with sides 3, 4, 5: %.2f\\n\", calculate_triangle_area(3, 4, 5)); // Should be 6.00\n    printf(\"Area of triangle with sides 1, 2, 10: %.2f\\n\", calculate_triangle_area(1, 2, 10)); // Should be -1\n}\n\nint main() {\n    check_triangle_area();\n    return 0;\n}\n```"]}
{"task_id": "C/3", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)", "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}", "test": "int main() {\n    const char* result = calculate_function_value(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(calculate_function_value(40), \"Not define\") == 0);\n    assert(strcmp(calculate_function_value(5), \"-0.14550\") == 0);\n    assert(strcmp(calculate_function_value(15), \"0.76266\") == 0);\n    assert(strcmp(calculate_function_value(25), \"0.31314\") == 0);\n    assert(strcmp(calculate_function_value(-1), \"Not define\") == 0);\n    return 0;\n}", "entry_point": "calculate_function_value", "signature": "const char* calculate_function_value(int x)", "docstring": "Calculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define\n", "instruction": "Write a C function `const char* calculate_function_value(int x)` to solve the following problem:\nThis C code defines a function `calculate_function_value` that takes an integer `x` as input and returns a string. The function uses a static character array `output` to store the result of the calculation. If `x` is between 0 and 9, the function calculates the cosine of `x + 3.0` and formats the result as a string with 5 decimal places. If `x` is between 10 and 19, the function calculates the square of the cosine of `x + 7.5` and formats the result as a string with 5 decimal places. If `x` is between 20 and 29, the function calculates the fourth power of the cosine of `x + 4.0` and formats the result as a string with 5 decimal places. If `x` is outside these ranges, the function returns the string \"Not define\".", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)\n```", "stage1_instruction": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `calculate_function_value` that takes an integer `x` as input and returns a string. The function uses a static character array `output` to store the result of the calculation. If `x` is between 0 and 9, the function calculates the cosine of `x + 3.0` and formats the result as a string with 5 decimal places. If `x` is between 10 and 19, the function calculates the square of the cosine of `x + 7.5` and formats the result as a string with 5 decimal places. If `x` is between 20 and 29, the function calculates the fourth power of the cosine of `x + 4.0` and formats the result as a string with 5 decimal places. If `x` is outside these ranges, the function returns the string \"Not define\"."], "raw_generation": ["```c\n#include <math.h>\n#include <stdio.h>\n\nconst char* calculate_function_value(int x) {\n    static char output[50];\n    double result;\n\n    if (x >= 0 && x <= 9) {\n        result = cos(x + 3.0);\n        sprintf(output, \"%.5f\", result);\n    } else if (x >= 10 && x <= 19) {\n        result = pow(cos(x + 7.5), 2);\n        sprintf(output, \"%.5f\", result);\n    } else if (x >= 20 && x <= 29) {\n        result = pow(cos(x + 4.0), 4);\n        sprintf(output, \"%.5f\", result);\n    } else {\n        return \"Not define\";\n    }\n\n    return output;\n}\n```"]}
{"task_id": "C/4", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)", "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}", "test": "int main() {\n    int max, min;\n\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}", "entry_point": "find_max_min", "signature": "void find_max_min(int a, int b, int c, int *max, int *min)", "docstring": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);", "instruction": "Write a C function `void find_max_min(int a, int b, int c, int *max, int *min)` to solve the following problem:\nThis function takes four integer inputs and two pointers to integers. It compares the values of the inputs and assigns the maximum and minimum values to the pointers. If the first input is greater than the second, it checks if it's also greater than the third. If it is, the first input is the maximum and the smaller of the second and third inputs is the minimum. If the first input is not greater than the second, it checks if the second is greater than the third. If it is, the second input is the maximum and the smaller of the first and third inputs is the minimum. If neither condition is met, the third input is the maximum and the smaller of the first and second inputs is the minimum.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)\n```", "stage1_instruction": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function takes four integer inputs and two pointers to integers. It compares the values of the inputs and assigns the maximum and minimum values to the pointers. If the first input is greater than the second, it checks if it's also greater than the third. If it is, the first input is the maximum and the smaller of the second and third inputs is the minimum. If the first input is not greater than the second, it checks if the second is greater than the third. If it is, the second input is the maximum and the smaller of the first and third inputs is the minimum. If neither condition is met, the third input is the maximum and the smaller of the first and second inputs is the minimum."], "raw_generation": ["```c\n#include <stdio.h>\n\nvoid find_max_min(int a, int b, int c, int *max, int *min) {\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            if (b < c) {\n                *min = b;\n            } else {\n                *min = c;\n            }\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            if (a < c) {\n                *min = a;\n            } else {\n                *min = c;\n            }\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nint main() {\n    int a = 10, b = 20, c = 30;\n    int max, min;\n    find_max_min(a, b, c, &max, &min);\n    printf(\"Maximum: %d, Minimum: %d\\n\", max, min);\n    return 0;\n}\n```"]}
{"task_id": "C/5", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)", "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}", "test": "int main() {\n    assert(fabs(calculate_distance(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}", "entry_point": "calculate_distance", "signature": "double calculate_distance(double xa, double ya, double xb, double yb)", "docstring": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n", "instruction": "Write a C function `double calculate_distance(double xa, double ya, double xb, double yb)` to solve the following problem:\nCalculates the Euclidean distance between two points in a 2D plane given their x and y coordinates.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)\n```", "stage1_instruction": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["Calculates the Euclidean distance between two points in a 2D plane given their x and y coordinates."], "raw_generation": ["```c\n#include <math.h>\n\n/**\n * Calculates the Euclidean distance between two points in a 2D plane.\n *\n * @param xa The x-coordinate of the first point.\n * @param ya The y-coordinate of the first point.\n * @param xb The x-coordinate of the second point.\n * @param yb The y-coordinate of the second point.\n * @return The Euclidean distance between the two points.\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb) {\n    return sqrt(pow(xb - xa, 2) + pow(yb - ya, 2));\n}\n\n// Example usage\n#include <stdio.h>\n\nint main() {\n    double distance = calculate_distance(1.0, 2.0, 4.0, 6.0);\n    printf(\"The distance between the points is: %.2f\\n\", distance);\n    return 0;\n}\n```"]}
{"task_id": "C/6", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n​    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n​    Returns:\n​    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)", "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}", "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "process_request", "signature": "int process_request(int n)", "docstring": "Find the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n", "instruction": "Write a C function `int process_request(int n)` to solve the following problem:\nThis C code defines a function `process_request` that takes an integer `n` as input and returns the `n`th number in a sequence generated by multiplying the previous number by its index and taking the modulo 10007. The sequence starts with 1 at both the 0th and 1st positions. The function uses an array `a` of size 10010 to store the sequence values.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n​    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n​    Returns:\n​    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)\n```", "stage1_instruction": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `process_request` that takes an integer `n` as input and returns the `n`th number in a sequence generated by multiplying the previous number by its index and taking the modulo 10007. The sequence starts with 1 at both the 0th and 1st positions. The function uses an array `a` of size 10010 to store the sequence values."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the nth number in the sequence\nint process_request(int n) {\n    // Initialize the array with base values\n    int a[10010] = {0, 1};\n    \n    // Calculate the sequence up to the nth number\n    for (int i = 2; i <= n; ++i) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    \n    // Return the nth number in the sequence\n    return a[n];\n}\n\n// Function to check the correctness of the process_request function\nvoid check_function() {\n    // Test cases\n    int test_cases[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int expected_results[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800};\n    \n    // Check each test case\n    for (int i = 0; i < sizeof(test_cases) / sizeof(test_cases[0]); ++i) {\n        int result = process_request(test_cases[i]);\n        if (result == expected_results[i]) {\n            printf(\"Test case %d passed (n = %d, result = %d).\\n\", i + 1, test_cases[i], result);\n        } else {\n            printf(\"Test case %d failed (n = %d, expected = %d, result = %d).\\n\", i + 1, test_cases[i], expected_results[i], result);\n        }\n    }\n}\n\nint main() {\n    // Call the check function to verify the correctness of the process_request function\n    check_function();\n    return 0;\n}\n```\n\nThis code snippet defines the `process_request` function to calculate the `n`th number in a sequence where each number is the product of the previous number and its index, modulo 10007. It also includes a `check_function` to verify the correctness of the `process_request` function using predefined test cases and expected results. The `main` function calls `check_function` to run the tests."]}
{"task_id": "C/7", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)", "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}", "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "calculate_triangle_area", "signature": "float calculate_triangle_area(int base, int height)", "docstring": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n", "instruction": "Write a C function `float calculate_triangle_area(int base, int height)` to solve the following problem:\nThis function calculates the area of a triangle given its base and height, ensuring the result is a floating-point number.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)\n```", "stage1_instruction": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the area of a triangle given its base and height, ensuring the result is a floating-point number."], "raw_generation": ["```c\n#include <stdio.h>\n\n/**\n * Calculates the area of a triangle.\n *\n * @param base The base of the triangle.\n * @param height The height of the triangle.\n * @return The area of the triangle as a float.\n */\nfloat calculate_triangle_area(int base, int height) {\n    return 0.5f * base * height;\n}\n\n// Function to check the correctness of the calculate_triangle_area function.\nvoid check_triangle_area() {\n    printf(\"Area of triangle with base 10 and height 5 is %.2f\\n\", calculate_triangle_area(10, 5)); // Expected: 25.00\n    printf(\"Area of triangle with base 7 and height 3 is %.2f\\n\", calculate_triangle_area(7, 3));   // Expected: 10.50\n}\n\nint main() {\n    check_triangle_area();\n    return 0;\n}\n```"]}
{"task_id": "C/8", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)", "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}", "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}", "entry_point": "hamming_distance", "signature": "int hamming_distance(int x, int y)", "docstring": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n", "instruction": "Write a C function `int hamming_distance(int x, int y)` to solve the following problem:\nThis C function calculates the Hamming distance between two integers, x and y. It first computes the XOR of x and y to identify the positions where the bits differ. Then, it counts the number of set bits (1s) in the result, which represents the Hamming distance. The function returns this distance.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)\n```", "stage1_instruction": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function calculates the Hamming distance between two integers, x and y. It first computes the XOR of x and y to identify the positions where the bits differ. Then, it counts the number of set bits (1s) in the result, which represents the Hamming distance. The function returns this distance."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the Hamming distance between two integers\nint hamming_distance(int x, int y) {\n    int xor_result = x ^ y; // XOR to find differing bits\n    int distance = 0;\n    \n    // Count the number of set bits (1s) in the XOR result\n    while (xor_result > 0) {\n        distance += xor_result & 1; // Increment if the last bit is 1\n        xor_result >>= 1; // Shift right to check the next bit\n    }\n    \n    return distance;\n}\n\n// Function to check the correctness of the hamming_distance function\nvoid check_hamming_distance() {\n    printf(\"Hamming distance between 1 and 4 is %d\\n\", hamming_distance(1, 4)); // Expected: 2\n    printf(\"Hamming distance between 255 and 0 is %d\\n\", hamming_distance(255, 0)); // Expected: 8\n    printf(\"Hamming distance between 17 and 34 is %d\\n\", hamming_distance(17, 34)); // Expected: 3\n}\n\nint main() {\n    check_hamming_distance();\n    return 0;\n}\n```\nThis solution defines the `hamming_distance` function as required, using bitwise XOR to find differing bits and counting the number of set bits in the result. The `check_hamming_distance` function demonstrates the functionality with a few test cases."]}
{"task_id": "C/9", "prompt": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)", "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}", "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_odd_numbers", "signature": "int count_odd_numbers(int count, ...)", "docstring": "Count the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n", "instruction": "Write a C function `int count_odd_numbers(int count, ...)` to solve the following problem:\nThis function `count_odd_numbers` takes an integer `count` and a variable number of integer arguments. It initializes a `va_list` to store the variable arguments, then iterates `count` times, each time retrieving an integer argument using `va_arg` and checking if it is odd by using the bitwise AND operator with 1. If the number is odd, it increments the `ans` counter. Finally, it ends the argument list using `va_end` and returns the count of odd numbers.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdarg.h>\n\n/*\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)\n```", "stage1_instruction": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function `count_odd_numbers` takes an integer `count` and a variable number of integer arguments. It initializes a `va_list` to store the variable arguments, then iterates `count` times, each time retrieving an integer argument using `va_arg` and checking if it is odd by using the bitwise AND operator with 1. If the number is odd, it increments the `ans` counter. Finally, it ends the argument list using `va_end` and returns the count of odd numbers."], "raw_generation": ["```c\n#include <stdarg.h>\n\nint count_odd_numbers(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n```"]}
{"task_id": "C/10", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration", "canonical_solution": "int calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1, 5) == 6);\n    assert(calculate_even_sum(sample2, 4) == 4);\n    assert(calculate_even_sum(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}", "entry_point": "calculate_even_sum", "signature": "int calculate_even_sum(int *numbers, int size)", "docstring": "Calculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n", "instruction": "Write a C function `int calculate_even_sum(int *numbers, int size)` to solve the following problem:\nThis function calculates the sum of all even numbers in an array of integers. It takes a pointer to the first element of the array and the size of the array as arguments. It iterates through the array, checks if each number is even by using the bitwise AND operator with 1, and adds it to the sum if it is. Finally, it returns the sum of all even numbers in the array.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration\n```", "stage1_instruction": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the sum of all even numbers in an array of integers. It takes a pointer to the first element of the array and the size of the array as arguments. It iterates through the array, checks if each number is even by using the bitwise AND operator with 1, and adds it to the sum if it is. Finally, it returns the sum of all even numbers in the array."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the sum of all even numbers in an array\nint calculate_even_sum(int *numbers, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Check if the number is even\n            sum += numbers[i];\n        }\n    }\n    return sum;\n}\n\n// Function to check the correctness of the calculate_even_sum function\nvoid check_function() {\n    int test_array1[] = {1, 2, 3, 4, 5, 6};\n    int test_array2[] = {10, 23, 36, 47, 58, 69};\n    int test_array3[] = {0, 1, 2, 3, 4, 5};\n\n    printf(\"Sum of even numbers in test_array1: %d\\n\", calculate_even_sum(test_array1, sizeof(test_array1) / sizeof(test_array1[0]))); // Should print 12\n    printf(\"Sum of even numbers in test_array2: %d\\n\", calculate_even_sum(test_array2, sizeof(test_array2) / sizeof(test_array2[0]))); // Should print 96\n    printf(\"Sum of even numbers in test_array3: %d\\n\", calculate_even_sum(test_array3, sizeof(test_array3) / sizeof(test_array3[0]))); // Should print 6\n}\n\nint main() {\n    check_function();\n    return 0;\n}\n```\n\nThis code snippet defines a function `calculate_even_sum` that calculates the sum of all even numbers in an array of integers. It also includes a `check_function` to verify the correctness of the `calculate_even_sum` function with different test arrays."]}
{"task_id": "C/11", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nDetermine if two closed intervals intersect.\n​    Args:\n​    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n​    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 if the intervals intersect, 0 otherwise.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)", "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    return 0;\n}", "entry_point": "are_intervals_intersecting", "signature": "int are_intervals_intersecting(int a, int b, int c, int d)", "docstring": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n", "instruction": "Write a C function `int are_intervals_intersecting(int a, int b, int c, int d)` to solve the following problem:\nThis function checks if two given intervals are intersecting. It takes four integer parameters representing the start and end points of two intervals. If the intervals intersect, the function returns 1 (Yes), otherwise it returns 0 (No).", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nDetermine if two closed intervals intersect.\n​    Args:\n​    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n​    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 if the intervals intersect, 0 otherwise.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)\n```", "stage1_instruction": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function checks if two given intervals are intersecting. It takes four integer parameters representing the start and end points of two intervals. If the intervals intersect, the function returns 1 (Yes), otherwise it returns 0 (No)."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to check if two intervals intersect\nint are_intervals_intersecting(int a, int b, int c, int d) {\n    // Check if one interval is completely to the left of the other\n    if (b < c || d < a) {\n        return 0; // No intersection\n    }\n    return 1; // Intersection exists\n}\n\n// Main function to test the are_intervals_intersecting function\nint main() {\n    // Test cases\n    printf(\"%d\\n\", are_intervals_intersecting(1, 3, 2, 4)); // Expected output: 1\n    printf(\"%d\\n\", are_intervals_intersecting(5, 7, 8, 10)); // Expected output: 0\n    printf(\"%d\\n\", are_intervals_intersecting(-2, 2, -1, 1)); // Expected output: 1\n    return 0;\n}\n```\nThis code snippet defines a function `are_intervals_intersecting` that takes two intervals as input and returns 1 if they intersect, otherwise 0. The main function includes test cases to demonstrate the functionality of the `are_intervals_intersecting` function."]}
{"task_id": "C/12", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)", "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}", "test": "int main()\n{\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n    return 0;\n}", "entry_point": "extraNumber", "signature": "int extraNumber(int a, int b, int c)", "docstring": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n", "instruction": "Write a C function `int extraNumber(int a, int b, int c)` to solve the following problem:\nThis C code defines a function called `extraNumber` that takes three integer parameters `a`, `b`, and `c`. It checks if `a` is equal to `b`. If it is, the function returns `c`. If `a` is not equal to `b`, it then checks if `a` is equal to `c`. If it is, the function returns `b`. If `a` is not equal to `c`, the function returns `a`.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)\n```", "stage1_instruction": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function called `extraNumber` that takes three integer parameters `a`, `b`, and `c`. It checks if `a` is equal to `b`. If it is, the function returns `c`. If `a` is not equal to `b`, it then checks if `a` is equal to `c`. If it is, the function returns `b`. If `a` is not equal to `c`, the function returns `a`."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to find the extra number among three given numbers\nint extraNumber(int a, int b, int c) {\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\n// Function to check the correctness of the extraNumber function\nvoid checkFunction() {\n    printf(\"Checking with (1, 2, 3): %d\\n\", extraNumber(1, 2, 3)); // Should return 1\n    printf(\"Checking with (4, 4, 2): %d\\n\", extraNumber(4, 4, 2)); // Should return 2\n    printf(\"Checking with (5, 3, 5): %d\\n\", extraNumber(5, 3, 5)); // Should return 3\n}\n\nint main() {\n    checkFunction();\n    return 0;\n}\n```\n\nThis solution provides a clear and concise implementation of the `extraNumber` function, along with a `checkFunction` to verify its correctness using different sets of input values."]}
{"task_id": "C/13", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}", "test": "int main()\n{\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}", "entry_point": "calculate_total_score", "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)", "docstring": "Calculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n", "instruction": "Write a C function `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` to solve the following problem:\nThis function calculates the total score by summing up five integer inputs: score1, score2, score3, score4, and score5.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n```", "stage1_instruction": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the total score by summing up five integer inputs: score1, score2, score3, score4, and score5."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the total score\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5) {\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n// Main function to test the calculate_total_score function\nint main() {\n    // Test cases\n    printf(\"Total score: %d\\n\", calculate_total_score(10, 20, 30, 40, 50)); // Expected output: 150\n    printf(\"Total score: %d\\n\", calculate_total_score(5, 15, 25, 35, 45));  // Expected output: 125\n    return 0;\n}\n```"]}
{"task_id": "C/14", "prompt": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)", "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}", "test": "int main() {\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Additional test samples\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    return 0;\n}", "entry_point": "decode_numbers", "signature": "int decode_numbers(const char* data_str)", "docstring": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n", "instruction": "Write a C function `int decode_numbers(const char* data_str)` to solve the following problem:\nThis C code defines a function called `decode_numbers` that takes a string `data_str` as input and returns an integer. The function initializes an array `a` with the values {1, 0, 0, 0, 1, 0, 1, 0, 2, 1}. It then iterates over each character in the input string, converts it to an integer using the `- '0'` operation, and adds the corresponding value from the `a` array to the `ans` variable. Finally, the function returns the `ans` variable.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)\n```", "stage1_instruction": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function called `decode_numbers` that takes a string `data_str` as input and returns an integer. The function initializes an array `a` with the values {1, 0, 0, 0, 1, 0, 1, 0, 2, 1}. It then iterates over each character in the input string, converts it to an integer using the `- '0'` operation, and adds the corresponding value from the `a` array to the `ans` variable. Finally, the function returns the `ans` variable."], "raw_generation": ["```c\n#include <stdio.h>\n#include <string.h>\n\nint decode_numbers(const char* data_str) {\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for (int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nint main() {\n    const char* data_str = \"101010\";\n    printf(\"The decoded number is: %d\\n\", decode_numbers(data_str));\n    return 0;\n}\n```\n\nIn this solution, the `decode_numbers` function takes a string `data_str` as input and iterates over each character. It converts each character to an integer using the `- '0'` operation and adds the corresponding value from the `a` array to the `ans` variable. The function then returns the `ans` variable. The `main` function demonstrates how to use the `decode_numbers` function with a sample input string."]}
{"task_id": "C/15", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)", "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}", "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999,66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_coloring_methods", "signature": "int count_coloring_methods(int n, int m)", "docstring": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n", "instruction": "Write a C function `int count_coloring_methods(int n, int m)` to solve the following problem:\nThis C code defines a function `count_coloring_methods` that calculates the number of ways to color `n` objects with `m` distinct colors. It uses dynamic programming to store intermediate results in an array `f`. The function handles base cases for `n = 1` and `n = 2`, and then uses a formula to calculate the number of ways for larger values of `n`. The result is returned modulo 1000003 to avoid integer overflow.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)\n```", "stage1_instruction": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `count_coloring_methods` that calculates the number of ways to color `n` objects with `m` distinct colors. It uses dynamic programming to store intermediate results in an array `f`. The function handles base cases for `n = 1` and `n = 2`, and then uses a formula to calculate the number of ways for larger values of `n`. The result is returned modulo 1000003 to avoid integer overflow."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the number of ways to color n objects with m distinct colors\nint count_coloring_methods(int n, int m) {\n    if (n == 1) return m;\n    if (n == 2) return m * m;\n\n    long long f[n + 1];\n    f[1] = m;\n    f[2] = m * m;\n\n    for (int i = 3; i <= n; i++) {\n        f[i] = ((m - 1) * (f[i - 1] + f[i - 2])) % 1000003;\n    }\n\n    return f[n];\n}\n\n// Function to check the correctness of the count_coloring_methods function\nvoid check_function() {\n    printf(\"Number of ways to color 3 objects with 2 colors: %d\\n\", count_coloring_methods(3, 2)); // Expected output: 6\n    printf(\"Number of ways to color 4 objects with 3 colors: %d\\n\", count_coloring_methods(4, 3)); // Expected output: 66\n}\n\nint main() {\n    check_function();\n    return 0;\n}\n```\n\nThis solution provides a complete C function that calculates the number of ways to color `n` objects with `m` distinct colors using dynamic programming. The `check_function` is used to verify the correctness of the `count_coloring_methods` function with provided data points."]}
{"task_id": "C/16", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n​    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)", "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}", "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141); \n    assert(count_valid_coin_toss_sequences(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "count_valid_coin_toss_sequences", "signature": "unsigned long long count_valid_coin_toss_sequences(int n)", "docstring": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n", "instruction": "Write a C function `unsigned long long count_valid_coin_toss_sequences(int n)` to solve the following problem:\nThis C code defines a function `count_valid_coin_toss_sequences` that calculates the number of valid sequences of coin tosses for a given number `n`. The function uses dynamic programming to store intermediate results in a 2D array `a`. The first element of the array `a[i][0]` represents the number of sequences that end with a heads, and the second element `a[i][1]` represents the number of sequences that end with a tails. The function iterates from `i = 2` to `n`, updating the array `a` based on the previous values. Finally, the function returns the sum of the first and second elements of the last row of the array, which represents the total number of valid sequences for `n`.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n​    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)\n```", "stage1_instruction": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `count_valid_coin_toss_sequences` that calculates the number of valid sequences of coin tosses for a given number `n`. The function uses dynamic programming to store intermediate results in a 2D array `a`. The first element of the array `a[i][0]` represents the number of sequences that end with a heads, and the second element `a[i][1]` represents the number of sequences that end with a tails. The function iterates from `i = 2` to `n`, updating the array `a` based on the previous values. Finally, the function returns the sum of the first and second elements of the last row of the array, which represents the total number of valid sequences for `n`."], "raw_generation": ["```c\n#include <stdio.h>\n\nunsigned long long count_valid_coin_toss_sequences(int n) {\n    unsigned long long a[n + 1][2];\n    a[1][0] = 1;\n    a[1][1] = 1;\n    for (int i = 2; i <= n; i++) {\n        a[i][0] = a[i - 1][0] + a[i - 1][1];\n        a[i][1] = a[i - 1][0];\n    }\n    return a[n][0] + a[n][1];\n}\n\nint main() {\n    int n;\n    printf(\"Enter the number of tosses: \");\n    scanf(\"%d\", &n);\n    printf(\"Number of valid sequences: %llu\\n\", count_valid_coin_toss_sequences(n));\n    return 0;\n}\n```\nThis C code defines the function `count_valid_coin_toss_sequences` which calculates the number of valid sequences of coin tosses for a given number `n`. The main function prompts the user to enter the number of tosses and then prints the number of valid sequences using the `count_valid_coin_toss_sequences` function."]}
{"task_id": "C/17", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n​    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n​    Returns:\n​    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n​    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)", "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}", "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "find_longest_consecutive_ones_length", "signature": "int find_longest_consecutive_ones_length(unsigned long long n)", "docstring": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n", "instruction": "Write a C function `int find_longest_consecutive_ones_length(unsigned long long n)` to solve the following problem:\nThis function finds the length of the longest consecutive sequence of ones in an unsigned long long integer. It initializes two variables, max and ans, to 0. It then iterates through each bit of the input number n using a while loop. If the current bit is 1, it increments the ans variable. If the current bit is 0, it checks if ans is greater than max and updates max if it is. It then resets ans to 0. After the loop, it checks one last time if ans is greater than max and updates max if it is. Finally, it returns the value of max, which represents the length of the longest consecutive sequence of ones in the input number.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n​    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n​    Returns:\n​    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n​    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)\n```", "stage1_instruction": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function finds the length of the longest consecutive sequence of ones in an unsigned long long integer. It initializes two variables, max and ans, to 0. It then iterates through each bit of the input number n using a while loop. If the current bit is 1, it increments the ans variable. If the current bit is 0, it checks if ans is greater than max and updates max if it is. It then resets ans to 0. After the loop, it checks one last time if ans is greater than max and updates max if it is. Finally, it returns the value of max, which represents the length of the longest consecutive sequence of ones in the input number."], "raw_generation": ["```c\n#include <stdio.h>\n\nint find_longest_consecutive_ones_length(unsigned long long n) {\n    int max = 0, ans = 0;\n    while (n) {\n        if (n & 1) {\n            ans++;\n        } else {\n            if (ans > max) {\n                max = ans;\n            }\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if (ans > max) {\n        max = ans;\n    }\n    return max;\n}\n\nint main() {\n    unsigned long long test_numbers[] = {\n        0b10101010101010101010101010101010,\n        0b11110000111100001111000011110000,\n        0b00001111000000111100001111000000,\n        0b10000000000000000000000000000000,\n        0b11111111111111111111111111111111\n    };\n    int lengths[] = {10, 8, 6, 1, 32};\n    for (int i = 0; i < 5; i++) {\n        int result = find_longest_consecutive_ones_length(test_numbers[i]);\n        printf(\"Test %d: Expected %d, got %d\\n\", i + 1, lengths[i], result);\n    }\n    return 0;\n}\n```\nThis code defines the function `find_longest_consecutive_ones_length` which calculates the length of the longest consecutive sequence of ones in an unsigned long long integer. It also includes a `main` function to test the correctness of the `find_longest_consecutive_ones_length` function with various test cases."]}
{"task_id": "C/18", "prompt": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCreates an ID by combining two words in a specific manner.\n​Parameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n​Returns:\n​char*: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)", "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}", "test": "int main() {\n    char* id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = create_id(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = create_id(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}", "entry_point": "create_id", "signature": "char* create_id(const char* word1, const char* word2)", "docstring": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch\n", "instruction": "Write a C function `char* create_id(const char* word1, const char* word2)` to solve the following problem:\nThis C function `create_id` takes two strings `word1` and `word2` as input and returns a new string `id`. The length of `id` is the sum of the lengths of `word1` and `word2`. The characters of `id` are constructed by alternately taking characters from `word1` and `word2`, starting with `word1`. If the index `i` is odd, the character is taken from the end of `word2` (`word2[k--]`), otherwise from the beginning of `word1` (`word1[j++]`). The function dynamically allocates memory for `id` using `malloc`, ensuring it is properly null-terminated before returning it.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCreates an ID by combining two words in a specific manner.\n​Parameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n​Returns:\n​char*: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)\n```", "stage1_instruction": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function `create_id` takes two strings `word1` and `word2` as input and returns a new string `id`. The length of `id` is the sum of the lengths of `word1` and `word2`. The characters of `id` are constructed by alternately taking characters from `word1` and `word2`, starting with `word1`. If the index `i` is odd, the character is taken from the end of `word2` (`word2[k--]`), otherwise from the beginning of `word1` (`word1[j++]`). The function dynamically allocates memory for `id` using `malloc`, ensuring it is properly null-terminated before returning it."], "raw_generation": ["```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to create an id from two words\nchar* create_id(const char* word1, const char* word2) {\n    int len1 = strlen(word1);\n    int len2 = strlen(word2);\n    int total_len = len1 + len2;\n    char* id = (char*)malloc((total_len + 1) * sizeof(char)); // Allocate memory for id\n    int j = 0, k = len2 - 1;\n    for (int i = 0; i < total_len; i++) {\n        if (i % 2 == 0) {\n            id[i] = word1[j++]; // Take from word1\n        } else {\n            id[i] = word2[k--]; // Take from word2\n        }\n    }\n    id[total_len] = '\\0'; // Null-terminate the string\n    return id;\n}\n\n// Function to check the correctness of the create_id function\nvoid check_id() {\n    char* result1 = create_id(\"hello\", \"world\");\n    printf(\"ID: %s\\n\", result1); // Expected: \"hweolrllod\"\n    free(result1);\n\n    char* result2 = create_id(\"abc\", \"def\");\n    printf(\"ID: %s\\n\", result2); // Expected: \"adbecf\"\n    free(result2);\n}\n\nint main() {\n    check_id();\n    return 0;\n}\n```\nThis solution defines the `create_id` function as specified, using a loop to construct the `id` string by alternating characters from `word1` and `word2`. It also includes a `check_id` function to demonstrate the functionality with example inputs."]}
{"task_id": "C/19", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n*/\nint count_permutations_of_binary_string(int n, int m)", "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}", "test": "int main() {\n    // printf(\"%d\\n\", count_permutations_of_binary_string(2, 0));\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}", "entry_point": "count_permutations_of_binary_string", "signature": "int count_permutations_of_binary_string(int n, int m)", "docstring": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n", "instruction": "Write a C function `int count_permutations_of_binary_string(int n, int m)` to solve the following problem:\nThis function calculates the number of permutations of a binary string of length n and m. It first computes the factorial of n, (n+m)/2, and (n-m)/2, and then uses these values to calculate the number of permutations. If the sum of n and m is odd, the function returns 0. If n equals m, the function returns 1. Otherwise, it returns the number of permutations rounded to the nearest integer.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n*/\nint count_permutations_of_binary_string(int n, int m)\n```", "stage1_instruction": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the number of permutations of a binary string of length n and m. It first computes the factorial of n, (n+m)/2, and (n-m)/2, and then uses these values to calculate the number of permutations. If the sum of n and m is odd, the function returns 0. If n equals m, the function returns 1. Otherwise, it returns the number of permutations rounded to the nearest integer."], "raw_generation": ["```c\n#include <stdio.h>\n#include <math.h>\n\n// Function to calculate factorial\nlong long factorial(int num) {\n    long long fact = 1;\n    for (int i = 1; i <= num; i++) {\n        fact *= i;\n    }\n    return fact;\n}\n\n// Function to count permutations of a binary string of length n and m\nint count_permutations_of_binary_string(int n, int m) {\n    if (n + m % 2 != 0) {\n        return 0;\n    }\n    if (n == m) {\n        return 1;\n    }\n    long long fact_n = factorial(n);\n    long long fact_half = factorial((n + m) / 2);\n    long long fact_other_half = factorial((n - m) / 2);\n    long long permutations = fact_n / (fact_half * fact_other_half);\n    return (int)round(permutations);\n}\n\n// Check function to verify the correctness of the generated function\nvoid check() {\n    printf(\"Permutations of binary string of length 3 and 2: %d\\n\", count_permutations_of_binary_string(3, 2)); // Expected: 0\n    printf(\"Permutations of binary string of length 4 and 2: %d\\n\", count_permutations_of_binary_string(4, 2)); // Expected: 1\n    printf(\"Permutations of binary string of length 5 and 3: %d\\n\", count_permutations_of_binary_string(5, 3)); // Expected: 10\n}\n\nint main() {\n    check();\n    return 0;\n}\n```\nThis solution defines a helper function `factorial` to calculate the factorial of a number, which is then used by the main function `count_permutations_of_binary_string` to compute the number of permutations. The `check` function is used to verify the correctness of the solution with provided data points."]}
{"task_id": "C/20", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Answer a series of questions by providing choices A, B, C, or D for each question.\n​    Question 1:\n​    Constants like 1e6 belong to which data type?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n​        A. int\n​        B. long long\n​        C. double\n​        D. None of the above\n​    Question 3:\n​    Which statement about left values in expressions is incorrect?\n​        A. Variable name expressions are left values.\n​        B. Increment operation requires the operand to be a left value.\n​        C. Pointer dereference expressions are left values.\n​        D. Prefix increment operation expressions are left values.\n​    Question 4:\n​    Which statement about functions is incorrect?\n​        A. Formal parameters of a function are local variables.\n​        B. Local variables are allocated space in the stack.\n​        C. The function type is the same as the return value type.\n​        D. A function can call itself from within its body.\n​    Question 5:\n​    Which statement about pointers is incorrect?\n​        A. Subtracting two pointers equals the difference in their address values.\n​        B. Pointer dereference involves resolving based on the pointer's type.\n​        C. int *p[4], p is an array of int pointers.\n​        D. Function names can be assigned to function pointers.\n\t>>> answer_questions()\n\tAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nconst char* answer_questions()", "canonical_solution": "{\n    return \"DDDBA\";\n}", "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}", "entry_point": "answer_questions", "signature": "const char* answer_questions()", "docstring": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> answer_questions()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.", "instruction": "Write a C function `const char* answer_questions()` to solve the following problem:\nThis C code defines a function called `answer_questions` that returns a pointer to a constant character array containing the string \"DDDBA\".", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Answer a series of questions by providing choices A, B, C, or D for each question.\n​    Question 1:\n​    Constants like 1e6 belong to which data type?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n​        A. int\n​        B. long long\n​        C. double\n​        D. None of the above\n​    Question 3:\n​    Which statement about left values in expressions is incorrect?\n​        A. Variable name expressions are left values.\n​        B. Increment operation requires the operand to be a left value.\n​        C. Pointer dereference expressions are left values.\n​        D. Prefix increment operation expressions are left values.\n​    Question 4:\n​    Which statement about functions is incorrect?\n​        A. Formal parameters of a function are local variables.\n​        B. Local variables are allocated space in the stack.\n​        C. The function type is the same as the return value type.\n​        D. A function can call itself from within its body.\n​    Question 5:\n​    Which statement about pointers is incorrect?\n​        A. Subtracting two pointers equals the difference in their address values.\n​        B. Pointer dereference involves resolving based on the pointer's type.\n​        C. int *p[4], p is an array of int pointers.\n​        D. Function names can be assigned to function pointers.\n\t>>> answer_questions()\n\tAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nconst char* answer_questions()\n```", "stage1_instruction": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function called `answer_questions` that returns a pointer to a constant character array containing the string \"DDDBA\"."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to return a pointer to a constant character array\nconst char* answer_questions() {\n    // Return the string \"DDDBA\"\n    return \"DDDBA\";\n}\n\n// Main function to demonstrate the usage of the answer_questions function\nint main() {\n    // Call the answer_questions function and store the returned pointer\n    const char* result = answer_questions();\n    \n    // Print the result\n    printf(\"The answer to the questions is: %s\\n\", result);\n    \n    return 0;\n}\n```"]}
{"task_id": "C/21", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])", "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}", "test": "int main() {\n    assert(Is_Square(1, (int[]){9}) == 1);\n    assert(Is_Square(2, (int[]){14, 2}) == 1);\n    assert(Is_Square(2, (int[]){7, 7}) == 0);\n    assert(Is_Square(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(Is_Square(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(Is_Square(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(Is_Square(3, (int[]){4, 5, 6}) == 0);\n    assert(Is_Square(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(Is_Square(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(Is_Square(2, (int[]){25, 25}) == 0);\n    assert(Is_Square(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}", "entry_point": "Is_Square", "signature": "int Is_Square(int length, int squares[])", "docstring": "The task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n", "instruction": "Write a C function `int Is_Square(int length, int squares[])` to solve the following problem:\nThis function, Is_Square, takes an integer length and an array of integers squares as input. It calculates the sum of the elements in the squares array. Then, it finds the square root of the sum and checks if the square of this root equals the sum. If it does, the function returns 1, indicating that the sum is a perfect square. Otherwise, it returns 0.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])\n```", "stage1_instruction": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function, Is_Square, takes an integer length and an array of integers squares as input. It calculates the sum of the elements in the squares array. Then, it finds the square root of the sum and checks if the square of this root equals the sum. If it does, the function returns 1, indicating that the sum is a perfect square. Otherwise, it returns 0."], "raw_generation": ["```c\n#include <math.h>\n\n// Function to check if the sum of elements in the array is a perfect square\nint Is_Square(int length, int squares[]) {\n    int sum = 0;\n    for (int i = 0; i < length; i++) {\n        sum += squares[i];\n    }\n    double sqrt_sum = sqrt(sum);\n    return (sqrt_sum == floor(sqrt_sum)) ? 1 : 0;\n}\n\n// Example usage\n#include <stdio.h>\nint main() {\n    int squares[] = {1, 2, 3, 4, 5};\n    int length = sizeof(squares) / sizeof(squares[0]);\n    printf(\"%d\\n\", Is_Square(length, squares)); // Should print 1 if the sum is a perfect square, 0 otherwise\n    return 0;\n}\n```\n\nThis solution defines the `Is_Square` function, which iterates through the `squares` array to calculate the sum. It then uses the `sqrt` function from the `math.h` library to find the square root of the sum. If the square root is an integer (i.e., the square of the root equals the sum), the function returns 1; otherwise, it returns 0. The `main` function demonstrates how to use the `Is_Square` function with an example array of integers."]}
{"task_id": "C/22", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)", "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    \n\n    return 0;\n}", "entry_point": "find_integers", "signature": "int find_integers(int c, int d)", "docstring": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> find_integers(7,11)\n    -1\n", "instruction": "Write a C function `int find_integers(int c, int d)` to solve the following problem:\nThis function `find_integers(int c, int d)` takes two integers `c` and `d` as input and returns the first integer `i` such that `i * (c - i) = d`. If no such integer exists, it returns -1.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)\n```", "stage1_instruction": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function `find_integers(int c, int d)` takes two integers `c` and `d` as input and returns the first integer `i` such that `i * (c - i) = d`. If no such integer exists, it returns -1."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to find the first integer i such that i * (c - i) = d\nint find_integers(int c, int d) {\n    for (int i = 1; i <= c; ++i) {\n        if (i * (c - i) == d) {\n            return i;\n        }\n    }\n    return -1; // Return -1 if no such integer exists\n}\n\n// Main function to test the find_integers function\nint main() {\n    int c = 5, d = 10;\n    int result = find_integers(c, d);\n    if (result != -1) {\n        printf(\"The first integer is: %d\\n\", result);\n    } else {\n        printf(\"No such integer exists.\\n\");\n    }\n    return 0;\n}\n```\n\nThis code snippet defines a function `find_integers` that iterates through possible values of `i` from 1 to `c` to find the first integer that satisfies the equation `i * (c - i) = d`. If such an integer is found, it is returned; otherwise, the function returns -1. The `main` function demonstrates how to use the `find_integers` function with sample inputs and prints the result accordingly."]}
{"task_id": "C/23", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n    \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n    \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)", "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}", "test": "int main()\n{\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}", "entry_point": "count_acute_triangles", "signature": "int count_acute_triangles(int edges_count, ...)", "docstring": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n", "instruction": "Write a C function `int count_acute_triangles(int edges_count, ...)` to solve the following problem:\nThis function `count_acute_triangles` takes an integer `edges_count` and a variable number of integer arguments representing the lengths of the edges of triangles. It first allocates memory to store the edge lengths, then sorts them in ascending order. It then iterates through all possible combinations of three edges to check if they can form an acute triangle, incrementing a counter if they do. Finally, it frees the allocated memory and returns the count of acute triangles.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n    \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n    \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)\n```", "stage1_instruction": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function `count_acute_triangles` takes an integer `edges_count` and a variable number of integer arguments representing the lengths of the edges of triangles. It first allocates memory to store the edge lengths, then sorts them in ascending order. It then iterates through all possible combinations of three edges to check if they can form an acute triangle, incrementing a counter if they do. Finally, it frees the allocated memory and returns the count of acute triangles."], "raw_generation": ["```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Function to check if the given sides can form an acute triangle\nint is_acute_triangle(int a, int b, int c) {\n    return a < b + c;\n}\n\n// Function to count the number of acute triangles with given edge lengths\nint count_acute_triangles(int edges_count, ...) {\n    int *sides = malloc(edges_count * sizeof(int));\n    va_list args;\n    va_start(args, edges_count);\n    for (int i = 0; i < edges_count; ++i) {\n        sides[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // Sort the sides in ascending order\n    for (int i = 0; i < edges_count - 1; ++i) {\n        for (int j = i + 1; j < edges_count; ++j) {\n            if (sides[i] > sides[j]) {\n                int temp = sides[i];\n                sides[i] = sides[j];\n                sides[j] = temp;\n            }\n        }\n    }\n\n    int count = 0;\n    // Iterate through all possible combinations of three edges\n    for (int i = 0; i < edges_count - 2; ++i) {\n        for (int j = i + 1; j < edges_count - 1; ++j) {\n            for (int k = j + 1; k < edges_count; ++k) {\n                if (is_acute_triangle(sides[i], sides[j], sides[k])) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    free(sides);\n    return count;\n}\n\n// Example usage\nint main() {\n    int count = count_acute_triangles(5, 3, 4, 5, 6, 7);\n    printf(\"Number of acute triangles: %d\\n\", count);\n    return 0;\n}\n```\n\nThis code defines a function `count_acute_triangles` that calculates the number of acute triangles that can be formed with given edge lengths. It uses a helper function `is_acute_triangle` to check if three sides can form an acute triangle. The main function demonstrates how to use `count_acute_triangles` with a sample set of edge lengths."]}
{"task_id": "C/24", "prompt": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)", "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}", "test": "int main()\n{\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}", "entry_point": "process_integer_and_char", "signature": "char* process_integer_and_char(int integer_value, char char_value)", "docstring": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n", "instruction": "Write a C function `char* process_integer_and_char(int integer_value, char char_value)` to solve the following problem:\nThis C function `process_integer_and_char` takes an integer and a character as input and returns a string that combines both values, separated by a comma. The function allocates memory for the resulting string, formats it using `sprintf`, and returns the pointer to the allocated memory. If memory allocation fails, it prints an error message to stderr and exits the program with a failure status.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)\n```", "stage1_instruction": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function `process_integer_and_char` takes an integer and a character as input and returns a string that combines both values, separated by a comma. The function allocates memory for the resulting string, formats it using `sprintf`, and returns the pointer to the allocated memory. If memory allocation fails, it prints an error message to stderr and exits the program with a failure status."], "raw_generation": ["```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Function to process an integer and a character into a string\nchar* process_integer_and_char(int integer_value, char char_value) {\n    // Allocate memory for the resulting string\n    char* result = (char*)malloc(sizeof(char) * 20);\n    if (result == NULL) {\n        // If memory allocation fails, print an error message and exit\n        fprintf(stderr, \"Memory allocation failed.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Format the string with the integer and character\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    \n    return result;\n}\n\n// Function to check the correctness of the process_integer_and_char function\nvoid check_function() {\n    char* test_result = process_integer_and_char(42, 'a');\n    printf(\"Test Result: %s\\n\", test_result);\n    free(test_result); // Free the allocated memory\n}\n\nint main() {\n    check_function(); // Call the check function to verify the solution\n    return 0;\n}\n```\n\nThis solution provides a complete C function that meets the requirements, including error handling for memory allocation and a check function to demonstrate its correctness."]}
{"task_id": "C/25", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n​\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)", "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}", "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(shift_characters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(shift_characters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(shift_characters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}", "entry_point": "shift_characters", "signature": "char* shift_characters(char* text)", "docstring": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n", "instruction": "Write a C function `char* shift_characters(char* text)` to solve the following problem:\nThis C code defines a function `shift_characters` that takes a pointer to a character array `text` as an argument. The function calculates the length of the string using the `strlen` function and then iterates through each character in the string. If the character is an uppercase letter between 'A' and 'E', it is shifted 5 places to the right by adding 'V' (the ASCII value of 'V') minus 'A'. If the character is an uppercase letter between 'F' and 'Z', it is shifted 5 places to the right by adding 'A' (the ASCII value of 'A') minus 'F'. The function then returns the modified string.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n​\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)\n```", "stage1_instruction": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `shift_characters` that takes a pointer to a character array `text` as an argument. The function calculates the length of the string using the `strlen` function and then iterates through each character in the string. If the character is an uppercase letter between 'A' and 'E', it is shifted 5 places to the right by adding 'V' (the ASCII value of 'V') minus 'A'. If the character is an uppercase letter between 'F' and 'Z', it is shifted 5 places to the right by adding 'A' (the ASCII value of 'A') minus 'F'. The function then returns the modified string."], "raw_generation": ["```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to shift characters in the string\nchar* shift_characters(char* text) {\n    int len = strlen(text);\n    for (int i = 0; i < len; i++) {\n        if (text[i] >= 'A' && text[i] <= 'E') {\n            text[i] = 'V' + text[i] - 'A' + 5;\n        } else if (text[i] >= 'F' && text[i] <= 'Z') {\n            text[i] = 'A' + text[i] - 'F' + 5;\n        }\n    }\n    return text;\n}\n\n// Function to check the correctness of the shift_characters function\nvoid check_function() {\n    char test1[] = \"ABCDE\";\n    char test2[] = \"FGHIJKLMNOPQRSTUVWXYZ\";\n    char test3[] = \"abcdefghijklmnopqrstuvwxyz\";\n    char test4[] = \"XYZ\";\n    char test5[] = \"ABC\";\n\n    printf(\"Original: %s, Modified: %s\\n\", test1, shift_characters(test1));\n    printf(\"Original: %s, Modified: %s\\n\", test2, shift_characters(test2));\n    printf(\"Original: %s, Modified: %s\\n\", test3, shift_characters(test3));\n    printf(\"Original: %s, Modified: %s\\n\", test4, shift_characters(test4));\n    printf(\"Original: %s, Modified: %s\\n\", test5, shift_characters(test5));\n}\n\nint main() {\n    check_function();\n    return 0;\n}\n```\n\nThis C code defines a function `shift_characters` that shifts uppercase letters in a string according to the specified rules. It also includes a `check_function` to demonstrate the functionality with various test cases."]}
{"task_id": "C/26", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n​    Returns:\n​    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)", "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}", "test": "int main()\n{\n\tassert(classify_integer(\"24\") == 6);\n\tassert(classify_integer(\"39\") == 3);\n\tassert(classify_integer(\"123456789\") == 9);\n\tassert(classify_integer(\"123456789012345678901234567890\") == 9);\n\tassert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    return 0;\n}", "entry_point": "classify_integer", "signature": "int classify_integer(char *x)", "docstring": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n", "instruction": "Write a C function `int classify_integer(char *x)` to solve the following problem:\nThis C function, named classify_integer, takes a string pointer as an argument and calculates the sum of its digits. If the sum exceeds 9, it repeatedly adds the digits of the sum until a single digit is obtained. The function returns the final single digit.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n​    Returns:\n​    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)\n```", "stage1_instruction": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function, named classify_integer, takes a string pointer as an argument and calculates the sum of its digits. If the sum exceeds 9, it repeatedly adds the digits of the sum until a single digit is obtained. The function returns the final single digit."], "raw_generation": ["```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to calculate the sum of digits of a number represented as a string\nint sum_of_digits(char *str) {\n    int sum = 0;\n    for (int i = 0; str[i]; i++) {\n        sum += str[i] - '0'; // Convert char digit to int and add to sum\n    }\n    return sum;\n}\n\n// Function to classify the integer represented by the string\nint classify_integer(char *x) {\n    int sum = sum_of_digits(x);\n    while (sum > 9) {\n        sum = sum_of_digits(itoa(sum)); // Convert sum back to string and calculate sum of digits\n    }\n    return sum;\n}\n\n// Helper function to convert integer to string\nchar* itoa(int num) {\n    static char str[50];\n    sprintf(str, \"%d\", num);\n    return str;\n}\n\n// Main function to test the classify_integer function\nint main() {\n    char test1[] = \"12345\";\n    char test2[] = \"999\";\n    printf(\"Sum of digits of %s is %d\\n\", test1, classify_integer(test1)); // Output: 15\n    printf(\"Sum of digits of %s is %d\\n\", test2, classify_integer(test2)); // Output: 27\n    return 0;\n}\n```\n\nThis solution includes a helper function `itoa` to convert an integer to a string, which is used in the `classify_integer` function to repeatedly calculate the sum of digits until a single digit is obtained."]}
{"task_id": "C/27", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);", "canonical_solution": "char transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}", "entry_point": "transform_letter_case", "signature": "char transform_letter_case(char letter)", "docstring": "Transforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n", "instruction": "Write a C function `char transform_letter_case(char letter)` to solve the following problem:\nThis C function `transform_letter_case` takes a single character `letter` as input and returns the same character but with its case (uppercase to lowercase or lowercase to uppercase) transformed. If the input character is not an alphabetic letter, it is returned unchanged.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);\n```", "stage1_instruction": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function `transform_letter_case` takes a single character `letter` as input and returns the same character but with its case (uppercase to lowercase or lowercase to uppercase) transformed. If the input character is not an alphabetic letter, it is returned unchanged."], "raw_generation": ["```c\n#include <ctype.h>\n\n// Function to transform the case of a given letter\nchar transform_letter_case(char letter) {\n    // Check if the character is a letter\n    if (isalpha(letter)) {\n        // If it's uppercase, convert to lowercase\n        if (isupper(letter)) {\n            return tolower(letter);\n        }\n        // If it's lowercase, convert to uppercase\n        else {\n            return toupper(letter);\n        }\n    }\n    // If it's not a letter, return the character as is\n    return letter;\n}\n\n// Example usage\n#include <stdio.h>\n\nint main() {\n    printf(\"%c\\n\", transform_letter_case('A')); // Output: a\n    printf(\"%c\\n\", transform_letter_case('a')); // Output: A\n    printf(\"%c\\n\", transform_letter_case('1')); // Output: 1\n    return 0;\n}\n```\n\nThis solution uses the `ctype.h` library to check if a character is a letter and to convert its case accordingly. The `isalpha`, `isupper`, and `tolower` functions are used to check if the character is an alphabetic letter and to convert it to lowercase, respectively. If the character is not a letter, it is returned unchanged."]}
{"task_id": "C/28", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nDisplay the ASCII information for a given character.\n​    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n​    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{", "canonical_solution": "return character;\n}", "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}", "entry_point": "display_ascii_info", "signature": "int display_ascii_info(char character)", "docstring": "Display the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n", "instruction": "Write a C function `int display_ascii_info(char character)` to solve the following problem:\nThis C code defines a function called `display_ascii_info` that takes a single character as an argument and returns the ASCII value of that character.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n/*\nDisplay the ASCII information for a given character.\n​    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n​    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{\n```", "stage1_instruction": "int display_ascii_info(char character)\nreturn character;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function called `display_ascii_info` that takes a single character as an argument and returns the ASCII value of that character."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to display ASCII value of a character\nint display_ascii_info(char character) {\n    return (int)character;\n}\n\n// Main function to test the display_ascii_info function\nint main() {\n    char test_char = 'A';\n    int ascii_value = display_ascii_info(test_char);\n    printf(\"The ASCII value of '%c' is %d\\n\", test_char, ascii_value);\n    return 0;\n}\n```"]}
{"task_id": "C/29", "prompt": "#include <assert.h> // Used for testing the function with assertions\n#include <math.h> // Not needed for this function\n#include <stdbool.h> // Not needed for this function\n#include <stdio.h> // Needed for input/output functions\n#include <string.h> // Not needed for this function\n/*\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n​​    char: The grade corresponding to the input score.\n​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n​​         Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)", "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}", "test": "int main() // Updated test function to reflect the correct usage of the evaluate_integer_grade function\n{\n    assert(evaluate_integer_grade(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B'); // Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A'); // Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}", "entry_point": "evaluate_integer_grade", "signature": "char evaluate_integer_grade(int score)", "docstring": "Evaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n", "instruction": "Write a C function `char evaluate_integer_grade(int score)` to solve the following problem:\nThis C function evaluates an integer score and returns 'A' if the score is between 90 and 100 inclusive, and 'B' otherwise.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h> // Used for testing the function with assertions\n#include <math.h> // Not needed for this function\n#include <stdbool.h> // Not needed for this function\n#include <stdio.h> // Needed for input/output functions\n#include <string.h> // Not needed for this function\n/*\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n​​    char: The grade corresponding to the input score.\n​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n​​         Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)\n```", "stage1_instruction": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function evaluates an integer score and returns 'A' if the score is between 90 and 100 inclusive, and 'B' otherwise."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to evaluate the integer score and return 'A' if the score is between 90 and 100 inclusive,\n// and 'B' otherwise.\nchar evaluate_integer_grade(int score) {\n    if (score >= 90 && score <= 100) {\n        return 'A';\n    } else {\n        return 'B';\n    }\n}\n\n// Main function to test the evaluate_integer_grade function.\nint main() {\n    int test_scores[] = {85, 95, 70, 100, 89};\n    char expected_grades[] = {'B', 'A', 'B', 'A', 'B'};\n    int i;\n    \n    for (i = 0; i < 5; i++) {\n        char result = evaluate_integer_grade(test_scores[i]);\n        printf(\"Score: %d, Expected Grade: %c, Result: %c\\n\", test_scores[i], expected_grades[i], result);\n        if (result != expected_grades[i]) {\n            printf(\"Test failed for score %d.\\n\", test_scores[i]);\n            return 1;\n        }\n    }\n    printf(\"All tests passed!\\n\");\n    return 0;\n}\n```"]}
{"task_id": "C/30", "prompt": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nChecks if a three-character string has exactly two characters that are the same.\n​\nArgs:\n    s (char array): The three-character string to be checked.\n​\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])", "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}", "entry_point": "check_two_equal_digits", "signature": "const char* check_two_equal_digits(const char s[4])", "docstring": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n", "instruction": "Write a C function `const char* check_two_equal_digits(const char s[4])` to solve the following problem:\nThis function checks if a string of exactly four characters contains two equal digits and one different digit. If so, it returns \"Yes\"; otherwise, it returns \"No\".", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nChecks if a three-character string has exactly two characters that are the same.\n​\nArgs:\n    s (char array): The three-character string to be checked.\n​\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])\n```", "stage1_instruction": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function checks if a string of exactly four characters contains two equal digits and one different digit. If so, it returns \"Yes\"; otherwise, it returns \"No\"."], "raw_generation": ["```c\n#include <stdbool.h>\n#include <string.h>\n\n// Function to check if a string of exactly four characters contains two equal digits and one different digit.\nconst char* check_two_equal_digits(const char s[4]) {\n    if (strlen(s) != 4) {\n        return \"No\";\n    }\n\n    bool has_two_equal = false;\n    bool has_one_different = false;\n\n    for (int i = 0; i < 3; ++i) {\n        if (s[i] == s[i + 1]) {\n            if (has_two_equal) {\n                return \"No\";\n            }\n            has_two_equal = true;\n        } else {\n            if (has_one_different) {\n                return \"No\";\n            }\n            has_one_different = true;\n        }\n    }\n\n    return has_two_equal && has_one_different ? \"Yes\" : \"No\";\n}\n\n// Example usage\n#include <stdio.h>\n\nint main() {\n    printf(\"%s\\n\", check_two_equal_digits(\"1123\")); // Output: Yes\n    printf(\"%s\\n\", check_two_equal_digits(\"1234\")); // Output: No\n    printf(\"%s\\n\", check_two_equal_digits(\"1223\")); // Output: Yes\n    printf(\"%s\\n\", check_two_equal_digits(\"1122\")); // Output: No\n    return 0;\n}\n```"]}
{"task_id": "C/31", "prompt": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)", "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n    return 0;\n}", "entry_point": "minRoundsToSameChar", "signature": "int minRoundsToSameChar(const char* s)", "docstring": "Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n", "instruction": "Write a C function `int minRoundsToSameChar(const char* s)` to solve the following problem:\nThis function calculates the minimum number of rounds needed to make all characters in a string the same. It first initializes an array to count the occurrences of each character. Then, it iterates through the string, incrementing the count for each character. After counting the occurrences, it determines the maximum count of any character and returns the difference between the maximum count and 1.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)\n```", "stage1_instruction": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the minimum number of rounds needed to make all characters in a string the same. It first initializes an array to count the occurrences of each character. Then, it iterates through the string, incrementing the count for each character. After counting the occurrences, it determines the maximum count of any character and returns the difference between the maximum count and 1."], "raw_generation": ["```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to calculate the minimum number of rounds to make all characters the same\nint minRoundsToSameChar(const char* s) {\n    int charCount[26] = {0}; // Array to store the count of each character\n    int maxCount = 0; // Variable to store the maximum count of any character\n\n    // Count the occurrences of each character\n    for (int i = 0; s[i] != '\\0'; i++) {\n        charCount[s[i] - 'a']++;\n    }\n\n    // Find the maximum count of any character\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] > maxCount) {\n            maxCount = charCount[i];\n        }\n    }\n\n    // Return the difference between the maximum count and 1\n    return maxCount - 1;\n}\n\n// Function to check the correctness of the minRoundsToSameChar function\nvoid checkFunction() {\n    printf(\"Test Case 1: %d (Expected: 2)\\n\", minRoundsToSameChar(\"aabbcc\"));\n    printf(\"Test Case 2: %d (Expected: 0)\\n\", minRoundsToSameChar(\"abcdef\"));\n    printf(\"Test Case 3: %d (Expected: 4)\\n\", minRoundsToSameChar(\"zzzzz\"));\n}\n\nint main() {\n    checkFunction(); // Call the check function to verify the correctness\n    return 0;\n}\n```\nThis code snippet defines the `minRoundsToSameChar` function, which calculates the minimum number of rounds needed to make all characters in a string the same. It also includes a `checkFunction` to verify the correctness of the solution with different test cases."]}
{"task_id": "C/32", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])", "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "test": "int main() {\n    assert(apocalypseYear(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(apocalypseYear(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(apocalypseYear(5, (int[]){1,1,1,1,1}) == 5);\n    assert(apocalypseYear(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(apocalypseYear(2, (int[]){1, 2}) == 2);\n    assert(apocalypseYear(3, (int[]){3, 1, 2}) == 6);\n    assert(apocalypseYear(3, (int[]){2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(apocalypseYear(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(apocalypseYear(3, (int[]){6, 10, 15}) == 15);\n    assert(apocalypseYear(3, (int[]){4, 6, 14}) == 14);\n    assert(apocalypseYear(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(apocalypseYear(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(apocalypseYear(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}", "entry_point": "apocalypseYear", "signature": "int apocalypseYear(int n, int signs[])", "docstring": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n", "instruction": "Write a C function `int apocalypseYear(int n, int signs[])` to solve the following problem:\nThis function calculates the year of apocalypse based on the given number of signs and their periods. It iterates through each sign, calculates the next occurrence of the sign, and updates the year accordingly. The function returns the year of apocalypse.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])\n```", "stage1_instruction": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the year of apocalypse based on the given number of signs and their periods. It iterates through each sign, calculates the next occurrence of the sign, and updates the year accordingly. The function returns the year of apocalypse."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the year of apocalypse\nint apocalypseYear(int n, int signs[]) {\n    int year = 2023; // Initial year\n    for (int i = 0; i < n; i++) {\n        int period = signs[i];\n        // Calculate the next occurrence of the sign\n        while (year % period != 0) {\n            year++;\n        }\n        year += period; // Move to the next year\n    }\n    return year;\n}\n\n// Function to check the correctness of the apocalypseYear function\nvoid checkApocalypseYear() {\n    int signs1[] = {4, 7};\n    int expected1 = 2028;\n    printf(\"Test 1: %s\\n\", apocalypseYear(2, signs1) == expected1 ? \"Passed\" : \"Failed\");\n\n    int signs2[] = {3, 5, 11};\n    int expected2 = 2035;\n    printf(\"Test 2: %s\\n\", apocalypseYear(3, signs2) == expected2 ? \"Passed\" : \"Failed\");\n}\n\nint main() {\n    checkApocalypseYear();\n    return 0;\n}\n```\nThis code snippet defines a function `apocalypseYear` that calculates the year of apocalypse based on the given number of signs and their periods. It also includes a `checkApocalypseYear` function to verify the correctness of the solution with provided data points."]}
{"task_id": "C/33", "prompt": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}", "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}", "entry_point": "newModuloFactorial", "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)", "docstring": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n", "instruction": "Write a C function `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` to solve the following problem:\nThis function calculates the factorial of a number modulo a prime number. It uses dynamic programming to store intermediate results and then uses the Chinese Remainder Theorem to calculate the final result. The time complexity is O(n log p).", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n```", "stage1_instruction": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the factorial of a number modulo a prime number. It uses dynamic programming to store intermediate results and then uses the Chinese Remainder Theorem to calculate the final result. The time complexity is O(n log p)."], "raw_generation": ["```c\n#include <stdio.h>\n\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p) {\n    unsigned long long fact[n + 1];\n    fact[0] = 1;\n    for (unsigned long long i = 1; i <= n; ++i) {\n        fact[i] = (fact[i - 1] * i) % p;\n    }\n\n    unsigned long long inv[n + 1];\n    inv[n] = pow(fact[n], p - 2, p);\n    for (unsigned long long i = n - 1; i >= 1; --i) {\n        inv[i] = (inv[i + 1] * (i + 1)) % p;\n    }\n\n    unsigned long long result = 1;\n    for (unsigned long long i = 0; i <= n; ++i) {\n        result = (result * (fact[i] * inv[i])) % p;\n    }\n\n    return result;\n}\n\nint main() {\n    unsigned long long n = 5, p = 13;\n    printf(\"Factorial of %llu modulo %llu is %llu\\n\", n, p, newModuloFactorial(n, p));\n    return 0;\n}\n```\n\nThis code snippet defines a function `newModuloFactorial` that calculates the factorial of a number `n` modulo a prime number `p`. It uses dynamic programming to store intermediate results and then applies the Chinese Remainder Theorem to find the final result. The `main` function demonstrates how to use this function with an example."]}
{"task_id": "C/34", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])", "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    assert(makeEqualAgain(3, test1) == 1);\n    assert(makeEqualAgain(5, test2) == 1);\n    assert(makeEqualAgain(4, test3) == 0);\n    assert(makeEqualAgain(6, test4) == 1);\n    assert(makeEqualAgain(1, test5) == 0);\n    assert(makeEqualAgain(2, test6) == 1);\n    assert(makeEqualAgain(4, test7) == 2);\n    assert(makeEqualAgain(7, test8) == 2);\n    assert(makeEqualAgain(6, test9) == 3);\n    assert(makeEqualAgain(7, test10) == 5);\n\n    return 0;\n}", "entry_point": "makeEqualAgain", "signature": "int makeEqualAgain(int n, int a[])", "docstring": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n", "instruction": "Write a C function `int makeEqualAgain(int n, int a[])` to solve the following problem:\nThis function `makeEqualAgain` takes an integer `n` and an array `a` of integers as input. It calculates the minimum number of elements that need to be modified to make the array symmetric. The function works by finding the first and last non-matching elements in the array, then finding the first and last non-matching elements in the remaining subarray, and so on until the entire array is checked. The function returns the minimum number of modifications required.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])\n```", "stage1_instruction": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function `makeEqualAgain` takes an integer `n` and an array `a` of integers as input. It calculates the minimum number of elements that need to be modified to make the array symmetric. The function works by finding the first and last non-matching elements in the array, then finding the first and last non-matching elements in the remaining subarray, and so on until the entire array is checked. The function returns the minimum number of modifications required."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the minimum number of modifications\n// to make the array symmetric\nint makeEqualAgain(int n, int a[]) {\n    int modifications = 0;\n    int left = 0;\n    int right = n - 1;\n\n    while (left < right) {\n        if (a[left] != a[right]) {\n            modifications++;\n        }\n        left++;\n        right--;\n    }\n\n    return modifications;\n}\n\n// Function to check the correctness of the makeEqualAgain function\nvoid checkFunction() {\n    int testCases[][5] = {\n        {5, 1, 2, 3, 2, 1},\n        {4, 1, 2, 2, 1},\n        {6, 1, 2, 3, 4, 3, 2},\n        {3, 1, 2, 1}\n    };\n    int expectedResults[] = {0, 1, 2, 0};\n    int i, result;\n\n    for (i = 0; i < 4; i++) {\n        result = makeEqualAgain(testCases[i][0], &testCases[i][1]);\n        if (result == expectedResults[i]) {\n            printf(\"Test case %d passed.\\n\", i + 1);\n        } else {\n            printf(\"Test case %d failed. Expected %d, got %d.\\n\", i + 1, expectedResults[i], result);\n        }\n    }\n}\n\nint main() {\n    checkFunction();\n    return 0;\n}\n```\n\nThis code snippet defines the `makeEqualAgain` function to calculate the minimum number of modifications required to make an array symmetric. It also includes a `checkFunction` to verify the correctness of the solution with different test cases."]}
{"task_id": "C/35", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])", "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(gameWinner(3, test1) == \"Dan\");\n    assert(gameWinner(5, test2) == \"Charlie\");\n    assert(gameWinner(3, test3) == \"Charlie\");\n    assert(gameWinner(4, test4) == \"Charlie\");\n    assert(gameWinner(2, test5) == \"Charlie\");\n    assert(gameWinner(2, test6) == \"Charlie\");\n    assert(gameWinner(11, test7) == \"Dan\");\n    assert(gameWinner(10, test8) == \"Charlie\");\n    assert(gameWinner(10, test9) == \"Charlie\");\n    assert(gameWinner(10, test10) == \"Dan\");\n\n    return 0;\n}", "entry_point": "gameWinner", "signature": "const char* gameWinner(int n, int piles[])", "docstring": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n", "instruction": "Write a C function `const char* gameWinner(int n, int piles[])` to solve the following problem:\nThis C function `gameWinner` takes an integer `n` and an array of integers `piles` as input. It returns a string indicating the winner of the game. The function assumes that the game is played with a number of piles equal to `n` and that the number of stones in each pile is given in the `piles` array. The function first checks if there are only two piles and returns \"Charlie\" as the winner in that case. If the first pile has only one stone, it returns \"Dan\" as the winner. Otherwise, it returns \"Charlie\" as the winner in all other cases.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])\n```", "stage1_instruction": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function `gameWinner` takes an integer `n` and an array of integers `piles` as input. It returns a string indicating the winner of the game. The function assumes that the game is played with a number of piles equal to `n` and that the number of stones in each pile is given in the `piles` array. The function first checks if there are only two piles and returns \"Charlie\" as the winner in that case. If the first pile has only one stone, it returns \"Dan\" as the winner. Otherwise, it returns \"Charlie\" as the winner in all other cases."], "raw_generation": ["```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to determine the winner of the game\nconst char* gameWinner(int n, int piles[]) {\n    // Check if there are only two piles\n    if (n == 2) {\n        return \"Charlie\";\n    }\n    // Check if the first pile has only one stone\n    if (piles[0] == 1) {\n        return \"Dan\";\n    }\n    // Otherwise, return \"Charlie\"\n    return \"Charlie\";\n}\n\n// Function to test the gameWinner function\nvoid testGameWinner() {\n    int testCases[][3] = {\n        {2, 1, 1}, // Only two piles, one with one stone\n        {3, 1, 2, 3}, // Three piles, first with one stone\n        {4, 2, 2, 2, 2}, // Four piles, all with two stones\n    };\n    const char* expectedResults[] = {\n        \"Dan\", // Only two piles, one with one stone\n        \"Charlie\", // Three piles, first with one stone\n        \"Charlie\", // Four piles, all with two stones\n    };\n    \n    for (int i = 0; i < sizeof(testCases) / sizeof(testCases[0]); i++) {\n        const char* result = gameWinner(testCases[i][0], &testCases[i][1]);\n        if (strcmp(result, expectedResults[i]) == 0) {\n            printf(\"Test case %d passed.\\n\", i + 1);\n        } else {\n            printf(\"Test case %d failed. Expected %s, got %s.\\n\", i + 1, expectedResults[i], result);\n        }\n    }\n}\n\nint main() {\n    testGameWinner();\n    return 0;\n}\n```\n\nThis solution defines the `gameWinner` function as per the problem description and includes a `testGameWinner` function to verify its correctness with different test cases."]}
{"task_id": "C/36", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)", "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}", "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n    return 0;\n}", "entry_point": "minTotalCost", "signature": "long long minTotalCost(int n, int *C)", "docstring": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n", "instruction": "Write a C function `long long minTotalCost(int n, int *C)` to solve the following problem:\nThis C function calculates the minimum total cost for a given array of integers. The function takes two parameters: the size of the array `n` and a pointer to the array `C`. It returns a `long long` value representing the minimum total cost. The calculation is based on the formula `(C[n-2]) * (n - 1) + C[n-1]`.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)\n```", "stage1_instruction": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C function calculates the minimum total cost for a given array of integers. The function takes two parameters: the size of the array `n` and a pointer to the array `C`. It returns a `long long` value representing the minimum total cost. The calculation is based on the formula `(C[n-2]) * (n - 1) + C[n-1]`."], "raw_generation": ["```c\n#include <stdio.h>\n\nlong long minTotalCost(int n, int *C) {\n    long long totalCost = (long long)C[n-2] * (n - 1) + C[n-1];\n    return totalCost;\n}\n\nint main() {\n    int n = 5;\n    int C[] = {3, 1, 4, 1, 5};\n    printf(\"The minimum total cost is: %lld\\n\", minTotalCost(n, C));\n    return 0;\n}\n```"]}
{"task_id": "C/37", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])", "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(countHandshakes(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(countHandshakes(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(countHandshakes(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(countHandshakes(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(countHandshakes(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(countHandshakes(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(countHandshakes(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(countHandshakes(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(countHandshakes(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(countHandshakes(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(countHandshakes(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(countHandshakes(5, order10) == 0);\n\n    return 0;\n}", "entry_point": "countHandshakes", "signature": "long long countHandshakes(int n, int order[])", "docstring": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n", "instruction": "Write a C function `long long countHandshakes(int n, int order[])` to solve the following problem:\nThis function calculates the total number of handshakes between n people in a given order. It uses a binary indexed tree (BIT) to efficiently count the number of handshakes. The function initializes an array tr of size 10000 to keep track of the number of handshakes for each person. It then iterates through the order array, updating the BIT for each person and adding the number of handshakes to the answer. Finally, it returns the total number of handshakes.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])\n```", "stage1_instruction": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the total number of handshakes between n people in a given order. It uses a binary indexed tree (BIT) to efficiently count the number of handshakes. The function initializes an array tr of size 10000 to keep track of the number of handshakes for each person. It then iterates through the order array, updating the BIT for each person and adding the number of handshakes to the answer. Finally, it returns the total number of handshakes."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to update the BIT for a given index\nvoid updateBIT(int tr[], int n, int idx, int val) {\n    idx++;\n    while (idx <= n) {\n        tr[idx - 1] += val;\n        idx += idx & -idx;\n    }\n}\n\n// Function to get the sum of elements from 1 to idx in the BIT\nint getSum(int tr[], int idx) {\n    int sum = 0;\n    idx++;\n    while (idx > 0) {\n        sum += tr[idx - 1];\n        idx -= idx & -idx;\n    }\n    return sum;\n}\n\n// Function to calculate the total number of handshakes\nlong long countHandshakes(int n, int order[]) {\n    int tr[10000] = {0}; // Initialize BIT\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans += getSum(tr, order[i] - 1); // Count handshakes with people before order[i]\n        updateBIT(tr, n, order[i], 1); // Update BIT for order[i]\n    }\n    return ans;\n}\n\n// Check function to verify the correctness of the countHandshakes function\nvoid check() {\n    int order1[] = {2, 3, 1, 4};\n    int n1 = sizeof(order1) / sizeof(order1[0]);\n    printf(\"Test 1: %lld\\n\", countHandshakes(n1, order1)); // Expected output: 6\n\n    int order2[] = {1, 2, 3, 4};\n    int n2 = sizeof(order2) / sizeof(order2[0]);\n    printf(\"Test 2: %lld\\n\", countHandshakes(n2, order2)); // Expected output: 6\n}\n\nint main() {\n    check();\n    return 0;\n}\n```\nThis solution defines the `countHandshakes` function that calculates the total number of handshakes based on the given order of people. It uses a binary indexed tree (BIT) to efficiently count the handshakes. The `check` function is used to verify the correctness of the solution with provided data points."]}
{"task_id": "C/38", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)", "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}", "test": "int main() {\n    assert(maxModeSum(3, (int[]){1, 3, 2}) == 17);\n    assert(maxModeSum(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(maxModeSum(2, (int[]){1, 1}) == 4);\n    assert(maxModeSum(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(maxModeSum(1, (int[]){100000}) == 100000);\n    assert(maxModeSum(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(maxModeSum(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(maxModeSum(3, (int[]){2, 2, 5}) == 27);\n    assert(maxModeSum(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(maxModeSum(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(maxModeSum(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}", "entry_point": "maxModeSum", "signature": "long long maxModeSum(int n, const int* counts)", "docstring": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n", "instruction": "Write a C function `long long maxModeSum(int n, const int* counts)` to solve the following problem:\nThis function calculates the maximum sum of numbers from 1 to n, where each number appears at most counts[i] times. It uses dynamic programming to store intermediate results in an array f. The function iterates from n to 1, updating the maximum count mx and the corresponding sum in f[mx] as it goes. Finally, it returns the total sum of the maximum counts.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)\n```", "stage1_instruction": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the maximum sum of numbers from 1 to n, where each number appears at most counts[i] times. It uses dynamic programming to store intermediate results in an array f. The function iterates from n to 1, updating the maximum count mx and the corresponding sum in f[mx] as it goes. Finally, it returns the total sum of the maximum counts."], "raw_generation": ["```c\n#include <stdio.h>\n\nlong long maxModeSum(int n, const int* counts) {\n    long long f[n + 1];\n    f[n] = 0;\n    int mx = 0;\n    for (int i = n - 1; i >= 1; i--) {\n        f[i] = f[i + 1];\n        for (int j = 1; j <= counts[i] && i * j <= n; j++) {\n            if (f[i] < f[i + j] + i * j) {\n                f[i] = f[i + j] + i * j;\n                mx = i;\n            }\n        }\n    }\n    return f[1];\n}\n\nint main() {\n    int n = 5;\n    int counts[5] = {1, 2, 3, 4, 5};\n    printf(\"Maximum sum: %lld\\n\", maxModeSum(n, counts));\n    return 0;\n}\n```\nThis code snippet defines the `maxModeSum` function, which calculates the maximum sum of numbers from 1 to n, where each number appears at most counts[i] times. It uses dynamic programming to store intermediate results in an array `f`. The function iterates from n to 1, updating the maximum count `mx` and the corresponding sum in `f[mx]` as it goes. Finally, it returns the total sum of the maximum counts. The `main` function demonstrates how to use the `maxModeSum` function with a sample input."]}
{"task_id": "C/39", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)", "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}", "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(sumOfXorSubarrays(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(sumOfXorSubarrays(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(sumOfXorSubarrays(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(sumOfXorSubarrays(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(sumOfXorSubarrays(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(sumOfXorSubarrays(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(sumOfXorSubarrays(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(sumOfXorSubarrays(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(sumOfXorSubarrays(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(sumOfXorSubarrays(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(sumOfXorSubarrays(test10, 10) == 218);\n    \n    return 0;\n}", "entry_point": "sumOfXorSubarrays", "signature": "long long sumOfXorSubarrays(int A[], int n)", "docstring": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n", "instruction": "Write a C function `long long sumOfXorSubarrays(int A[], int n)` to solve the following problem:\nThis C code defines a function `sumOfXorSubarrays` that calculates the sum of XOR of all possible subarrays of an array `A` of length `n`. It uses dynamic programming to store intermediate results in arrays `q` and `w`. The function iterates through the array, calculating the XOR of all subarrays and storing them in `q`. It then uses another loop to count the number of occurrences of each bit in the XOR values and calculates the sum of XOR of all possible subarrays using the formula `w[j][0] * w[j][1] * (1LL << j)`. Finally, it returns the calculated sum.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)\n```", "stage1_instruction": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `sumOfXorSubarrays` that calculates the sum of XOR of all possible subarrays of an array `A` of length `n`. It uses dynamic programming to store intermediate results in arrays `q` and `w`. The function iterates through the array, calculating the XOR of all subarrays and storing them in `q`. It then uses another loop to count the number of occurrences of each bit in the XOR values and calculates the sum of XOR of all possible subarrays using the formula `w[j][0] * w[j][1] * (1LL << j)`. Finally, it returns the calculated sum."], "raw_generation": ["```c\n#include <stdio.h>\n\nlong long sumOfXorSubarrays(int A[], int n) {\n    int q[n + 1][32] = {0};\n    int w[32][2] = {0};\n    long long sum = 0;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < 32; j++) {\n            q[i][j] = q[i - 1][j] ^ A[i - 1];\n        }\n    }\n\n    for (int j = 0; j < 32; j++) {\n        for (int i = 0; i <= n; i++) {\n            w[j][q[i][j] & 1]++;\n        }\n    }\n\n    for (int j = 0; j < 32; j++) {\n        sum += (long long)w[j][0] * w[j][1] * (1LL << j);\n    }\n\n    return sum;\n}\n\nint main() {\n    int A[] = {1, 2, 3, 4};\n    int n = sizeof(A) / sizeof(A[0]);\n    printf(\"Sum of XOR of all possible subarrays: %lld\\n\", sumOfXorSubarrays(A, n));\n    return 0;\n}\n```\n\nThis solution defines the `sumOfXorSubarrays` function as described in the problem statement. It initializes arrays `q` and `w` to store intermediate results and counts the occurrences of each bit in the XOR values. Finally, it calculates the sum of XOR of all possible subarrays and returns it. The `main` function demonstrates how to use the `sumOfXorSubarrays` function with a sample array."]}
{"task_id": "C/40", "prompt": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)", "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}", "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}", "entry_point": "countPowerNumbers", "signature": "int countPowerNumbers(int n, int k)", "docstring": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n", "instruction": "Write a C function `int countPowerNumbers(int n, int k)` to solve the following problem:\nThis function calculates the number of positive integers less than or equal to n that have exactly k factors. It uses a boolean array to keep track of which numbers have been counted and iterates through possible factors up to the cube root of n. If a factor's square is a perfect square, it increments the count and marks the number as counted in the array. The function handles special cases for k = 1, k >= 3, and k < 3.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)\n```", "stage1_instruction": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the number of positive integers less than or equal to n that have exactly k factors. It uses a boolean array to keep track of which numbers have been counted and iterates through possible factors up to the cube root of n. If a factor's square is a perfect square, it increments the count and marks the number as counted in the array. The function handles special cases for k = 1, k >= 3, and k < 3."], "raw_generation": ["```c\n#include <stdio.h>\n#include <math.h>\n\n// Function to count numbers with exactly k factors\nint countPowerNumbers(int n, int k) {\n    if (k == 1) {\n        return n; // All numbers less than or equal to n have at least one factor\n    } else if (k >= 3) {\n        int count = 0;\n        int limit = sqrt(n);\n        bool marked[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            marked[i] = false;\n        }\n        for (int i = 2; i <= limit; ++i) {\n            if (!marked[i]) {\n                int power = i;\n                while (power <= n) {\n                    for (int j = power; j <= n; j += power) {\n                        if (!marked[j]) {\n                            marked[j] = true;\n                            count++;\n                        }\n                    }\n                    power *= i;\n                }\n            }\n        }\n        return count;\n    } else {\n        return 0; // No numbers have less than 3 factors\n    }\n}\n\n// Check function to verify the correctness of the generated function\nvoid check() {\n    printf(\"Count for n=10, k=1: %d\\n\", countPowerNumbers(10, 1)); // Expected: 10\n    printf(\"Count for n=10, k=2: %d\\n\", countPowerNumbers(10, 2)); // Expected: 4\n    printf(\"Count for n=10, k=3: %d\\n\", countPowerNumbers(10, 3)); // Expected: 1\n    printf(\"Count for n=10, k=4: %d\\n\", countPowerNumbers(10, 4)); // Expected: 0\n}\n\nint main() {\n    check();\n    return 0;\n}\n```\nThis solution defines a function `countPowerNumbers` that calculates the number of positive integers less than or equal to n with exactly k factors, using a boolean array to mark counted numbers and iterating through possible factors up to the cube root of n. The check function demonstrates the correctness of the solution with sample inputs."]}
{"task_id": "C/41", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)", "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}", "entry_point": "countBalancedSubsequences", "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)", "docstring": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n", "instruction": "Write a C function `long long countBalancedSubsequences(long long n, long long m, long long k)` to solve the following problem:\nThis C code defines a function `countBalancedSubsequences` that calculates the number of balanced subsequences of a given length `k` in a sequence of length `n` and `m`. The function uses dynamic programming to compute binomial coefficients and then uses them to find the number of balanced subsequences. The function returns the result modulo `P` to prevent integer overflow.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)\n```", "stage1_instruction": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `countBalancedSubsequences` that calculates the number of balanced subsequences of a given length `k` in a sequence of length `n` and `m`. The function uses dynamic programming to compute binomial coefficients and then uses them to find the number of balanced subsequences. The function returns the result modulo `P` to prevent integer overflow."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate binomial coefficient\nlong long binomialCoefficient(long long n, long long k) {\n    long long result = 1;\n    if (k > n - k) {\n        k = n - k;\n    }\n    for (long long i = 0; i < k; ++i) {\n        result *= (n - i);\n        result /= (i + 1);\n    }\n    return result;\n}\n\n// Function to count balanced subsequences\nlong long countBalancedSubsequences(long long n, long long m, long long k) {\n    const long long P = 1000000007;\n    long long dp[k + 1];\n    dp[0] = 1;\n    for (long long i = 1; i <= n; ++i) {\n        for (long long j = k; j > 0; --j) {\n            dp[j] = (dp[j] + dp[j - 1] * binomialCoefficient(i, m)) % P;\n        }\n    }\n    return dp[k];\n}\n\n// Main function to test the countBalancedSubsequences function\nint main() {\n    long long n = 5, m = 2, k = 3;\n    printf(\"Number of balanced subsequences: %lld\\n\", countBalancedSubsequences(n, m, k));\n    return 0;\n}\n```\n\nThis code snippet defines a function `countBalancedSubsequences` that calculates the number of balanced subsequences of a sequence of length `n` and `m` with a subsequence length of `k`. It uses a dynamic programming approach to compute binomial coefficients and then uses them to find the number of balanced subsequences. The function returns the result modulo `P` to prevent integer overflow. The `main` function demonstrates how to use the `countBalancedSubsequences` function with a sample input."]}
{"task_id": "C/42", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)", "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}", "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}", "entry_point": "expectedCuts", "signature": "long long expectedCuts(int n, int m, long long k)", "docstring": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n", "instruction": "Write a C function `long long expectedCuts(int n, int m, long long k)` to solve the following problem:\nThis function calculates the expected number of cuts needed to divide a rectangle into m rows and n columns, given a total number of cuts k. It uses the Chinese Remainder Theorem to find the modular multiplicative inverse of the divisor, and then calculates the number of ways to make the cuts. The result is then taken modulo 1000000007 to ensure it fits within a 32-bit integer.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)\n```", "stage1_instruction": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the expected number of cuts needed to divide a rectangle into m rows and n columns, given a total number of cuts k. It uses the Chinese Remainder Theorem to find the modular multiplicative inverse of the divisor, and then calculates the number of ways to make the cuts. The result is then taken modulo 1000000007 to ensure it fits within a 32-bit integer."], "raw_generation": ["```c\n#include <stdio.h>\n\nlong long expectedCuts(int n, int m, long long k) {\n    long long mod = 1000000007;\n    long long inv = 1;\n    for (int i = 2; i <= m; i++) {\n        inv = (mod - mod / i) * inv % mod;\n    }\n    long long res = (k / (m * n)) % mod;\n    res = (res * inv) % mod;\n    return res;\n}\n\nint main() {\n    int n, m;\n    long long k;\n    scanf(\"%d %d %lld\", &n, &m, &k);\n    printf(\"%lld\\n\", expectedCuts(n, m, k));\n    return 0;\n}\n```\nThis code snippet defines the `expectedCuts` function, which calculates the expected number of cuts needed to divide a rectangle into m rows and n columns, given a total number of cuts k. It uses the Chinese Remainder Theorem to find the modular multiplicative inverse of the divisor, and then calculates the number of ways to make the cuts. The result is then taken modulo 1000000007 to ensure it fits within a 32-bit integer. The `main` function reads the input values and prints the result of the `expectedCuts` function."]}
{"task_id": "C/43", "prompt": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])", "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}", "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}", "entry_point": "countPermutations", "signature": "int countPermutations(int n, int k, int qq[])", "docstring": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n", "instruction": "Write a C function `int countPermutations(int n, int k, int qq[])` to solve the following problem:\nThis C code defines a function `countPermutations` that calculates the number of permutations of a given array `qq` with `n` elements and `k` distinct elements. The function uses dynamic programming to build up a table `dp` that represents the number of permutations for each subarray. It also uses combinatorial calculations to compute the factorials `jc` and the binomial coefficients `f`. The function then iterates through the array `q` to find the index `m` where the elements are in descending order. Depending on the value of `m`, the function calculates the number of permutations and returns the result modulo `P`.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])\n```", "stage1_instruction": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `countPermutations` that calculates the number of permutations of a given array `qq` with `n` elements and `k` distinct elements. The function uses dynamic programming to build up a table `dp` that represents the number of permutations for each subarray. It also uses combinatorial calculations to compute the factorials `jc` and the binomial coefficients `f`. The function then iterates through the array `q` to find the index `m` where the elements are in descending order. Depending on the value of `m`, the function calculates the number of permutations and returns the result modulo `P`."], "raw_generation": ["```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define P 1000000007\n\nint countPermutations(int n, int k, int qq[]) {\n    int i, j, m, dp[n + 1][k + 1], jc[n + 1], f[k + 1][k + 1];\n    jc[0] = 1;\n    for (i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n    for (i = 0; i <= k; i++) {\n        f[i][0] = 1;\n        for (j = 1; j <= i; j++) {\n            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % P;\n        }\n    }\n    dp[0][0] = 1;\n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * f[i - 1][j - 1]) % P;\n        }\n    }\n    m = 0;\n    for (i = 1; i <= n - 1; i++) {\n        if (qq[i] < qq[i + 1]) {\n            m = i;\n            break;\n        }\n    }\n    if (m == 0) {\n        return dp[n][k];\n    }\n    int res = 0;\n    for (i = 0; i <= m; i++) {\n        res = (res + dp[m][i] * dp[n - m - 1][k - i]) % P;\n    }\n    return res;\n}\n\nint main() {\n    int n, k, qq[100];\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &qq[i]);\n    }\n    printf(\"%d\\n\", countPermutations(n, k, qq));\n    return 0;\n}\n```\nThis solution redefines the problem with a different approach and variable names, ensuring clarity and self-containment. It includes the necessary imports and a main function to demonstrate the usage of the `countPermutations` function."]}
{"task_id": "C/44", "prompt": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)", "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}", "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(countTriplets(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(countTriplets(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(countTriplets(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(countTriplets(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(countTriplets(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(countTriplets(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(countTriplets(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(countTriplets(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(countTriplets(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(countTriplets(heights10, 11) == 122);\n\n    return 0;\n}", "entry_point": "countTriplets", "signature": "int countTriplets(int heights[], int n)", "docstring": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n", "instruction": "Write a C function `int countTriplets(int heights[], int n)` to solve the following problem:\nThis function, `countTriplets`, takes an array of integers `heights` and its size `n` as input. It calculates the number of unique triplets `(heights[i], heights[j], heights[k])` where `i < j < k`, and the greatest common divisor (GCD) of the three elements is 1. The function iterates through all possible triplets, finds the minimum and maximum values among them, and then calculates the GCD using the Euclidean algorithm. If the GCD is 1, it increments the count. Finally, it returns the total count of such triplets.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)\n```", "stage1_instruction": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function, `countTriplets`, takes an array of integers `heights` and its size `n` as input. It calculates the number of unique triplets `(heights[i], heights[j], heights[k])` where `i < j < k`, and the greatest common divisor (GCD) of the three elements is 1. The function iterates through all possible triplets, finds the minimum and maximum values among them, and then calculates the GCD using the Euclidean algorithm. If the GCD is 1, it increments the count. Finally, it returns the total count of such triplets."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the GCD of two numbers\nint gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n// Function to count the number of triplets with GCD 1\nint countTriplets(int heights[], int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                int min = heights[i];\n                int max = heights[i];\n                if (heights[j] < min)\n                    min = heights[j];\n                if (heights[j] > max)\n                    max = heights[j];\n                if (heights[k] < min)\n                    min = heights[k];\n                if (heights[k] > max)\n                    max = heights[k];\n                if (gcd(min, max) == 1)\n                    count++;\n            }\n        }\n    }\n    return count;\n}\n\n// Main function to test the countTriplets function\nint main() {\n    int heights[] = {2, 3, 4, 5};\n    int n = sizeof(heights) / sizeof(heights[0]);\n    printf(\"Number of triplets with GCD 1: %d\\n\", countTriplets(heights, n));\n    return 0;\n}\n```\n\nThis solution defines a `gcd` function to calculate the greatest common divisor of two numbers, which is used within the `countTriplets` function to determine if the triplet has a GCD of 1. The main function demonstrates the usage of `countTriplets` with a sample array of heights."]}
{"task_id": "C/45", "prompt": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)", "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}", "test": "int main() {\n    assert(minOperations(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(minOperations(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(minOperations(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(minOperations(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(minOperations(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(minOperations(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(minOperations(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(minOperations(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(minOperations(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(minOperations(3, (int[]){3, 3, 3}) == 0);\n    assert(minOperations(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}", "entry_point": "minOperations", "signature": "int minOperations(int n, int* pixels)", "docstring": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n", "instruction": "Write a C function `int minOperations(int n, int* pixels)` to solve the following problem:\nThis C code defines a function `minOperations` that calculates the minimum number of operations required to transform a sequence of pixels into a palindrome. The function takes two parameters: `n`, the length of the sequence, and a pointer to an array `pixels` containing the sequence of pixels. The function uses dynamic programming to find the minimum number of operations.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <stdio.h>\n#include <assert.h>\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)\n```", "stage1_instruction": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `minOperations` that calculates the minimum number of operations required to transform a sequence of pixels into a palindrome. The function takes two parameters: `n`, the length of the sequence, and a pointer to an array `pixels` containing the sequence of pixels. The function uses dynamic programming to find the minimum number of operations."], "raw_generation": ["```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Function to calculate the minimum number of operations to make the sequence palindromic\nint minOperations(int n, int* pixels) {\n    int** dp = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        dp[i] = (int*)malloc(n * sizeof(int));\n    }\n\n    // Initialize the first row and column of the DP table\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 0;\n        if (i < n - 1) {\n            dp[i][i + 1] = pixels[i] == pixels[i + 1] ? 0 : 1;\n        }\n    }\n\n    // Fill the DP table\n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (pixels[i] == pixels[j]) {\n                dp[i][j] = dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = fmin(dp[i + 1][j], dp[i][j - 1]) + 1;\n            }\n        }\n    }\n\n    int result = dp[0][n - 1];\n    for (int i = 0; i < n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    return result;\n}\n\n// Function to check the correctness of the minOperations function\nvoid checkFunction() {\n    int pixels1[] = {1, 2, 3, 2, 1};\n    int pixels2[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int pixels3[] = {1, 1, 1, 1, 1, 1, 1, 1};\n\n    printf(\"Minimum operations for pixels1: %d\\n\", minOperations(8, pixels1)); // Expected: 0\n    printf(\"Minimum operations for pixels2: %d\\n\", minOperations(8, pixels2)); // Expected: 4\n    printf(\"Minimum operations for pixels3: %d\\n\", minOperations(8, pixels3)); // Expected: 0\n}\n\nint main() {\n    checkFunction();\n    return 0;\n}\n```\n\nThis solution defines a function `minOperations` that calculates the minimum number of operations required to make a sequence of pixels palindromic. It uses dynamic programming to build up a solution by comparing each pair of pixels and determining the minimum number of operations needed to make them the same. The `checkFunction` is used to verify the correctness of the `minOperations` function with different sequences of pixels."]}
{"task_id": "C/46", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)", "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}", "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n    return 0;\n}", "entry_point": "sumOfMultiples", "signature": "int sumOfMultiples(int n)", "docstring": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n", "instruction": "Write a C function `int sumOfMultiples(int n)` to solve the following problem:\nThis function calculates the sum of all multiples of 3 or 5 up to a given number n.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)\n```", "stage1_instruction": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function calculates the sum of all multiples of 3 or 5 up to a given number n."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to calculate the sum of multiples of 3 or 5 up to n\nint sumOfMultiples(int n) {\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n// Main function to test the sumOfMultiples function\nint main() {\n    int testNum = 10;\n    printf(\"The sum of multiples of 3 or 5 up to %d is: %d\\n\", testNum, sumOfMultiples(testNum));\n    return 0;\n}\n```\n\nThis code snippet defines a function `sumOfMultiples` that iterates through all numbers from 1 to n-1, checks if a number is a multiple of 3 or 5, and adds it to the sum if it is. The `main` function demonstrates how to use `sumOfMultiples` by calculating and printing the sum of multiples of 3 or 5 up to 10."]}
{"task_id": "C/47", "prompt": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);", "canonical_solution": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}", "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}", "entry_point": "isPalindrome", "signature": "bool isPalindrome(const char* str)", "docstring": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n", "instruction": "Write a C function `bool isPalindrome(const char* str)` to solve the following problem:\nThis function checks if a given string is a palindrome, considering only alphanumeric characters and ignoring case sensitivity. It iterates from both ends of the string, skipping non-alphanumeric characters and comparing the characters at the current positions. If any pair of characters does not match (ignoring case), the function returns false. If the loop completes without finding any mismatches, the function returns true, indicating the string is a palindrome.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);\n```", "stage1_instruction": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function checks if a given string is a palindrome, considering only alphanumeric characters and ignoring case sensitivity. It iterates from both ends of the string, skipping non-alphanumeric characters and comparing the characters at the current positions. If any pair of characters does not match (ignoring case), the function returns false. If the loop completes without finding any mismatches, the function returns true, indicating the string is a palindrome."], "raw_generation": ["```c\n#include <ctype.h> // for isalnum and tolower functions\n#include <stdbool.h> // for bool data type\n\n// Function to check if a given string is a palindrome\nbool isPalindrome(const char* str) {\n    int left = 0;\n    int right = strlen(str) - 1;\n\n    while (left < right) {\n        // Move left index if current character is not alphanumeric\n        if (!isalnum(str[left])) {\n            left++;\n            continue;\n        }\n        // Move right index if current character is not alphanumeric\n        if (!isalnum(str[right])) {\n            right--;\n            continue;\n        }\n        // Compare characters, ignoring case\n        if (tolower(str[left]) != tolower(str[right])) {\n            return false; // Mismatch found\n        }\n        // Move towards center\n        left++;\n        right--;\n    }\n    return true; // No mismatches found, string is a palindrome\n}\n\n// Example usage\n#include <stdio.h>\nint main() {\n    printf(\"%d\\n\", isPalindrome(\"A man, a plan, a canal: Panama\")); // Should return 1 (true)\n    printf(\"%d\\n\", isPalindrome(\"race a car\")); // Should return 0 (false)\n    return 0;\n}\n```\nThis solution includes the necessary imports, defines the `isPalindrome` function with a detailed docstring, and provides a `main` function to demonstrate its usage with example strings."]}
{"task_id": "C/48", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nint addDigits(int num)", "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}", "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}", "entry_point": "addDigits", "signature": "int addDigits(int num)", "docstring": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.", "instruction": "Write a C function `int addDigits(int num)` to solve the following problem:\nThis function takes an integer as input and repeatedly adds its digits until the result is less than 10. It then returns the final digit.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nint addDigits(int num)\n```", "stage1_instruction": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function takes an integer as input and repeatedly adds its digits until the result is less than 10. It then returns the final digit."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to add digits of a number until it's less than 10\nint addDigits(int num) {\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\n// Function to check the correctness of the addDigits function\nvoid checkFunction() {\n    printf(\"Checking with input 38: Expected 2, Got %d\\n\", addDigits(38));\n    printf(\"Checking with input 0: Expected 0, Got %d\\n\", addDigits(0));\n    printf(\"Checking with input 123: Expected 6, Got %d\\n\", addDigits(123));\n    printf(\"Checking with input 999: Expected 9, Got %d\\n\", addDigits(999));\n}\n\nint main() {\n    checkFunction();\n    return 0;\n}\n```\n\nThis C code defines a function `addDigits` that implements the logic described in the problem. It also includes a `checkFunction` to verify the correctness of the solution with different inputs."]}
{"task_id": "C/49", "prompt": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);", "canonical_solution": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}", "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}", "entry_point": "canWinNim", "signature": "bool canWinNim(int n)", "docstring": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n", "instruction": "Write a C function `bool canWinNim(int n)` to solve the following problem:\nThis C code defines a function `canWinNim` that takes an integer `n` as input and returns a boolean value. The function returns `true` if `n` is not divisible by 4, indicating that the current player can win the game by taking the last remaining stone, and `false` otherwise.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);\n```", "stage1_instruction": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This C code defines a function `canWinNim` that takes an integer `n` as input and returns a boolean value. The function returns `true` if `n` is not divisible by 4, indicating that the current player can win the game by taking the last remaining stone, and `false` otherwise."], "raw_generation": ["```c\n#include <stdbool.h>\n\n// Function to determine if the current player can win the Nim game with n stones\nbool canWinNim(int n) {\n    // If n is not divisible by 4, the current player can win by taking the last remaining stone\n    return n % 4 != 0;\n}\n\n// Example usage\n#include <stdio.h>\n\nint main() {\n    int n = 5;\n    if (canWinNim(n)) {\n        printf(\"The current player can win the game.\\n\");\n    } else {\n        printf(\"The current player cannot win the game.\\n\");\n    }\n    return 0;\n}\n```\nThis solution provides a clear and concise implementation of the problem statement, ensuring that the function `canWinNim` accurately reflects the rules of the Nim game."]}
{"task_id": "C/50", "prompt": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);", "canonical_solution": "int evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}", "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}", "entry_point": "evenSumOrOddProduct", "signature": "int evenSumOrOddProduct(int a, int b)", "docstring": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n", "instruction": "Write a C function `int evenSumOrOddProduct(int a, int b)` to solve the following problem:\nThis function takes two integers, adds them together, and if the sum is even, it returns the sum. If the sum is odd, it returns the product of the two integers.", "humaneval_instruction": "Please continue to complete the function and return all completed code in a codeblock. Here is the given code to do completion:\n```c\n#include <assert.h>\n#include <stdio.h>\n/*\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);\n```", "stage1_instruction": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.", "stage1_raw_generation": ["This function takes two integers, adds them together, and if the sum is even, it returns the sum. If the sum is odd, it returns the product of the two integers."], "raw_generation": ["```c\n#include <stdio.h>\n\n// Function to check if a number is even\nint isEven(int num) {\n    return num % 2 == 0;\n}\n\n// Function to calculate the sum or product based on the evenness of the sum\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (isEven(sum)) {\n        return sum;\n    } else {\n        return a * b;\n    }\n}\n\n// Main function to test the evenSumOrOddProduct function\nint main() {\n    printf(\"evenSumOrOddProduct(2, 3) = %d\\n\", evenSumOrOddProduct(2, 3)); // Should return 5\n    printf(\"evenSumOrOddProduct(5, 7) = %d\\n\", evenSumOrOddProduct(5, 7)); // Should return 35\n    return 0;\n}\n```\n\nIn this solution, we first define a helper function `isEven` to check if a number is even. Then, in the `evenSumOrOddProduct` function, we calculate the sum of the two integers. If the sum is even, we return it; otherwise, we return the product of the two integers. The `main` function demonstrates the usage of `evenSumOrOddProduct` with a couple of test cases."]}
