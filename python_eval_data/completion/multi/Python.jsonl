{"task_id": "Python/1-0-multi", "prompt": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)", "entry_point": "has_close_elements", "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n* Incomplete Code:\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n[MASK]\n[MASK]\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n[MASK]\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n[MASK]"}
{"task_id": "Python/1-1-multi", "prompt": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False", "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)", "entry_point": "has_close_elements", "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n\n* Incomplete Code:\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n[MASK]\n[MASK]\n[MASK]\n                distance = abs(elem - elem2)\n[MASK]\n                    return True\n\n    return False\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n[MASK]\n[MASK]\n                distance = abs(elem - elem2)\n[MASK]\n                    return True\n\n    return False"}
{"task_id": "Python/2-0-multi", "prompt": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result", "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)", "entry_point": "separate_paren_groups", "signature": "def separate_paren_groups(paren_string: str) -> List[str]:", "docstring": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']\n\n* Incomplete Code:\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n[MASK]\n    stack = []\n[MASK]\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n[MASK]\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n[MASK]\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n[MASK]\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n[MASK]\n    stack = []\n[MASK]\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n[MASK]\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n[MASK]\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n[MASK]\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result"}
{"task_id": "Python/2-1-multi", "prompt": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"", "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result", "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)", "entry_point": "separate_paren_groups", "signature": "def separate_paren_groups(paren_string: str) -> List[str]:", "docstring": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']\n\n* Incomplete Code:\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n[MASK]\n    \n    # Initialize variables to store current group and stack to track parentheses\n[MASK]\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n[MASK]\n[MASK]\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Remove spaces from the input string\n[MASK]\n    \n    # Initialize variables to store current group and stack to track parentheses\n[MASK]\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n[MASK]\n[MASK]\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result"}
{"task_id": "Python/4-0-multi", "prompt": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False", "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)", "entry_point": "below_zero", "signature": "def below_zero(operations: List[int]) -> bool:", "docstring": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nYou're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue\n\n* Incomplete Code:\ndef below_zero(operations: List[int]) -> bool:\n[MASK]\n \n    for op in operations:\n        balance += op\n[MASK]\n        return True\n \n    return False\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n \n    for op in operations:\n        balance += op\n[MASK]\n        return True\n \n    return False"}
{"task_id": "Python/4-1-multi", "prompt": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"", "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False", "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)", "entry_point": "below_zero", "signature": "def below_zero(operations: List[int]) -> bool:", "docstring": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nYou're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue\n\n* Incomplete Code:\ndef below_zero(operations: List[int]) -> bool:\n[MASK]\n \n[MASK]\n[MASK]\n[MASK]\n        return True\n \n    return False\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n \n[MASK]\n[MASK]\n[MASK]\n        return True\n \n    return False"}
{"task_id": "Python/7-0-multi", "prompt": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point", "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()", "entry_point": "find_topmost_carpet", "signature": "def find_topmost_carpet(n, carpets, point) -> int:", "docstring": "Finds the topmost carpet covering a given point on the coordinate plane.\n\nArgs:\nn (int): The total number of carpets.\ncarpets (list of tuples): A list containing n tuples, each representing a carpet's information.\nEach tuple contains four integers (a, b, g, k) where (a, b) is the\ncoordinates of the bottom-left corner of the carpet and (g, k) are\nthe lengths of the carpet along the x and y axis respectively.\npoint (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\nReturns:\nint: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nFinds the topmost carpet covering a given point on the coordinate plane.\n\nArgs:\nn (int): The total number of carpets.\ncarpets (list of tuples): A list containing n tuples, each representing a carpet's information.\nEach tuple contains four integers (a, b, g, k) where (a, b) is the\ncoordinates of the bottom-left corner of the carpet and (g, k) are\nthe lengths of the carpet along the x and y axis respectively.\npoint (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\nReturns:\nint: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1\n\n* Incomplete Code:\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n[MASK]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n[MASK]\n    return -1  # If no carpet covers the point\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n[MASK]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n[MASK]\n    return -1  # If no carpet covers the point"}
{"task_id": "Python/7-1-multi", "prompt": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"", "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point", "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()", "entry_point": "find_topmost_carpet", "signature": "def find_topmost_carpet(n, carpets, point) -> int:", "docstring": "Finds the topmost carpet covering a given point on the coordinate plane.\n\nArgs:\nn (int): The total number of carpets.\ncarpets (list of tuples): A list containing n tuples, each representing a carpet's information.\nEach tuple contains four integers (a, b, g, k) where (a, b) is the\ncoordinates of the bottom-left corner of the carpet and (g, k) are\nthe lengths of the carpet along the x and y axis respectively.\npoint (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\nReturns:\nint: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nFinds the topmost carpet covering a given point on the coordinate plane.\n\nArgs:\nn (int): The total number of carpets.\ncarpets (list of tuples): A list containing n tuples, each representing a carpet's information.\nEach tuple contains four integers (a, b, g, k) where (a, b) is the\ncoordinates of the bottom-left corner of the carpet and (g, k) are\nthe lengths of the carpet along the x and y axis respectively.\npoint (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\nReturns:\nint: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1\n\n* Incomplete Code:\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n[MASK]\n[MASK]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n[MASK]\n[MASK]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n[MASK]\n[MASK]"}
{"task_id": "Python/8-0-multi", "prompt": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]", "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()", "entry_point": "max_value_on_paths", "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:", "docstring": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\nThis function utilizes dynamic programming to find two paths from the top-left corner to\nthe bottom-right corner of the grid which maximize the sum of the values collected. Each\nvalue can be collected at most once, even if both paths pass through it.\n\nArgs:\n- N (int): The size of the grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\nthe x-coordinate, y-coordinate, and value to be placed on the grid at that position.\nThe list is terminated by a tuple with all zeros.\n\nReturns:\n- int: The maximum sum of values collected on the two paths.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum sum of values collected on two paths in an N x N grid.\n\nThis function utilizes dynamic programming to find two paths from the top-left corner to\nthe bottom-right corner of the grid which maximize the sum of the values collected. Each\nvalue can be collected at most once, even if both paths pass through it.\n\nArgs:\n- N (int): The size of the grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\nthe x-coordinate, y-coordinate, and value to be placed on the grid at that position.\nThe list is terminated by a tuple with all zeros.\n\nReturns:\n- int: The maximum sum of values collected on the two paths.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67\n\n* Incomplete Code:\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n[MASK]\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n[MASK]\n                        dp[x1-1][y1][x2][y2-1],\n[MASK]\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n[MASK]\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n[MASK]\n                        dp[x1-1][y1][x2][y2-1],\n[MASK]\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]"}
{"task_id": "Python/8-1-multi", "prompt": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"", "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]", "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()", "entry_point": "max_value_on_paths", "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:", "docstring": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\nThis function utilizes dynamic programming to find two paths from the top-left corner to\nthe bottom-right corner of the grid which maximize the sum of the values collected. Each\nvalue can be collected at most once, even if both paths pass through it.\n\nArgs:\n- N (int): The size of the grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\nthe x-coordinate, y-coordinate, and value to be placed on the grid at that position.\nThe list is terminated by a tuple with all zeros.\n\nReturns:\n- int: The maximum sum of values collected on the two paths.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum sum of values collected on two paths in an N x N grid.\n\nThis function utilizes dynamic programming to find two paths from the top-left corner to\nthe bottom-right corner of the grid which maximize the sum of the values collected. Each\nvalue can be collected at most once, even if both paths pass through it.\n\nArgs:\n- N (int): The size of the grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\nthe x-coordinate, y-coordinate, and value to be placed on the grid at that position.\nThe list is terminated by a tuple with all zeros.\n\nReturns:\n- int: The maximum sum of values collected on the two paths.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67\n\n* Incomplete Code:\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n[MASK]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n[MASK]\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n[MASK]\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n[MASK]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n[MASK]\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n[MASK]\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n[MASK]"}
{"task_id": "Python/9-0-multi", "prompt": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])", "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")", "entry_point": "find_number_combinations", "signature": "def find_number_combinations():", "docstring": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\nsuch that the second number is twice the first and the third is three times the first.\n\nReturns:\nlist of tuples: A sorted list of tuples, where each tuple contains three integers representing the\nvalid number combinations in ascending order based on the first number.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\nsuch that the second number is twice the first and the third is three times the first.\n\nReturns:\nlist of tuples: A sorted list of tuples, where each tuple contains three integers representing the\nvalid number combinations in ascending order based on the first number.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]\n\n* Incomplete Code:\ndef find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n[MASK]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n[MASK]\n\n[MASK]\n\n# Print the valid combinations\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n[MASK]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n[MASK]\n\n[MASK]\n\n# Print the valid combinations\n[MASK]\n[MASK]"}
{"task_id": "Python/9-1-multi", "prompt": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"", "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])", "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")", "entry_point": "find_number_combinations", "signature": "def find_number_combinations():", "docstring": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\nsuch that the second number is twice the first and the third is three times the first.\n\nReturns:\nlist of tuples: A sorted list of tuples, where each tuple contains three integers representing the\nvalid number combinations in ascending order based on the first number.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\nsuch that the second number is twice the first and the third is three times the first.\n\nReturns:\nlist of tuples: A sorted list of tuples, where each tuple contains three integers representing the\nvalid number combinations in ascending order based on the first number.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]\n\n* Incomplete Code:\ndef find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n[MASK]\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n[MASK]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n[MASK]\n\n[MASK]\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n[MASK]\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n[MASK]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n[MASK]\n\n[MASK]\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])"}
{"task_id": "Python/10-0-multi", "prompt": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()", "entry_point": "sum_of_factorials_optimized", "signature": "def sum_of_factorials_optimized(n: int) -> int:", "docstring": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\nThis function employs a more efficient method to calculate factorials by iteratively\nmultiplying the current number to the previous factorial result, thus avoiding redundant\ncalculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\nArgs:\nn (int): The upper limit of the range for which the factorial sum is to be calculated.\nThe value of n should be in the range of 1 to 50, inclusive.\n\nReturns:\nint: The sum of all factorial values from 1! to n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCompute the cumulative sum of factorial values from 1 up to a specified integer n.\n\nThis function employs a more efficient method to calculate factorials by iteratively\nmultiplying the current number to the previous factorial result, thus avoiding redundant\ncalculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\nArgs:\nn (int): The upper limit of the range for which the factorial sum is to be calculated.\nThe value of n should be in the range of 1 to 50, inclusive.\n\nReturns:\nint: The sum of all factorial values from 1! to n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873\n\n* Incomplete Code:\ndef sum_of_factorials_optimized(n: int) -> int:\n[MASK]\n[MASK]\n[MASK]\n        current_factorial *= i\n        sum_factorials += current_factorial\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n[MASK]\n[MASK]\n        current_factorial *= i\n        sum_factorials += current_factorial\n[MASK]"}
{"task_id": "Python/10-1-multi", "prompt": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"", "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials", "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()", "entry_point": "sum_of_factorials_optimized", "signature": "def sum_of_factorials_optimized(n: int) -> int:", "docstring": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\nThis function employs a more efficient method to calculate factorials by iteratively\nmultiplying the current number to the previous factorial result, thus avoiding redundant\ncalculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\nArgs:\nn (int): The upper limit of the range for which the factorial sum is to be calculated.\nThe value of n should be in the range of 1 to 50, inclusive.\n\nReturns:\nint: The sum of all factorial values from 1! to n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCompute the cumulative sum of factorial values from 1 up to a specified integer n.\n\nThis function employs a more efficient method to calculate factorials by iteratively\nmultiplying the current number to the previous factorial result, thus avoiding redundant\ncalculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\nArgs:\nn (int): The upper limit of the range for which the factorial sum is to be calculated.\nThe value of n should be in the range of 1 to 50, inclusive.\n\nReturns:\nint: The sum of all factorial values from 1! to n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873\n\n* Incomplete Code:\ndef sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n[MASK]\n        current_factorial *= i\n        sum_factorials += current_factorial\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    sum_factorials = 0\n    current_factorial = 1\n[MASK]\n        current_factorial *= i\n        sum_factorials += current_factorial\n[MASK]"}
{"task_id": "Python/11-0-multi", "prompt": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"", "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"", "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()", "entry_point": "cantor_numbering", "signature": "def cantor_numbering(N: int) -> str:", "docstring": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\nArgs:\n- N (int): The position in the Cantor table to find the corresponding fraction for.\n\nReturns:\n- str: A string representation of the fraction at the N-th position in the Cantor table.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDetermines the numerator and denominator of the N-th term in the Cantor table.\n\nArgs:\n- N (int): The position in the Cantor table to find the corresponding fraction for.\n\nReturns:\n- str: A string representation of the fraction at the N-th position in the Cantor table.\n\n* Incomplete Code:\ndef cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n[MASK]\n    while N > line:\n[MASK]\n[MASK]\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n[MASK]\n[MASK]\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n[MASK]\n    while N > line:\n[MASK]\n[MASK]\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n[MASK]\n[MASK]\n        denominator = N\n\n    return f\"{numerator}/{denominator}\""}
{"task_id": "Python/11-1-multi", "prompt": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"", "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"", "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()", "entry_point": "cantor_numbering", "signature": "def cantor_numbering(N: int) -> str:", "docstring": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\nArgs:\n- N (int): The position in the Cantor table to find the corresponding fraction for.\n\nReturns:\n- str: A string representation of the fraction at the N-th position in the Cantor table.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDetermines the numerator and denominator of the N-th term in the Cantor table.\n\nArgs:\n- N (int): The position in the Cantor table to find the corresponding fraction for.\n\nReturns:\n- str: A string representation of the fraction at the N-th position in the Cantor table.\n\n* Incomplete Code:\ndef cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n[MASK]\n[MASK]\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n[MASK]\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n[MASK]\n[MASK]\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n[MASK]\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n[MASK]"}
{"task_id": "Python/12-0-multi", "prompt": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"", "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]", "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()", "entry_point": "max_product", "signature": "def max_product(num_str: str, N: int, K: int) -> int:", "docstring": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nFunction name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n\n* Incomplete Code:\ndef max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n[MASK]\n    # Initialize the dp table with 0 values\n[MASK]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n[MASK]\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Convert the string to a list of integers for easier manipulation\n[MASK]\n    # Initialize the dp table with 0 values\n[MASK]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n[MASK]\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n[MASK]"}
{"task_id": "Python/12-1-multi", "prompt": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"", "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]", "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()", "entry_point": "max_product", "signature": "def max_product(num_str: str, N: int, K: int) -> int:", "docstring": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nFunction name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n\n* Incomplete Code:\ndef max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n[MASK]\n\n    # Fill the dp table\n[MASK]\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n[MASK]\n\n    # Return the maximum product after using K multiplication signs\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n[MASK]\n\n    # Fill the dp table\n[MASK]\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n[MASK]\n\n    # Return the maximum product after using K multiplication signs\n[MASK]"}
{"task_id": "Python/13-0-multi", "prompt": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\n    The function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\n    Scholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    The first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\n    who is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\n    would receive a total of 4850 units of currency.\n\n    In the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\n    is from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.\n    \"\"\"", "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship", "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()", "entry_point": "calculate_scholarship", "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:", "docstring": "Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\nThe function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\nScholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\nParameters:\ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\nleader (str): A string ('Y' or 'N') indicating if the student is a class leader.\nwest (str): A string ('Y' or 'N') indicating if the student is from a western province.\npapers (int): An integer representing the number of research papers published by the student.\n\nReturns:\nint: The total scholarship amount the student is eligible for.\n\nExamples:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nThe first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\nwho is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\nwould receive a total of 4850 units of currency.\n\nIn the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\nis from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\nThe function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\nScholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\nParameters:\ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\nleader (str): A string ('Y' or 'N') indicating if the student is a class leader.\nwest (str): A string ('Y' or 'N') indicating if the student is from a western province.\npapers (int): An integer representing the number of research papers published by the student.\n\nReturns:\nint: The total scholarship amount the student is eligible for.\n\nExamples:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nThe first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\nwho is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\nwould receive a total of 4850 units of currency.\n\nIn the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\nis from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.\n\n* Incomplete Code:\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n[MASK]\n        scholarship += 4000\n[MASK]\n        scholarship += 2000\n[MASK]\n[MASK]\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n[MASK]\n        scholarship += 4000\n[MASK]\n        scholarship += 2000\n[MASK]\n[MASK]\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship"}
{"task_id": "Python/13-1-multi", "prompt": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\n    The function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\n    Scholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    The first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\n    who is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\n    would receive a total of 4850 units of currency.\n\n    In the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\n    is from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.\n    \"\"\"", "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship", "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()", "entry_point": "calculate_scholarship", "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:", "docstring": "Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\nThe function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\nScholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\nParameters:\ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\nleader (str): A string ('Y' or 'N') indicating if the student is a class leader.\nwest (str): A string ('Y' or 'N') indicating if the student is from a western province.\npapers (int): An integer representing the number of research papers published by the student.\n\nReturns:\nint: The total scholarship amount the student is eligible for.\n\nExamples:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nThe first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\nwho is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\nwould receive a total of 4850 units of currency.\n\nIn the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\nis from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\nThe function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\nScholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\nParameters:\ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\nleader (str): A string ('Y' or 'N') indicating if the student is a class leader.\nwest (str): A string ('Y' or 'N') indicating if the student is from a western province.\npapers (int): An integer representing the number of research papers published by the student.\n\nReturns:\nint: The total scholarship amount the student is eligible for.\n\nExamples:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nThe first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\nwho is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\nwould receive a total of 4850 units of currency.\n\nIn the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\nis from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.\n\n* Incomplete Code:\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n[MASK]\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n[MASK]\n        scholarship += 850\n    return scholarship\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n[MASK]\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n[MASK]\n        scholarship += 850\n    return scholarship"}
{"task_id": "Python/14-0-multi", "prompt": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    The second example shows the correction of the ISBN number where the checksum digit is calculated\n    to be '4' instead of the provided '0', thus the corrected ISBN is returned.\n    \"\"\"\n    # Function implementation goes here.", "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit", "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()", "entry_point": "verify_isbn", "signature": "def verify_isbn(isbn: str) -> str:", "docstring": "Verify the correctness of a given ISBN number and correct it if necessary.\n\nThe function checks the provided ISBN number against the ISBN standard checksum calculation.\nIf the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\nthe function returns the corrected ISBN number.\n\nArgs:\nisbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\nwhere 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\nReturns:\nA string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\nin the same format as the input if the checksum is incorrect.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nThe second example shows the correction of the ISBN number where the checksum digit is calculated\nto be '4' instead of the provided '0', thus the corrected ISBN is returned.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nVerify the correctness of a given ISBN number and correct it if necessary.\n\nThe function checks the provided ISBN number against the ISBN standard checksum calculation.\nIf the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\nthe function returns the corrected ISBN number.\n\nArgs:\nisbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\nwhere 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\nReturns:\nA string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\nin the same format as the input if the checksum is incorrect.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nThe second example shows the correction of the ISBN number where the checksum digit is calculated\nto be '4' instead of the provided '0', thus the corrected ISBN is returned.\n\n* Incomplete Code:\ndef verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n[MASK]\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n[MASK]\n[MASK]\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n[MASK]\n    else:\n        # Return the corrected ISBN\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n[MASK]\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n[MASK]\n[MASK]\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n[MASK]\n    else:\n        # Return the corrected ISBN\n[MASK]"}
{"task_id": "Python/14-1-multi", "prompt": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    The second example shows the correction of the ISBN number where the checksum digit is calculated\n    to be '4' instead of the provided '0', thus the corrected ISBN is returned.\n    \"\"\"\n    # Function implementation goes here.", "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit", "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()", "entry_point": "verify_isbn", "signature": "def verify_isbn(isbn: str) -> str:", "docstring": "Verify the correctness of a given ISBN number and correct it if necessary.\n\nThe function checks the provided ISBN number against the ISBN standard checksum calculation.\nIf the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\nthe function returns the corrected ISBN number.\n\nArgs:\nisbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\nwhere 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\nReturns:\nA string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\nin the same format as the input if the checksum is incorrect.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nThe second example shows the correction of the ISBN number where the checksum digit is calculated\nto be '4' instead of the provided '0', thus the corrected ISBN is returned.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nVerify the correctness of a given ISBN number and correct it if necessary.\n\nThe function checks the provided ISBN number against the ISBN standard checksum calculation.\nIf the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\nthe function returns the corrected ISBN number.\n\nArgs:\nisbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\nwhere 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\nReturns:\nA string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\nin the same format as the input if the checksum is incorrect.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nThe second example shows the correction of the ISBN number where the checksum digit is calculated\nto be '4' instead of the provided '0', thus the corrected ISBN is returned.\n\n* Incomplete Code:\ndef verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n[MASK]\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n[MASK]\n        check_digit = 'X'\n[MASK]\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n[MASK]\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n[MASK]\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n[MASK]\n        check_digit = 'X'\n[MASK]\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n[MASK]\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit"}
{"task_id": "Python/15-0-multi", "prompt": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n    \"\"\"", "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()", "entry_point": "optimize_seating", "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):", "docstring": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\nArgs:\nM (int): The number of rows in the classroom.\nN (int): The number of columns in the classroom.\nK (int): The number of horizontal aisles to add.\nL (int): The number of vertical aisles to add.\nD (int): The number of chatting pairs in the classroom.\nchatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\nReturns:\n(str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\nThe function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\nIt then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nOptimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\nArgs:\nM (int): The number of rows in the classroom.\nN (int): The number of columns in the classroom.\nK (int): The number of horizontal aisles to add.\nL (int): The number of vertical aisles to add.\nD (int): The number of chatting pairs in the classroom.\nchatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\nReturns:\n(str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\nThe function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\nIt then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n\n* Incomplete Code:\ndef optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n[MASK]\n[MASK]\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n[MASK]\n        elif Yi == Qi:  # Same column, different rows\n[MASK]\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n[MASK]\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize the counter lists\n[MASK]\n[MASK]\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n[MASK]\n        elif Yi == Qi:  # Same column, different rows\n[MASK]\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n[MASK]\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)"}
{"task_id": "Python/15-1-multi", "prompt": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n    \"\"\"", "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)", "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()", "entry_point": "optimize_seating", "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):", "docstring": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\nArgs:\nM (int): The number of rows in the classroom.\nN (int): The number of columns in the classroom.\nK (int): The number of horizontal aisles to add.\nL (int): The number of vertical aisles to add.\nD (int): The number of chatting pairs in the classroom.\nchatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\nReturns:\n(str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\nThe function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\nIt then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nOptimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\nArgs:\nM (int): The number of rows in the classroom.\nN (int): The number of columns in the classroom.\nK (int): The number of horizontal aisles to add.\nL (int): The number of vertical aisles to add.\nD (int): The number of chatting pairs in the classroom.\nchatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\nReturns:\n(str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\nThe function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\nIt then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n\n* Incomplete Code:\ndef optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n[MASK]\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n[MASK]\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n[MASK]\n[MASK]\n\n    # Return the results as space-separated strings\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n[MASK]\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n[MASK]\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n[MASK]\n[MASK]\n\n    # Return the results as space-separated strings\n[MASK]"}
{"task_id": "Python/16-0-multi", "prompt": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    Case 1:\n    For n = 3 students and m = 3 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\n    Case 2:\n    For n = 4 students and m = 2 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\n    Case 3:\n    For n = 5 students and m = 4 passes, the function should return 6.\n    The sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    and 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # The code implementation would go here.", "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]", "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()", "entry_point": "count_passing_ways", "signature": "def count_passing_ways(n: int, m: int) -> int:", "docstring": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle\nsuch that after 'm' passes, the ball returns to the starting student.\n\nThe function uses dynamic programming to determine the number of passing sequences. Each student\ncan pass the ball either to the left neighbor or to the right neighbor.\n\nArgs:\nn: The number of students standing in a circle.\nm: The number of times the ball is passed.\n\nReturns:\nAn integer representing the number of distinct passing ways that result in the ball\nreturning to the starting student after 'm' passes.\n\nCases:\nCase 1:\nFor n = 3 students and m = 3 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nCase 2:\nFor n = 4 students and m = 2 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nCase 3:\nFor n = 5 students and m = 4 passes, the function should return 6.\nThe sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCounts the number of different ways to pass a ball among 'n' students arranged in a circle\nsuch that after 'm' passes, the ball returns to the starting student.\n\nThe function uses dynamic programming to determine the number of passing sequences. Each student\ncan pass the ball either to the left neighbor or to the right neighbor.\n\nArgs:\nn: The number of students standing in a circle.\nm: The number of times the ball is passed.\n\nReturns:\nAn integer representing the number of distinct passing ways that result in the ball\nreturning to the starting student after 'm' passes.\n\nCases:\nCase 1:\nFor n = 3 students and m = 3 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nCase 2:\nFor n = 4 students and m = 2 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nCase 3:\nFor n = 5 students and m = 4 passes, the function should return 6.\nThe sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.\n\n* Incomplete Code:\ndef count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n[MASK]\n\n    # Base case\n[MASK]\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n[MASK]\n\n    # Return the result\n    return dp[m][0]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize the DP table\n[MASK]\n\n    # Base case\n[MASK]\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n[MASK]\n\n    # Return the result\n    return dp[m][0]"}
{"task_id": "Python/16-1-multi", "prompt": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    Case 1:\n    For n = 3 students and m = 3 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\n    Case 2:\n    For n = 4 students and m = 2 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\n    Case 3:\n    For n = 5 students and m = 4 passes, the function should return 6.\n    The sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    and 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # The code implementation would go here.", "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]", "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()", "entry_point": "count_passing_ways", "signature": "def count_passing_ways(n: int, m: int) -> int:", "docstring": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle\nsuch that after 'm' passes, the ball returns to the starting student.\n\nThe function uses dynamic programming to determine the number of passing sequences. Each student\ncan pass the ball either to the left neighbor or to the right neighbor.\n\nArgs:\nn: The number of students standing in a circle.\nm: The number of times the ball is passed.\n\nReturns:\nAn integer representing the number of distinct passing ways that result in the ball\nreturning to the starting student after 'm' passes.\n\nCases:\nCase 1:\nFor n = 3 students and m = 3 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nCase 2:\nFor n = 4 students and m = 2 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nCase 3:\nFor n = 5 students and m = 4 passes, the function should return 6.\nThe sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCounts the number of different ways to pass a ball among 'n' students arranged in a circle\nsuch that after 'm' passes, the ball returns to the starting student.\n\nThe function uses dynamic programming to determine the number of passing sequences. Each student\ncan pass the ball either to the left neighbor or to the right neighbor.\n\nArgs:\nn: The number of students standing in a circle.\nm: The number of times the ball is passed.\n\nReturns:\nAn integer representing the number of distinct passing ways that result in the ball\nreturning to the starting student after 'm' passes.\n\nCases:\nCase 1:\nFor n = 3 students and m = 3 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nCase 2:\nFor n = 4 students and m = 2 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nCase 3:\nFor n = 5 students and m = 4 passes, the function should return 6.\nThe sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.\n\n* Incomplete Code:\ndef count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n[MASK]\n[MASK]\n            # Calculate the number of ways to pass the ball to j-th student\n[MASK]\n\n    # Return the result\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n[MASK]\n[MASK]\n            # Calculate the number of ways to pass the ball to j-th student\n[MASK]\n\n    # Return the result\n[MASK]"}
{"task_id": "Python/18-0-multi", "prompt": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    The first example represents a budget of 1000 units with 5 items to choose from. The function \n    returns 3900, which is the maximum importance value sum achievable within the budget.\n    \n    The second example has a smaller budget of 50 units and 3 items. The function returns 80, \n    which is the maximum sum of importance values for the chosen items within the budget.\n    \"\"\"", "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]", "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()", "entry_point": "max_happiness", "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:", "docstring": "Calculates the maximum total importance value of items that can be bought within a given budget.\n\nThis function solves a variant of the 0-1 knapsack problem where each item has a price and an\nassociated importance value. The goal is to maximize the sum of the importance values of a\nselection of items without the total price exceeding the budget.\n\nArgs:\nn (int): The total budget available for purchasing items.\nm (int): The number of different items to choose from.\nitems (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n- The first integer represents the price of the item.\n- The second integer represents the importance value of the item.\n\nReturns:\nint: The maximum total importance value that can be achieved without exceeding the budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nThe first example represents a budget of 1000 units with 5 items to choose from. The function\nreturns 3900, which is the maximum importance value sum achievable within the budget.\n\nThe second example has a smaller budget of 50 units and 3 items. The function returns 80,\nwhich is the maximum sum of importance values for the chosen items within the budget.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum total importance value of items that can be bought within a given budget.\n\nThis function solves a variant of the 0-1 knapsack problem where each item has a price and an\nassociated importance value. The goal is to maximize the sum of the importance values of a\nselection of items without the total price exceeding the budget.\n\nArgs:\nn (int): The total budget available for purchasing items.\nm (int): The number of different items to choose from.\nitems (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n- The first integer represents the price of the item.\n- The second integer represents the importance value of the item.\n\nReturns:\nint: The maximum total importance value that can be achieved without exceeding the budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nThe first example represents a budget of 1000 units with 5 items to choose from. The function\nreturns 3900, which is the maximum importance value sum achievable within the budget.\n\nThe second example has a smaller budget of 50 units and 3 items. The function returns 80,\nwhich is the maximum sum of importance values for the chosen items within the budget.\n\n* Incomplete Code:\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n[MASK]\n    \n    # The maximum value is stored in dp[n]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n[MASK]\n    \n    # The maximum value is stored in dp[n]\n[MASK]"}
{"task_id": "Python/18-1-multi", "prompt": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    The first example represents a budget of 1000 units with 5 items to choose from. The function \n    returns 3900, which is the maximum importance value sum achievable within the budget.\n    \n    The second example has a smaller budget of 50 units and 3 items. The function returns 80, \n    which is the maximum sum of importance values for the chosen items within the budget.\n    \"\"\"", "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]", "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()", "entry_point": "max_happiness", "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:", "docstring": "Calculates the maximum total importance value of items that can be bought within a given budget.\n\nThis function solves a variant of the 0-1 knapsack problem where each item has a price and an\nassociated importance value. The goal is to maximize the sum of the importance values of a\nselection of items without the total price exceeding the budget.\n\nArgs:\nn (int): The total budget available for purchasing items.\nm (int): The number of different items to choose from.\nitems (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n- The first integer represents the price of the item.\n- The second integer represents the importance value of the item.\n\nReturns:\nint: The maximum total importance value that can be achieved without exceeding the budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nThe first example represents a budget of 1000 units with 5 items to choose from. The function\nreturns 3900, which is the maximum importance value sum achievable within the budget.\n\nThe second example has a smaller budget of 50 units and 3 items. The function returns 80,\nwhich is the maximum sum of importance values for the chosen items within the budget.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the maximum total importance value of items that can be bought within a given budget.\n\nThis function solves a variant of the 0-1 knapsack problem where each item has a price and an\nassociated importance value. The goal is to maximize the sum of the importance values of a\nselection of items without the total price exceeding the budget.\n\nArgs:\nn (int): The total budget available for purchasing items.\nm (int): The number of different items to choose from.\nitems (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n- The first integer represents the price of the item.\n- The second integer represents the importance value of the item.\n\nReturns:\nint: The maximum total importance value that can be achieved without exceeding the budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nThe first example represents a budget of 1000 units with 5 items to choose from. The function\nreturns 3900, which is the maximum importance value sum achievable within the budget.\n\nThe second example has a smaller budget of 50 units and 3 items. The function returns 80,\nwhich is the maximum sum of importance values for the chosen items within the budget.\n\n* Incomplete Code:\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n[MASK]\n        # Loop over the possible budgets from n to price\n[MASK]\n            # Update the dp array if the current item can be added\n[MASK]\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n[MASK]\n        # Loop over the possible budgets from n to price\n[MASK]\n            # Update the dp array if the current item can be added\n[MASK]\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]"}
{"task_id": "Python/19-0-multi", "prompt": "\ndef max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        This sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\n        released by merging them in the optimal order is 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        This sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\n        released by merging them in the optimal order is 48.\n    \"\"\"", "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))", "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()", "entry_point": "max_energy", "signature": "def max_energy(beads):", "docstring": "Calculate the maximum energy that can be released by merging beads on a necklace.\n\nThe function takes a list of integers representing the energy beads on a necklace, where\neach bead has a head and a tail value. The head value of each bead must match the tail\nvalue of the next bead in the sequence. The necklace is circular, and merging two adjacent\nbeads releases energy equal to the product of the head value of the first bead, the matching\nvalue, and the tail value of the second bead.\n\nTo find the maximum energy release, the function considers all possible orders of merging beads\nand uses dynamic programming to compute the maximum energy obtainable.\n\nArgs:\nbeads: A list of integers where each integer represents the head value of a bead and\nthe tail value of the previous bead. The tail value of the last bead is assumed\nto match the head value of the first bead due to the circular nature of the necklace.\n\nReturns:\nAn integer representing the maximum energy that can be obtained by optimally merging all beads.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nThis sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\nreleased by merging them in the optimal order is 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nThis sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\nreleased by merging them in the optimal order is 48.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum energy that can be released by merging beads on a necklace.\n\nThe function takes a list of integers representing the energy beads on a necklace, where\neach bead has a head and a tail value. The head value of each bead must match the tail\nvalue of the next bead in the sequence. The necklace is circular, and merging two adjacent\nbeads releases energy equal to the product of the head value of the first bead, the matching\nvalue, and the tail value of the second bead.\n\nTo find the maximum energy release, the function considers all possible orders of merging beads\nand uses dynamic programming to compute the maximum energy obtainable.\n\nArgs:\nbeads: A list of integers where each integer represents the head value of a bead and\nthe tail value of the previous bead. The tail value of the last bead is assumed\nto match the head value of the first bead due to the circular nature of the necklace.\n\nReturns:\nAn integer representing the maximum energy that can be obtained by optimally merging all beads.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nThis sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\nreleased by merging them in the optimal order is 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nThis sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\nreleased by merging them in the optimal order is 48.\n\n* Incomplete Code:\ndef max_energy(beads):\n[MASK]\n    # Duplicate the sequence to account for the circular nature of the necklace\n[MASK]\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n[MASK]\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n    # Duplicate the sequence to account for the circular nature of the necklace\n[MASK]\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n[MASK]\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))"}
{"task_id": "Python/19-1-multi", "prompt": "\ndef max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        This sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\n        released by merging them in the optimal order is 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        This sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\n        released by merging them in the optimal order is 48.\n    \"\"\"", "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))", "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()", "entry_point": "max_energy", "signature": "def max_energy(beads):", "docstring": "Calculate the maximum energy that can be released by merging beads on a necklace.\n\nThe function takes a list of integers representing the energy beads on a necklace, where\neach bead has a head and a tail value. The head value of each bead must match the tail\nvalue of the next bead in the sequence. The necklace is circular, and merging two adjacent\nbeads releases energy equal to the product of the head value of the first bead, the matching\nvalue, and the tail value of the second bead.\n\nTo find the maximum energy release, the function considers all possible orders of merging beads\nand uses dynamic programming to compute the maximum energy obtainable.\n\nArgs:\nbeads: A list of integers where each integer represents the head value of a bead and\nthe tail value of the previous bead. The tail value of the last bead is assumed\nto match the head value of the first bead due to the circular nature of the necklace.\n\nReturns:\nAn integer representing the maximum energy that can be obtained by optimally merging all beads.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nThis sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\nreleased by merging them in the optimal order is 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nThis sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\nreleased by merging them in the optimal order is 48.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum energy that can be released by merging beads on a necklace.\n\nThe function takes a list of integers representing the energy beads on a necklace, where\neach bead has a head and a tail value. The head value of each bead must match the tail\nvalue of the next bead in the sequence. The necklace is circular, and merging two adjacent\nbeads releases energy equal to the product of the head value of the first bead, the matching\nvalue, and the tail value of the second bead.\n\nTo find the maximum energy release, the function considers all possible orders of merging beads\nand uses dynamic programming to compute the maximum energy obtainable.\n\nArgs:\nbeads: A list of integers where each integer represents the head value of a bead and\nthe tail value of the previous bead. The tail value of the last bead is assumed\nto match the head value of the first bead due to the circular nature of the necklace.\n\nReturns:\nAn integer representing the maximum energy that can be obtained by optimally merging all beads.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nThis sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\nreleased by merging them in the optimal order is 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nThis sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\nreleased by merging them in the optimal order is 48.\n\n* Incomplete Code:\ndef max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n[MASK]\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n[MASK]\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n[MASK]\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n[MASK]\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n[MASK]\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n[MASK]\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))"}
{"task_id": "Python/20-0-multi", "prompt": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)", "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()", "entry_point": "polynomial_to_string", "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:", "docstring": "Converts a list of polynomial coefficients into a formatted string representation.\n\nThe function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\nwhich are ordered from the highest degree term to the constant term. It returns a string that\nrepresents the polynomial with the following rules:\n- Terms with a coefficient of zero are omitted.\n- The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n- The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n- The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\nnothing for degree 0 (constant term).\n- Terms are joined without additional spaces, starting with the highest degree term.\n\nArgs:\nn (int): The highest degree of the polynomial.\ncoeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\nReturns:\nstr: The string representation of the polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nConverts a list of polynomial coefficients into a formatted string representation.\n\nThe function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\nwhich are ordered from the highest degree term to the constant term. It returns a string that\nrepresents the polynomial with the following rules:\n- Terms with a coefficient of zero are omitted.\n- The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n- The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n- The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\nnothing for degree 0 (constant term).\n- Terms are joined without additional spaces, starting with the highest degree term.\n\nArgs:\nn (int): The highest degree of the polynomial.\ncoeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\nReturns:\nstr: The string representation of the polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'\n\n* Incomplete Code:\ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n[MASK]\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n[MASK]\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n[MASK]\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n[MASK]\n[MASK]\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n[MASK]\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n[MASK]\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n[MASK]\n[MASK]\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)"}
{"task_id": "Python/20-1-multi", "prompt": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"", "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)", "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()", "entry_point": "polynomial_to_string", "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:", "docstring": "Converts a list of polynomial coefficients into a formatted string representation.\n\nThe function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\nwhich are ordered from the highest degree term to the constant term. It returns a string that\nrepresents the polynomial with the following rules:\n- Terms with a coefficient of zero are omitted.\n- The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n- The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n- The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\nnothing for degree 0 (constant term).\n- Terms are joined without additional spaces, starting with the highest degree term.\n\nArgs:\nn (int): The highest degree of the polynomial.\ncoeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\nReturns:\nstr: The string representation of the polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nConverts a list of polynomial coefficients into a formatted string representation.\n\nThe function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\nwhich are ordered from the highest degree term to the constant term. It returns a string that\nrepresents the polynomial with the following rules:\n- Terms with a coefficient of zero are omitted.\n- The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n- The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n- The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\nnothing for degree 0 (constant term).\n- Terms are joined without additional spaces, starting with the highest degree term.\n\nArgs:\nn (int): The highest degree of the polynomial.\ncoeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\nReturns:\nstr: The string representation of the polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'\n\n* Incomplete Code:\ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n[MASK]\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n[MASK]\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n[MASK]\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n[MASK]\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n[MASK]\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n[MASK]\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)"}
{"task_id": "Python/21-0-multi", "prompt": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    This means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n    90, 88, and 88, and their respective registration numbers are listed alongside their scores.\n    \"\"\"", "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants", "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()", "entry_point": "select_volunteers", "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:", "docstring": "Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n\nThe function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\nthey are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\nof the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\nqualified for the interview.\n\nArgs:\n- n (int): The total number of applicants.\n- m (int): The planned number of volunteers to be recruited.\n- applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\nthe registration number and test score of qualified applicants.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nThis means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n90, 88, and 88, and their respective registration numbers are listed alongside their scores.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nSelects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n\nThe function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\nthey are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\nof the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\nqualified for the interview.\n\nArgs:\n- n (int): The total number of applicants.\n- m (int): The planned number of volunteers to be recruited.\n- applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\nthe registration number and test score of qualified applicants.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nThis means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n90, 88, and 88, and their respective registration numbers are listed alongside their scores.\n\n* Incomplete Code:\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n[MASK]\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n[MASK]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n[MASK]\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n[MASK]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n[MASK]"}
{"task_id": "Python/21-1-multi", "prompt": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    This means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n    90, 88, and 88, and their respective registration numbers are listed alongside their scores.\n    \"\"\"", "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants", "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()", "entry_point": "select_volunteers", "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:", "docstring": "Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n\nThe function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\nthey are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\nof the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\nqualified for the interview.\n\nArgs:\n- n (int): The total number of applicants.\n- m (int): The planned number of volunteers to be recruited.\n- applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\nthe registration number and test score of qualified applicants.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nThis means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n90, 88, and 88, and their respective registration numbers are listed alongside their scores.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nSelects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n\nThe function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\nthey are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\nof the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\nqualified for the interview.\n\nArgs:\n- n (int): The total number of applicants.\n- m (int): The planned number of volunteers to be recruited.\n- applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\nthe registration number and test score of qualified applicants.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nThis means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n90, 88, and 88, and their respective registration numbers are listed alongside their scores.\n\n* Incomplete Code:\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n[MASK]\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n[MASK]\n    \n    # Determine the actual applicants who will be interviewed\n[MASK]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n[MASK]\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n[MASK]\n    \n    # Determine the actual applicants who will be interviewed\n[MASK]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants"}
{"task_id": "Python/22-0-multi", "prompt": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message", "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()", "entry_point": "decode", "signature": "def decode(encoded: str, original: str, message: str) -> str:", "docstring": "Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n\nThe function builds a mapping from encoded letters to their original letters and uses this\nmapping to decode a given encrypted message. If a contradiction is found during mapping\nconstruction, or not all letters are represented in the mapping, the function returns \"Failed\".\n\nArgs:\nencoded (str): A string representing the encoded information.\noriginal (str): A string representing the original information corresponding to the encoded string.\nmessage (str): A string representing the encrypted message to be decoded.\n\nReturns:\nstr: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDecodes an encrypted message using a cipher derived from a known encoded-original pair.\n\nThe function builds a mapping from encoded letters to their original letters and uses this\nmapping to decode a given encrypted message. If a contradiction is found during mapping\nconstruction, or not all letters are represented in the mapping, the function returns \"Failed\".\n\nArgs:\nencoded (str): A string representing the encoded information.\noriginal (str): A string representing the original information corresponding to the encoded string.\nmessage (str): A string representing the encrypted message to be decoded.\n\nReturns:\nstr: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'\n\n* Incomplete Code:\ndef decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n[MASK]\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n[MASK]\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n[MASK]\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n[MASK]\n    \n    return decoded_message\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n[MASK]\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n[MASK]\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n[MASK]\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n[MASK]\n    \n    return decoded_message"}
{"task_id": "Python/22-1-multi", "prompt": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"", "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message", "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()", "entry_point": "decode", "signature": "def decode(encoded: str, original: str, message: str) -> str:", "docstring": "Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n\nThe function builds a mapping from encoded letters to their original letters and uses this\nmapping to decode a given encrypted message. If a contradiction is found during mapping\nconstruction, or not all letters are represented in the mapping, the function returns \"Failed\".\n\nArgs:\nencoded (str): A string representing the encoded information.\noriginal (str): A string representing the original information corresponding to the encoded string.\nmessage (str): A string representing the encrypted message to be decoded.\n\nReturns:\nstr: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDecodes an encrypted message using a cipher derived from a known encoded-original pair.\n\nThe function builds a mapping from encoded letters to their original letters and uses this\nmapping to decode a given encrypted message. If a contradiction is found during mapping\nconstruction, or not all letters are represented in the mapping, the function returns \"Failed\".\n\nArgs:\nencoded (str): A string representing the encoded information.\noriginal (str): A string representing the original information corresponding to the encoded string.\nmessage (str): A string representing the encrypted message to be decoded.\n\nReturns:\nstr: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'\n\n* Incomplete Code:\ndef decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n[MASK]\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n[MASK]\n[MASK]\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n[MASK]\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n[MASK]\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n[MASK]\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n[MASK]\n[MASK]\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n[MASK]\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n[MASK]\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message"}
{"task_id": "Python/23-0-multi", "prompt": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor", "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()", "entry_point": "largest_prime_factor", "signature": "def largest_prime_factor(n: int) -> int:", "docstring": "Find the largest prime factor of a given positive integer.\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\nThe function iterates through potential factors starting from the smallest prime (2)\nand checks if they are a factor of 'n'. If a factor is found, the function returns\nthe division of 'n' by this factor, which is the larger prime factor. If no factors\nare found up to the square root of 'n', then 'n' itself is a prime number and is\nreturned as the largest prime factor.\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nFind the largest prime factor of a given positive integer.\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\nThe function iterates through potential factors starting from the smallest prime (2)\nand checks if they are a factor of 'n'. If a factor is found, the function returns\nthe division of 'n' by this factor, which is the larger prime factor. If no factors\nare found up to the square root of 'n', then 'n' itself is a prime number and is\nreturned as the largest prime factor.\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29\n\n* Incomplete Code:\ndef largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n[MASK]\n[MASK]\n[MASK]\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n[MASK]\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Starting from the smallest prime number\n[MASK]\n[MASK]\n[MASK]\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n[MASK]\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor"}
{"task_id": "Python/23-1-multi", "prompt": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ", "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor", "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()", "entry_point": "largest_prime_factor", "signature": "def largest_prime_factor(n: int) -> int:", "docstring": "Find the largest prime factor of a given positive integer.\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\nThe function iterates through potential factors starting from the smallest prime (2)\nand checks if they are a factor of 'n'. If a factor is found, the function returns\nthe division of 'n' by this factor, which is the larger prime factor. If no factors\nare found up to the square root of 'n', then 'n' itself is a prime number and is\nreturned as the largest prime factor.\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nFind the largest prime factor of a given positive integer.\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\nThe function iterates through potential factors starting from the smallest prime (2)\nand checks if they are a factor of 'n'. If a factor is found, the function returns\nthe division of 'n' by this factor, which is the larger prime factor. If no factors\nare found up to the square root of 'n', then 'n' itself is a prime number and is\nreturned as the largest prime factor.\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29\n\n* Incomplete Code:\ndef largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n[MASK]\n            last_factor = factor\n            while n % factor == 0:\n[MASK]\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n[MASK]\n        last_factor = n\n    return last_factor\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n[MASK]\n            last_factor = factor\n            while n % factor == 0:\n[MASK]\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n[MASK]\n        last_factor = n\n    return last_factor"}
{"task_id": "Python/24-0-multi", "prompt": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    - count_partitions(7, 3, 1) will return 4, because there are four ways to partition \n      the number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) will return 3, because there are three ways to partition \n      the number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].\n    \"\"\"", "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count", "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()", "entry_point": "count_partitions", "signature": "def count_partitions(n: int, k: int, x: int) -> int:", "docstring": "Count the number of ways to partition an integer n into k parts,\nwhere each part is at least x and order of parts does not matter.\n\nParameters:\nn (int): The integer to be partitioned.\nk (int): The number of parts to divide n into.\nx (int): The minimum value for each part.\n\nReturns:\nint: The number of distinct partitioning ways.\n\nExamples:\n- count_partitions(7, 3, 1) will return 4, because there are four ways to partition\nthe number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) will return 3, because there are three ways to partition\nthe number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCount the number of ways to partition an integer n into k parts,\nwhere each part is at least x and order of parts does not matter.\n\nParameters:\nn (int): The integer to be partitioned.\nk (int): The number of parts to divide n into.\nx (int): The minimum value for each part.\n\nReturns:\nint: The number of distinct partitioning ways.\n\nExamples:\n- count_partitions(7, 3, 1) will return 4, because there are four ways to partition\nthe number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) will return 3, because there are three ways to partition\nthe number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].\n\n* Incomplete Code:\ndef count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n[MASK]\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n[MASK]\n    return count\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    if k == 1:\n        if n >= x:\n[MASK]\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n[MASK]\n    return count"}
{"task_id": "Python/24-1-multi", "prompt": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    - count_partitions(7, 3, 1) will return 4, because there are four ways to partition \n      the number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) will return 3, because there are three ways to partition \n      the number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].\n    \"\"\"", "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count", "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()", "entry_point": "count_partitions", "signature": "def count_partitions(n: int, k: int, x: int) -> int:", "docstring": "Count the number of ways to partition an integer n into k parts,\nwhere each part is at least x and order of parts does not matter.\n\nParameters:\nn (int): The integer to be partitioned.\nk (int): The number of parts to divide n into.\nx (int): The minimum value for each part.\n\nReturns:\nint: The number of distinct partitioning ways.\n\nExamples:\n- count_partitions(7, 3, 1) will return 4, because there are four ways to partition\nthe number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) will return 3, because there are three ways to partition\nthe number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCount the number of ways to partition an integer n into k parts,\nwhere each part is at least x and order of parts does not matter.\n\nParameters:\nn (int): The integer to be partitioned.\nk (int): The number of parts to divide n into.\nx (int): The minimum value for each part.\n\nReturns:\nint: The number of distinct partitioning ways.\n\nExamples:\n- count_partitions(7, 3, 1) will return 4, because there are four ways to partition\nthe number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) will return 3, because there are three ways to partition\nthe number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].\n\n* Incomplete Code:\ndef count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n[MASK]\n[MASK]\n        else:\n[MASK]\n    count = 0\n[MASK]\n[MASK]\n    return count\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    if k == 1:\n[MASK]\n[MASK]\n        else:\n[MASK]\n    count = 0\n[MASK]\n[MASK]\n    return count"}
{"task_id": "Python/25-0-multi", "prompt": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        # Only one sequence can be formed starting with 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Six sequences can be formed starting with 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # More complex example with memoization dictionary passed\n        # You would typically not pass this dictionary manually,\n        # it's used internally by the function for optimization.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # This is an assumed value for the example; the actual result may differ.\n    \"\"\"\n    # Function implementation is here...", "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count", "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()", "entry_point": "count_sequences", "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:", "docstring": "Calculate the number of valid sequences that can be formed according to specific rules.\n\nEach sequence starts with a given number 'n', and a new number can be appended to the sequence\nif it is a positive integer and not greater than half the last number in the sequence. This\nfunction uses memoization to store previously calculated results to optimize performance.\n\nArgs:\nn (int): The starting number of the sequence.\nlast (int): The last number in the current sequence.\nmemo (dict): A dictionary used for memoization, storing the number of valid sequences\nfor each 'last' value encountered.\n\nReturns:\nint: The total number of valid sequences that can be formed starting with 'n'.\n\nExamples:\nOnly one sequence can be formed starting with 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix sequences can be formed starting with 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMore complex example with memoization dictionary passed\nYou would typically not pass this dictionary manually,\nit's used internally by the function for optimization.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # This is an assumed value for the example; the actual result may differ.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of valid sequences that can be formed according to specific rules.\n\nEach sequence starts with a given number 'n', and a new number can be appended to the sequence\nif it is a positive integer and not greater than half the last number in the sequence. This\nfunction uses memoization to store previously calculated results to optimize performance.\n\nArgs:\nn (int): The starting number of the sequence.\nlast (int): The last number in the current sequence.\nmemo (dict): A dictionary used for memoization, storing the number of valid sequences\nfor each 'last' value encountered.\n\nReturns:\nint: The total number of valid sequences that can be formed starting with 'n'.\n\nExamples:\nOnly one sequence can be formed starting with 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix sequences can be formed starting with 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMore complex example with memoization dictionary passed\nYou would typically not pass this dictionary manually,\nit's used internally by the function for optimization.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # This is an assumed value for the example; the actual result may differ.\n\n* Incomplete Code:\ndef count_sequences(n: int, last: int, memo: dict) -> int:\n[MASK]\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n[MASK]"}
{"task_id": "Python/25-1-multi", "prompt": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        # Only one sequence can be formed starting with 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Six sequences can be formed starting with 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # More complex example with memoization dictionary passed\n        # You would typically not pass this dictionary manually,\n        # it's used internally by the function for optimization.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # This is an assumed value for the example; the actual result may differ.\n    \"\"\"\n    # Function implementation is here...", "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count", "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()", "entry_point": "count_sequences", "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:", "docstring": "Calculate the number of valid sequences that can be formed according to specific rules.\n\nEach sequence starts with a given number 'n', and a new number can be appended to the sequence\nif it is a positive integer and not greater than half the last number in the sequence. This\nfunction uses memoization to store previously calculated results to optimize performance.\n\nArgs:\nn (int): The starting number of the sequence.\nlast (int): The last number in the current sequence.\nmemo (dict): A dictionary used for memoization, storing the number of valid sequences\nfor each 'last' value encountered.\n\nReturns:\nint: The total number of valid sequences that can be formed starting with 'n'.\n\nExamples:\nOnly one sequence can be formed starting with 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix sequences can be formed starting with 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMore complex example with memoization dictionary passed\nYou would typically not pass this dictionary manually,\nit's used internally by the function for optimization.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # This is an assumed value for the example; the actual result may differ.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of valid sequences that can be formed according to specific rules.\n\nEach sequence starts with a given number 'n', and a new number can be appended to the sequence\nif it is a positive integer and not greater than half the last number in the sequence. This\nfunction uses memoization to store previously calculated results to optimize performance.\n\nArgs:\nn (int): The starting number of the sequence.\nlast (int): The last number in the current sequence.\nmemo (dict): A dictionary used for memoization, storing the number of valid sequences\nfor each 'last' value encountered.\n\nReturns:\nint: The total number of valid sequences that can be formed starting with 'n'.\n\nExamples:\nOnly one sequence can be formed starting with 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix sequences can be formed starting with 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMore complex example with memoization dictionary passed\nYou would typically not pass this dictionary manually,\nit's used internally by the function for optimization.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # This is an assumed value for the example; the actual result may differ.\n\n* Incomplete Code:\ndef count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n[MASK]\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    if last in memo:\n[MASK]\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n[MASK]"}
{"task_id": "Python/26-0-multi", "prompt": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    Case 1: count_coprime_pairs(3, 60)\n    Explanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\n    Case 2: count_coprime_pairs(2, 50)\n    Explanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\n    Case 3: count_coprime_pairs(6, 180)\n    Explanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\n    Note:\n    For the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0, \n    indicating no valid pairs exist under the given constraints.\n    \"\"\"", "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count", "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()", "entry_point": "count_coprime_pairs", "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:", "docstring": "Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\nand y0 as their least common multiple (LCM).\n\nArgs:\nx0 (int): The GCD that each pair (P, Q) must have.\ny0 (int): The LCM that each pair (P, Q) must have.\n\nReturns:\nint: The count of all possible pairs (P, Q) that meet the specified criteria.\n\nThe function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\nit calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\nare co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\nthe GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\nelse by 2 to account for both (P, Q) and (Q, P) pairs.\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\nNote:\nFor the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0,\nindicating no valid pairs exist under the given constraints.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCounts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\nand y0 as their least common multiple (LCM).\n\nArgs:\nx0 (int): The GCD that each pair (P, Q) must have.\ny0 (int): The LCM that each pair (P, Q) must have.\n\nReturns:\nint: The count of all possible pairs (P, Q) that meet the specified criteria.\n\nThe function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\nit calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\nare co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\nthe GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\nelse by 2 to account for both (P, Q) and (Q, P) pairs.\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\nNote:\nFor the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0,\nindicating no valid pairs exist under the given constraints.\n\n* Incomplete Code:\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n[MASK]\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n[MASK]\n        if product % a == 0:\n[MASK]\n            # Check if a and b are co-prime.\n[MASK]\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n[MASK]\n        if product % a == 0:\n[MASK]\n            # Check if a and b are co-prime.\n[MASK]\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n[MASK]"}
{"task_id": "Python/26-1-multi", "prompt": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    Case 1: count_coprime_pairs(3, 60)\n    Explanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\n    Case 2: count_coprime_pairs(2, 50)\n    Explanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\n    Case 3: count_coprime_pairs(6, 180)\n    Explanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\n    Note:\n    For the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0, \n    indicating no valid pairs exist under the given constraints.\n    \"\"\"", "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count", "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()", "entry_point": "count_coprime_pairs", "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:", "docstring": "Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\nand y0 as their least common multiple (LCM).\n\nArgs:\nx0 (int): The GCD that each pair (P, Q) must have.\ny0 (int): The LCM that each pair (P, Q) must have.\n\nReturns:\nint: The count of all possible pairs (P, Q) that meet the specified criteria.\n\nThe function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\nit calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\nare co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\nthe GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\nelse by 2 to account for both (P, Q) and (Q, P) pairs.\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\nNote:\nFor the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0,\nindicating no valid pairs exist under the given constraints.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCounts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\nand y0 as their least common multiple (LCM).\n\nArgs:\nx0 (int): The GCD that each pair (P, Q) must have.\ny0 (int): The LCM that each pair (P, Q) must have.\n\nReturns:\nint: The count of all possible pairs (P, Q) that meet the specified criteria.\n\nThe function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\nit calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\nare co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\nthe GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\nelse by 2 to account for both (P, Q) and (Q, P) pairs.\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\nNote:\nFor the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0,\nindicating no valid pairs exist under the given constraints.\n\n* Incomplete Code:\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n[MASK]\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n[MASK]\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n[MASK]\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n[MASK]\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n[MASK]\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n[MASK]"}
{"task_id": "Python/27-0-multi", "prompt": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Cases:\n    - If both inorder and postorder traversals are empty, returns an empty string.\n    - If the tree consists of a single node, returns a string with that single node.\n    - For a larger tree, recursively finds the root from the postorder traversal,\n      splits the inorder traversal into left and right subtrees, and constructs\n      the preorder traversal by visiting the root followed by the left and right\n      subtrees.\n\n    Example:\n    - Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\n      will return the preorder traversal 'ABCD'.\n    - Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\n      will return the preorder traversal 'ABDEGCF'.\n    - Given a tree with a single node represented by the inorder and postorder traversal 'A',\n      the function will return 'A'.\n    \"\"\"", "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder", "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()", "entry_point": "preorder_traversal", "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:", "docstring": "Reconstructs the binary tree from its inorder and postorder traversals and\nreturns the preorder traversal as a string.\n\nArgs:\ninorder (str): The inorder traversal of the binary tree.\npostorder (str): The postorder traversal of the binary tree.\n\nReturns:\nstr: The preorder traversal of the binary tree.\n\nCases:\n- If both inorder and postorder traversals are empty, returns an empty string.\n- If the tree consists of a single node, returns a string with that single node.\n- For a larger tree, recursively finds the root from the postorder traversal,\nsplits the inorder traversal into left and right subtrees, and constructs\nthe preorder traversal by visiting the root followed by the left and right\nsubtrees.\n\nExample:\n- Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\nwill return the preorder traversal 'ABCD'.\n- Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\nwill return the preorder traversal 'ABDEGCF'.\n- Given a tree with a single node represented by the inorder and postorder traversal 'A',\nthe function will return 'A'.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nReconstructs the binary tree from its inorder and postorder traversals and\nreturns the preorder traversal as a string.\n\nArgs:\ninorder (str): The inorder traversal of the binary tree.\npostorder (str): The postorder traversal of the binary tree.\n\nReturns:\nstr: The preorder traversal of the binary tree.\n\nCases:\n- If both inorder and postorder traversals are empty, returns an empty string.\n- If the tree consists of a single node, returns a string with that single node.\n- For a larger tree, recursively finds the root from the postorder traversal,\nsplits the inorder traversal into left and right subtrees, and constructs\nthe preorder traversal by visiting the root followed by the left and right\nsubtrees.\n\nExample:\n- Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\nwill return the preorder traversal 'ABCD'.\n- Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\nwill return the preorder traversal 'ABDEGCF'.\n- Given a tree with a single node represented by the inorder and postorder traversal 'A',\nthe function will return 'A'.\n\n* Incomplete Code:\ndef preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n[MASK]\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n[MASK]\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Base case: if the traversals are empty, return an empty string\n[MASK]\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n[MASK]\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder"}
{"task_id": "Python/27-1-multi", "prompt": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Cases:\n    - If both inorder and postorder traversals are empty, returns an empty string.\n    - If the tree consists of a single node, returns a string with that single node.\n    - For a larger tree, recursively finds the root from the postorder traversal,\n      splits the inorder traversal into left and right subtrees, and constructs\n      the preorder traversal by visiting the root followed by the left and right\n      subtrees.\n\n    Example:\n    - Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\n      will return the preorder traversal 'ABCD'.\n    - Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\n      will return the preorder traversal 'ABDEGCF'.\n    - Given a tree with a single node represented by the inorder and postorder traversal 'A',\n      the function will return 'A'.\n    \"\"\"", "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder", "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()", "entry_point": "preorder_traversal", "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:", "docstring": "Reconstructs the binary tree from its inorder and postorder traversals and\nreturns the preorder traversal as a string.\n\nArgs:\ninorder (str): The inorder traversal of the binary tree.\npostorder (str): The postorder traversal of the binary tree.\n\nReturns:\nstr: The preorder traversal of the binary tree.\n\nCases:\n- If both inorder and postorder traversals are empty, returns an empty string.\n- If the tree consists of a single node, returns a string with that single node.\n- For a larger tree, recursively finds the root from the postorder traversal,\nsplits the inorder traversal into left and right subtrees, and constructs\nthe preorder traversal by visiting the root followed by the left and right\nsubtrees.\n\nExample:\n- Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\nwill return the preorder traversal 'ABCD'.\n- Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\nwill return the preorder traversal 'ABDEGCF'.\n- Given a tree with a single node represented by the inorder and postorder traversal 'A',\nthe function will return 'A'.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nReconstructs the binary tree from its inorder and postorder traversals and\nreturns the preorder traversal as a string.\n\nArgs:\ninorder (str): The inorder traversal of the binary tree.\npostorder (str): The postorder traversal of the binary tree.\n\nReturns:\nstr: The preorder traversal of the binary tree.\n\nCases:\n- If both inorder and postorder traversals are empty, returns an empty string.\n- If the tree consists of a single node, returns a string with that single node.\n- For a larger tree, recursively finds the root from the postorder traversal,\nsplits the inorder traversal into left and right subtrees, and constructs\nthe preorder traversal by visiting the root followed by the left and right\nsubtrees.\n\nExample:\n- Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\nwill return the preorder traversal 'ABCD'.\n- Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\nwill return the preorder traversal 'ABDEGCF'.\n- Given a tree with a single node represented by the inorder and postorder traversal 'A',\nthe function will return 'A'.\n\n* Incomplete Code:\ndef preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n[MASK]\n    \n    # The root is always the last element in postorder traversal\n[MASK]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n[MASK]\n[MASK]\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n[MASK]\n    \n    # The root is always the last element in postorder traversal\n[MASK]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n[MASK]\n[MASK]\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n[MASK]"}
{"task_id": "Python/28-0-multi", "prompt": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    Case 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) should return 3.\n\n    Case 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\n    is not possible within 10 steps.\n\n    Case 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) should return 3, as each character is replaced\n    individually.\n    \"\"\"", "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"", "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()", "entry_point": "string_transformation", "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:", "docstring": "Perform string transformation from A to B using a set of transformation rules.\n\nThis function takes an initial string A and a target string B, along with a list\nof transformation rules, and attempts to transform A into B using the rules.\nA Breadth-First Search (BFS) algorithm is used to explore the possible transformations\nup to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\nreturns the minimum number of steps required. If it's not possible, the function returns\n\"NO ANSWER!\".\n\nParameters:\nA (str): The initial string to be transformed.\nB (str): The target string to be achieved.\nrules (list of tuples): A list of transformation rules, where each rule is a tuple\ncontaining the source substring (to be replaced) and the\ntarget substring (to replace with).\n\nReturns:\nUnion[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) should return 3.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\nis not possible within 10 steps.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) should return 3, as each character is replaced\nindividually.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nPerform string transformation from A to B using a set of transformation rules.\n\nThis function takes an initial string A and a target string B, along with a list\nof transformation rules, and attempts to transform A into B using the rules.\nA Breadth-First Search (BFS) algorithm is used to explore the possible transformations\nup to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\nreturns the minimum number of steps required. If it's not possible, the function returns\n\"NO ANSWER!\".\n\nParameters:\nA (str): The initial string to be transformed.\nB (str): The target string to be achieved.\nrules (list of tuples): A list of transformation rules, where each rule is a tuple\ncontaining the source substring (to be replaced) and the\ntarget substring (to replace with).\n\nReturns:\nUnion[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) should return 3.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\nis not possible within 10 steps.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) should return 3, as each character is replaced\nindividually.\n\n* Incomplete Code:\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n[MASK]\n[MASK]\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n[MASK]\n                    visited.add(next_string)\n[MASK]\n                index = current.find(source, index + 1)\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n[MASK]\n[MASK]\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n[MASK]\n                    visited.add(next_string)\n[MASK]\n                index = current.find(source, index + 1)\n[MASK]"}
{"task_id": "Python/28-1-multi", "prompt": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    Case 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) should return 3.\n\n    Case 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\n    is not possible within 10 steps.\n\n    Case 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) should return 3, as each character is replaced\n    individually.\n    \"\"\"", "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"", "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()", "entry_point": "string_transformation", "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:", "docstring": "Perform string transformation from A to B using a set of transformation rules.\n\nThis function takes an initial string A and a target string B, along with a list\nof transformation rules, and attempts to transform A into B using the rules.\nA Breadth-First Search (BFS) algorithm is used to explore the possible transformations\nup to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\nreturns the minimum number of steps required. If it's not possible, the function returns\n\"NO ANSWER!\".\n\nParameters:\nA (str): The initial string to be transformed.\nB (str): The target string to be achieved.\nrules (list of tuples): A list of transformation rules, where each rule is a tuple\ncontaining the source substring (to be replaced) and the\ntarget substring (to replace with).\n\nReturns:\nUnion[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) should return 3.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\nis not possible within 10 steps.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) should return 3, as each character is replaced\nindividually.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nPerform string transformation from A to B using a set of transformation rules.\n\nThis function takes an initial string A and a target string B, along with a list\nof transformation rules, and attempts to transform A into B using the rules.\nA Breadth-First Search (BFS) algorithm is used to explore the possible transformations\nup to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\nreturns the minimum number of steps required. If it's not possible, the function returns\n\"NO ANSWER!\".\n\nParameters:\nA (str): The initial string to be transformed.\nB (str): The target string to be achieved.\nrules (list of tuples): A list of transformation rules, where each rule is a tuple\ncontaining the source substring (to be replaced) and the\ntarget substring (to replace with).\n\nReturns:\nUnion[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) should return 3.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\nis not possible within 10 steps.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) should return 3, as each character is replaced\nindividually.\n\n* Incomplete Code:\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n[MASK]\n        if current == B:\n[MASK]\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n[MASK]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n[MASK]\n    return \"NO ANSWER!\"\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n[MASK]\n        if current == B:\n[MASK]\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n[MASK]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n[MASK]\n    return \"NO ANSWER!\""}
{"task_id": "Python/29-0-multi", "prompt": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    The sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    The sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.\n    \"\"\"", "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1", "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()", "entry_point": "find_min_n_greater_than_k", "signature": "def find_min_n_greater_than_k(k: int) -> int:", "docstring": "Calculate the smallest positive integer n such that the sum of the harmonic series\nup to 1/n is greater than a given positive integer k.\n\nThe harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\nReturns:\n- int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nThe sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nThe sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the smallest positive integer n such that the sum of the harmonic series\nup to 1/n is greater than a given positive integer k.\n\nThe harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\nReturns:\n- int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nThe sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nThe sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.\n\n* Incomplete Code:\ndef find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n[MASK]\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n[MASK]\n[MASK]\n\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize variables\n[MASK]\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n[MASK]\n[MASK]\n\n\n[MASK]"}
{"task_id": "Python/29-1-multi", "prompt": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    The sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    The sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.\n    \"\"\"", "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1", "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()", "entry_point": "find_min_n_greater_than_k", "signature": "def find_min_n_greater_than_k(k: int) -> int:", "docstring": "Calculate the smallest positive integer n such that the sum of the harmonic series\nup to 1/n is greater than a given positive integer k.\n\nThe harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\nReturns:\n- int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nThe sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nThe sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the smallest positive integer n such that the sum of the harmonic series\nup to 1/n is greater than a given positive integer k.\n\nThe harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\nReturns:\n- int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nThe sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nThe sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.\n\n* Incomplete Code:\ndef find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n[MASK]\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n[MASK]\n[MASK]\n        n += 1\n\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "# Initialize variables\n[MASK]\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n[MASK]\n[MASK]\n        n += 1\n\n\n[MASK]"}
{"task_id": "Python/30-0-multi", "prompt": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    - For num = 2 or num = 3, the function should return True, since both are prime numbers.\n    - For num = 1 or num = 0, the function should return False, as neither is considered prime.\n    - For num = 15, which is divisible by 3 and 5, the function should return False.\n    - For num = 29, which has no divisors other than 1 and itself, the function should return True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()", "entry_point": "is_prime", "signature": "def is_prime(num: int) -> bool:", "docstring": "Determine whether a given integer is a prime number.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\nArgs:\nnum (int): The integer to check for primality.\n\nReturns:\nbool: True if `num` is a prime number, False otherwise.\n\nCases:\n- For num = 2 or num = 3, the function should return True, since both are prime numbers.\n- For num = 1 or num = 0, the function should return False, as neither is considered prime.\n- For num = 15, which is divisible by 3 and 5, the function should return False.\n- For num = 29, which has no divisors other than 1 and itself, the function should return True.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a given integer is a prime number.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\nArgs:\nnum (int): The integer to check for primality.\n\nReturns:\nbool: True if `num` is a prime number, False otherwise.\n\nCases:\n- For num = 2 or num = 3, the function should return True, since both are prime numbers.\n- For num = 1 or num = 0, the function should return False, as neither is considered prime.\n- For num = 15, which is divisible by 3 and 5, the function should return False.\n- For num = 29, which has no divisors other than 1 and itself, the function should return True.\n\n* Incomplete Code:\ndef is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n[MASK]\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n[MASK]\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    \"\"\"Check if a number is a prime.\"\"\"\n[MASK]\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n[MASK]\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True"}
{"task_id": "Python/30-1-multi", "prompt": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    - For num = 2 or num = 3, the function should return True, since both are prime numbers.\n    - For num = 1 or num = 0, the function should return False, as neither is considered prime.\n    - For num = 15, which is divisible by 3 and 5, the function should return False.\n    - For num = 29, which has no divisors other than 1 and itself, the function should return True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()", "entry_point": "is_prime", "signature": "def is_prime(num: int) -> bool:", "docstring": "Determine whether a given integer is a prime number.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\nArgs:\nnum (int): The integer to check for primality.\n\nReturns:\nbool: True if `num` is a prime number, False otherwise.\n\nCases:\n- For num = 2 or num = 3, the function should return True, since both are prime numbers.\n- For num = 1 or num = 0, the function should return False, as neither is considered prime.\n- For num = 15, which is divisible by 3 and 5, the function should return False.\n- For num = 29, which has no divisors other than 1 and itself, the function should return True.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDetermine whether a given integer is a prime number.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\nArgs:\nnum (int): The integer to check for primality.\n\nReturns:\nbool: True if `num` is a prime number, False otherwise.\n\nCases:\n- For num = 2 or num = 3, the function should return True, since both are prime numbers.\n- For num = 1 or num = 0, the function should return False, as neither is considered prime.\n- For num = 15, which is divisible by 3 and 5, the function should return False.\n- For num = 29, which has no divisors other than 1 and itself, the function should return True.\n\n* Incomplete Code:\ndef is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n[MASK]\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n[MASK]\n    return True\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n[MASK]\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n[MASK]\n    return True"}
{"task_id": "Python/31-0-multi", "prompt": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    - Case 1: n = 234, rules = [(2, 5), (3, 6)]\n              This case should return 4 because the following unique numbers can be generated:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n    - Case 2: n = 100, rules = [(1, 9)]\n              This case should return 2 because the following unique numbers can be generated:\n              100 (original) and 900 (1 -> 9).\n\n    - Case 3: n = 8, rules = [(8, 3), (8, 5)]\n              This case should return 3 because the following unique numbers can be generated:\n              8 (original), 3 (8 -> 3), and 5 (8 -> 5).\n    \"\"\"", "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)", "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()", "entry_point": "generate_numbers", "signature": "def generate_numbers(n, rules) -> int:", "docstring": "Generate all unique numbers from the given number by applying transformation rules.\n\nEach rule allows a single digit to be transformed into another. A breadth-first search\n(BFS) is used to explore all possible transformations. The function returns the count\nof unique numbers that can be generated from the original number, including the number itself.\n\nArgs:\n- n (int): The original integer number to transform.\n- rules (list of tuples): A list of transformation rules, where each rule is represented\nas a tuple (x, y) indicating that digit x can be transformed into y.\n\nReturns:\n- int: The total count of unique numbers that can be generated.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nThis case should return 4 because the following unique numbers can be generated:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nThis case should return 2 because the following unique numbers can be generated:\n100 (original) and 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nThis case should return 3 because the following unique numbers can be generated:\n8 (original), 3 (8 -> 3), and 5 (8 -> 5).", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique numbers from the given number by applying transformation rules.\n\nEach rule allows a single digit to be transformed into another. A breadth-first search\n(BFS) is used to explore all possible transformations. The function returns the count\nof unique numbers that can be generated from the original number, including the number itself.\n\nArgs:\n- n (int): The original integer number to transform.\n- rules (list of tuples): A list of transformation rules, where each rule is represented\nas a tuple (x, y) indicating that digit x can be transformed into y.\n\nReturns:\n- int: The total count of unique numbers that can be generated.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nThis case should return 4 because the following unique numbers can be generated:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nThis case should return 2 because the following unique numbers can be generated:\n100 (original) and 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nThis case should return 3 because the following unique numbers can be generated:\n8 (original), 3 (8 -> 3), and 5 (8 -> 5).\n\n* Incomplete Code:\ndef generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n[MASK]\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n[MASK]\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n[MASK]\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Convert the input number n to a string for easier manipulation\n[MASK]\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n[MASK]\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n[MASK]\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)"}
{"task_id": "Python/31-1-multi", "prompt": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    - Case 1: n = 234, rules = [(2, 5), (3, 6)]\n              This case should return 4 because the following unique numbers can be generated:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n    - Case 2: n = 100, rules = [(1, 9)]\n              This case should return 2 because the following unique numbers can be generated:\n              100 (original) and 900 (1 -> 9).\n\n    - Case 3: n = 8, rules = [(8, 3), (8, 5)]\n              This case should return 3 because the following unique numbers can be generated:\n              8 (original), 3 (8 -> 3), and 5 (8 -> 5).\n    \"\"\"", "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)", "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()", "entry_point": "generate_numbers", "signature": "def generate_numbers(n, rules) -> int:", "docstring": "Generate all unique numbers from the given number by applying transformation rules.\n\nEach rule allows a single digit to be transformed into another. A breadth-first search\n(BFS) is used to explore all possible transformations. The function returns the count\nof unique numbers that can be generated from the original number, including the number itself.\n\nArgs:\n- n (int): The original integer number to transform.\n- rules (list of tuples): A list of transformation rules, where each rule is represented\nas a tuple (x, y) indicating that digit x can be transformed into y.\n\nReturns:\n- int: The total count of unique numbers that can be generated.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nThis case should return 4 because the following unique numbers can be generated:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nThis case should return 2 because the following unique numbers can be generated:\n100 (original) and 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nThis case should return 3 because the following unique numbers can be generated:\n8 (original), 3 (8 -> 3), and 5 (8 -> 5).", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nGenerate all unique numbers from the given number by applying transformation rules.\n\nEach rule allows a single digit to be transformed into another. A breadth-first search\n(BFS) is used to explore all possible transformations. The function returns the count\nof unique numbers that can be generated from the original number, including the number itself.\n\nArgs:\n- n (int): The original integer number to transform.\n- rules (list of tuples): A list of transformation rules, where each rule is represented\nas a tuple (x, y) indicating that digit x can be transformed into y.\n\nReturns:\n- int: The total count of unique numbers that can be generated.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nThis case should return 4 because the following unique numbers can be generated:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nThis case should return 2 because the following unique numbers can be generated:\n100 (original) and 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nThis case should return 3 because the following unique numbers can be generated:\n8 (original), 3 (8 -> 3), and 5 (8 -> 5).\n\n* Incomplete Code:\ndef generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n[MASK]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n[MASK]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n[MASK]"}
{"task_id": "Python/32-0-multi", "prompt": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      False if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\n      since statements about the day of the week are ignored.\n    \"\"\"\n    # Function implementation...", "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True", "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()", "entry_point": "check_scenario", "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:", "docstring": "Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\nThis function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\nthe statements made by all participants are consistent with this scenario, disregarding any statements\nabout the day of the week.\n\nParameters:\n- scenario (str): The name of the participant being tested as the potential criminal.\n- liar_count (set): A set of names of participants who are assumed to be liars.\n- statements (dict): A dictionary mapping participant names to lists of their respective statements.\n- days_of_week (set): A set of strings representing the days of the week.\n\nReturns:\n- bool: True if the scenario is consistent with the statements, False otherwise.\n\nTest Cases:\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nFalse if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\nsince statements about the day of the week are ignored.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nEvaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\nThis function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\nthe statements made by all participants are consistent with this scenario, disregarding any statements\nabout the day of the week.\n\nParameters:\n- scenario (str): The name of the participant being tested as the potential criminal.\n- liar_count (set): A set of names of participants who are assumed to be liars.\n- statements (dict): A dictionary mapping participant names to lists of their respective statements.\n- days_of_week (set): A set of strings representing the days of the week.\n\nReturns:\n- bool: True if the scenario is consistent with the statements, False otherwise.\n\nTest Cases:\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nFalse if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\nsince statements about the day of the week are ignored.\n\n* Incomplete Code:\ndef check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n[MASK]\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n[MASK]\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n[MASK]\n[MASK]\n[MASK]\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n[MASK]\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n[MASK]\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n[MASK]\n[MASK]\n[MASK]\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True"}
{"task_id": "Python/32-1-multi", "prompt": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      False if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\n      since statements about the day of the week are ignored.\n    \"\"\"\n    # Function implementation...", "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True", "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()", "entry_point": "check_scenario", "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:", "docstring": "Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\nThis function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\nthe statements made by all participants are consistent with this scenario, disregarding any statements\nabout the day of the week.\n\nParameters:\n- scenario (str): The name of the participant being tested as the potential criminal.\n- liar_count (set): A set of names of participants who are assumed to be liars.\n- statements (dict): A dictionary mapping participant names to lists of their respective statements.\n- days_of_week (set): A set of strings representing the days of the week.\n\nReturns:\n- bool: True if the scenario is consistent with the statements, False otherwise.\n\nTest Cases:\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nFalse if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\nsince statements about the day of the week are ignored.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nEvaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\nThis function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\nthe statements made by all participants are consistent with this scenario, disregarding any statements\nabout the day of the week.\n\nParameters:\n- scenario (str): The name of the participant being tested as the potential criminal.\n- liar_count (set): A set of names of participants who are assumed to be liars.\n- statements (dict): A dictionary mapping participant names to lists of their respective statements.\n- days_of_week (set): A set of strings representing the days of the week.\n\nReturns:\n- bool: True if the scenario is consistent with the statements, False otherwise.\n\nTest Cases:\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nFalse if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\nsince statements about the day of the week are ignored.\n\n* Incomplete Code:\ndef check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n[MASK]\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n[MASK]\n            elif \"I am not guilty.\" == stmt:\n[MASK]\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n[MASK]\n                if (other == scenario) != (name in liar_count):\n[MASK]\n    return True\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    for name, stmts in statements.items():\n        for stmt in stmts:\n[MASK]\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n[MASK]\n            elif \"I am not guilty.\" == stmt:\n[MASK]\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n[MASK]\n                if (other == scenario) != (name in liar_count):\n[MASK]\n    return True"}
{"task_id": "Python/33-0-multi", "prompt": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    - If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\n      with scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\n      The 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores", "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()", "entry_point": "calculate_score", "signature": "def calculate_score(system: int, points: str) -> list:", "docstring": "Calculate the score of a series of ping-pong games based on the provided scoring system.\n\nThis function takes in the desired scoring system (either 11 or 21 points) and a string\nrepresenting the sequence of points won by the player ('W') and the opponent ('L').\nThe function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\nThe game is considered finished when one player reaches the system's required number of points\n(11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game,\nthat game's current score is also included in the output.\n\nArgs:\n- system (int): The number of points required to win a game (either 11 or 21).\n- points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\nReturns:\n- list: A list of strings representing the score of each game.\n\nCases:\n- If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\nwith scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\nThe 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the score of a series of ping-pong games based on the provided scoring system.\n\nThis function takes in the desired scoring system (either 11 or 21 points) and a string\nrepresenting the sequence of points won by the player ('W') and the opponent ('L').\nThe function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\nThe game is considered finished when one player reaches the system's required number of points\n(11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game,\nthat game's current score is also included in the output.\n\nArgs:\n- system (int): The number of points required to win a game (either 11 or 21).\n- points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\nReturns:\n- list: A list of strings representing the score of each game.\n\nCases:\n- If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\nwith scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\nThe 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]\n\n* Incomplete Code:\ndef calculate_score(system: int, points: str) -> list:\n    match_scores = []\n[MASK]\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n[MASK]\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    match_scores = []\n[MASK]\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n[MASK]\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores"}
{"task_id": "Python/33-1-multi", "prompt": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    - If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\n      with scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\n      The 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"", "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores", "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()", "entry_point": "calculate_score", "signature": "def calculate_score(system: int, points: str) -> list:", "docstring": "Calculate the score of a series of ping-pong games based on the provided scoring system.\n\nThis function takes in the desired scoring system (either 11 or 21 points) and a string\nrepresenting the sequence of points won by the player ('W') and the opponent ('L').\nThe function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\nThe game is considered finished when one player reaches the system's required number of points\n(11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game,\nthat game's current score is also included in the output.\n\nArgs:\n- system (int): The number of points required to win a game (either 11 or 21).\n- points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\nReturns:\n- list: A list of strings representing the score of each game.\n\nCases:\n- If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\nwith scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\nThe 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the score of a series of ping-pong games based on the provided scoring system.\n\nThis function takes in the desired scoring system (either 11 or 21 points) and a string\nrepresenting the sequence of points won by the player ('W') and the opponent ('L').\nThe function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\nThe game is considered finished when one player reaches the system's required number of points\n(11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game,\nthat game's current score is also included in the output.\n\nArgs:\n- system (int): The number of points required to win a game (either 11 or 21).\n- points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\nReturns:\n- list: A list of strings representing the score of each game.\n\nCases:\n- If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\nwith scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\nThe 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]\n\n* Incomplete Code:\ndef calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n[MASK]\n            score_b += 1\n\n        # Check if a game is finished under the current system\n[MASK]\n[MASK]\n[MASK]\n\n    # Include the last game if it's not finished when input ends\n[MASK]\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n[MASK]\n            score_b += 1\n\n        # Check if a game is finished under the current system\n[MASK]\n[MASK]\n[MASK]\n\n    # Include the last game if it's not finished when input ends\n[MASK]\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores"}
{"task_id": "Python/34-0-multi", "prompt": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n    - For n=0, the function should return 1, since C(0) = 1.\n      catalan_number(0) -> 1\n\n    - For n=3, the function should return 5, since C(3) = 5.\n      catalan_number(3) -> 5\n\n    - For n=5, the function should return 42, since C(5) = 42.\n      catalan_number(5) -> 42\n\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"", "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]", "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()", "entry_point": "catalan_number", "signature": "def catalan_number(n: int) -> int:", "docstring": "Calculate the nth Catalan number.\n\nThe function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural\nnumbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths,\nthe number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1\nfactors can be completely parenthesized, and more.\n\nArgs:\n- n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\nReturns:\n- int: The nth Catalan number.\n\nCases:\n- For n=0, the function should return 1, since C(0) = 1.\ncatalan_number(0) -> 1\n\n- For n=3, the function should return 5, since C(3) = 5.\ncatalan_number(3) -> 5\n\n- For n=5, the function should return 42, since C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nThe computation is based on the recursive formula:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwhere C(0) is 1.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the nth Catalan number.\n\nThe function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural\nnumbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths,\nthe number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1\nfactors can be completely parenthesized, and more.\n\nArgs:\n- n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\nReturns:\n- int: The nth Catalan number.\n\nCases:\n- For n=0, the function should return 1, since C(0) = 1.\ncatalan_number(0) -> 1\n\n- For n=3, the function should return 5, since C(3) = 5.\ncatalan_number(3) -> 5\n\n- For n=5, the function should return 42, since C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nThe computation is based on the recursive formula:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwhere C(0) is 1.\n\n* Incomplete Code:\ndef catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n[MASK]\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n[MASK]\n        for j in range(i):\n[MASK]\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize an array to store the intermediate catalan numbers\n[MASK]\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n[MASK]\n        for j in range(i):\n[MASK]\n\n[MASK]"}
{"task_id": "Python/34-1-multi", "prompt": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n    - For n=0, the function should return 1, since C(0) = 1.\n      catalan_number(0) -> 1\n\n    - For n=3, the function should return 5, since C(3) = 5.\n      catalan_number(3) -> 5\n\n    - For n=5, the function should return 42, since C(5) = 42.\n      catalan_number(5) -> 42\n\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"", "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]", "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()", "entry_point": "catalan_number", "signature": "def catalan_number(n: int) -> int:", "docstring": "Calculate the nth Catalan number.\n\nThe function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural\nnumbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths,\nthe number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1\nfactors can be completely parenthesized, and more.\n\nArgs:\n- n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\nReturns:\n- int: The nth Catalan number.\n\nCases:\n- For n=0, the function should return 1, since C(0) = 1.\ncatalan_number(0) -> 1\n\n- For n=3, the function should return 5, since C(3) = 5.\ncatalan_number(3) -> 5\n\n- For n=5, the function should return 42, since C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nThe computation is based on the recursive formula:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwhere C(0) is 1.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the nth Catalan number.\n\nThe function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural\nnumbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths,\nthe number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1\nfactors can be completely parenthesized, and more.\n\nArgs:\n- n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\nReturns:\n- int: The nth Catalan number.\n\nCases:\n- For n=0, the function should return 1, since C(0) = 1.\ncatalan_number(0) -> 1\n\n- For n=3, the function should return 5, since C(3) = 5.\ncatalan_number(3) -> 5\n\n- For n=5, the function should return 42, since C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nThe computation is based on the recursive formula:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwhere C(0) is 1.\n\n* Incomplete Code:\ndef catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n[MASK]\n[MASK]\n[MASK]\n\n    return catalan[n]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n[MASK]\n[MASK]\n[MASK]\n\n    return catalan[n]"}
{"task_id": "Python/35-0-multi", "prompt": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n    1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples", "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()", "entry_point": "count_apples_reachable", "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:", "docstring": "Calculate the number of apples that Tao Tao can reach.\n\nArgs:\napple_heights (List[int]): The heights of apples from the ground (in centimeters).\ntao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\nReturns:\nint: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\nThis function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\nconsidering an additional 30cm that the stool provides.\n\nExample cases:\n1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of apples that Tao Tao can reach.\n\nArgs:\napple_heights (List[int]): The heights of apples from the ground (in centimeters).\ntao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\nReturns:\nint: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\nThis function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\nconsidering an additional 30cm that the stool provides.\n\nExample cases:\n1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n\n* Incomplete Code:\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n[MASK]\n        if height <= total_reach:\n[MASK]\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n[MASK]\n        if height <= total_reach:\n[MASK]\n\n[MASK]"}
{"task_id": "Python/35-1-multi", "prompt": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n    1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"", "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples", "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()", "entry_point": "count_apples_reachable", "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:", "docstring": "Calculate the number of apples that Tao Tao can reach.\n\nArgs:\napple_heights (List[int]): The heights of apples from the ground (in centimeters).\ntao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\nReturns:\nint: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\nThis function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\nconsidering an additional 30cm that the stool provides.\n\nExample cases:\n1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of apples that Tao Tao can reach.\n\nArgs:\napple_heights (List[int]): The heights of apples from the ground (in centimeters).\ntao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\nReturns:\nint: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\nThis function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\nconsidering an additional 30cm that the stool provides.\n\nExample cases:\n1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n\n* Incomplete Code:\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n[MASK]\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n[MASK]\n[MASK]\n[MASK]\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n[MASK]\n[MASK]\n[MASK]\n\n[MASK]"}
{"task_id": "Python/36-0-multi", "prompt": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\n      and 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\n      and at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\n      are cleared, leaving trees at positions 0 to 9 and 91 to 100.\n    \"\"\"", "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees", "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()", "entry_point": "remaining_trees_after_clearing", "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:", "docstring": "Calculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.\n\n* Incomplete Code:\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n[MASK]\n[MASK]\n\n    # Count the remaining trees\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n[MASK]\n[MASK]\n\n    # Count the remaining trees\n[MASK]\n[MASK]"}
{"task_id": "Python/36-1-multi", "prompt": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\n      and 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\n      and at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\n      are cleared, leaving trees at positions 0 to 9 and 91 to 100.\n    \"\"\"", "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees", "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()", "entry_point": "remaining_trees_after_clearing", "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:", "docstring": "Calculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.\n\n* Incomplete Code:\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n[MASK]\n[MASK]\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n[MASK]\n[MASK]\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n[MASK]\n[MASK]"}
{"task_id": "Python/37-0-multi", "prompt": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      In this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\n      to the time constraint, leading to a maximum value of 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Here, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      With a time limit of 5, only the first herb can be picked, providing a value of 10.\n    \"\"\"", "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]", "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()", "entry_point": "max_herb_value", "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:", "docstring": "Calculate the maximum total value of herbs that can be picked within a given time limit.\n\nThis function solves a variation of the 0/1 knapsack problem where the goal is to maximize\nthe total value of herbs picked without exceeding the time limit. Each herb can be picked\nat most once and has an associated time cost and value.\n\nArgs:\n- T (int): The total time available for picking herbs.\n- M (int): The number of different herbs in the cave.\n- herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\nrepresenting the time required to pick the herb and the herb's value, respectively.\n\nReturns:\n- int: The maximum total value of herbs that can be picked within the time limit.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\nto the time constraint, leading to a maximum value of 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHere, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nWith a time limit of 5, only the first herb can be picked, providing a value of 10.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum total value of herbs that can be picked within a given time limit.\n\nThis function solves a variation of the 0/1 knapsack problem where the goal is to maximize\nthe total value of herbs picked without exceeding the time limit. Each herb can be picked\nat most once and has an associated time cost and value.\n\nArgs:\n- T (int): The total time available for picking herbs.\n- M (int): The number of different herbs in the cave.\n- herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\nrepresenting the time required to pick the herb and the herb's value, respectively.\n\nReturns:\n- int: The maximum total value of herbs that can be picked within the time limit.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\nto the time constraint, leading to a maximum value of 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHere, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nWith a time limit of 5, only the first herb can be picked, providing a value of 10.\n\n* Incomplete Code:\ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n[MASK]\n\n    for i in range(1, M + 1):\n[MASK]\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n[MASK]\n[MASK]\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n\n    for i in range(1, M + 1):\n[MASK]\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n[MASK]\n[MASK]\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n[MASK]"}
{"task_id": "Python/37-1-multi", "prompt": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      In this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\n      to the time constraint, leading to a maximum value of 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Here, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      With a time limit of 5, only the first herb can be picked, providing a value of 10.\n    \"\"\"", "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]", "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()", "entry_point": "max_herb_value", "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:", "docstring": "Calculate the maximum total value of herbs that can be picked within a given time limit.\n\nThis function solves a variation of the 0/1 knapsack problem where the goal is to maximize\nthe total value of herbs picked without exceeding the time limit. Each herb can be picked\nat most once and has an associated time cost and value.\n\nArgs:\n- T (int): The total time available for picking herbs.\n- M (int): The number of different herbs in the cave.\n- herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\nrepresenting the time required to pick the herb and the herb's value, respectively.\n\nReturns:\n- int: The maximum total value of herbs that can be picked within the time limit.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\nto the time constraint, leading to a maximum value of 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHere, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nWith a time limit of 5, only the first herb can be picked, providing a value of 10.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the maximum total value of herbs that can be picked within a given time limit.\n\nThis function solves a variation of the 0/1 knapsack problem where the goal is to maximize\nthe total value of herbs picked without exceeding the time limit. Each herb can be picked\nat most once and has an associated time cost and value.\n\nArgs:\n- T (int): The total time available for picking herbs.\n- M (int): The number of different herbs in the cave.\n- herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\nrepresenting the time required to pick the herb and the herb's value, respectively.\n\nReturns:\n- int: The maximum total value of herbs that can be picked within the time limit.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\nto the time constraint, leading to a maximum value of 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHere, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nWith a time limit of 5, only the first herb can be picked, providing a value of 10.\n\n* Incomplete Code:\ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n[MASK]\n        for j in range(1, T + 1):\n[MASK]\n            if j >= time:\n                # We can choose to pick this herb or not\n[MASK]\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n[MASK]\n        for j in range(1, T + 1):\n[MASK]\n            if j >= time:\n                # We can choose to pick this herb or not\n[MASK]\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]"}
{"task_id": "Python/38-0-multi", "prompt": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      All items can be fit into the box without any remaining space.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      An optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Since all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.\n    \"\"\"", "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]", "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()", "entry_point": "min_remaining_space", "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:", "docstring": "Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n\nThis function uses a dynamic programming approach to determine the maximum volume that can be occupied\nin the box by any subset of the given items. It then returns the difference between the box's total capacity\nand this maximum occupied volume, which is the minimum remaining space.\n\nArgs:\n- V (int): The total capacity of the box.\n- n (int): The number of items to consider for packing into the box.\n- volumes (List[int]): A list of the volumes of the n items.\n\nReturns:\n- int: The minimum remaining space in the box after fitting the items.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAll items can be fit into the box without any remaining space.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAn optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nSince all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n\nThis function uses a dynamic programming approach to determine the maximum volume that can be occupied\nin the box by any subset of the given items. It then returns the difference between the box's total capacity\nand this maximum occupied volume, which is the minimum remaining space.\n\nArgs:\n- V (int): The total capacity of the box.\n- n (int): The number of items to consider for packing into the box.\n- volumes (List[int]): A list of the volumes of the n items.\n\nReturns:\n- int: The minimum remaining space in the box after fitting the items.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAll items can be fit into the box without any remaining space.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAn optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nSince all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.\n\n* Incomplete Code:\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n[MASK]\n\n    # Loop through each item\n[MASK]\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Create a list to store the maximum volume that can be filled for each capacity\n[MASK]\n\n    # Loop through each item\n[MASK]\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n[MASK]"}
{"task_id": "Python/38-1-multi", "prompt": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      All items can be fit into the box without any remaining space.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      An optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Since all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.\n    \"\"\"", "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]", "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()", "entry_point": "min_remaining_space", "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:", "docstring": "Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n\nThis function uses a dynamic programming approach to determine the maximum volume that can be occupied\nin the box by any subset of the given items. It then returns the difference between the box's total capacity\nand this maximum occupied volume, which is the minimum remaining space.\n\nArgs:\n- V (int): The total capacity of the box.\n- n (int): The number of items to consider for packing into the box.\n- volumes (List[int]): A list of the volumes of the n items.\n\nReturns:\n- int: The minimum remaining space in the box after fitting the items.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAll items can be fit into the box without any remaining space.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAn optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nSince all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n\nThis function uses a dynamic programming approach to determine the maximum volume that can be occupied\nin the box by any subset of the given items. It then returns the difference between the box's total capacity\nand this maximum occupied volume, which is the minimum remaining space.\n\nArgs:\n- V (int): The total capacity of the box.\n- n (int): The number of items to consider for packing into the box.\n- volumes (List[int]): A list of the volumes of the n items.\n\nReturns:\n- int: The minimum remaining space in the box after fitting the items.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAll items can be fit into the box without any remaining space.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAn optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nSince all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.\n\n* Incomplete Code:\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n[MASK]\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n[MASK]\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Create a list to store the maximum volume that can be filled for each capacity\n[MASK]\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n[MASK]\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]"}
{"task_id": "Python/39-0-multi", "prompt": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n      There are two possible arrangements for 4 pots using two types of flowers with\n      at most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n      There are six ways to arrange 3 pots using three types of flowers when the\n      maximum pots are 1, 2, and 3 for the first, second, and third types respectively.\n    \"\"\"", "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]", "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()", "entry_point": "calculate_arrangements", "signature": "def calculate_arrangements(n, m, a) -> int:", "docstring": "Compute the number of ways to arrange m pots of flowers using up to n types,\nwhere the ith type can have at most a[i] pots, and the arrangement must be in\nincreasing order of flower types.\n\nArgs:\n- n (int): The number of flower types available.\n- m (int): The total number of flower pots to arrange.\n- a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\nReturns:\n- int: The number of distinct arrangements modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nThere are two possible arrangements for 4 pots using two types of flowers with\nat most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nThere are six ways to arrange 3 pots using three types of flowers when the\nmaximum pots are 1, 2, and 3 for the first, second, and third types respectively.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCompute the number of ways to arrange m pots of flowers using up to n types,\nwhere the ith type can have at most a[i] pots, and the arrangement must be in\nincreasing order of flower types.\n\nArgs:\n- n (int): The number of flower types available.\n- m (int): The total number of flower pots to arrange.\n- a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\nReturns:\n- int: The number of distinct arrangements modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nThere are two possible arrangements for 4 pots using two types of flowers with\nat most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nThere are six ways to arrange 3 pots using three types of flowers when the\nmaximum pots are 1, 2, and 3 for the first, second, and third types respectively.\n\n* Incomplete Code:\ndef calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n[MASK]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n[MASK]\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n[MASK]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n[MASK]\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n[MASK]"}
{"task_id": "Python/39-1-multi", "prompt": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n      There are two possible arrangements for 4 pots using two types of flowers with\n      at most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n      There are six ways to arrange 3 pots using three types of flowers when the\n      maximum pots are 1, 2, and 3 for the first, second, and third types respectively.\n    \"\"\"", "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]", "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()", "entry_point": "calculate_arrangements", "signature": "def calculate_arrangements(n, m, a) -> int:", "docstring": "Compute the number of ways to arrange m pots of flowers using up to n types,\nwhere the ith type can have at most a[i] pots, and the arrangement must be in\nincreasing order of flower types.\n\nArgs:\n- n (int): The number of flower types available.\n- m (int): The total number of flower pots to arrange.\n- a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\nReturns:\n- int: The number of distinct arrangements modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nThere are two possible arrangements for 4 pots using two types of flowers with\nat most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nThere are six ways to arrange 3 pots using three types of flowers when the\nmaximum pots are 1, 2, and 3 for the first, second, and third types respectively.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCompute the number of ways to arrange m pots of flowers using up to n types,\nwhere the ith type can have at most a[i] pots, and the arrangement must be in\nincreasing order of flower types.\n\nArgs:\n- n (int): The number of flower types available.\n- m (int): The total number of flower pots to arrange.\n- a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\nReturns:\n- int: The number of distinct arrangements modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nThere are two possible arrangements for 4 pots using two types of flowers with\nat most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nThere are six ways to arrange 3 pots using three types of flowers when the\nmaximum pots are 1, 2, and 3 for the first, second, and third types respectively.\n\n* Incomplete Code:\ndef calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n[MASK]\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n[MASK]\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n[MASK]\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n[MASK]\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]"}
{"task_id": "Python/40-0-multi", "prompt": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()", "entry_point": "vigenere_decrypt", "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:", "docstring": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n\nThe Vigenère cipher is a method of encrypting alphabetic text by using a series of\nCaesar ciphers based on the letters of a keyword. This function reverses the process\nto recover the original plaintext from the ciphertext.\n\nArgs:\nkey (str): The encryption key used to encrypt the original plaintext.\nThis key should consist only of alphabetic characters.\nciphertext (str): The encrypted text that needs to be decrypted.\nThe ciphertext should consist only of alphabetic characters.\n\nReturns:\nstr: The decrypted plaintext corresponding to the input ciphertext.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDecrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n\nThe Vigenère cipher is a method of encrypting alphabetic text by using a series of\nCaesar ciphers based on the letters of a keyword. This function reverses the process\nto recover the original plaintext from the ciphertext.\n\nArgs:\nkey (str): The encryption key used to encrypt the original plaintext.\nThis key should consist only of alphabetic characters.\nciphertext (str): The encrypted text that needs to be decrypted.\nThe ciphertext should consist only of alphabetic characters.\n\nReturns:\nstr: The decrypted plaintext corresponding to the input ciphertext.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'\n\n* Incomplete Code:\ndef vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n[MASK]\n[MASK]\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n[MASK]\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n[MASK]\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Convert the key to uppercase for simplicity\n[MASK]\n[MASK]\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n[MASK]\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n[MASK]\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)"}
{"task_id": "Python/40-1-multi", "prompt": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided", "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)", "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()", "entry_point": "vigenere_decrypt", "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:", "docstring": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n\nThe Vigenère cipher is a method of encrypting alphabetic text by using a series of\nCaesar ciphers based on the letters of a keyword. This function reverses the process\nto recover the original plaintext from the ciphertext.\n\nArgs:\nkey (str): The encryption key used to encrypt the original plaintext.\nThis key should consist only of alphabetic characters.\nciphertext (str): The encrypted text that needs to be decrypted.\nThe ciphertext should consist only of alphabetic characters.\n\nReturns:\nstr: The decrypted plaintext corresponding to the input ciphertext.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDecrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n\nThe Vigenère cipher is a method of encrypting alphabetic text by using a series of\nCaesar ciphers based on the letters of a keyword. This function reverses the process\nto recover the original plaintext from the ciphertext.\n\nArgs:\nkey (str): The encryption key used to encrypt the original plaintext.\nThis key should consist only of alphabetic characters.\nciphertext (str): The encrypted text that needs to be decrypted.\nThe ciphertext should consist only of alphabetic characters.\n\nReturns:\nstr: The decrypted plaintext corresponding to the input ciphertext.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'\n\n* Incomplete Code:\ndef vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n[MASK]\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n[MASK]\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n[MASK]\n            if char.islower():\n[MASK]\n            \n            plaintext.append(decrypted_char)\n[MASK]\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n[MASK]\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n[MASK]\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n[MASK]\n            if char.islower():\n[MASK]\n            \n            plaintext.append(decrypted_char)\n[MASK]\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)"}
{"task_id": "Python/41-0-multi", "prompt": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n      # Explanation: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explanation: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explanation: gcd(42, 2017) != 1, so no inverse exists\n    \"\"\"", "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()", "entry_point": "mod_inverse", "signature": "def mod_inverse(a, b):", "docstring": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n\nThis function finds an integer `x` such that (a * x) % b == 1, provided that\n`a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\nAlgorithm to compute the inverse. If `a` and `b` are not coprime, the modular\ninverse does not exist, and the function returns `None`.\n\nArgs:\na (int): The integer whose modular inverse is to be found.\nb (int): The modulus with respect to which the inverse is sought.\n\nReturns:\nint: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the modular multiplicative inverse of `a` modulo `b`.\n\nThis function finds an integer `x` such that (a * x) % b == 1, provided that\n`a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\nAlgorithm to compute the inverse. If `a` and `b` are not coprime, the modular\ninverse does not exist, and the function returns `None`.\n\nArgs:\na (int): The integer whose modular inverse is to be found.\nb (int): The modulus with respect to which the inverse is sought.\n\nReturns:\nint: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists\n\n* Incomplete Code:\ndef mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n[MASK]\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n[MASK]\n[MASK]\n        # Make sure the result is positive\n        return x % b\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n[MASK]\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n[MASK]\n[MASK]\n        # Make sure the result is positive\n        return x % b"}
{"task_id": "Python/41-1-multi", "prompt": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n      # Explanation: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explanation: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explanation: gcd(42, 2017) != 1, so no inverse exists\n    \"\"\"", "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b", "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()", "entry_point": "mod_inverse", "signature": "def mod_inverse(a, b):", "docstring": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n\nThis function finds an integer `x` such that (a * x) % b == 1, provided that\n`a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\nAlgorithm to compute the inverse. If `a` and `b` are not coprime, the modular\ninverse does not exist, and the function returns `None`.\n\nArgs:\na (int): The integer whose modular inverse is to be found.\nb (int): The modulus with respect to which the inverse is sought.\n\nReturns:\nint: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the modular multiplicative inverse of `a` modulo `b`.\n\nThis function finds an integer `x` such that (a * x) % b == 1, provided that\n`a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\nAlgorithm to compute the inverse. If `a` and `b` are not coprime, the modular\ninverse does not exist, and the function returns `None`.\n\nArgs:\na (int): The integer whose modular inverse is to be found.\nb (int): The modulus with respect to which the inverse is sought.\n\nReturns:\nint: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists\n\n* Incomplete Code:\ndef mod_inverse(a, b):\n    def extended_gcd(a, b):\n[MASK]\n[MASK]\n        gcd, x1, y1 = extended_gcd(b % a, a)\n[MASK]\n[MASK]\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    def extended_gcd(a, b):\n[MASK]\n[MASK]\n        gcd, x1, y1 = extended_gcd(b % a, a)\n[MASK]\n[MASK]\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n[MASK]"}
{"task_id": "Python/42-0-multi", "prompt": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n        - If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          she is most unhappy on Wednesday (day 3), so the function will return 3.\n        - If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\n          unhappy, and the function will return 0.\n        - For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally \n          unhappy on Monday and Thursday, but since Monday comes first, the function returns 1.\n    \"\"\"", "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day", "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()", "entry_point": "find_most_unhappy_day", "signature": "def find_most_unhappy_day(schedule) -> int:", "docstring": "Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n\nJinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day.\nThe function finds the day when her unhappiness is the greatest, which is the day when the total\nhours are the farthest above the threshold. If there are multiple days with the same level of\nmaximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the\nfunction returns 0.\n\nArgs:\nschedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the\nnumber of hours spent at school and in extra classes\nfor each day of the week, respectively.\n\nReturns:\nint: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0\nif she is never unhappy.\n\nCases:\n- If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nshe is most unhappy on Wednesday (day 3), so the function will return 3.\n- If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\nunhappy, and the function will return 0.\n- For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally\nunhappy on Monday and Thursday, but since Monday comes first, the function returns 1.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the day of the week when Jinjin is most unhappy based on her schedule.\n\nJinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day.\nThe function finds the day when her unhappiness is the greatest, which is the day when the total\nhours are the farthest above the threshold. If there are multiple days with the same level of\nmaximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the\nfunction returns 0.\n\nArgs:\nschedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the\nnumber of hours spent at school and in extra classes\nfor each day of the week, respectively.\n\nReturns:\nint: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0\nif she is never unhappy.\n\nCases:\n- If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nshe is most unhappy on Wednesday (day 3), so the function will return 3.\n- If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\nunhappy, and the function will return 0.\n- For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally\nunhappy on Monday and Thursday, but since Monday comes first, the function returns 1.\n\n* Incomplete Code:\ndef find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n[MASK]\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n[MASK]\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n[MASK]\n            max_unhappiness = unhappiness\n[MASK]\n\n    return most_unhappy_day\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n[MASK]\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n[MASK]\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n[MASK]\n            max_unhappiness = unhappiness\n[MASK]\n\n    return most_unhappy_day"}
{"task_id": "Python/42-1-multi", "prompt": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n        - If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          she is most unhappy on Wednesday (day 3), so the function will return 3.\n        - If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\n          unhappy, and the function will return 0.\n        - For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally \n          unhappy on Monday and Thursday, but since Monday comes first, the function returns 1.\n    \"\"\"", "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day", "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()", "entry_point": "find_most_unhappy_day", "signature": "def find_most_unhappy_day(schedule) -> int:", "docstring": "Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n\nJinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day.\nThe function finds the day when her unhappiness is the greatest, which is the day when the total\nhours are the farthest above the threshold. If there are multiple days with the same level of\nmaximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the\nfunction returns 0.\n\nArgs:\nschedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the\nnumber of hours spent at school and in extra classes\nfor each day of the week, respectively.\n\nReturns:\nint: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0\nif she is never unhappy.\n\nCases:\n- If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nshe is most unhappy on Wednesday (day 3), so the function will return 3.\n- If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\nunhappy, and the function will return 0.\n- For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally\nunhappy on Monday and Thursday, but since Monday comes first, the function returns 1.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the day of the week when Jinjin is most unhappy based on her schedule.\n\nJinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day.\nThe function finds the day when her unhappiness is the greatest, which is the day when the total\nhours are the farthest above the threshold. If there are multiple days with the same level of\nmaximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the\nfunction returns 0.\n\nArgs:\nschedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the\nnumber of hours spent at school and in extra classes\nfor each day of the week, respectively.\n\nReturns:\nint: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0\nif she is never unhappy.\n\nCases:\n- If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nshe is most unhappy on Wednesday (day 3), so the function will return 3.\n- If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\nunhappy, and the function will return 0.\n- For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally\nunhappy on Monday and Thursday, but since Monday comes first, the function returns 1.\n\n* Incomplete Code:\ndef find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n[MASK]\n\n    most_unhappy_day = 0\n[MASK]\n\n[MASK]\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n[MASK]\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    DAYS_OF_WEEK = 7\n[MASK]\n\n    most_unhappy_day = 0\n[MASK]\n\n[MASK]\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n[MASK]\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n[MASK]"}
{"task_id": "Python/43-0-multi", "prompt": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True", "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()", "entry_point": "next_permutation", "signature": "def next_permutation(perm: list) -> bool:", "docstring": "Transforms the input permutation to the next permutation in lexicographic order.\n\nThe function finds the first number from the end that is smaller than the number following it\nand swaps it with the smallest number that is larger and comes after it. Then it reverses the\norder of numbers after the original first smaller number. If the input is the last permutation\n(in descending order), the function returns False, indicating no next permutation is possible.\n\nArgs:\nperm (list): A list of integers representing the current permutation.\n\nReturns:\nbool: True if the permutation was successfully transformed, False if it was the last permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nTransforms the input permutation to the next permutation in lexicographic order.\n\nThe function finds the first number from the end that is smaller than the number following it\nand swaps it with the smallest number that is larger and comes after it. Then it reverses the\norder of numbers after the original first smaller number. If the input is the last permutation\n(in descending order), the function returns False, indicating no next permutation is possible.\n\nArgs:\nperm (list): A list of integers representing the current permutation.\n\nReturns:\nbool: True if the permutation was successfully transformed, False if it was the last permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]\n\n* Incomplete Code:\ndef next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n[MASK]\n[MASK]\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n[MASK]\n    \n    return True\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n[MASK]\n[MASK]\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n[MASK]\n    \n    return True"}
{"task_id": "Python/43-1-multi", "prompt": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"", "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True", "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()", "entry_point": "next_permutation", "signature": "def next_permutation(perm: list) -> bool:", "docstring": "Transforms the input permutation to the next permutation in lexicographic order.\n\nThe function finds the first number from the end that is smaller than the number following it\nand swaps it with the smallest number that is larger and comes after it. Then it reverses the\norder of numbers after the original first smaller number. If the input is the last permutation\n(in descending order), the function returns False, indicating no next permutation is possible.\n\nArgs:\nperm (list): A list of integers representing the current permutation.\n\nReturns:\nbool: True if the permutation was successfully transformed, False if it was the last permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nTransforms the input permutation to the next permutation in lexicographic order.\n\nThe function finds the first number from the end that is smaller than the number following it\nand swaps it with the smallest number that is larger and comes after it. Then it reverses the\norder of numbers after the original first smaller number. If the input is the last permutation\n(in descending order), the function returns False, indicating no next permutation is possible.\n\nArgs:\nperm (list): A list of integers representing the current permutation.\n\nReturns:\nbool: True if the permutation was successfully transformed, False if it was the last permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]\n\n* Incomplete Code:\ndef next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n[MASK]\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n[MASK]\n    \n    # Swap these two numbers\n[MASK]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Find the first (smaller) number from the end which is smaller than the number after it\n[MASK]\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n[MASK]\n    \n    # Swap these two numbers\n[MASK]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n[MASK]"}
{"task_id": "Python/44-0-multi", "prompt": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin runs out of money in July (the 7th month)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin has 1580 units of currency by the end of the year\n    \"\"\"", "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money", "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()", "entry_point": "jinjin_savings_plan", "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:", "docstring": "Calculates the total amount of money Jinjin will have by the end of the year\nafter following her savings plan with her mother. Each month, she can save\nmultiples of 100 from her pocket money (300 per month) if she predicts having\nat least 100 units remaining after expenses. The saved money will gain 20%\ninterest at the end of the year.\n\nParameters:\nbudgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\nReturns:\nint: The total amount of money Jinjin will have at the end of the year after interest.\nIf Jinjin runs out of money in any given month, returns the negative value of\nthat month (-X, where X is the month number).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin runs out of money in July (the 7th month)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin has 1580 units of currency by the end of the year", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the total amount of money Jinjin will have by the end of the year\nafter following her savings plan with her mother. Each month, she can save\nmultiples of 100 from her pocket money (300 per month) if she predicts having\nat least 100 units remaining after expenses. The saved money will gain 20%\ninterest at the end of the year.\n\nParameters:\nbudgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\nReturns:\nint: The total amount of money Jinjin will have at the end of the year after interest.\nIf Jinjin runs out of money in any given month, returns the negative value of\nthat month (-X, where X is the month number).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin runs out of money in July (the 7th month)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin has 1580 units of currency by the end of the year\n\n* Incomplete Code:\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n[MASK]\n        \n[MASK]\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n[MASK]\n        \n[MASK]\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money"}
{"task_id": "Python/44-1-multi", "prompt": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin runs out of money in July (the 7th month)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin has 1580 units of currency by the end of the year\n    \"\"\"", "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money", "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()", "entry_point": "jinjin_savings_plan", "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:", "docstring": "Calculates the total amount of money Jinjin will have by the end of the year\nafter following her savings plan with her mother. Each month, she can save\nmultiples of 100 from her pocket money (300 per month) if she predicts having\nat least 100 units remaining after expenses. The saved money will gain 20%\ninterest at the end of the year.\n\nParameters:\nbudgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\nReturns:\nint: The total amount of money Jinjin will have at the end of the year after interest.\nIf Jinjin runs out of money in any given month, returns the negative value of\nthat month (-X, where X is the month number).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin runs out of money in July (the 7th month)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin has 1580 units of currency by the end of the year", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the total amount of money Jinjin will have by the end of the year\nafter following her savings plan with her mother. Each month, she can save\nmultiples of 100 from her pocket money (300 per month) if she predicts having\nat least 100 units remaining after expenses. The saved money will gain 20%\ninterest at the end of the year.\n\nParameters:\nbudgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\nReturns:\nint: The total amount of money Jinjin will have at the end of the year after interest.\nIf Jinjin runs out of money in any given month, returns the negative value of\nthat month (-X, where X is the month number).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin runs out of money in July (the 7th month)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin has 1580 units of currency by the end of the year\n\n* Incomplete Code:\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n[MASK]\n    money_saved = 0\n    \n[MASK]\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n[MASK]\n[MASK]\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n[MASK]\n    return total_money\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n    money_saved = 0\n    \n[MASK]\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n[MASK]\n[MASK]\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n[MASK]\n    return total_money"}
{"task_id": "Python/45-0-multi", "prompt": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Merging (5+5) with a total cost of 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\n        # followed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\n        # Total cost is 30+60+90+150 = 300.\n    \"\"\"", "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()", "entry_point": "minimum_cost_to_merge_fruits", "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:", "docstring": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\nThe cost of merging two heaps is equal to the sum of their weights. The function utilizes\na greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\nminimizing the total cost.\n\nParameters:\nfruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\nReturns:\nint: The minimum total cost required to merge all heaps of fruits.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Merging (5+5) with a total cost of 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\nfollowed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\nTotal cost is 30+60+90+150 = 300.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the minimum total cost to merge multiple heaps of fruits into a single heap.\nThe cost of merging two heaps is equal to the sum of their weights. The function utilizes\na greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\nminimizing the total cost.\n\nParameters:\nfruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\nReturns:\nint: The minimum total cost required to merge all heaps of fruits.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Merging (5+5) with a total cost of 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\nfollowed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\nTotal cost is 30+60+90+150 = 300.\n\n* Incomplete Code:\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n[MASK]\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n[MASK]\n        \n        # Push the new heap back into the min-heap.\n[MASK]\n    \n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n[MASK]\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n[MASK]\n        \n        # Push the new heap back into the min-heap.\n[MASK]\n    \n[MASK]"}
{"task_id": "Python/45-1-multi", "prompt": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Merging (5+5) with a total cost of 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\n        # followed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\n        # Total cost is 30+60+90+150 = 300.\n    \"\"\"", "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost", "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()", "entry_point": "minimum_cost_to_merge_fruits", "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:", "docstring": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\nThe cost of merging two heaps is equal to the sum of their weights. The function utilizes\na greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\nminimizing the total cost.\n\nParameters:\nfruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\nReturns:\nint: The minimum total cost required to merge all heaps of fruits.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Merging (5+5) with a total cost of 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\nfollowed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\nTotal cost is 30+60+90+150 = 300.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the minimum total cost to merge multiple heaps of fruits into a single heap.\nThe cost of merging two heaps is equal to the sum of their weights. The function utilizes\na greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\nminimizing the total cost.\n\nParameters:\nfruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\nReturns:\nint: The minimum total cost required to merge all heaps of fruits.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Merging (5+5) with a total cost of 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\nfollowed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\nTotal cost is 30+60+90+150 = 300.\n\n* Incomplete Code:\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n[MASK]\n        # Pop the two smallest heaps.\n[MASK]\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n[MASK]\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n[MASK]\n        # Pop the two smallest heaps.\n[MASK]\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n[MASK]\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n[MASK]"}
{"task_id": "Python/46-0-multi", "prompt": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"", "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length", "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()", "entry_point": "minimum_students_to_leave", "signature": "def minimum_students_to_leave(heights):", "docstring": "Calculate the minimum number of students that need to leave to form a choir formation.\nA choir formation is defined such that for some position 'i', the heights of students\nincrease from the start to 'i' and decrease from 'i' to the end of the formation.\n\nArgs:\nheights (List[int]): A list of student heights.\n\nReturns:\nint: The minimum number of students that need to leave.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum number of students that need to leave to form a choir formation.\nA choir formation is defined such that for some position 'i', the heights of students\nincrease from the start to 'i' and decrease from 'i' to the end of the formation.\n\nArgs:\nheights (List[int]): A list of student heights.\n\nReturns:\nint: The minimum number of students that need to leave.\n\n* Incomplete Code:\ndef minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n[MASK]\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n[MASK]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n[MASK]\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n[MASK]\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n[MASK]\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n[MASK]\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length"}
{"task_id": "Python/46-1-multi", "prompt": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"", "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length", "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()", "entry_point": "minimum_students_to_leave", "signature": "def minimum_students_to_leave(heights):", "docstring": "Calculate the minimum number of students that need to leave to form a choir formation.\nA choir formation is defined such that for some position 'i', the heights of students\nincrease from the start to 'i' and decrease from 'i' to the end of the formation.\n\nArgs:\nheights (List[int]): A list of student heights.\n\nReturns:\nint: The minimum number of students that need to leave.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum number of students that need to leave to form a choir formation.\nA choir formation is defined such that for some position 'i', the heights of students\nincrease from the start to 'i' and decrease from 'i' to the end of the formation.\n\nArgs:\nheights (List[int]): A list of student heights.\n\nReturns:\nint: The minimum number of students that need to leave.\n\n* Incomplete Code:\ndef minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n[MASK]\n        for j in range(i):\n            if heights[i] > heights[j]:\n[MASK]\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n[MASK]\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n[MASK]\n        for j in range(i):\n            if heights[i] > heights[j]:\n[MASK]\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n[MASK]\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length"}
{"task_id": "Python/48-0-multi", "prompt": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    \n    Case 1:\n    A limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    The minimum number of groups is 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Case 2:\n    A limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\n    The minimum number of groups is 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Case 3:\n    A limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\n    Since each pair's total price does not exceed the limit, the minimum number of groups is 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups", "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()", "entry_point": "min_groups", "signature": "def min_groups(w, n, prices):", "docstring": "Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n\nThe souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`.\nThe function aims to minimize the number of groups created under this constraint.\n\nArgs:\nw (int): The maximum allowed sum of prices for any group of souvenirs.\nn (int): The total number of souvenirs.\nprices (list): A list of integers representing the price of each souvenir.\n\nReturns:\nint: The minimum number of groups required to distribute all souvenirs.\n\nExamples:\n\nCase 1:\nA limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\nThe minimum number of groups is 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCase 2:\nA limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\nThe minimum number of groups is 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCase 3:\nA limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\nSince each pair's total price does not exceed the limit, the minimum number of groups is 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDetermines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n\nThe souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`.\nThe function aims to minimize the number of groups created under this constraint.\n\nArgs:\nw (int): The maximum allowed sum of prices for any group of souvenirs.\nn (int): The total number of souvenirs.\nprices (list): A list of integers representing the price of each souvenir.\n\nReturns:\nint: The minimum number of groups required to distribute all souvenirs.\n\nExamples:\n\nCase 1:\nA limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\nThe minimum number of groups is 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCase 2:\nA limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\nThe minimum number of groups is 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCase 3:\nA limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\nSince each pair's total price does not exceed the limit, the minimum number of groups is 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2\n\n* Incomplete Code:\ndef min_groups(w, n, prices):\n[MASK]\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n[MASK]\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n[MASK]\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups"}
{"task_id": "Python/48-1-multi", "prompt": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    \n    Case 1:\n    A limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    The minimum number of groups is 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Case 2:\n    A limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\n    The minimum number of groups is 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Case 3:\n    A limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\n    Since each pair's total price does not exceed the limit, the minimum number of groups is 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"", "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups", "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()", "entry_point": "min_groups", "signature": "def min_groups(w, n, prices):", "docstring": "Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n\nThe souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`.\nThe function aims to minimize the number of groups created under this constraint.\n\nArgs:\nw (int): The maximum allowed sum of prices for any group of souvenirs.\nn (int): The total number of souvenirs.\nprices (list): A list of integers representing the price of each souvenir.\n\nReturns:\nint: The minimum number of groups required to distribute all souvenirs.\n\nExamples:\n\nCase 1:\nA limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\nThe minimum number of groups is 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCase 2:\nA limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\nThe minimum number of groups is 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCase 3:\nA limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\nSince each pair's total price does not exceed the limit, the minimum number of groups is 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nDetermines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n\nThe souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`.\nThe function aims to minimize the number of groups created under this constraint.\n\nArgs:\nw (int): The maximum allowed sum of prices for any group of souvenirs.\nn (int): The total number of souvenirs.\nprices (list): A list of integers representing the price of each souvenir.\n\nReturns:\nint: The minimum number of groups required to distribute all souvenirs.\n\nExamples:\n\nCase 1:\nA limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\nThe minimum number of groups is 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCase 2:\nA limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\nThe minimum number of groups is 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCase 3:\nA limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\nSince each pair's total price does not exceed the limit, the minimum number of groups is 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2\n\n* Incomplete Code:\ndef min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n[MASK]\n    right = n - 1  # Pointer to the most expensive souvenir\n\n[MASK]\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n[MASK]\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n[MASK]\n\n    return groups\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n[MASK]\n    right = n - 1  # Pointer to the most expensive souvenir\n\n[MASK]\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n[MASK]\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n[MASK]\n\n    return groups"}
{"task_id": "Python/49-0-multi", "prompt": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n    - For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n    - For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair, \n      4 more for the second, and then 8 additional moves for the third pair.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()", "entry_point": "hanoi_double_iterative", "signature": "def hanoi_double_iterative(n: int) -> int:", "docstring": "Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n\nThis function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc\ncan be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation\nand iteratively computes the total number of moves for n pairs of discs.\n\nArgs:\nn (int): The number of disc pairs (each of two identical discs) on the A pole.\n\nReturns:\nint: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\nCases:\n- For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n- For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n- For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair,\n4 more for the second, and then 8 additional moves for the third pair.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n\nThis function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc\ncan be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation\nand iteratively computes the total number of moves for n pairs of discs.\n\nArgs:\nn (int): The number of disc pairs (each of two identical discs) on the A pole.\n\nReturns:\nint: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\nCases:\n- For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n- For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n- For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair,\n4 more for the second, and then 8 additional moves for the third pair.\n\n* Incomplete Code:\ndef hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "    moves = 2\n    for i in range(2, n + 1):\n[MASK]\n[MASK]"}
{"task_id": "Python/49-1-multi", "prompt": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n    - For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n    - For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair, \n      4 more for the second, and then 8 additional moves for the third pair.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves", "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()", "entry_point": "hanoi_double_iterative", "signature": "def hanoi_double_iterative(n: int) -> int:", "docstring": "Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n\nThis function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc\ncan be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation\nand iteratively computes the total number of moves for n pairs of discs.\n\nArgs:\nn (int): The number of disc pairs (each of two identical discs) on the A pole.\n\nReturns:\nint: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\nCases:\n- For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n- For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n- For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair,\n4 more for the second, and then 8 additional moves for the third pair.", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n\nThis function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc\ncan be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation\nand iteratively computes the total number of moves for n pairs of discs.\n\nArgs:\nn (int): The number of disc pairs (each of two identical discs) on the A pole.\n\nReturns:\nint: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\nCases:\n- For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n- For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n- For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair,\n4 more for the second, and then 8 additional moves for the third pair.\n\n* Incomplete Code:\ndef hanoi_double_iterative(n: int) -> int:\n[MASK]\n    for i in range(2, n + 1):\n[MASK]\n    return moves\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n    for i in range(2, n + 1):\n[MASK]\n    return moves"}
{"task_id": "Python/50-0-multi", "prompt": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total", "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes", "entry_point": "total_smoked_cigarettes", "signature": "def total_smoked_cigarettes(n, k):", "docstring": "Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n\n* Incomplete Code:\ndef total_smoked_cigarettes(n, k):\n[MASK]\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n[MASK]\n        # Exchange butts for new cigarettes\n[MASK]\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n[MASK]\n        # Exchange butts for new cigarettes\n[MASK]\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n[MASK]\n[MASK]"}
{"task_id": "Python/50-1-multi", "prompt": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"", "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total", "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes", "entry_point": "total_smoked_cigarettes", "signature": "def total_smoked_cigarettes(n, k):", "docstring": "Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14", "instruction": "Below is a explanation of Python code and incomplete code implementation.\n\n* Docstring: \nCalculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n\n* Incomplete Code:\ndef total_smoked_cigarettes(n, k):\n[MASK]\n[MASK]\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n[MASK]\n        # Update the count of butts: add new butts, subtract used butts\n[MASK]\n[MASK]\n\nPlease fill the [MASK]（multiple lines of code may be masked out) and write the complete function.", "mask_code": "[MASK]\n[MASK]\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n[MASK]\n        # Update the count of butts: add new butts, subtract used butts\n[MASK]\n[MASK]"}
